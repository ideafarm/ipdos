
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( tinP.fingerprint ) ;

    }
        }
            break ;
            //}
            //{
            //switch( idCmd )
            slP >> idCmd ;
            ZE( countT , idCmd ) ;
        {
        case ifcIDcMDbASE_CMDsPECIFIED :
        }
            break ;
            ether.delF( tinP , psttw ) ;

            }
                ether.delF( tinP , psttUseLex ) ;
                if( !bFound ) *paStack OR(*this) << psttw O(*paRootWord) ;
                }
                    while( !ether && ~hDown && !bFound ) ;
                    }
                        }
                            *paStack >> bFound ;
                            *paStack << psttw << (countT)ifcIDcMDbASE_CMDdEFAULT << pLex ;
    
                            if( psttUseLex && ether.strCompareF( tinP , psttUseLex , T(pLex->postNameF(tinP)) ) ) continue ;
                        {
                        if( pLex )
                        lexC* pLex = (lexC*)stLex.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stLex )
                ZE( boolT , bFound ) ;
            {
            if( bLookup )

            else bLookup = 1 ;
            }
                DEL( pObject ) ;

                }
                    while( !ether && ~hDown ) ;
                    }
                        }
                            break ;
                            stLex.extractF( tinP ) ;
                        {
                        if( pLex == pObject )
                        baseSoilXxxxC* pLex = (baseSoilXxxxC*)stLex.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                else if( stLex )
                else if( (baseSoilXxxxC*)paRootWord == pObject ) paRootWord = 0 ;
                     if( (baseSoilXxxxC*)paStack    == pObject ) paStack    = 0 ;

                sw_pObject.ungrabF( tinP ) ;
                sw_pObject.freeF( tinP ) ;
                baseSoilXxxxC* pObject = (baseSoilXxxxC*)(countT&)sw_pObject ; sw_pObject = (countT)0 ;
                postLever = tName ;
                sw_pObject.grabF( tinP , TAG( TAGiDnULL ) ) ;
                ether.delF( tinP , psttName ) ;
                TN( tName , "" ) ; tName = T(psttName) ;

                ether.strokeF( tinP , T(postName)+T(" is supposed to del ")+T(psttName)+T(".\r\n") ) ;
                *paStack >> psttName ;
                ZE( strokeS* , psttName ) ;
            {
            else if( !ether.strCompareF( tinP , psttw , T("d") ) )  //"d" IS FOR "DELETE"
            }
                ether.delF( tinP , psttNewType ) ;
                }
                    stLex << (countT)pLex ; pLex = 0 ;
                    PoBJECT( tNewName ) = pLex ;
                    lexC* pLex = new( 0 , tinP , LF ) lexC( tinP , ether , TAG( TAGiDnULL ) , tNewName ) ; ___( pLex ) ;
                {
                else if( !ether.strCompareF( tinP , psttNewType , T("lexicon") ) )
                }
                    PoBJECT( tNewName ) = pObject ;
                    baseSoilXxxxC* pObject = new( 0 , tinP , LF ) switchC( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , psttLever , 0 , 0 , ifcIDgRABlAYER_7BASEmISC1 , tNewName ) ; ___( pObject ) ;
                {
                else if( !ether.strCompareF( tinP , psttNewType , T("switchC") ) )
                }
                    PoBJECT( tNewName ) = pObject ;
                    baseSoilXxxxC* pObject = new( 0 , tinP , LF ) etherC( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_null , flWATCH_TIME , tNewName ) ; ___( pObject ) ;
                {
                else if( !ether.strCompareF( tinP , psttNewType , T("etherC") ) )
                }
                    PoBJECT( tNewName ) = pObject ;
                    baseSoilXxxxC* pObject = new( 0 , tinP , LF ) countC( tNewName ) ; ___( pObject ) ;
                {
                else if( !ether.strCompareF( tinP , psttNewType , T("countC") ) )
                }
                    PoBJECT( tNewName ) = paStack ;
                    paStack = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) , flSOUL_null , (osTextT*)0 , 0 , (osTextT*)tNewName ) ; ___( paStack ) ;
                {
                else if( !ether.strCompareF( tinP , psttNewType , T("list") ) )
                }
                    PoBJECT( tNewName ) = paStack ;
                    paStack = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) , flSOUL_LIFO|flSOUL_LIVE , (osTextT*)0 , 0 , (osTextT*)tNewName ) ; ___( paStack ) ;
                {
                if( !ether.strCompareF( tinP , psttNewType , T("stack") ) )
                ether.delF( tinP , psttNewName ) ;
                TN( tNewName , "" ) ; tNewName = T(psttNewName) ;

                ether.strokeF( tinP , T(postName)+T(" is supposed to new a ")+T(psttNewType)+T(" named ")+T(psttNewName)+T(".\r\n") ) ;
                *paStack >> psttNewName ;
                *paStack >> psttNewType ;
                ZE( strokeS* , psttNewName ) ;
                ZE( strokeS* , psttNewType ) ;
            {
            else if( !ether.strCompareF( tinP , psttw , T("n") ) )  //"n" IS FOR "NEW"
            }
                POPUPsOIXLoLD( T("I, \"")+T(postName)+T("\", have created \"")+tNameShort+T("\".  Read that document and then edit it to indicate what additional information you want.  Then drop it into the Mouth to obtain the additional information.") ) ;
                ether.boxPutF( tinP , tName , tBody , tBody.csF(  tinP ) ) ;
                TN( tName , "" ) ; tName = tSoixlOld+tNameShort ;
                ether.delF( tinP , psttOldCmd ) ;
                TN( tNameShort , "") ; tNameShort = T("soixlOld.help.")+T(postName)+T(".")+T(psttOldCmd)+T(".txt") ;

                TN( tMouthShort , postSOIXLoLDfILESfOLDERS_SHORTmOUTH ) ;
                TN( tSoixlOldShort , postSOIXLoLDfILESfOLDERS_SHORTsOIXLoLD ) ;
                TN_tMouth
                TN_tSoixlOld

                ether.delF( tinP , psttQueryWord ) ;
                else                                                              { psttOldCmd = psttQueryWord ; psttQueryWord = 0 ; }
                else if( !ether.strCompareF( tinP , psttQueryWord , T("??"  ) ) ) ether.strMakeF( tinP , psttOldCmd , T("specificHelp") ) ;
                else if( !ether.strCompareF( tinP , psttQueryWord , T("?"   ) ) ) ether.strMakeF( tinP , psttOldCmd , T("generalHelp") ) ;
                     if( !ether.strCompareF( tinP , psttQueryWord , T("."   ) ) ) ether.strMakeF( tinP , psttOldCmd , T("literal") ) ;
                ZE( strokeS* , psttOldCmd ) ;

                ether.delF( tinP , pstth ) ;
                tBody = T(pstth) ;
                ether.strReverseF( tinP , pstth , tBody , T("\r\n") ) ; ___( pstth ) ;
                ZE( strokeS* , pstth ) ;

                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    . myList . d space\r\n"
                    "    myWord\r\n"
                    "    myWord\r\n"
                    "    . myList . myWord . x space\r\n"
                    "    .@ stack1\r\n"
                    "    . \"Thank you, God!\" POPUP\r\n"
                    "    . myList . list . n space\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "Notes:\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              strokeString\r\n"
                    "\r\n"
                    "Example phrase:    . myEther    . d ")+T(postName)+T("\r\n"
                    "Example phrase:    . myStack    . d ")+T(postName)+T("\r\n"
                    "Example phrase:    . myList     . d ")+T(postName)+T("\r\n"
                    "Example phrase:    . myVariable . d ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Summary:  I destroy an object.\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("d") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    myWord\r\n"
                    "    myWord\r\n"
                    "    . myList . myWord . x space\r\n"
                    "    .@ stack1\r\n"
                    "    . \"Thank you, God!\" POPUP\r\n"
                    "    . myList . list . n space\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "IdeaFarm " "(tm) SOIL (tm).\r\n"
                    "as they are pushed.  etherC objects are the workhorses of\r\n"
                    "can be pushed onto a list; such words are \"dead\"; no action occurs\r\n"
                    "Each countC object can store a single countT value.  SOIL (tm) words\r\n"
                    "\r\n"
                    "Notes:\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              strokeString strokeString\r\n"
                    "\r\n"
                    "Example phrase:    . myEther    . etherC . n ")+T(postName)+T("\r\n"
                    "Example phrase:    . myStack    . stack  . n ")+T(postName)+T("\r\n"
                    "Example phrase:    . myList     . list   . n ")+T(postName)+T("\r\n"
                    "Example phrase:    . myVariable . countC . n ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Summary:  I construct an object.\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("n") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "Notes: A simple example will be added to this document.\r\n" //U::
                    "\r\n"
                    "Pushes:            Nothing\r\n"
                    "\r\n"
                    "Pops:              Nothing\r\n"
                    "\r\n"
                    "Example phrase:    . c abcd\r\n"
                    "\r\n"
                    "Summary:  The next word will be pushed as a countT.\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("c") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "Notes: A simple example will be added to this document.\r\n" //U::
                    "\r\n"
                    "Pushes:            Nothing\r\n"
                    "\r\n"
                    "Pops:              Nothing\r\n"
                    "\r\n"
                    "Example phrase:    . b@ \"abcd efgh\"\r\n"
                    "\r\n"
                    "Summary:  The next word will be pushed as a string of osTextT.\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("b@") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    myWord\r\n"
                    "    myWord\r\n"
                    "    . myList . myWord . x space\r\n"
                    "    .@ stack1\r\n"
                    "    . \"Thank you, God!\" POPUP\r\n"
                    "    . myList . list . n space\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "current contents of list myList.\r\n"
                    "each manifest of the word myNewWord is the manifestation of the\r\n"
                    "Notes:  The list myList must not be destroyed.  The meaning of\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              strokeString strokeString\r\n"
                    "\r\n"
                    "Example phrase:    . myList . myNewWord . x ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Summary:  I define a new word to refer to a specific list.\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("x") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    xx . myWord1 . myWord0 if\r\n"
                    "    . 0 . xx . = space\r\n"
                    "\r\n"
                    "    xx . myWord1 . myWord0 if\r\n"
                    "    . 1 . xx . = space\r\n"
                    "\r\n"
                    "    xx . myWord1 . myWord0 if\r\n"
                    "    . 0  . xx . = space\r\n"
                    "\r\n"
                    "    . xx . countC . n space\r\n"
                    "\r\n"
                    "    . myList1 . myWord1 . x space\r\n"
                    "    .@ stack1\r\n"
                    "   \r\n"
                    "    . \"The variable xx contains a value other than 0 (it is true).\" POPUP\r\n"
                    "    . myList1 . list . n space\r\n"
                    "\r\n"
                    "    . myList0 . myWord0 . x space\r\n"
                    "    .@ stack1\r\n"
                    "\r\n"
                    "    . \"The variable xx contains 0 (it is false).\" POPUP\r\n"
                    "    . myList0 . list . n space\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "Notes:  objName must be a countC object.\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              countC strokeString\r\n"
                    "\r\n"
                    "Example phrase:    . 1234 . myObject . = ")+T(postName)+T("\r\n"
                    "\r\n"
                    "replacing its prior value.\r\n"
                    "Summary:  The specified value is stored in the specified object,\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("=") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "   . \"This is a Comment.\" . # ")+T(postName)+T("\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "Notes:  My behavior is subject to change.  I currently do nothing.\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              strokeString\r\n"
                    "\r\n"
                    "Example phrase:    . \"This is a Comment.\" . # ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Summary:  I pop a word that I treat as a comment.\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("#") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "\r\n"
                    "    . 4 . + . \"This message is stored in an unnamed string of strokeS objects, and there are 4 extra strokeS objects at the end.)\" POPUP\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "This example will be replaced soon with a more useful wo.\r\n"
                    "\r\n"
                    "is popped.\r\n"
                    "strokes.  Those extra strokes are not allocated until the string\r\n"
                    "is being pushed.  It will cause that string to specify 001 extra\r\n"
                    "The value specified will be stored until the next strokeS string\r\n"
                    "\r\n"
                    "Notes:\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              countC\r\n"
                    "\r\n"
                    "Example phrase:    . 001 . + ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Summary:  I modify the parsing of the next stroke string literal.\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("+") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    . \"Every help file exemplifies the use of the \\\"version\\\" word, which you will find in the bottom line.\" POPUP\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              countC\r\n"
                    "\r\n"
                    "Example phrase:    . 1 . version ")+T(postName)+T("\r\n"
                    "\r\n"
                    "defines the meaning of this SOIL (tm) program.\r\n"
                    "Summary:  Specifies the version of the SOIL (tm) implementation that\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("version") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    . \"Every help file exemplifies the use of the \\\"tm\\\" word, which you will find in the bottom line.\" POPUP\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "limited rights to use the trademarks of competing implementations.\r\n"
                    "Notes:  The SOIL (tm) language specification grants implementers\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              strokeString\r\n"
                    "\r\n"
                    "Example phrase:    . IdeaFarm . tm ")+T(postName)+T("\r\n"
                    "\r\n"
                    "defines the meaning of this SOIL (tm) program.\r\n"
                    "Summary:  Specifies the trademark of the SOIL (tm) implementation that\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("tm") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    . \"Message 2: You won't see this; I don't even get input by the space.\" POPUP\r\n"
                    "    . quit space\r\n"
                    "    . \"Message 1\" POPUP\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "\r\n"
                    "space object to destroy itself.\r\n"
                    "Notes:  In the current implementation, \"quit\" causes the\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              Nothing.\r\n"
                    "\r\n"
                    "Example phrase:    . quit ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Summary:  Causes me to abandon parsing the current input.\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("quit") ) ) tBody += T(
                    ) ;
                    ". on\r\n"
                    "    . off ")+T(postName)+T("\r\n"
                    "\r\n"
                    "    . \"Message 3\" POPUP\r\n"
                    "    . on ")+T(postName)+T("\r\n"
                    "    . \"Message 2: You won't see this.\" POPUP\r\n"
                    "    . off ")+T(postName)+T("\r\n"
                    "    . \"Message 1\" POPUP\r\n"
                    "\r\n"
                    "    . on ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "does not occur within a \". on space\" phrase will be ignored.\r\n"
                    "resume parsing.  Normal syntax must be used.  An \"on\" that\r\n"
                    "I decrement the off counter.  If that counter becomes 0, I\r\n"
                    "\r\n"
                    "Notes:\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              Nothing.\r\n"
                    "\r\n"
                    ". off ")+T(postName)+T("\r\n"
                    "Example phrase:    . on ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Summary:  Causes me to resume parsing.  (See \"off\".)\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("on") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    . \"Message 3\" POPUP\r\n"
                    "    . on space\r\n"
                    "    . \"Message 2: You won't see this.\" POPUP\r\n"
                    "    . off space\r\n"
                    "    . \"Message 1\" POPUP\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "nonze""ro.  This word causes me to increment that counter.\r\n"
                    "A counter is kept.  I ignore input words whenever that counter is\r\n"
                    "\r\n"
                    "Notes:\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              Nothing.\r\n"
                    "\r\n"
                    "Example phrase:    . off ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Summary:  Causes me to ignore input words until I implicitly pop an \"on\".\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("off") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    . \"Message 3\" POPUP\r\n"
                    "    . noquiet space\r\n"
                    "    . \"Message 2: Currently, \\\"noquiet\\\" has no effect.\" POPUP\r\n"
                    "    . quiet space\r\n"
                    "    . \"Message 1\" POPUP\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "the associated counter.\r\n"
                    "Notes:  The effect is to undo a single \"quiet\" word by decrementing.\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              Nothing.\r\n"
                    "\r\n"
                    "Example phrase:    . noquiet ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Summary:  This is a hint to me that I should operate loudly.\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("noquiet") ) ) tBody += T(
                    ) ;
                    ". on space\r\n"
                    "    . off space\r\n"
                    "\r\n"
                    "    . \"Message 3\" POPUP\r\n"
                    "    . noquiet space\r\n"
                    "    . \"Message 2: Currently, \\\"quiet\\\" has no effect.\" POPUP\r\n"
                    "    . quiet space\r\n"
                    "    . \"Message 1\" POPUP\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "nonze""ro.  I cause this counter to be incremented.\r\n"
                    "maintains a counter which causes quiet behavior whenever it is\r\n"
                    "The effect of this word is subject to change.  Each instance\r\n"
                    "Notes:  The current effect is to suppress some popup messages.\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              Nothing.\r\n"
                    "\r\n"
                    "Example phrase:    . quiet  ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Summary:  This is a hint to me that I should operate quietly.\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("quiet") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    . \"Every help file exemplifies the use of the \\\"soixlOld\\\" word, which you will find in the bottom line.\" POPUP\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "            consideration for new projects.\r\n"
                    "            and shunned and, whenever possible, excluded from\r\n"
                    "            in\", let that supplier be despised and reviled\r\n"
                    "            dominates the market because its users are \"locked\r\n"
                    "            dynamic, and innovative.  If an implementation\r\n"
                    "            the market for SOIL (tm) implementations is competitive,\r\n"
                    "            and competition between implementations, so that\r\n"
                    "            and otherwise to endeavor to maximize portability\r\n"
                    "        F4. Implementors should be encouraged by the market\r\n"
                    "\r\n"
                    "            root words.\r\n"
                    "            of the CPU, should be done by root objects, not by\r\n"
                    "            All computing work, including the basic operations\r\n"
                    "            limited to providing program flow control capability.\r\n"
                    "            The root word set should be small and orthogonal, and\r\n"
                    "            of the root words and root objects that it provides.\r\n"
                    "        F3. The \"content\" of a SOIL (tm) implementation consists\r\n"
                    "\r\n"
                    "            of YYY.\".\r\n"
                    "            implementation of the SOIL (tm) language.  XXX is a trademark\r\n"
                    "            \"This implementation (also) supports the XXX (tm)\r\n"
                    "            Such use must be limited to statements of this form:\r\n"
                    "            the identity of the implementation or its supplier.\r\n"
                    "            Such statements must not create confusion regarding\r\n"
                    "            written for the foreign trademark is supported.\r\n"
                    "            of other SOIL (tm) implementations when stating that code\r\n"
                    "            SOIL (tm) implementors are allowed to use the trademarks\r\n"
                    "        F3. To encourage portability and interoperability,\r\n"
                    "\r\n"
                    "            \"meaning\" of the code.\r\n"
                    "            and version, together with the code, determines the\r\n"
                    "            exactly 1 trademark and version.  This trademark\r\n"
                    "            a foreign trademark.  Each program must specify\r\n"
                    "            an implementation may support code that specifies\r\n"
                    "        F2. To encourage portability and interoperability,\r\n"
                    "\r\n"
                    "            containing object, is implementation dependent.\r\n"
                    "            but the alias used, and the function of the \"root\"\r\n"
                    "            contained objects can refer to the containing object.\r\n"
                    "            All implementations must have some alias name by which\r\n"
                    "            name for what this document refers to as the word \"god\".\r\n"
                    "            implementations of the SOIL (tm) language must have some\r\n"
                    "            name or meaning of any word.  For example, all\r\n"
                    "        F1. The SOIL (tm) language specification does not specify the\r\n"
                    "\r\n"
                    "    Look and Feel:\r\n"
                    "\r\n"
                    "\r\n"
                    "            the manifestation is undoable even after commit.\r\n"
                    "            what kinds of side effects a manifestation can have, and whether\r\n"
                    "        P8. Implementations are to support word definitions that declare\r\n"
                    "\r\n"
                    "            values are pulled, and what types and possible values are pushed.\r\n"
                    "            the number of stack items, declaration of what types and valid\r\n"
                    "            This includes, at a minimum, declaration of the net change in\r\n"
                    "            what effect the word has on the stack upon which it manifests.\r\n"
                    "        P7. Implementations are to support word definitions that declare\r\n"
                    "\r\n"
                    "            is practical.\r\n"
                    "            visibility into what is going on \"under the hood\" as\r\n"
                    "        P6. Implementations are to have glass walls, providing as much\r\n"
                    "\r\n"
                    "            expected by the recieving object.\r\n"
                    "            the value must provide it explicitly in the type that is\r\n"
                    "            silently converted.  In general, the code that provides\r\n"
                    "        P5. The language is strongly typed, in that values are not\r\n"
                    "\r\n"
                    "            end.\r\n"
                    "            the objects involved become impotent and manifestations\r\n"
                    "            of the code is to be of an \"impotence backoff\" nature;\r\n"
                    "            taken when an exception occurs.  The default behavior\r\n"
                    "            from a menu of orthogonal actions that are to be\r\n"
                    "            must provide a means by which the code can select\r\n"
                    "            exceptional conditions do occur.  Implementations\r\n"
                    "            of this language specification except to note that\r\n"
                    "        P4. Exception handling details are not within the scope\r\n"
                    "\r\n"
                    "            temporary lexicons, public lexicons, etc.\r\n"
                    "            should facilitate this by supporting multiple lexicons,\r\n"
                    "            new words with care and restraint.  Implementations\r\n"
                    "            SOIL (tm) programmers commit themselves to defining\r\n"
                    "            protection against this must be ethical; let all\r\n"
                    "            the lexicon to which it is added.  The primary\r\n"
                    "            new word will contribute to the quality of\r\n"
                    "            need, without any consideration of how the\r\n"
                    "            named and conceived to meet an immediate\r\n"
                    "            lexicons containing words that are poorly\r\n"
                    "            those who would develop huge, nonorthogonal\r\n"
                    "            Forth, in that both languages are vulnerable to\r\n"
                    "        P3. SOIL (tm) shares a key weakness with its inspiration,\r\n"
                    "\r\n"
                    "            computer programmers.\r\n"
                    "            stupid, careless, and/or lazy people into\r\n"
                    "            of craftsmanship.  It makes no attempt to turn\r\n"
                    "        P2. The language is intended to be used in a spirit\r\n"
                    "\r\n"
                    "            can do it, you can do it in SOIL (tm).\r\n"
                    "            As far as is possible, if the underlying hardware\r\n"
                    "        P1. The language makes no attempt to be idiot proof.\r\n"
                    "\r\n"
                    "    Philosophy:\r\n"
                    "\r\n"
                    "\r\n"
                    "            must be completely transparent.\r\n"
                    "            interprocess communication, and interhost communication\r\n"
                    "            all implementation details involving multithreading,\r\n"
                    "            in an implementation's Root Space exist in real time, and\r\n"
                    "        Se. All extant SOIL (tm) objects contained, directly or indirectly,\r\n"
                    "\r\n"
                    "            of the SOIL (tm) language.\r\n"
                    "            interobject interface protocols are allowed but are not part\r\n"
                    "            interhost must be transparent.  Support for other kinds of\r\n"
                    "            Support for this interaction when it is interprocess or\r\n"
                    "            by pushing a reference to that object onto a stack object.\r\n"
                    "        Sd. An object can interact with any object that it sees\r\n"
                    "\r\n"
                    "            a peer object.  (Contained objects hide peer objects.)\r\n"
                    "            object with that name, if it exists.  Else it refers to\r\n"
                    "            For the SOIL (tm) space object, a name refers to a contained \r\n"
                    "            and those objects can see it, using the alias \"god\".\r\n"
                    "        Sc. Each SOIL (tm) space object can see the objects that it contains,\r\n"
                    "\r\n"
                    "            except those hidden due to name collisions.\r\n"
                    "        Sb. Within a SOIL (tm) space, every object can \"see\" every other object,\r\n"
                    "\r\n"
                    "            is already in use, it will \"hide\" the other objects.\r\n"
                    "            an object.  An object can be created with any name, but if that name\r\n"
                    "        Sa. Within a SOIL (tm) space, every distinct name value completely identifies\r\n"
                    "\r\n"
                    "            on which that implementation of SOIL (tm) is installed.\r\n"
                    "            The Root Space is a single space encompassing all Internet hosts\r\n"
                    "            is contained in the Root Space for that implementation of SOIL (tm).\r\n"
                    "            SOIL (tm) space.  Every object that is not in another containing object\r\n"
                    "        S9. When a SOIL (tm) object contains other SOIL (tm) objects, it is called a\r\n"
                    "\r\n"
                    "            but glyphs that are not distinct are permitted.\r\n"
                    "            the character.  This rendering will normally be distinct,\r\n"
                    "            when combined the current rendering mode, the rendering of\r\n"
                    "            (A glyph specifies enough information to fully determine,\r\n"
                    "            a glyph with each of some or all values within that class.\r\n"
                    "            the meaning of any undefined character class and associate\r\n"
                    "        S8. The character set is extensible; a program can define\r\n"
                    "\r\n"
                    "            until the program specifies \"commit\".\r\n"
                    "            All inherently undoable side effects are deferred\r\n"
                    "        S7. The action of every word is reversable (undoable).\r\n"
                    "\r\n"
                    "            popping of words is called a \"side effect\".\r\n"
                    "        S6. Any resultant state change other than the pushing and\r\n"
                    "\r\n"
                    "\r\n    S5. Possible actions include pushing and popping words."
                    "\r\n"
                    "            pushed onto a list, no action occurs; there is no manifestation.\r\n"
                    "            effect of this action is called a manifestation.  If the word is\r\n"
                    "            which always includes removing the reference from the stack.  The\r\n"
                    "        S4. If a word is pushed onto a stack, the object referenced takes action,\r\n"
                    "\r\n"
                    "        S3. Each word is pushed onto a stack or list as it is parsed.\r\n"
                    "\r\n"
                    "        S2. There are no reserved names.\r\n"
                    "\r\n"
                    "            is destroyed.  Named objects must be explicitly created and destroyed.\r\n"
                    "            when the reference is popped, or when the receiving stack or list\r\n"
                    "            Reference by value creates an unnamed object that is destroyed\r\n"
                    "        S1. Each word refers to an object, ether by name or by value.\r\n"
                    "\r\n"
                    "    Semantics:\r\n"
                    "\r\n"
                    "\r\n"
                    "            256_9, or 256 as it is conventionally written using base 10.\r\n"
                    "            digits increases from left to right.  For example, 001 is the value\r\n"
                    "            always in a radix that is a power of 2.  The significance of the\r\n"
                    "            a fractional part is always represented using a radix point, and\r\n"
                    "            (base 16) digits unless indicated otherwise.  A numeric value with\r\n"
                    "            from the bottom up.  (2) Numeric values are represented using radix f\r\n"
                    "            the SOIL (tm) language:  (1) Text wraps upward and multiline text is read\r\n"
                    "        G8. IdeaFarm " "(tm) City is the cultural context of all implementations of\r\n"
                    "\r\n"
                    "            of collision with a future version of the SOIL (tm) implementation.\r\n"
                    "            as undefined, but code that does this should anticipate the possibility\r\n"
                    "            Classes below 000000ff that are currently undefined may be treated\r\n"
                    "            Within a defined class, all values are either defined or reserved.\r\n"
                    "            Classes at or above 000000ff are guaranteed to be undefined.\r\n"
                    "            Classes that are defined in the language are numbered upward from 1.\r\n"
                    "        G7. Most points in the SOIL (tm) character set space have undefined meaning.\r\n"
                    "\r\n"
                    "            the use of characters of classes that are dedicated to that purpose.\r\n"
                    "        G6. Rendering is controlled by modal information, which can be specified by\r\n"
                    "\r\n"
                    "            specify font, color, or other rendering information.\r\n"
                    "            only in class MUST be semantically distinct; class is not to be used to\r\n"
                    "            c represents the \"class\" of the character.  Oo characters that differ\r\n"
                    "            value v represents the \"value\" of the character.  the high order value\r\n"
                    "            pairs: (v,c) where v,c are each elements of [0,ffffffff].  The low order\r\n"
                    "        G5. The SOIL (tm) character set is the set of all possible 32 bit counting number\r\n"
                    "\r\n"
                    "        G4. Machine-independent binary input is supported.\r\n"
                    "\r\n"
                    "            support provides for the input of any character in the SOIL (tm) character set.\r\n"
                    "        G3. Input in the form of text partitioned by whitespace is supported.  This\r\n"
                    "\r\n"
                    "            word.\r\n"
                    "        G2. Every character in the SOIL (tm) character set is allowed in every position of a\r\n"
                    "\r\n"
                    "        G1. The language is a sequence of words with no grammar and no punctuation.\r\n"
                    "\r\n"
                    "    Syntax:\r\n"
                    "\r\n"
                    "\r\n"
                    "market for SOIL (tm) implementations and applications.\r\n"
                    "in a manner that increases competition, innovation, and dynamism in the\r\n"
                    "battle each other through product quality, not through lawyer quality,\r\n"
                    "language definition on an implementor.  In all things, let implementors\r\n"
                    "No implementor or committee may trademark SOIL (tm) or impose a particular\r\n"
                    "a standards committee that may publish a definition of the language.\r\n"
                    "Implementers and users may publish competing definitions, and may form\r\n"
                    "criteria, which are offered as a provisional definition of the language.\r\n"
                    "implementation unless that language satisfies all of the following\r\n"
                    "asked to refrain from using the term SOIL (tm) to refer to their language\r\n"
                    "used as a trademark herein.  Other computer language implementors are\r\n"
                    "The term SOIL (tm) is hereby released into the public domain; it is not\r\n"
                    "\r\n"
                    "Notes:\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              Nothing.\r\n"
                    "\r\n"
                    "Example phrase:    . soixlOld ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Object Interface Language) program.\r\n"
                    "Summary:  Declares that this string of text is a SOIL (tm) (Sentient\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("soixlOld") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    . n . ?? ")+T(postName)+T("\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "Pushes:            Nothing\r\n"
                    "\r\n"
                    "Pops:              strokeString\r\n"
                    "\r\n"
                    "Example phrase:    . someWord . ?? ")+T(postName)+T("\r\n"
                    "\r\n"
                    "local desk.\r\n"
                    "Summary:  Places help information for a specified word onto the\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("??") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    . ? ")+T(postName)+T("\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "    . ? ")+T(postName)+T("\r\n"
                    "\r\n"
                    "are reading:\r\n"
                    "For example, the following phrase will produce the document that you\r\n"
                    "\r\n"
                    "    . ? someObjectName\r\n"
                    "\r\n"
                    "The normal syntax is\r\n"
                    "Every object in IdeaFarm " "(tm) SOIL (tm) accepts the \"?\" command.\r\n"
                    "\r\n"
                    "Notes:\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              Nothing.\r\n"
                    "\r\n"
                    "Example phrase:    . ? ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Summary: Places general help information onto the local desk.\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T("?") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    .0 . POPUP\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "the space immediately.\r\n"
                    "This is not a command word.  It is intercepted by the space and affects\r\n"
                    "\r\n"
                    "Notes:\r\n"
                    "\r\n"
                    "Pushes:            strokeS*\r\n"
                    "\r\n"
                    "Pops:              Nothing.\r\n"
                    "\r\n"
                    "Example phrase:    .0\r\n"
                    "\r\n"
                    "Summary: Pushes a null value of type strokeS* .\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T(".0") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    myWord\r\n"
                    "    myWord\r\n"
                    "    . myList . myWord . x space\r\n"
                    "    .@ stack1\r\n"
                    "    . \"Thank you, God!\" POPUP\r\n"
                    "    . myList . list . n space\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "pushes.\r\n"
                    "can occur without touching the stack or list that is currently receiving\r\n"
                    "argument.  The SOIL (tm) language makes this exception so that stack switches\r\n"
                    "This word is the only exception to the SOIL (tm) grammer, in that it precedes its\r\n"
                    "\r\n"
                    "in this manner.\r\n"
                    "object interface specification.  These departures are few, and are noted\r\n"
                    "are the only class of objects that do not completely conform to the SOIL (tm)\r\n"
                    "it can be popped by an object and obeyed by that object.  Parser objects\r\n"
                    "the space immediately.  A command word is pushed to the stack so that\r\n"
                    "This is not a command word.  It is intercepted by the space and affects\r\n"
                    "\r\n"
                    "Notes:\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              Nothing.\r\n"
                    "\r\n"
                    "Example phrase:    .@ myList\r\n"
                    "\r\n"
                    "the name of the stack or list object that is to receive subsequent pushes.\r\n"
                    "Summary: Modifies the parsing of the next word, which will be parsed as\r\n"
                    "\r\n"
                else if( !ether.strCompareF( tinP , psttQueryWord , T(".@") ) ) tBody += T(
                    ) ;
                    "    . off space\r\n"
                    "\r\n"
                    "    . \"Hello!\" POPUP\r\n"
                    "\r\n"
                    "    . on space\r\n"
                    "\r\n"
                    "Simple example:\r\n"
                    "\r\n"
                    "the strokeS string, interpret it as a command, and obey it.\r\n"
                    "the object named ")+T(postName)+T(" to manifest.  That object will pop\r\n"
                    "string object since \"quiet\" is not numeric.  The following word causes\r\n"
                    "object whose value is \"quiet\".  The value will be pushed as a strokeS\r\n"
                    "In the example phrase, the \".\" tells the space to push an unnamed\r\n"
                    "\r\n"
                    "in this manner.\r\n"
                    "object interface specification.  These departures are few, and are noted\r\n"
                    "are the only class of objects that do not completely conform to the SOIL (tm)\r\n"
                    "it can be popped by an object and obeyed by that object.  Parser objects\r\n"
                    "the space immediately.  A command word is pushed to the stack so that\r\n"
                    "This is not a command word.  It is intercepted by the space and affects\r\n"
                    "\r\n"
                    "Notes:\r\n"
                    "\r\n"
                    "Pushes:            Nothing.\r\n"
                    "\r\n"
                    "Pops:              Nothing.\r\n"
                    "\r\n"
                    "Example phrase:    . quiet ")+T(postName)+T("\r\n"
                    "\r\n"
                    "Else, it will be pushed as a string of strokeS objects.\r\n"
                    "a literal.  If it is a valid countT object, it will be pushed as a countT.\r\n"
                    "Summary: Modifies the parsing of the next word, which will be parsed as\r\n"
                    "\r\n"
                if( !ether.strCompareF( tinP , psttQueryWord , T(".") ) ) tBody += T(

                ) ;

                    "\r\n"
                    "is also an executable SOIL (tm) program.\r\n"
                    "manifest that code, drop this file into the Mouth.  IOW, this file\r\n"
                    "Instructions:  Read this file.  It contains simple example code.  To\r\n"
                    "\r\n"
                    "\r\n"
                    "Subject: Command word \"")+T(psttQueryWord)+T("\"\r\n"
                    "\r\n"
                    "Author: ")+T(postName)+T("\r\n"
                    "Class: soixlOldSpaceC")+T("\r\n"
                    "\r\n"
                    "IdeaFarm " "(tm) SOIL (tm) <> Sentient Object Interface Language\r\n"
                    USCORE79 "\r\n"
                    "\r\n"
                    ". off space\r\n"
                    POSTpROLOG "\r\n"

                tBody = T(
                TN( tBody , "" ) ;

                *paStack >> psttQueryWord ;
                ZE( strokeS* , psttQueryWord ) ;
            {
            else if( !ether.strCompareF( tinP , psttw , T("??") ) )
            }
                POPUPsOIXLoLD( T("I, \"")+T(postName)+T("\", have created \"")+tNameShort+T("\".  Read that document and then edit it to indicate what additional information you want.  Then drop it into the Mouth to obtain the additional information.") ) ;
                ether.boxPutF( tinP , tName , tBody , tBody.csF(  tinP ) ) ;
                TN( tName , "" ) ; tName = tSoixlOld+tNameShort ;
                TN( tNameShort , "") ; tNameShort = T("soixlOld.help.")+T(postName)+T(".txt") ;

                TN( tMouthShort , postSOIXLoLDfILESfOLDERS_SHORTmOUTH ) ;
                TN( tSoixlOldShort , postSOIXLoLDfILESfOLDERS_SHORTsOIXLoLD ) ;
                TN_tMouth
                TN_tSoixlOld

                ether.delF( tinP , pstth ) ;
                tBody = T(pstth) ;
                ether.strReverseF( tinP , pstth , tBody , T("\r\n") ) ; ___( pstth ) ;
                ZE( strokeS* , pstth ) ;

                ) ;

                    ". off space\r\n"

                tBody += T(

                }
                    if( pObject != this ) tBody += T("    . ? ")+T(pObject->postNameF(tinP))+T("\r\n") ;
                    baseSoilXxxxC*& pObject = *(baseSoilXxxxC**)&(countT&)sw_pObject ;
                    postLever = (osTextT*)sw_pObject.leverF( tinP , idf ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                cFlavors = sw_pObject.cFlavorsF( tinP ) ;

                ) ;

                    ". on space\r\n"
                    "\r\n"
                    "this document into the Mouth.\r\n"
                    "To obtain additional information, d" "elete ze""ro or more of the following lines and then drop\r\n"
                    "\r\n"

                tBody += T(

                }}
                    if( pObject != this ) tBody += T("    \"")+T(pObject->postNameF(tinP))+T("\"\r\n") ;
                    baseSoilXxxxC*& pObject = *(baseSoilXxxxC**)&(countT&)sw_pObject ;
                    postLever = (osTextT*)sw_pObject.leverF( tinP , idf ) ;
                {
                {for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                countT cFlavors = sw_pObject.cFlavorsF( tinP ) ;

                ) ;

                    "\r\n"
                    "The names of the objects that I work with are:\r\n"
                    "\r\n"
                    "about the words that each object understands.\r\n"
                    "way, you can obtain further information about how your SOIL (tm) text is processed and\r\n"
                    "the Mouth.  You can reference these objects by name in your SOIL (tm) text.  In this\r\n"
                    "I work with other objects to process the SOIL (tm) program text that you drop into\r\n"
                    "\r\n"
                    ". off space\r\n"
                    ". +        . ?? ")+T(postName)+T("\r\n"
                    ". x        . ?? ")+T(postName)+T("\r\n"
                    ". =        . ?? ")+T(postName)+T("\r\n"
                    ". n        . ?? ")+T(postName)+T("\r\n"
                    ". c        . ?? ")+T(postName)+T("\r\n"
                    ". b@       . ?? ")+T(postName)+T("\r\n"
                    ". #        . ?? ")+T(postName)+T("\r\n"
                    ". noquiet  . ?? ")+T(postName)+T("\r\n"
                    ". quiet    . ?? ")+T(postName)+T("\r\n"
                    ". version  . ?? ")+T(postName)+T("\r\n"
                    ". tm       . ?? ")+T(postName)+T("\r\n"
                    ". soixlOld     . ?? ")+T(postName)+T("\r\n"
                    ". ??       . ?? ")+T(postName)+T("\r\n"
                    ". ?        . ?? ")+T(postName)+T("\r\n"
                    ". quit     . ?? ")+T(postName)+T("\r\n"
                    ". on       . ?? ")+T(postName)+T("\r\n"
                    ". off      . ?? ")+T(postName)+T("\r\n"
                    ". .@       . ?? ")+T(postName)+T("\r\n"
                    ". .0       . ?? ")+T(postName)+T("\r\n"
                    ". .        . ?? ")+T(postName)+T("\r\n"
                    ". on space\r\n"
                    "\r\n"
                    "representative in IdeaFarm " "(tm) Space.\r\n"
                    "Object synopsis: The author of this document, \"")+T(postName)+T("\", is your\r\n"
                    "\r\n"
                    "objects there, including soixlOldSpaceC objects representing other humans.\r\n"
                    "the human can be present in IdeaFarm " "(tm) Space and can interact with the other\r\n"
                    "operator in IdeaFarm " "(tm) Space.  Through the intermediary of a soixlOldSpaceC object,\r\n"
                    "Class synopsis: Each object of the soixlOldSpaceC class represents a single human computer\r\n"
                    "\r\n"
                    "Author: ")+T(postName)+T("\r\n"
                    "Class: soixlOldSpaceC")+T("\r\n"
                    "\r\n"
                    "IdeaFarm " "(tm) SOIL (tm) <> Sentient Object Interface Language\r\n"
                    ". off space\r\n"
                    ". quiet space\r\n"
                    POSTpROLOG "\r\n"

                tBody = T(
                TN( tBody , "" ) ;
            {
            else if( !ether.strCompareF( tinP , psttw , T("?") ) )
            else if( !ether.strCompareF( tinP , psttw , T("useLex") ) ) slP >> psttUseLex ;
            }
                ether.delF( tinP , psttFileName ) ;

                }
                    ether.delF( tinP , posti ) ;
                    }
                        ether.delF( tinP , psttr ) ;
                        *this << psttr ;
                        ether.strReverseF( tinP , psttr , T(posti) , T("\r\n") ) ; ___( psttr ) ;
                        ZE( strokeS* , psttr ) ;
                    {
                    if( posti && costi )
                    ether.boxGetShadowF( tinP , posti , costi , psttFileName ) ;
                    ZE( countT   , costi ) ;
                    ZE( osTextT* , posti ) ;
                {
                if( psttFileName && ether.diskFileExistsF( tinP , psttFileName ) )

                slP >> psttFileName ;
                ZE( strokeS* , psttFileName ) ;
            {
            else if( !ether.strCompareF( tinP , psttw , T("include") ) )
            else if( !ether.strCompareF( tinP , psttw , T("c") ) ) bLiteralCount = 1 ;
            }
                }
                    *paStack << pbz ;
                    ZE( byteT* , pbz ) ;
                    bLiteralNull = 0 ;
                {
                else
                if( !bLiteralNull ) bLiteralBytesAt = 1 ;
            {
            else if( !ether.strCompareF( tinP , psttw , T("b@") ) )
            }
                ether.delF( tinP , psttDefName ) ;
                ether.delF( tinP , psttNewWord ) ;

                }
                    }
                        else { POPUPsOIXLoLD( T(psttDefName)+T(" is a ")+T(psttOldClass)+T(" object.  \".x\" requires a list object") ) ; }
                        }
                            *paStack << psttNewWord O2(IDcMDwORD_DEFINE,lex) ;
                            *paStack << *(soulC*)pObject ;
                            lexC& lex = *(lexC*)stLex[ 1 ] ;
                        {
                        if( !ether.strCompareF( tinP , psttOldClass , T("soulC") ) )
                        *paStack >> psttOldClass ;
                        ZE( strokeS* , psttOldClass ) ;
                        *paStack << (countT)ifcIDcMDbASE_CLASSnAME << pObject ;
                    {
                    if( pObject )
                    baseSoilXxxxC* pObject = (baseSoilXxxxC*)(countT)sw_pObject ;
                {
                if( sw_pObject.idSlotOfLeverF( tinP , (countT)postLever ) )
                postLever = tLever ;
                TN( tLever , "" ) ; tLever = T(psttDefName) ;

                *paStack >> psttDefName ;
                ZE( strokeS* , psttDefName ) ;
                *paStack >> psttNewWord ;
                ZE( strokeS* , psttNewWord ) ;
            {
            else if( !ether.strCompareF( tinP , psttw , T("x") ) )
            }
                }
                    }
                        else { POPUPsOIXLoLD( T(postName)+T(" is a ")+T(psttOldClass)+T(" object.  \".=\" requires countC object") ) ; }
                        }
                            *(countC*)pObject = vv ; //U:: USE THE FORTH INTERFACE TO THE OBJECT
                            *paStack >> vv ;
                            ZE( countT , vv ) ;
                        {
                        if( !ether.strCompareF( tinP , psttOldClass , T("countC") ) )
                        *paStack >> psttOldClass ;
                        ZE( strokeS* , psttOldClass ) ;
                        *paStack << (countT)ifcIDcMDbASE_CLASSnAME << pObject ;
                    {
                    if( pObject )
                    baseSoilXxxxC* pObject = (baseSoilXxxxC*)(countT)sw_pObject ;
                {
                if( sw_pObject.idSlotOfLeverF( tinP , (countT)postLever ) )

                postLever = tLever ;
                TN( tLever , "" ) ; tLever = T(psttToName) ;

                *paStack >> psttToName ;
                ZE( strokeS* , psttToName ) ;
            {
            else if( !ether.strCompareF( tinP , psttw , T("=") ) )
            }
                ether.delF( tinP , psttw ) ;
                ether.strokeF( tinP , T("comment: \"")+T(psttw)+T("\"\r\n") ) ;
                *paStack >> psttw ;
                ZE( strokeS* , psttw ) ;
            {
            else if( !ether.strCompareF( tinP , psttw , T("#") ) )
            }
                ether.delF( tinP , psttw ) ;
                csttExtra = idv ;
                *paStack >> idv ;
                ZE( countT , idv ) ;
            {
            else if( !ether.strCompareF( tinP , psttw , T("+") ) )
            }
                ether.delF( tinP , psttw ) ;
                if( idv != 1 ) { POPUPsOIXLoLD( T("I do not know how to parse SOIL (tm) code that specifies version ")+TF2(idv,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".") ) ; }
                *paStack >> idv ;
                ZE( countT , idv ) ;
            {
            else if( !ether.strCompareF( tinP , psttw , T("version") ) )
            }
                ether.delF( tinP , psttw ) ;
                if( ether.strCompareF( tinP , psttw , T("IdeaFarm") ) ) { POPUPsOIXLoLD( T("I do not know how to parse SOIL (tm) code that is marked with the \"")+T(psttw)+T("\" trademark.") ) ; }
                *paStack >> psttw ;
                ZE( strokeS* , psttw ) ;
            {
            else if( !ether.strCompareF( tinP , psttw , T("tm"     ) ) )  //"tm" IS FOR "TRADE MARK"
            else if( !ether.strCompareF( tinP , psttw , T("quit"   ) ) ) bQuit = 1 ;
            else if( !ether.strCompareF( tinP , psttw , T("on"     ) ) ) scOff -- ; //ADDED BECAUSE APPARENTLY A MISSING LINE BUG
            else if( !ether.strCompareF( tinP , psttw , T("off"    ) ) ) scOff ++ ;
            else if( !ether.strCompareF( tinP , psttw , T("noquiet") ) ) scQuiet -- ;
            else if( !ether.strCompareF( tinP , psttw , T("quiet"  ) ) ) scQuiet ++ ;
            else if( !ether.strCompareF( tinP , psttw , T("soixlOld"   ) ) ) ; //"soixlOld" IS FOR "SENTIENT OBJECT INTERFACE LANGUAGE"
            if( psttUseLex ) bLookup = 1 ;
            ZE( boolT , bLookup ) ;

            //ether.strokeF( tinP , T(postName)+T(" received \"")+T(psttw)+T("\"\r\n") ) ;
            slP >> psttw ;
            ZE( strokeS* , psttw ) ;
        {
        case ifcIDcMDbASE_CMDdEFAULT :
        }
            break ;
            slP.flags = save ;
            slP << (baseSoilXxxxC*)this ;
            slP.flags &= ~( F(flSOUL_LIVE) ) ;
            flagsT save = slP.flags ;
        {
        case ifcIDcMDbASE_REFERENCE :
        }
            break ;
        {
        case ifcIDcMDbASE_TOCK :
        }
            break ;
        {
        case ifcIDcMDbASE_TICK :
        }
            break ;
            slP << (strokeS*)T(postName) ;
        {
        case ifcIDcMDbASE_INSTANCEnAME :
        }
            break ;
            slP << (strokeS*)T("soixlOldSpaceC") ;
        {
        case ifcIDcMDbASE_CLASSnAME :
    {
    switch( idCmdBase )
    slP >> idCmdBase ;
    ZE( countT , idCmdBase ) ;

    }
        if( pMeI != (baseSoilXxxxC*)this ) { BLAMMO ; }
        slP >> pMeI ;
        ZE( baseSoilXxxxC* , pMeI ) ;
    {
{
/*1*/voidT soixlOldSpaceC::operator ()( tinS& tinP , soulC& slP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

