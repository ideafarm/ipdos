
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tinP , T("bye") ) ;
etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    sgnGo.giveF( tinP , ifcIDmODEsIGNgIVE_FLASH ) ;

    grabAccumulators.ungrabF( tinP ) ;
    mMax = 0 ;
    mSum = 0 ;
    mMin = MAXcOUNTT ;
    cGorillasWaiting = 0 ;
    etThread.traceF( tinP , T("----------------------------------------------------------------------- [idCycle,mMin,mMean,mMax]:   ")+TF2(++idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)mMin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)mSum,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)mMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_1 ) ;
    mSum /= cProcessors ;
    grabAccumulators.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        etThread.osSleepF( tinP , TOCK >> 6 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;

        if( cWaiting == cProcessors ) break ;
        //etThread.traceF( tinP , T("[cWaiting]:   ")+TF2(cWaiting,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        countT cWaiting = grabb.idGrabberHighF() - grabb.idGrabberOkF() ;
        const grabC& grabb = sgnGo ;
    {
    for(;;)     // THIS LOOP PREVENTS RACE IN WHICH I GIVE SIGN BEFORE ALL GORILLA THREADS ARE ACTUALLY REGISTERED AS WAITING WITHIN THE grabC OBJECT WITHIN THE SIGN

    }
        ether.osSleepF( tinP , TICK >> 4 , TOCK , flSLEEP_null ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    while( !ether && cGorillasWaiting < cProcessors )  // NORMALLY WILL EXECUTE ONLY WO ITERATION ; CODED THIS WAY TO HANDLE HEAVILY LOADED COMPUTER ON WHICH exerciseF DOES NOT COMPLETE WITHIN THE INTENDED PERIOD
{
while( !ether || cExtra -- )
countT cExtra = 0 ;
ZE( countT , idCycle ) ;

ether.ifcHireF( tinP , T("ifcIDaDAM_WATCHiDLEcPU") , ifcIDaDAM_HOMEfLAGS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

while( cDo -- ) etThread.osThreadF( TaRG1( tmGorillaF ) , (countT)&sgnGo , (countT)&cGorillasWaiting , (countT)&grabAccumulators , (countT)&mMin , (countT)&mSum , (countT)&mMax ) ;
countT cDo = cProcessors ;
TN( tb4 , "    " ) ;
grabC grabAccumulators( tinP , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS , ifcIDgRABlAYER_7BASEmISC1 ) ;    //20200610@2039: flGRABc_NOTjEALOUS ADDED WITHOUT ANALYSIS WITHOUT IDENTIFYING THIS AS THE CULPRIT IN A JEALOUSY
ZE( measure04T , mMax  ) ;
ZE( measure04T , mSum  ) ;
ZE( measure04T , mMin  ) ;
signC sgnGo( tinP , TAG( TAGiDnULL ) ) ;
ZE( countT , cGorillasWaiting ) ;

etThread.traceF( tinP , T("[cProcessors]:    ")+TF2(cProcessors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
const countT cProcessors = thirdC::osProcessorsIF( tinP ) ;

TODO

DONE( tmGorillaF )
}
    etThread.osThreadSwitchingDesireF( tinP , idPriorityDefault ) ;
    }
        }
            grabAccumulatorsP.ungrabF( tinP ) ;

            if( mMaxP < timeB1 ) mMaxP  = timeB1 ;
                                 mSumP += timeB1 ;
            if( mMinP > timeB1 ) mMinP  = timeB1 ;

            grabAccumulatorsP.grabF( tinP , TAG( TAGiDnULL ) ) ;

            etThread.traceF( tinP , T("time to complete: ")+TF2(timeB1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            etThread.osTimeSubtractF( tinP , timeB1 , timeB2 , timeA1 , timeA2 ) ;
            etThread.osTimeNowF( tinP , timeB1 , timeB2 ) ;
            ZE( sCountT , timeB2 ) ;
            ZE( countT , timeB1 ) ;

            etThread.osThreadSwitchingDesireF( tinP , idPriorityRude ) ;
            }
                //etThread.traceF( tinP , t2 ) ;
                exerciseF( bQuit ) ;
                //etThread.traceF( tinP , t1 ) ;
            {
            while( cDo -- )
            countT idPriorityRude = etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIEST ) ;

            const countT& bQuit = ether ;
            countT cDo = CeXERCISES ;

            etThread.osTimeNowF( tinP , timeA1 , timeA2 ) ;
            ZE( sCountT , timeA2 ) ;
            ZE( countT , timeA1 ) ;
        {
        if( !ether )        

        sgnGoP.waitF( tinP , flSIGNcWAIT_null ) ;

        //}
        //    ether.osSleepF( tinP , TOCK << 6 ) ;
        //    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        //{
        //U::REMOVE IN PRODUCTION ; THIS IS TO ELICIT RACE CONDITION TO VERIFY THAT CODE HANDLES IT BY NOT ALLOWING SIGN TO BE GIVEN BEFORE ALL ARE WAITING

        inc02AM( cGorillasWaitingP ) ;
    {
    while( !ether )
    countT idPriorityDefault = etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;

    TN( t2 , "called  exerciseF" ) ;
    TN( t1 , "calling exerciseF" ) ;
    measure04T& mMaxP             = *(measure04T*)pTaskP->c6 ;
    measure04T& mSumP             = *(measure04T*)pTaskP->c5 ;
    measure04T& mMinP             = *(measure04T*)pTaskP->c4 ;
    grabC&      grabAccumulatorsP =      *(grabC*)pTaskP->c3 ;
    countT&     cGorillasWaitingP =     *(countT*)pTaskP->c2 ;
    signC&      sgnGoP            =      *(signC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmGorillaF )

}
    while( !bQuitP && cDo -- ) ;
    }
        cc = cDo * cDo ;
    {
    do
    ZE( countT , cc ) ;
    countT cDo = ( TICK << 5 ) - 1 ;     // WILL DO THIS + 1 ITERATIONS
{
voidT exerciseF( const countT& bQuitP )         // WO CALL TO ME TAKES ABOUT 1 TOCK ON factory 1

#define CeXERCISES 1

/*1*/WAKEhIDE( "ifcIDaDAM_WATCHiDLEcPU" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
