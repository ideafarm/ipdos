
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        }
            }
                }
                    break ;

                    POSTPONEtEST( psttP ) ; // CALLER MUST TAG
                    }
                        strSubstringF( tinP , psttP , idf , idl , psttAllP , csttExtraP ) ;
                        if( idl ) idl -- ;
                    {
                    else
                    if( idl == idf ) strMakeF( tinP , psttP , T("") , csttExtraP ) ;
                {
                if( idLine == idLineP )

                countT idl = bAnyP ? strIdAnyF( tinP , 0 , flSTRmATCH_null , idFirstP , sttQuoteP , tEnd , psttAllP ) : strIdF( tinP , 0 , flSTRmATCH_null , idFirstP , sttQuoteP , tEnd , psttAllP ) ;
                countT idf = idFirstP ;

                idLine ++ ;
            {
            while( !POOP && idFirstP ) 
            ZE( countT , idLine ) ;
        {
        else
        }
            }
                POSTPONEtEST( psttP ) ;
                strSubstringLineF( tinP , psttP , idFirstP , sttQuoteP , psttAllP , cWords + idLineP + 1 , tEnd , bAnyP , csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;
            {
            if( cWords + idLineP >= 0 )
            sCountT cWords = strCLinesF( tinP , psttAllP , tEnd , 1 ) ;
        {
        if( idLineP < 0 )

        textC tEnd = psttEndP ? T(psttEndP) : T("\r\n") ;
    {
    if( psttAllP->idAdam )

    _INoLD_

    }
        if( POOP ) return ;
        __Z( idLineP ) ;
        __Z( psttAllP ) ;
        __Z( idFirstP ) ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/**//*1*/voidT etherC::strSubstringLineF( tinS& tinP , strokeS*& psttP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* const psttAllP , const sCountT idLineP , const strokeS* const psttEndP , const boolT bAnyP , const countT csttExtraP )/*1*/
*/
 csttExtraP
  if 1 then each substring that consists only of strokes in psttEndP is treated as a delimiter
  of 0 then each occurance of psttEndP is treated as a delimiter
 bAnyP
  if 0 then T("\r\n") is used
  delimits each line
 psttEndP
   - 1 refers to the last line
  if negative then indexes from the end
  can be negative
  must not be 0
 idLineP
  must not be 0
 psttAllP
  normally, this should be 0 when beginning to process psttAllP
 sttQuoteP
  normally this should be 1 when beginning to process psttAllP
  must not be 0
 idFirstP
  must be 0
 psttP
arguments
 in contrast, strWordsOldF will copy the entire input
 this results in using less poolOld space
 this copy can be d eleted by the caller before calling me for the next line
 my efficiency is that i only create a copy of wo line per call
i am more efficient than strWordsOldF
if there are not enough lines, psttP will be 0 and impotence does not occur
this can be evaluated repeatedly with idLineP == 1 to retrieve each line in psttAllP
retrieves the idLineP'th line in psttAllP, treating the stroke at idFirstP as in line 1
  \<A HREF=\"5.3030104.1.1.0.html\"\>3030104:  WAKEsHOW( "example.simplest.func.10300dc.etherC.strSubstringLineF" )\</A\>
 simplest
examples
\<A HREF=\"5.10300dc.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strSubstringLineF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

