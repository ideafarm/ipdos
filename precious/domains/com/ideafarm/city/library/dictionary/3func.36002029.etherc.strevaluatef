
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bTagsStillExist ;
    delF( tinP , psttOld ) ;

    __( STOP ) ;
    }
        }
            }
                delF( tinP , psttKid ) ;
                if( !bTagsStillExist ){ idfTrim2 = 1 ; sttqTrim2 = sttq ; bTagsStillExist = !!strIdF( tinP , 0 , flSTRmATCH_null , idfTrim2 , sttqTrim2 , T("/" "/" "|" "|" "!") , psttP ) ; }

                }
                    }
                        delF( tinP , psttw ) ;
                        strFuseF( tinP , psttP , psttw ) ;
                        strFuseF( tinP , psttP , T(" ") ) ; ___( psttP ) ;
                        strIndentOldF( tinP , psttw , 1 , strokeS() , 0 , 0 ) ;
                        strTrimF( tinP , psttw , 0 , T(TbLACKnEWlINE) ) ;
                        strReplaceAnyF( tinP , psttw , 0 , T(" ") , T(" ") ) ;
                        strSubstringF( tinP , psttw , idfChunk , sttqc , idlChunk , psttKid ) ;
                        ZE( countT , idlChunk ) ;
                    {
                    if( idfChunk )

                    delF( tinP , psttw ) ;
                    strFuseF( tinP , psttP , T("\r\n") ) ; ___( psttP ) ;
                    strFuseF( tinP , psttP , psttw ) ;
                    strFuseF( tinP , psttP , T(" ") ) ; ___( psttP ) ;
                    strIndentOldF( tinP , psttw , 1 , strokeS() , 0 , 0 ) ;
                    strTrimF( tinP , psttw , 0 , T(TbLACKnEWlINE) , T("\t\x1a") , strokeS() ) ;
                    strSubstringF( tinP , psttw , idfChunk , sttqc , T("*/") , psttKid ) ;

                    delF( tinP , psttw ) ;
                    strSubstringF( tinP , psttw , idfChunk , sttqc , T("/*") , psttKid ) ;

                    strokeS sttqc( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idfChunk = 1 ;
                    ZE( strokeS* , psttw ) ;
                {

                strAbridgeF( tinP , psttKid , 0 , 0 ) ;
                strReplaceAutomaticallyF( tinP , psttKid ) ;
                strReverseF( tinP , psttKid , 0 , T("\r\n") ) ;
                delF( tinP , postKid ) ;
                strMakeF( tinP , psttKid , T(postKid) ) ;
                ZE( strokeS* , psttKid ) ;
                delF( tinP , psttw ) ;
                }
                    }
                        costKid = strMakeF( tinP , postKid , psttw ) ;
                        ifcSayIF( T("103002f ERROR: File \"")+T(psttw)+T("\" does not exist") , flSAY_APPEND | flSAY_LOG ) ;
                        POOPR
                    {
                    if( POOP )
                    tinP.pEtScratch->boxGetShadowF( tinP , postKid , costKid , psttw , 1 ) ; ___( postKid );
                    ZE( countT   , costKid ) ;
                    SCOOPS
                {
                IFsCRATCH
                ZE( osTextT* , postKid ) ;
                strSubstringF( tinP , psttw , idf , sttq , T("!" "|" "|") , psttOld ) ; ___( psttw ) ;
                sttq = sttqTrim2 ;
                idf = idfTrim2 ;
            {
            else if( bTrim2 )            
            }
                delF( tinP , psttKid ) ;
                else     { idfTrim = 1 ; sttqTrim = sttq ; bTagsStillExist |= !!strIdF( tinP , 0 , flSTRmATCH_null , idfTrim , sttqTrim , T("/" "/" "|" "|" "!") , psttKid ) ; }
                if( bKt ){ idfKt   = 1 ; sttqKt   = sttq ; bTagsStillExist |= !!strIdF( tinP , 0 , flSTRmATCH_null , idfKt   , sttqKt   , T("/" "/" "|" "|" "!") , psttKid ) ; }

                }
                    boxPutF( tinP , T("///d/tmpe.b")  , tb  , tb.csF( tinP  ) ) ; //U::
                    TN( tb  , "" ) ; tb  = T(psttP) ; //U::
                {
                if( bDebug )

                strFuseF( tinP , psttP , psttKid ) ; ___( psttP ) ;
                strFuseF( tinP , psttP , T(" ") ) ; ___( psttP ) ;
                }
                    boxPutF( tinP , T("///d/tmpe.a")  , ta  , ta.csF( tinP  ) ) ; //U::
                    TN( ta  , "" ) ; ta  = T(psttKid) ; //U::
                {
                if( bDebug )
                strReplaceF( tinP , psttKid , 0 , T("@" "." " ") , T(" . ") ) ; ___( psttKid ) ;
                }
                    boxPutF( tinP , T("///d/tmpe.9")  , t9  , t9.csF( tinP  ) ) ; //U::
                    TN( t9  , "" ) ; t9  = T(psttKid) ; //U::
                {
                if( bDebug )
                strIndentOldF( tinP , psttKid , 1 , strokeS() , 0 , 0 ) ; ___( psttKid ) ;
                }
                    boxPutF( tinP , T("///d/tmpe.8")  , t8  , t8.csF( tinP  ) ) ; //U::
                    TN( t8  , "" ) ; t8  = T(psttKid) ; //U::
                {
                if( bDebug )
                strRemoveBlankLinesF( tinP , psttKid , 0 , 0 , T("/*") ) ; ___( psttKid ) ; // SUPPRESS THE "/*" AND "*/" LINES THAT DELIMIT THE FILE COMMENTS
                }
                    boxPutF( tinP , T("///d/tmpe.7")  , t7  , t7.csF( tinP  ) ) ; //U::
                    TN( t7  , "" ) ; t7  = T(psttKid) ; //U::
                {
                if( bDebug )
                else      { strTrimF( tinP , psttKid , 0 , T(TbLACKnEWlINE) ) ; ___( psttKid ) ; }
                if( bKt ) { strTrimF( tinP , psttKid , 0 , T(TbLACKnEWlINE) , T("\t\x1a")              , strokeS() ) ; ___( psttKid ) ; }
                }
                    boxPutF( tinP , T("///d/tmpe.6")  , t6  , t6.csF( tinP  ) ) ; //U::
                    TN( t6  , "" ) ; t6  = T(psttKid) ; //U::
                {
                if( bDebug )
                strReplaceF( tinP , psttKid , 0 , T("/" "@" "@" "/") , T("/" "*" "*" "/") ) ; ___( psttKid ) ;
                }
                    boxPutF( tinP , T("///d/tmpe.5")  , t5  , t5.csF( tinP  ) ) ; //U::
                    TN( t5  , "" ) ; t5  = T(psttKid) ; //U::
                {
                if( bDebug )
                strAbridgeF( tinP , psttKid , 0 , 0 ) ; ___( psttKid ) ;
                }
                    boxPutF( tinP , T("///d/tmpe.4")  , t4  , t4.csF( tinP  ) ) ; //U::
                    TN( t4  , "" ) ; t4  = T(psttKid) ; //U::
                {
                if( bDebug )
                strReplaceAutomaticallyF( tinP , psttKid ) ; ___( psttKid ) ;

                }
                    boxPutF( tinP , T("///d/tmpe.3")  , t3  , t3.csF( tinP  ) ) ; //U::
                    TN( t3  , "" ) ; t3  = T(psttKid) ; //U::
                {
                if( bDebug )
                strReverseF( tinP , psttKid , 0 , T("\r\n") ) ; ___( psttKid ) ;

                }
                    boxPutF( tinP , T("///d/tmpe.2")  , t2  , t2.csF( tinP  ) ) ; //U::
                    TN( t2  , "" ) ; t2  = T(psttKid) ; //U::

                    delF( tinP , psttv ) ;
                    strInsertF( tinP , psttKid , idtInsert , psttv ) ;

                    boxPutF( tinP , T("///d/tmpe.1") , t1 , t1.csF( tinP ) ) ; //U::
                    TN( t1 , "" ) ; t1 = T(psttKid) ; //U::

                    strReplaceF( tinP , psttv , 0 , T("/" "/" "|" "|") , T("/" "/" "%" "%") ) ; ___( psttv ) ; // ASSUME: NO SOURCE LINES WILL EVER CONTAIN "/" "/" "%" "%"
                    strReplaceF( tinP , psttv , 0 , T("/" "*" "*" "/") , T("/" "@" "@" "/") ) ; ___( psttv ) ; // ASSUME: NO SOURCE LINES WILL EVER CONTAIN "/" "@" "@" "/"

                    //if( bFound ) { strFuseF( tinP , psttv , T("daffynition\r\n") ) ; ___( psttv ) ; }
                    //THIS WAS ENABLED IN ORDER TO FIX.  THE PRECEDING COMMENT (COMMENTED OUT BECAUSE...) APPEARS TO DOCUMENT A MISTAKE: THE FOLLOWING LINE IS NEEDED
                    // COMMENTED OUT BECAUSE THE "definition" LINK IS NOW INSERTED INTO ALL VISIBLE SOURCE BY bf30104/listVisibleDefinitionsFlistVisibleDefinitionsF

                    }
                        }
                            delF( tinP , psttl ) ;
                            strFuseF( tinP , psttv , T("@" "." " ")+T(psttl)+T("\r\n") ) ; ___( psttv ) ; // ASSUME: NO SOURCE LINES WILL EVER CONTAIN WITH "@" "." " "
                            if( !bFound ) bFound = 1 ;
                        {
                        if( psttl )
                        strSubstringF( tinP , psttl , idf , sttq , T("\r\n") , psttKid ) ; ___( psttl ) ;
                        ZE( strokeS* , psttl ) ;
                    {
                    while( idf && !POOP )
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf = 1 ;
                    ZE( boolT , bFound ) ;
                    strFuseF( tinP , psttv , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ psttKid ? psttKid->idAdam * 2 : 0 ) ; ___( psttv ) ;
                    ZE( strokeS* , psttv ) ;
                    bDebug = 1 ; //U::
                {
                if( idtInsert )
                ZE( boolT , bDebug ) ; //U::

                }
                    }
                        }
                            else idtInsert -- ;
                            else if( psttKid[ CSpREFIX - 2 + idtInsert ] == sLF ) break ;
                            if( idtInsert == 1 ) idtInsert = 0 ;
                        {
                        while( idtInsert )
                        strokeS sLF( '\n' ) ;
                    {
                    if( idtInsert ) //MOVE CURSOR BACK TO THE BEGINNING OF THE CURRENT LINE
                    idtInsert = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tLink , psttKid ) ;
                    countT idf = 1 ;
                    TN( tLink , "" ) ; tLink = T(".1.0.html\\\"\\>definition\\</A\\>\r\n") ;
                {
                if( idtVisible )
                ZE( countT , idtInsert ) ; //"idt" = "ID TAG"

                }
                    idtVisible = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , T("\r\n//VISIBLE\r\n") , psttKid ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf = 1 ;
                {
                ZE( countT , idtVisible ) ; //"idt" = "ID TAG"
                // IF THIS FILE IS TO BE VISIBLE, AND THERE EXISTS A DEFINITION LINK, FORMAT AND INSERT IT

                }
                    }
                        idClass = 0 ;
                        delF( tinP , psttSet ) ;
                        }
                            }
                                }
                                    delF( tinP , psttl ) ;
                                    }
                                        delF( tinP , psttw ) ;
                                        strFuseF( tinP , psttKid , T("\r\n")+T(psttw) ) ;
                                        strWordF( tinP , psttw , psttl , sttq , S1C(' ') , 2 ) ; ___( psttw ) ;
                                        ZE( strokeS* , psttw ) ;
                                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                    {
                                    if( psttl->idAdam )
                                {
                                if( psttl )
                                strSubstringF( tinP , psttl , idfs , sttqs , T("\r\n") , psttSet ) ; ___( psttl ) ;
                                ZE( strokeS* , psttl ) ;
                            {
                            while( idfs && !POOP )
                            strokeS sttqs( (countT)0 , sc_IGNOREqUOTES ) ;
                            countT idfs = 1 ;
                        {
                        if( psttSet && idClass == 3 )
                        strSubstringDelimitedF( tinP , psttSet , idClass , idf , sttq , psttKid ) ; ___( psttSet ) ;
                        ZE( strokeS* , psttSet ) ;
                        ZE( countT , idClass ) ;
                    {
                    while( idf && !POOP )
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf = 1 ;
                {
                // IF A LISTS OF SYMBOLIC CONSTANTS IS FOUND, FORMAT AND APPEND THEM

                delF( tinP , postKid ) ;
                strMakeF( tinP , psttKid , T(postKid) , costKid * 2 + 0x100 ) ; // 1 EXTRA FOR SYMBOLIC CONSTANTS, 1 EXTRA FOR VISIBLE, 0x100 FOR MISCELLANY
                ZE( strokeS* , psttKid ) ;
                delF( tinP , psttw ) ;
                }
                    }
                        costKid = strMakeF( tinP , postKid , psttw ) ;
                        ifcSayIF( T("103002f WARNING 1: File \"")+T(psttw)+T("\" does not exist") , flSAY_APPEND | flSAY_LOG ) ;
                        POOPR
                    {
                    if( POOP )
                    tinP.pEtScratch->boxGetShadowF( tinP , postKid , costKid , psttw , 1 ) ; ___( postKid );
                    SCOOPS
                {
                IFsCRATCH
                ZE( countT   , costKid ) ;
                ZE( osTextT* , postKid ) ;
                strSubstringF( tinP , psttw , idf , sttq , T("!" "|" "|") , psttOld ) ; ___( psttw ) ;
                else      sttq = sttqTrim ;
                if( bKt ) sttq = sttqKt ;
                else      idf = idfTrim ;
                if( bKt ) idf = idfKt ;
            {
            else if( bTrim || bKt )            
            }
                delF( tinP , psttKid ) ;

                strFuseF( tinP , psttP , psttKid ) ; ___( psttP ) ;
                strReplaceF( tinP , psttKid , 0 , T("@" "." " ") , T(" . ") ) ; ___( psttKid ) ;
                strReplaceF( tinP , psttKid , 0 , T("/" "@" "@" "/") , T("/" "*" "*" "/") ) ; ___( psttKid ) ;
                strReverseF( tinP , psttKid , 0 , T("\r\n") ) ; ___( psttKid ) ;

                }
                    delF( tinP , psttv ) ;
                    strMakeF( tinP , psttKid , psttv ) ; ___( psttKid ) ;
                    delF( tinP , psttKid ) ;
                    strReplaceF( tinP , psttv , 0 , T("/" "/" "|" "|") , T("/" "/" "%" "%") ) ; ___( psttv ) ; // ASSUME: NO SOURCE LINES WILL EVER CONTAIN "/" "/" "%" "%"
                    strReplaceF( tinP , psttv , 0 , T("/" "*" "*" "/") , T("/" "@" "@" "/") ) ; ___( psttv ) ; // ASSUME: NO SOURCE LINES WILL EVER CONTAIN "/" "@" "@" "/"
                    }
                        }
                            delF( tinP , psttl ) ;
                            strFuseF( tinP , psttv , T("@" "." " ")+T(psttl)+T("\r\n") ) ; ___( psttv ) ; // ASSUME: NO SOURCE LINES WILL EVER CONTAIN WITH "@" "|" " "
                            if( !bFound ) bFound = 1 ;
                        {
                        if( psttl )
                        strSubstringF( tinP , psttl , idf , sttq , T("\r\n") , psttKid ) ; ___( psttl ) ;
                        ZE( strokeS* , psttl ) ;
                    {
                    while( idf && !POOP )
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf = 1 ;
                    ZE( boolT , bFound ) ;
                    strFuseF( tinP , psttv , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ psttKid ? psttKid->idAdam * 2 : 0 ) ; ___( psttv ) ;
                    ZE( strokeS* , psttv ) ;
                {
                // FORMAT AND APPEND THE SPECIFIED FILE

                delF( tinP , postKid ) ;
                strMakeF( tinP , psttKid , T(postKid) , costKid * 2 + 0x100 ) ; // 1 EXTRA FOR SYMBOLIC CONSTANTS, 1 EXTRA FOR VISIBLE, 0x100 FOR MISCELLANY
                ZE( strokeS* , psttKid ) ;
                delF( tinP , psttw ) ;
                }
                    }
                        costKid = strMakeF( tinP , postKid , psttw ) ;
                        ifcSayIF( T("103002f WARNING 1: File \"")+T(psttw)+T("\" does not exist") , flSAY_APPEND | flSAY_LOG ) ;
                        POOPR
                    {
                    if( POOP )
                    tinP.pEtScratch->boxGetShadowF( tinP , postKid , costKid , psttw , 1 ) ; ___( postKid );
                    SCOOPS
                {
                IFsCRATCH
                ZE( countT   , costKid ) ;
                ZE( osTextT* , postKid ) ;
                strSubstringF( tinP , psttw , idf , sttq , T("!" "|" "|") , psttOld ) ; ___( psttw ) ;
                sttq = sttqRaw ;
                idf = idfRaw ;
            {
            if( bRaw )            
            boolT bKt   = idf == strIdF( tinP , 0 , flSTRmATCH_null , idfKt , sttqKt , T("kt|") , psttOld ) ;
            countT idfKt = idf ;
            strokeS sttqKt = sttq ;
            boolT bTrim2 = idf == strIdF( tinP , 0 , flSTRmATCH_null , idfTrim2 , sttqTrim2 , T("trim2|") , psttOld ) ;
            strokeS sttqTrim2 = sttq ;
            countT idfTrim2 = idf ;
            boolT bTrim = idf == strIdF( tinP , 0 , flSTRmATCH_null , idfTrim , sttqTrim , T("trim|") , psttOld ) ;
            strokeS sttqTrim = sttq ;
            countT idfTrim = idf ;
            boolT bRaw = idf == strIdF( tinP , 0 , flSTRmATCH_null , idfRaw , sttqRaw , T("raw|") , psttOld ) ;
            strokeS sttqRaw = sttq ;
            countT idfRaw = idf ;
        {
        if( idf )

        delF( tinP , psttw ) ;
        strFuseF( tinP , psttP , psttw ) ;
        strSubstringF( tinP , psttw , idf , sttq , T("/" "/" "|" "|" "!") , psttOld , 0 ) ; ___( psttw ) ;

        ZE( strokeS* , psttw ) ;
    {
    while( !STOP && !POOP && idf )
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    countT idf = 1 ;
    ZE( boolT , bTagsStillExist ) ;
    POSTPONEtEST( psttP ) ;
    strFuseF( tinP , psttP , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ psttOld->idAdam + csttExtraP ) ; // CALLER MUST TAG

    }
        psttP = 0 ;
        psttOld = psttP ;
    {
    else
    if( psttOldP ) { strFuseF( tinP , psttOld , psttOldP ) ; ___( psttOld ) ; }
    ZE( strokeS* , psttOld ) ;

    _IO_

    }
        if( POOP ) return 0 ;
        __( !!psttP && !!psttOldP ) ;
        __( !psttP && !psttOldP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/**//*1*/boolT etherC::strEvaluateF( tinS& tinP , strokeS*& psttP , const countT csttExtraP , const strokeS* const psttOldP )/*1*/
*/
  if psttP is 0 then psttOldP must not be 0
  can be 0
 psttOldP
 csttExtraP
  if psttOldP is 0 then psttP must not be 0
  can be 0
 psttP
arguments
 if a tag is raw, then it must be the only tag
it is illegal for a raw tag to occur along with another tag, raw or otherwise
the content of the file is edited and used to replace the symbol
the parameter is a file name
   each line will be prepended with a ". " so that leading blanks are preserved innocuously
  such files will be appended
  the file is visible if it contains a line that consists solely of "//VISIBLE"
 kt & trim: if the file is marked "visible" then it will be appended
 kt & trim: class 3 delimited substrings are assumed to be symbolic constant defines and will be formatted and appended
  strings of blanks are compressed, except in the file comments
  strokes above the file comments are trimmed for blanks as well as tabs and file eofs
  the file comments are trimmed for tab and end of file marks but not for blanks
  strokes prior to the file comments are discarded
  the referenced file must contain a file comment
 trim2: blanks are trimmed, except in the file comments, which are assumed to be at the base of the file
 trim: blanks are trimmed
 kt: blanks are not trimmed
 raw: each line is simply prepended with T(" | ")
the key indicates the type of replacement
the symbols contain a key and a parameter
replaces symbols in a string
 it is usually called repeatedly until it returns 0
 this function is not iterative
  if there is only one tag, and it is raw, then the return value is 0
 the occurance of a raw tag does not contribute to a nonze return value
evaluates to 1 iff the resulting string still contains tokens that could be evaluated
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.103002f.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strEvaluateF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

