
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

CELL( jobFillCourseF , jobHearOrderF , 0 )

}
    if( ether && *tinP.zEtScratch && cArgP && c8argP.c1 && sDataP && sNotesTextP && sNotesDataP && idChatSessionP ) ;

    }
        }
            break ;

            }
                }
                    break ;

                    etThread.delF( tinP , psttFrom ) ;
                    }
                        }
                            etThread.delF( tinP , psttu ) ;
                            etThread.boxPutUniqueF( tinP , psttu , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/9440104/in/in") , WS( sAsynchOrder ) ) ; ___( psttu ) ;
                            ZE( strokeS* , psttu ) ;

                            sAsynchOrder << sOrder ;
                            soulC sAsynchOrder( tinP , TAG( TAGiDnULL ) , flSOUL_null , stJobTo[ 1 ] ) ;

                            }
                                etThread.delF( tinP , pc2t ) ;
                                }
                                    sOrder << bmTime ;
                                    measure04T bmTime = (measure04T)pc2t->c2 * McOUNTmAXpLUSwO + (measure04T)pc2t->c1 ;
                                {
                                if( pc2t )
                                swsDeltaTime >> pc2t ;
                                ZE( count2S* , pc2t ) ;
                            {
                            while( swsDeltaTime && !etThread )

                            //U:: sOrder << (countT)swsDeltaTime ;
                            sOrder << cObs ; //U::
                            countT cObs = swsDeltaTime ; //U::

                            sOrder << pstt1Delta ;
                            sOrder << psttFrom ;
                            }
                                while( ~hDown && !etThread ) ;
                                }
                                    else sOrder << stJobTo.downF( tinP , hDown ) ;
                                    }
                                        stJobTo.downF( tinP , hDown ) ;
                                        bWoth = 0 ;
                                    {
                                    if( bWoth )
                                {
                                do
                                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                boolT bWoth = 1 ;
                            {
                            sOrder << (countT)( stJobTo - 1 ) ;                            
                            sOrder << (countT)1 ; // IDvERSION
                            sOrder << (strokeS*)T("!batchOfUnivariate") ;
                            soulC sOrder( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDjOBoRDER_NAMED ) ;

                            pstt1Delta = (strokeS*)swsDeltaTime.leverF( tinP , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        countT cFlavors = swsDeltaTime.cFlavorsF( tinP ) ;

                        __( stJobTo[ 1 ] - 0x401044c ) ;
                    {
                    else
                    }
                        etThread.boxPutF( tinP ,  T("ideafarm.com//smtp/")+T(DDNUMB)+T("/")+T(psttFrom) , tm , tm.csF( tinP ) ) ;

                        }
                            }
                                tm += T("\r\n") ;
                                }
                                    etThread.delF( tinP , pc2t ) ;
                                    if( pc2t ) tm += T("  ")+TT(pc2t->c1,pc2t->c2)+T("\r\n") ;
                                    swsDeltaTime >> pc2t ;
                                    ZE( count2S* , pc2t ) ;
                                {
                                while( swsDeltaTime && !etThread )

                                }
                                    }
                                        case 3 : { tm += T(psttc1)+T("\r\n") ; break ; }
                                        case 2 : { tm += T(psttc1)+T(" -> ") ; break ; }
                                        case 1 : { tm += T(" ")+T(psttc1)+T(": ") ; break ; }
                                    {
                                    switch( ++ ids )
                                {
                                FORsTRINGSiN1( pstt1Delta )
                                ZE( countT , ids ) ;
                                pstt1Delta = (strokeS*)swsDeltaTime.leverF( tinP , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            countT cFlavors = swsDeltaTime.cFlavorsF( tinP ) ;
                        {
                        tm += T("\r\nevent transition times, by domain\r\n\r\n") ;
                    {
                    if( bMail )

                    }
                        }
                            DEL( pSwsEvent ) ;
                            }
                                }
                                    if( bMail ) tm += T("\r\n") ;
                                    etThread.delF( tinP , psttEventL ) ;
                                    }
                                        etThread.delF( tinP , (byteT*&)pInfo ) ;
                                        }
                                            etThread.delF( tinP , pInfo->pczName ) ;

                                            }
                                                psttEventL = psttEvent ; // psttEvent = 0 ;
                                                etThread.delF( tinP , psttEventL ) ;
                                                timeL2 = pInfo->timeE2 ;
                                                timeL1 = pInfo->timeE1 ;

                                                }
                                                    etThread.delF( tinP , pstt1Delta ) ;
                                                    }
                                                        swsDeltaTime << pc2t ;
                                                        pc2t->c2 = timeD2 ;
                                                        pc2t->c1 = timeD1 ;
                                                    {
                                                    if( pc2t )
                                                    etThread.newF( tinP , LF , pc2t ) ; ___( pc2t ) ;
                                                    ZE( count2S* , pc2t ) ; //U::CONJ: THIS IS CORRECT
                                                    //U::CONJ: THIS IS A BUG: count2S*& pc2t = (count2S*&)(countT&)swsDeltaTime ;

                                                    etThread.strFuseSeparateF( tinP , pstt1Delta , psttEventL ) ; ___( pstt1Delta ) ;
                                                    etThread.strFuseSeparateF( tinP , pstt1Delta , psttEvent ) ; ___( pstt1Delta ) ;
                                                    etThread.strFuseSeparateF( tinP , pstt1Delta , psttDomain , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 2 * CSpREFIX + psttEvent->idAdam + psttEventL->idAdam ) ; ___( pstt1Delta ) ;

                                                    etThread.osTimeSubtractF( tinP , timeD1 , timeD2 , timeL1 , timeL2 ) ;
                                                    sCountT timeD2 = pInfo->timeE2 ;
                                                    countT  timeD1 = pInfo->timeE1 ;
                                                {
                                                else
                                                if( bWoth ) bWoth = 0 ;
                                            {
                                            if( psttEvent )
                                            etThread.strMakeF( tinP , psttEvent , T(pInfo->pczName) ) ; ___( psttEvent ) ;
                                            ZE( strokeS* , psttEvent ) ;

                                            if( bMail ) tm += T("   ")+TT(pInfo->timeE1,pInfo->timeE2)+T(" ")+T(pInfo->pczName)+T("\r\n") ;
                                        {
                                        if( pInfo )
                                        *pSwsEvent >> (countT&)pInfo ;
                                        ZE( infoS* , pInfo ) ;
                                    {
                                    while( *pSwsEvent )
                                    boolT bWoth = 1 ;
                                    ZE( strokeS* , psttEventL ) ;
                                    ZE( sCountT , timeL2 ) ;
                                    ZE( countT , timeL1 ) ;

                                    if( bMail ) tm += T("  ")+T(psttDomain)+T("\r\n") ;
                                    psttDomain = (strokeS*)pSwsEvent->leverF( tinP , idf2 ) ;
                                {
                                for( countT idf2 = 1 ; idf2 <= cFlavors2 ; idf2 ++ )
                                countT cFlavors2 = pSwsEvent->cFlavorsF( tinP ) ;
                            {
                            if( pSwsEvent )
                            __Z( pSwsEvent ) ;
                            switchStackC*& pSwsEvent = (switchStackC*&)(countT&)sw_pSwsEvent ;

                            if( bMail ) tm += T(" ")+T(idhPeer)+T("\r\n\r\n") ;
                            idhPeer = *pIdhPeer ;
                        {
                        if( pIdhPeer )
                        __Z( pIdhPeer ) ;
                        nicNameC* pIdhPeer = (nicNameC*)sw_pSwsEvent.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = sw_pSwsEvent.cFlavorsF( tinP ) ;
                    switchStackC swsDeltaTime( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , pstt1Delta , flSTACKc_null , ifcSTACKtYPE_PTR_count2S ) ;
                    ZE( strokeS* , pstt1Delta ) ;

                    ;

                        "\r\n")
                        "event times, by peer, by domain\r\n"
                        "\r\n"
                        T("subject: [ifc] timed event transitions, by peer, by domain\r\n"

                       //================================================================================================================================

                    if( bMail ) tm =
                    TN( tm , "" ) ;

                    const boolT bMail = !stJobTo ;

                    }
                        }
                            etThread.delF( tinP , psttDomain ) ;
                            }
                                }
                                    if( pSwsEvent ) *pSwsEvent << (countT)pInfo ;
                                    switchStackC* pSwsEvent = (switchStackC*)(countT)sw_pSwsEvent ;
                                    if( !sw_pSwsEvent ) { sw_pSwsEvent = (countT)new( 0 , tinP , LF ) switchStackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , psttDomain , flSTACKc_FIFO ) ; ___( sw_pSwsEvent ) ; }
                                    idhPeer = pInfo->idhPeer ;

                                    sOrderP >> pInfo->pczName ; ___( pInfo->pczName ) ;
                                    sOrderP >> pInfo->cczName ;
                                    sOrderP >> pInfo->idhPeer ;
                                    sOrderP >> (countT&)pInfo->timeE2 ;
                                    sOrderP >> pInfo->timeE1 ;
                                {
                                if( pInfo )
                                newF( tinP , LF , etThread , pInfo ) ; ___( pInfo ) ;
                                ZE( infoS* , pInfo ) ;
                            {
                            while( cEvent -- )

                            sOrderP >> cEvent ;
                            ZE( countT , cEvent ) ;

                            sOrderP >> psttDomain ; ___( psttDomain ) ;
                        {
                        while( cFlavors -- )

                        sOrderP >> cFlavors ;
                        ZE( countT , cFlavors ) ;
                    {
                    ZE( strokeS* , psttDomain ) ;
                    switchC sw_pSwsEvent( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , idhPeer ) ;
                    nicNameC idhPeer ;

                    sOrderP >> psttFrom ; ___( psttFrom ) ;
                    ZE( strokeS* , psttFrom ) ;

                    }
                        }
                            stJobTo << idAdamJobTo ;
                            __Z( idAdamJobTo ) ;
                            sOrderP >> idAdamJobTo ;
                            ZE( countT , idAdamJobTo ) ;
                        {
                        while( cJobTo -- )
                        sOrderP >> cJobTo ;
                        ZE( countT , cJobTo ) ;
                    {
                    stackC stJobTo( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;

                    __( idVersion - 1 ) ;
                    sOrderP >> idVersion ;
                    ZE( countT , idVersion ) ;

                    __( idOut - 1 ) ;
                    sOrderP >> idOut ;
                    ZE( countT , idOut ) ;

                    __( idAdamOut - 0x401044a ) ;
                    sOrderP >> idAdamOut ;
                    ZE( countT , idAdamOut ) ;
                {
                case ifcIDcMDjOBoRDER_IDaDAMiDoUT :
                }
                    break ;
                    etThread.delF( tinP , psttJobType ) ;

                    else __1
                    }
                    {
                    if( !etThread.strCompareF( tinP , psttJobType , T("!fooey") ) )

                    sOrderP >> psttJobType ; ___( psttJobType ) ;
                    ZE( strokeS* , psttJobType )
                {
                case ifcIDcMDjOBoRDER_NAMED :
                }
                    break ;

                    etThread.delF( tinP , psttBody ) ;
                    etThread.delF( tinP , psttFrom ) ;

                    }
                        etThread.delF( tinP , postBody ) ;
                        etThread.delF( tinP , psttu ) ;
                        etThread.boxPutUniqueF( tinP , psttu , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(DDNUMB)+T("/in/ignored/in") , postBody , costBody ) ;
                        ZE( strokeS* , psttu ) ;

                        countT costBody = etThread.strMakeF( tinP , postBody , psttBody ) ; ___( postBody ) ;
                        ZE( osTextT* , postBody ) ;
                    {

                    sOrderP >> psttBody ; ___( psttBody ) ;
                    ZE( strokeS* , psttBody ) ;

                    __( idAdamTo - DDNUMB ) ;
                    __Z(  idAdamTo ) ;
                    sOrderP >> idAdamTo ;
                    ZE( countT , idAdamTo ) ;

                    __(  psttFrom && !psttFrom->idAdam ) ;
                    __Z( psttFrom ) ;
                    sOrderP >> psttFrom ; ___( psttFrom ) ;
                    ZE( strokeS* , psttFrom ) ;
                {
                case ifcIDcMDjOBoRDER_MAIL :
            {
            switch( idJobType )

            sOrderP >> idJobType ;
            ZE( countT , idJobType ) ;
        {
        case 1 :
    {
    switch( idCourseP )

    __( idAdamP - DDNUMB ) ;
{
voidT jobFillCourseF( tinS& tinP , etherC& ether , etherC& etThread , soulC& sDataP , soulC& sNotesTextP , soulC& sNotesDataP , const countT idCourseP , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

}
    if( cArgP && c8argP.c1 && sOrderP && ether && *tinP.zEtScratch && idChatSessionP ) ;

    __( idAdamP - DDNUMB ) ;
{
voidT jobHearOrderF( tinS& tinP , etherC& ether , etherC& etThread , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

}
    etThread.memSetF( tinP , (byteT*)pInfoP , sizeof( infoS ) ) ;
    etThread.newF( tinP , idLineP , idiFileP , (byteT*&)pInfoP , sizeof( infoS ) ) ; ___( pInfoP ) ;
{
voidT newF( tinS& tinP , const countT idLineP , const countT idiFileP , etherC& etThread , infoS*& pInfoP )
//U: CODE DUPLICATED IN a440104 AND b440104

;
}
    countT* pczName ;
    countT  cczName ;
    sCountT timeE2 ;
    countT  timeE1 ;
    nicNameC idhPeer ;
{
struct infoS
//U: CODE DUPLICATED IN a440104 AND b440104

/*1*/WAKEhIDE( "sentient.data.separator" )/*1*/
/**/
*/
\<A HREF=\"5.b440104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

