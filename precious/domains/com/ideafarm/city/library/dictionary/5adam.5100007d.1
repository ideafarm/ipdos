
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    b_pczLever.ungrabF( tinP ) ;

    }
        DEL( prd ) ;
        recDirC* prd = (recDirC*)c_prd ;
        swsDir >> c_prd ;
        ZE( countT , c_prd ) ;
    {
    while( swsDir )

    pczLever = (countT*)swsDir.leverF( tinP , idf ) ;

    b_pczLever.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
countT cFlavors = swsDir.cFlavorsF( tinP ) ;

etThread.loafIF( tinP ) ;

}
    }
        else                    { ZE( countT , tid ) ; etThread.osThreadF( tinP , tid , tmDirectoryServeClientF , 0 , flTHREADlAUNCH_null , 0 , (countT)pso , (countT)&etThread , (countT)&b_pczLever , (countT)&pczLever , (countT)&swsDir ) ; }
        if( ether || etThread ) { DEL( pso ) ; }
        sock.acceptF( tinP , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        ZE( socketC* , pso ) ;
    {
    while( !ether && !etThread )

    sock.listenF( tinP ) ;
    sock.bindF( tinP , ifcPORToLD1_DIRECTORY ) ;
    socketC sock( tinP , etThread , TAG( TAGiDnULL ) ) ;
{
while( !ether && !etThread )

etThread.etherCryF( tinP ) ;

switchStackC swsDir( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , pczLever ) ;
ZE( countT* , pczLever ) ;
batonC b_pczLever( tinP , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmDirectoryServeClientF )
}
    DEL( pso ) ;
    etThread = 0 ;
    { ZE( byteT , bnu ) ; pso->readF( tinP , &bnu , 1 , flSOCKETcrEAD_STILLhUNGRYiSoK ) ; }
    etThread = 0 ;

    }
        pso->writeF( tinP , (byteT*)&idAck , sizeof idAck ) ;
        etThread = 0 ;
        countT idAck = etThread ? ifcREPLY_NACK : ifcREPLY_ACK ;

        }
            }
                break ;

                etThread.delF( tinP , pczl ) ;

                }
                    }
                        //}
                        //    __( dr != dr2 ) ;
                        //    etThread.delF( tinP , pbSoul ) ;
                        //    recDirC dr2( tinP , ether , pbSoul ) ;
                        //    dr.soulF( tinP , pbSoul ) ; ___( pbSoul ) ;
                        //    ZE( byteT* , pbSoul ) ;
                        //    recDirC& dr = *prd ;
                        //{
                        //if( prd )
                        //THIS CODE TESTS CREATING AND USING pbSoul

                        b_pczLever.ungrabF( tinP ) ;

                        }
                            __1
                            DEL( prd ) ;
                        {
                        if( !idSlot )
                        swsDir.sinkF( tinP , idSlot , (countT)prd , flSTACKsINK_UNIQUE , 0 , subtract_recDirC_F ) ;
                        ZE( countT , idSlot ) ;

                        pczLever = pczl ;
                        b_pczLever.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    if( prd )

                    recDirC* prd = new( 0 , tinP , LF ) recDirC( tinP , ettListener , *pso ) ; ___( prd ) ;
                {
                if( pczl )

                }
                    if( pczl ) pczl[ cLever ] = 0 ;
                    __( sizeof( countT ) * cLever - pso->readF( tinP , (byteT*)pczl , sizeof( countT ) * cLever ) ) ;
                    etThread.newF( tinP , LF , pczl , cLever + 1 ) ; ___( pczl ) ;
                    __Z( cLever ) ;
                    __( sizeof cLever - pso->readF( tinP , (byteT*)&cLever , sizeof cLever ) ) ;
                    ZE( countT , cLever ) ;
                {
                ZE( countT* , pczl ) ;
            {
            case ifcCMDdIR_NEW :
            }
                break ;

                etThread.delF( tinP , pczl ) ;

                b_pczLever.ungrabF( tinP ) ;

                else __1
                }
                    DEL( prd ) ;
                    recDirC* prd = (recDirC*)swsDir.extractF( tinP ) ;
                {
                if( idSlot )
                swsDir.sinkF( tinP , idSlot , (countT)&rd , flSTACKsINK_QUERY , 0 , subtract_recDirC_F ) ;
                ZE( countT , idSlot ) ;

                pczLever = pczl ;
                b_pczLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

                recDirC rd( tinP , ettListener , *pso ) ;

                }
                    if( pczl ) pczl[ cLever ] = 0 ;
                    __( sizeof( countT ) * cLever - pso->readF( tinP , (byteT*)pczl , sizeof( countT ) * cLever ) ) ;
                    etThread.newF( tinP , LF , pczl , cLever + 1 ) ; ___( pczl ) ;
                    __Z( cLever ) ;
                    __( sizeof cLever - pso->readF( tinP , (byteT*)&cLever , sizeof cLever ) ) ;
                    ZE( countT , cLever ) ;
                {
                ZE( countT* , pczl ) ;
            {
            case ifcCMDdIR_DEL :
            }
                break ;

                etThread.delF( tinP , pczl ) ;

                b_pczLever.ungrabF( tinP ) ;

                }
                    while( handle ) ;
                    }
                        if( prd ) pso->writeF( tinP , WS( *prd ) ) ;
                        recDirC* prd = (recDirC*)swsDir.downF( tinP , handle ) ;
                    {
                    do
                    handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( cPlates )
                pso->writeF( tinP , (byteT*)&cPlates , sizeof cPlates ) ;
                countT cPlates = swsDir ;

                pczLever = pczl ;
                b_pczLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

                }
                    if( pczl ) pczl[ cLever ] = 0 ;
                    __( sizeof( countT ) * cLever - pso->readF( tinP , (byteT*)pczl , sizeof( countT ) * cLever ) ) ;
                    etThread.newF( tinP , LF , pczl , cLever + 1 ) ; ___( pczl ) ;
                    __Z( cLever ) ;
                    __( sizeof cLever - pso->readF( tinP , (byteT*)&cLever , sizeof cLever ) ) ;
                    ZE( countT , cLever ) ;
                {
                ZE( countT* , pczl ) ;
            {
            case ifcCMDdIR_QUERYgROUP :
            }
                break ;
                bDirQuit = 1 ;
            {
            case ifcCMDdIR_QUIT :
        {
        switch( idCmd )

        __( sizeof idCmd - pso->readF( tinP , (byteT*)&idCmd , sizeof idCmd ) ) ;
        ZE( countT , idCmd ) ;
    {
    while( !etThread && !bDirQuit )
    ZE( boolT , bDirQuit ) ;

    pso->etherF( tinP , etThread ) ;

    switchStackC& swsDir = *(switchStackC*)pTaskP->c5 ;
    countT*& pczLever    =      *(countT**)pTaskP->c4 ;
    batonC&  b_pczLever  =       *(batonC*)pTaskP->c3 ;
    etherC&  ettListener =       *(etherC*)pTaskP->c2 ;
    socketC* pso         =       (socketC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
TASK( tmDirectoryServeClientF )

}
    return scSgn ;
    if( c3P ) ;

    else if( sccSgn > scc0 ) scSgn =   1 ;
         if( sccSgn < scc0 ) scSgn = - 1 ;
    ZE( sCountT , scSgn ) ;
    sCountC scc0 = sCountC( tinP , ether ) ;
    sCountC sccSgn = *(recDirC*)c1P - *(recDirC*)c2P ;

    etherC& ether = *(etherC*)pEtherP ;

    }
        if( !pEtherP ) return 0 ;
    {
    IFbEcAREFUL
{
countT subtract_recDirC_F( tinS& tinP , countT& pEtherP , countT& c1P , countT& c2P , countT& c3P )

/*1*/WAKEhIDE( "directory.port.groups" )/*1*/
/**/
*/
\<A HREF=\"5.c700104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

