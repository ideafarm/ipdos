
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.strokeF( tinP , T("ok\r\n") ) ;

THREADmODE2rESTORE
}
    }
        }
            ++ s ; ether.osSleepF( tinP , etThread.diskIdF( tinP , T("///c") ) == IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 ? TOCK : TICK >> 2 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;                                 IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0
    
            CONoUTrAW3( "\rcycle " , idCycle , " -\r\n" ) ;
            }
                }
                    thirdC::dosSleepWinkIF( tinP ) ;
                    CONoUTrAW3( "\r        \r" , cAlive , "\r" ) ;
                {
                while( cAlive )
        
                }
                    etThread.osThreadF( TaRG1( tmGorillaF ) , (countT)&cAlive , (countT)&puseMaster , (countT)&cDone ) ;
                    inc02AM( cAlive ) ;
                {    
                while( !ether && cToDo -- )
                countT cToDo = TUCK >> 1 ; //PRODUCTION: DOES NOT WORK AS EXPECTED ON IFC8
                //countT cToDo = TUCK >> 3 ;
                //countT cToDo = 2 ; //DUT
                //countT cToDo = 1 ; //DUT
                etThread.strokeF( tinP , T("launching gorilla attack\r\n") ) ;
            
                ZE( countT , cDone ) ;
            {
            CONoUTrAW3( "cycle " , ++ idCycle , " +\r\n" ) ;
    
            ZE( countT , cAlive ) ;
        {
    {
    while( !ether && !POOP )
    ZE( countT , idCycle ) ;
    
    puseC puseWork1( tinP , ifcIDpOOL_ADAMtEMP ) ; //--------------------------------------------------------------------------------------
    puseC puseMaster( tinP , "list.test.gorilla" ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
{
THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

TODO

DONE( tmGorillaF )
}
    dec02AM( cAliveP ) ;
    THREADmODE2rESTORE

    }
        THREADmODE2rESTORE
        }
            else if( !( ( ++ idCycle ) % TUCK ) ) thirdC::dosSleepWinkIF( tinP ) ;
                 if( cDoneCopy >= ( TOCK >> 5 ) ) break ; //PRODUCDTION

            listC::dictionaryForgetTextIF( tinP , ostoWord ) ;

            if( !( cDoneCopy % TUCK ) ) CONoUTrAW3( "\r        \r" , cDoneCopy , "\r" ) ;
            countT cDoneCopy = 1 + incv02AM( cDoneP ) ;

            }
                }
                    CONoUTrAW( ostoSay ) ;
                    OStEXTAK( ostoSay , "\"\r\n" ) ;
                    OStEXTA(  ostoSay , spWord ) ;
                    OStEXTAK( ostoSay , "[spWord]: \"" ) ;
                    OStEXT(   ostoSay , TUCK ) ;
                {
                else
                if( !spWord || thirdC::c_strcmpIF( tinP , spWord , ostoWord ) ) { BLAMMO ; }
        
                blobVSP spWord = listC::dictionaryQueryFromIdIF( tinP , idWord ) ;
            {

            countT idWord = listC::dictionaryQueryFromTextIF( tinP , ostoWord ) ;

            puseC pusem( puseMasterP ) ;
        {
        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
    {
    while( !ether && !POOP )
    ZE( countT , idCycle ) ;

    OStEXTC(  ostoWord , tinP.monitor.idThread , 0 ) ;
    OStEXTAK( ostoWord , "foo." ) ;
    OStEXT(   ostoWord , TUCK ) ;

    THREADmODE2oN( flTHREADmODE2_MONITORdOnOTrEPORToNmE )

    }
        thirdC::dosPriorityIF( tinP , save ) ;
        thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) ) ;
        thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_RUSH ) ;
        countT save = thirdC::dosPriorityIF( tinP ) ;
    {

    //if( etThread.diskIdF( tinP , T("///c") ) != IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 ) thirdC::osSelectProcessorsIF( tinP , 2 ) ; //FOR DEVELOPMENT CONVENIENCE; THIS LINE CAN REMAIN IN PRODUCTION CODE

    countT& cDoneP      = *(countT*)pTaskP->c3 ;
    puseC&  puseMasterP =  *(puseC*)pTaskP->c2 ;
    countT& cAliveP     = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmGorillaF )

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_GORILLAlISTS.gorilla.poolC.lists" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

