
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    ether.osSleepF( tinP , TOCK * 0x10 ) ;

    }
        { countT idAdam = ifcIDaDAMoLD_CHATsERVER ; ether.ifcHireF( tinP , T("city.monitor") , idAdam , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ; }
        bWoth = 0 ;
    {
    if( bWoth && !ether )

    etThread.delF( tinP , postr ) ;
    etThread.boxPutF( tinP , tFile , postr , costr ) ;
    etThread.delF( tinP , psttr ) ;
    countT costr = etThread.strMakeF( tinP , LF , postr , psttr ) ; ___( postr ) ;
    ZE( osTextT* , postr ) ;

        etThread.strFuseF( tinP , psttr , TF3(off+1,flFORMAT_UNSIGNED,3)+TF1(pfa[ off ].cHeartBeats )+T("\r\n") ) ;
    for( countT off = 0 ; off < CfIREaLLrANKS ; off ++ )

    etThread.strMakeF( tinP , LF , psttr , T("IdeaFarm " "(tm) Operating System\r\nLocal Monitor Report\r\n")+TT(timeN1,timeN2)+T("\r\nidReport: ")+TF1(++idReport)+T("\r\n \r\nsection: fireAll record (there is wo record for this host)\r\ngr: idFireAllGroup\r\ncHeartBeats: each cell increments this until its main function returns\r\ngr cHeartBeats\r\n") , 0x10000 ) ; ___( psttr ) ;
    ZE( strokeS* , psttr ) ;
    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT , timeN1 ) ;
{
while( !ether && !etThread )
boolT bWoth = 1 ;
TN( tFile , "///d/ideafarm.rpt.monitor" ) ;
ZE( countT , idReport ) ;

else if( napMonitor != cbMonitor ) { BLAMMO ; }
}
    napMonitor.formattingIsDoneF( tinP ) ;
    etThread.memSetF( tinP , (byteT*)ph , sizeof( napMonitorHeaderS ) ) ;
{
else if( !( F(napMonitor.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
if( !ph ) { BLAMMO ; }
napMonitorHeaderS* ph = (napMonitorHeaderS*)(byteT*)napMonitor ;
napkinC napMonitor( tinP , LF , (byteT*)bits , "napMonitor" , 0 , cbMonitor ) ;
const countT cbMonitor = sizeof( napMonitorHeaderS ) + CBmONITORbUFFER ;
BLAMMO ; //U:: FOR DEBUGGING, TO VERIFY THAT NO WO ACCESSES napMonitorG

fireAllS* pfa = (fireAllS*)( pcn + 2 ) ;

else if( getNegAM( pcn[ 0 ] ) != FINGERnEG_NAPfIREcELLmONITOR ) { BLAMMO ; }
else if( napFireAll != 2 * sizeof( countT ) + CfIREaLLrANKS * sizeof( fireAllS ) ) { BLAMMO ; }
}
    napFireAll.formattingIsDoneF( tinP ) ;
    putNegAM( pcn[ 0 ] , FINGERnEG_NAPfIREcELLmONITOR ) ;
    pcn[ 1 ] = etherC::ifc_idAdamG_IF( tinP ) ;

    for( countT off = 0 ; off < CfIREaLLrANKS ; off ++ ) pfa[ off ].bFire = pfa[ off ].cHeartBeats = pfa[ off ].cCells = 0 ;
    fireAllS* pfa = (fireAllS*)( pcn + 2 ) ;
{
else if( !( F(napFireAll.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
if( !pcn ) { BLAMMO ; }
countT* pcn = (countT*)(byteT*)napFireAll ;
napkinC napFireAll( tinP , LF , (byteT*)bits , "tmWatchF/napFireAll" , 0 , 2 * sizeof( countT ) + CfIREaLLrANKS * sizeof( fireAllS ) ) ; // THIS IS CREATE SO THAT THE CELL MONITOR CAN BE RUN WITHOUT THE DRIVER (FOR DEBUGGING)
bitsC bits( tinP , CbITSlIFI , 0 , 1 ) ;
//CODE SYNCH: f040104 ec40104 0b00013 1610009 5d40104 ec40104


TODO

/*1*/WAKEhIDE( "monitor" )/*1*/
/**/
*/
obsoleted by ad4
obsoletes 6a4
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

