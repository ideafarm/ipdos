
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    }
        etThread.delF( tinP , pcRaceAll ) ;
        countT* pcRaceAll = (countT*)(countT)sw_pcRace ;
        pcRaceId = (countT*)sw_pcRace.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; !etThread && idf <= cFlavors ; idf ++ )
    cFlavors = sw_pcRace.cFlavorsF( tinP ) ;

    }
        DEL( pCar ) ;
        carC* pCar = (carC*)(countT)swCar ;
        idcHirer = swCar.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; !etThread && idf <= cFlavors ; idf ++ )
    countT cFlavors = swCar.cFlavorsF( tinP ) ;

    }
        etThread.osSleepF( tinP , TOCK ) ;
        if( idTry > 0x10 ) etThread.beeSingDigitsF( tinP , 0x4 ) ;
    {
    while( idTry ++ , !etThread && etThread.os_cAllKidThreadsI_IF( tinP ) > cctAtStart )
    ZE( countT , idTry ) ;

    }
        etThread.osSleepF( tinP , TOCK * 8 ) ;
        }
            etThread.delF( tinP , pbDatum ) ;
            }
                eatDatumF( tinP , *tinP.zEtScratch , pbDatum , swCar , idcHirer , b_idcHirer , sw_pcRace , pcRaceId , b_pcRaceId ) ;
            {
            byteT* pbDatum = (byteT*)cDatum ;
            stDatum >> cDatum ;
            ZE( countT , cDatum ) ;
        {
        while( !ether && !etThread && stDatum )

        etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+S2(0,scOld_SYSmARK) ) ;
    {
    while( !ether )
    etThread.etherCryF( tinP ) ;

    { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmRaceReportsF , 0 , flTHREADlAUNCH_null , 0 , (countT)&b_pcRaceId , (countT)&pcRaceId , (countT)&sw_pcRace ) ; }
    { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmArchiveF     , 0 , flTHREADlAUNCH_null , 0 , (countT)&b_idcHirer , (countT)&idcHirer , (countT)&swCar ) ; }
    //{ ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmObeyF        , 0 , flTHREADlAUNCH_null , 0 , (countT)&b_idcHirer , (countT)&idcHirer , (countT)&swCar ) ; }

    switchC sw_pcRace( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , pcRaceId ) ;
    ZE( countT* , pcRaceId ) ;
    batonC b_pcRaceId( tinP , TAG( TAGiDnULL ) ) ;

    switchC swCar( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idcHirer ) ;
    ZE( countT , idcHirer ) ;
    batonC b_idcHirer( tinP , TAG( TAGiDnULL ) ) ;

    { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmAcceptF , 0 , flTHREADlAUNCH_null , 0 , (countT)&stDatum ) ; }
    stackC stDatum( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;

    etThread.strokeF( tinP , T("IdeaFarm " "(tm) City Data Eater\r\ni eat incoming data\r\n")+S2(0,scOld_SYSmARK) ) ;

    const countT cctAtStart = etThread.os_cAllKidThreadsI_IF( tinP ) ;
{
else
}
    etThread.strokeF( tinP , T("Another ")+textIdFileC( tinP , DDNAME )+T(" appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tinP , TAG( TAGiDnULL ) , T("3f30104") ) ;

TODO

DONE( tmAcceptF )
}
    }
        }
            else                    { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmPeerF , 0 , flTHREADlAUNCH_null , 0 , (countT)&stDatum , (countT)pso ) ; }
            if( ether || etThread ) { DEL( pso ) ; }
            sIn.acceptF( tinP , pso , idPortPeer , nnPeer , countTC() ) ;
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            ZE( socketC* , pso ) ;
        {
        while( !ether && !etThread )

        sIn.listenF( tinP ) ;
        sIn.bindF( tinP , ifcPORToLD1rIVERrESERVED ) ;
        socketC sIn( tinP , etThread , TAG( TAGiDnULL ) ) ;
    {
    while( !ether )

    stackC& stDatum = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmAcceptF )

DONE( tmPeerF )
}
    DEL( pso ) ;

    }
        etThread.delF( tinP , pbMsg ) ;
        }
            pso->etherF( tinP , etThread ) ;
            pso->readMsgNokF( tinP ) ;
            pso->etherF( tinP , *tinP.zEtScratch ) ;
        {
        else
        if( !etThread ) pso->readMsgOkF( tinP ) ;
        pushDataF( tinP , etThread , stDatum , pbMsg , cbMsg ) ;
        }
            break ;
            pso->readMsgOkF( tinP ) ;
            etThread.delF( tinP , pbMsg ) ;
        {
        if( cbMsg == tDry.csF( tinP ) && !etThread.strCompareF( tinP , T(pbMsg) , tDry ) )
        countT cbMsg = pso->readMsgF( tinP , pbMsg ) ; ___( pbMsg ) ;
        ZE( byteT* , pbMsg ) ;
    {
    while( !ether && !etThread )    
    TN( tDry , "!amDry" ) ;

    pso->etherF( tinP , etThread ) ;
    socketC* pso     = (socketC*)pTaskP->c2 ;
    stackC&  stDatum = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmPeerF )

}
    }
        }
            pbc += cbDatum ;
            if( pbDatum ) stDatumP << (countT)pbDatum ;
            etThread.memCopyF( tinP , pbDatum , pbc , cbDatum ) ;
            if( pbDatum ) pbDatum[ cbDatum ] = 0 ;
            etThread.newF( tinP , LF , pbDatum , cbDatum + 1 ) ;
            ZE( byteT* , pbDatum ) ;

            __( pbc + cbDatum > pbEnd ) ;
            countT cbDatum = sizeof( headerS ) + sizeof( countT ) * ccRid + pHdr->cbd ;
            countT ccRid = etThread.strBodyLengthF( tinP , &pHdr->cResourceId ) ;
            headerS* pHdr = (headerS*)pbc ;
            __( pbc + sizeof( headerS ) > pbEnd ) ;
        {
        while( !etThread && pbc < pbEnd )
        const byteT* pbc = pbMsgP ;
        const byteT* const pbEnd = pbMsgP + cbMsgP ;
    {
    if( pbMsgP )
{
voidT pushDataF( tinS& tinP , etherC& etThread , stackC& stDatumP , const byteT* const pbMsgP , const cbMsgP )

}
    }
        pCar->baton.ungrabF( tinP ) ;

        }
            }
                etThread.delF( tinP , psttnu ) ;
                etThread.boxPutUniqueF( tinP , psttnu , T("///ideafarm/ephemeral/domains/com/ideafarm/3f30104/impotences/impotence") , pbd , pHdr->cbd ) ;
                ZE( strokeS* , psttnu ) ;
            {
            else if( F(pHdr->flags2) & flDATUM2_impotenceS )
            }
                else                                                pCar->stLog          << psttl ;
                if( F(pHdr->flags1) & flDATUM1_CLASSeXCEPTIONiMPOTENCE ) pCar->stLogImpotence << psttl ;

                //etThread.strokeF( tinP , T(USCORE79 "\r\n\r\n\"")+T(psttl)+T("\"\r\n" USCORE79 "\r\n\r\n") ) ;

                }
                    if( off < cc - 1 ) { etThread.strFuseF( tinP , psttl , T(" ") ) ; ___( psttl ) ; }
                    etThread.strFuseF( tinP , psttl , TF3(((sCountT*)pbd)[off],0,8) ) ; ___( psttl ) ;
                {
                for( countT off = 0 ; off < cc ; off ++ )
                etThread.strMakeF( tinP , psttl , T("") , cc * 0xa ) ; ___( psttl ) ;
                countT cc = pHdr->cbd / sizeof( countT ) ;
                ZE( strokeS* , psttl ) ;
            {
            else if( F(pHdr->flags2) & flDATUM2_ScOUNT )
            }
                else                                                pCar->stLog          << psttl ;
                if( F(pHdr->flags1) & flDATUM1_CLASSeXCEPTIONiMPOTENCE ) pCar->stLogImpotence << psttl ;

                //etThread.strokeF( tinP , T(USCORE79 "\r\n\r\n\"")+T(psttl)+T("\"\r\n" USCORE79 "\r\n\r\n") ) ;

                }
                    if( off < cc - 1 ) { etThread.strFuseF( tinP , psttl , T(" ") ) ; ___( psttl ) ; }
                    etThread.strFuseF( tinP , psttl , TF3(((countT*)pbd)[off],0,8) ) ; ___( psttl ) ;
                {
                for( countT off = 0 ; off < cc ; off ++ )
                etThread.strMakeF( tinP , psttl , T("") , cc * 0xa ) ; ___( psttl ) ;
                countT cc = pHdr->cbd / sizeof( countT ) ;
                ZE( strokeS* , psttl ) ;
            {
            else if( F(pHdr->flags2) & flDATUM2_countT )
            }
                else                                                pCar->stLog          << psttl ;
                if( F(pHdr->flags1) & flDATUM1_CLASSeXCEPTIONiMPOTENCE ) pCar->stLogImpotence << psttl ;

                //etThread.strokeF( tinP , T(USCORE79 "\r\n\r\n\"")+T(psttl)+T("\"\r\n" USCORE79 "\r\n\r\n") ) ;

                etThread.strMakeF( tinP , psttl , (strokeS*)pbd ) ; ___( psttl ) ;
                ZE( strokeS* , psttl ) ;
            {
            else if( F(pHdr->flags2) & flDATUM2_strokeS )
            }
                else                                                pCar->stLog          << psttl ;
                if( F(pHdr->flags1) & flDATUM1_CLASSeXCEPTIONiMPOTENCE ) pCar->stLogImpotence << psttl ;

                //etThread.strokeF( tinP , T(USCORE79 "\r\n\r\n\"")+T(psttl)+T("\"\r\n" USCORE79 "\r\n\r\n") ) ;

                etThread.strMakeF( tinP , psttl , T(pbd) ) ; ___( psttl ) ;
                ZE( strokeS* , psttl ) ;
            {
            if( F(pHdr->flags2) & flDATUM2_osTextT )
        {
        if( pHdr->cbd )

        (countT&)pCar->swUsage += pHdr->amount ;
        pCar->pcPart = &pHdr->flags1 ; // THIS IS "PREFIXED RID"

        }
            }
                }
                    pcc += 5 ;
                    etThread.osTimeAddF( tinP , pcRaceAll[ 5 * cRank + 3 ] , (sCountT&)pcRaceAll[ 5 * cRank + 4 ] , pcc[ 3 ] , pcc[ 4 ] ) ;
                    pcRaceAll[ 5 * cRank + 2 ] += pcc[ 2 ]         ; // cExits
                    pcRaceAll[ 5 * cRank + 1 ] += pcc[ 1 ]         ; // cEntries
                    countT cRank = processGlobal7I.source.idFileRankF( tinP , pcc[ 0 ] ) ; // IMMUTABLE FILE ID
                {
                for( countT ida = 1 ; ida <= cActive ; ida ++ )
                countT* pcc = (countT*)pbd ;
            {
            if( !etThread )

            __Z( pcRaceAll ) ;
            __( pHdr->cbd - cActive * 5 * sizeof( countT ) ) ;
            countT cActive = pHdr->amount ;
            boolT bNet = pcPart[ 4 ] == 2 ;

            __( pcPart[ 4 ] > 2 ) ;
            __( pcPart[ 3 ] - 1 ) ;
            __( pcPart[ 2 ] - 0x2600301 ) ;
            __( etThread.strBodyLengthF( tinP , pcPart ) < 6 ) ;
            countT* pcPart = &pHdr->idComputer ;
            __( !pHdr->cbd ) ;
            __( !( F(pHdr->flags2) & flDATUM2_countT ) ) ;

            // the part number of the datum is { 1030062 , 1 , 1 + !!( F(flagsWatch) & flWATCH_EMPLOYERS ) } followed by pcRaceIdP guaranteed to be of length >= 1 countT
        {
        else if( F(pHdr->flags1) & flDATUM1_CLASStIMER ) // KEEP THIS CODE IN SYNC WITH 1030062
        }
            pCar->mPayin += *(measureT*)&pHdr->amount ;

            //etThread.ifcDatumF( tinP , flDATUM1_CLASSpAYiN , flDATUM2_null , *(countT*)&mPayin , pcPart , pstt1d ) ;
            //countT pcPart[] = { 0x40103d9 , 1 , idCitizen , idCheck , 0 } ;
            //etThread.ether_idCitizenHirer_F( tinP ) = idCitizen ;
            // LINES SIMILAR TO THE FOLLOWING ARE ASSUMED TO HAVE CREATED THE DATUM
        {
        if( F(pHdr->flags1) & flDATUM1_CLASSpAYiN )

        pCar->cDatum ++ ;

        pCar->baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( pCar )

    }
        b_pcRaceIdP.ungrabF( tinP ) ;
        }
            if( pcRaceAll ) sw_pcRaceP = (countT)pcRaceAll ;
            etThread.memSetF( tinP , (byteT*)pcRaceAll , ccRace * sizeof( countT ) ) ;
            etThread.newF( tinP , LF , pcRaceAll , ccRace ) ;

            const countT ccRace = ( 1 + cSourceFiles ) * 5 ;
            const countT cSourceFiles = processGlobal7I.source.cFilesF( tinP ) ;
        {
        if( !pcRaceAll )

        pcRaceAll = (countT*)(countT)sw_pcRaceP ;
        pcRaceIdP = &pHdr->idiOwner ;
        b_pcRaceIdP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( F(pHdr->flags1) & flDATUM1_CLASStIMER )
    ZE( countT* , pcRaceAll ) ;

    }
        b_idcHirerP.ungrabF( tinP ) ;
        }
            swCarP = (countT)pCar ;
            pCar = new( 0 , tinP , LF ) carC( tinP , etThread.etPrimeIF( tinP ) , idcHirerP ) ;
        {
        if( !pCar )
        pCar = (carC*)(countT)swCarP ;
        idcHirerP = pHdr->idCitizenHirer ;
        b_idcHirerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    ZE( carC* , pCar ) ;

    if( !pHdr->idiOwner   ) pHdr->idiOwner   = - 1 ;
    if( !pHdr->idComputer ) pHdr->idComputer = - 1 ;
    if( !pHdr->nicName     ) pHdr->nicName     = - 1 ;
    if( !F(pHdr->flags2)  ) pHdr->flags2     |= F(-1) ;
    if( !F(pHdr->flags1)  ) pHdr->flags1     |= F(-1) ;

    byteT*   pbd   = pbDatumP + sizeof( headerS ) + sizeof( countT ) * ccRid ;
    countT   ccRid = etThread.strBodyLengthF( tinP , &pHdr->cResourceId ) ;
    headerS* pHdr  = (headerS*)pbDatumP ;

    if( etThread ) return ;
    __Z( pbDatumP ) ;
    if( etThread ) return ;
{
voidT eatDatumF( tinS& tinP , etherC& etThread , byteT* const pbDatumP , switchC& swCarP , countT& idcHirerP , batonC& b_idcHirerP , switchC& sw_pcRaceP , countT*& pcRaceIdP , batonC& b_pcRaceIdP )

DONE( tmObeyF )
}
    }
        etThread = 0 ;

        }
            else                    { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmShitF , 0 , flTHREADlAUNCH_null , 0 , (countT)pso , (countT)&b_idcHirer , (countT)&idcHirer , (countT)&swCar ) ; }
            if( ether || etThread ) { DEL( pso ) ; }

            socket.acceptF( tinP , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            ZE( socketC* , pso ) ;
        {
        while( !ether && !etThread )

        socket.listenF( tinP ) ;
        socket.bindF( tinP , ifcPORToLD1dATAaNUS ) ;
        socketC socket( tinP , etThread , TAG( TAGiDnULL ) ) ;
    {
    while( !ether )

    switchC& swCar      = *(switchC*)pTaskP->c3 ;
    countT&  idcHirer   = *(countT*) pTaskP->c2 ;
    batonC&  b_idcHirer = *(batonC*) pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmObeyF )

DONE( tmShitF )
}
    DEL( pso ) ;

    }
        }
            }
                break ;
                __1
                __( idCmd ) ;
            {
            default :
            }
                break ;
                }
                    etThread.delF( tinP , pbSoul ) ;
                    pso->writeF( tinP , pbSoul , cbSoul ) ;
                    pCar->baton.ungrabF( tinP ) ;
                    countT cbSoul = pCar->soulF( tinP , pbSoul ) ;
                    pCar->baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    ZE( byteT* , pbSoul ) ;
                {
                if( pCar )
                __Z( pCar ) ;

                b_idcHirer.ungrabF( tinP ) ;
                carC* pCar = (carC*)(countT)swCar ;
                idcHirer = idcHirerIn ;
                b_idcHirer.grabF( tinP , TAG( TAGiDnULL ) ) ;

                pso->readF( tinP , (byteT*)&idcHirerIn , sizeof idcHirerIn ) ;
                ZE( countT , idcHirerIn ) ;
            {
            case idCMDdATAaNUS_GETaCTIVITY :
            }
                break ;
                b_idcHirer.ungrabF( tinP ) ;
                }
                    pso->writeF( tinP , (byteT*)&idcHirer , sizeof idcHirer ) ;
                    idcHirer = swCar.leverF( tinP , idf ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                pso->writeF( tinP , (byteT*)&cFlavors , sizeof cFlavors ) ;
                countT cFlavors = swCar.cFlavorsF( tinP ) ;
                b_idcHirer.grabF( tinP , TAG( TAGiDnULL ) ) ;
                ZE( countT , idcHirer ) ;
            {
            case idCMDdATAaNUS_ENUMERATEhIRERS :
            }
                break ;
            {
            case idCMDdATAaNUS_CLOSE :
        {
        switch( idCmd )
        pso->readF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;
    {
    while( !ether && !etThread && idCmd != idCMDdATAaNUS_CLOSE )
    ZE( countT , idCmd ) ;

    pso->etherF( tinP , etThread ) ;

    switchC& swCar      = *(switchC*)pTaskP->c4 ;
    countT&  idcHirer   = *(countT*) pTaskP->c3 ;
    batonC&  b_idcHirer = *(batonC*) pTaskP->c2 ;
    socketC* pso        = (socketC*) pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmShitF )

DONE( tmArchiveF )
}
    toArchiveF( tinP , etThread , b_idcHirer , idcHirer , swCar ) ;
    }
        if( !( ++ idTock % 0x100 ) ) toArchiveF( tinP , etThread , b_idcHirer , idcHirer , swCar ) ;
        etThread.osSleepF( tinP , TOCK ) ;
    {
    while( !ether && !etThread )
    ZE( countT , idTock ) ;

    switchC& swCar      = *(switchC*)pTaskP->c3 ;
    countT&  idcHirer   = *(countT*) pTaskP->c2 ;
    batonC&  b_idcHirer = *(batonC*) pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmArchiveF )

DONE( tmRaceReportsF )
}
    }
        etThread.osSleepF( tinP , TOCK * 0x8 ) ;
        //etThread.strokeF( tinP , T("\r" BLANK79 "\r") ) ;

        }
            b_pcRaceId.ungrabF( tinP ) ;

            //etThread.strokeF( tinP , T("writing race files -\r\n") ) ;

            }
                etThread.boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/3f30104/races/race.")+tRaceId , (byteT*)pci , sizeof( countT ) * cci ) ;
                textC tRaceId = TF3(pcRaceId[0],flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T(".")+TF3(pcRaceId[1],flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T(".")+TF5(pcRaceId+2,0,0,0,psttDot) ;
                strokeS* psttDot = tDot ;
                TN( tDot , "." ) ;

                etThread.memCopyF( tinP , pbi , (byteT*)pcRaceAll , cbi ) ;
                cbi = sizeof( countT ) * ccRace ;                
                pbi += cbi ;

                etThread.memCopyF( tinP , pbi , (byteT*)pcRaceId , cbi ) ;
                countT cbi = sizeof( countT ) * ( ccRaceId + 1 ) ;                
                byteT* pbi = (byteT*)pci ;

                etThread.newF( tinP , LF , pci , cci ) ;
                ZE( countT* , pci ) ;
                countT cci = ccRaceId + 1 + ccRace ;
                countT ccRaceId  = etThread.strBodyLengthF( tinP , pcRaceId  ) ;
                __Z( pcRaceAll ) ;
                countT* pcRaceAll = (countT*)(countT)sw_pcRace ;
                __Z( pcRaceId ) ;
                pcRaceId = (countT*)sw_pcRace.leverF( tinP , idr ) ;
            {
            for( countT idr = 1 ; idr <= cFlavors ; idr ++ )

            //etThread.strokeF( tinP , T("writing race files (")+TF1(cFlavors)+T(" races)+\r\n") ) ;

            const countT cFlavors = sw_pcRace.cFlavorsF( tinP ) ;

            b_pcRaceId.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( bNewTick )

        time2last = time2 ;
        time1last = time1 ;

        const boolT bNewDayEnd    = bNewHour && offHOUR( time1 ) == 0x5 ;
        const boolT bNewStrongEnd = bNewDay && ( offDAY( time2 ) == 0x6 || offDAY( time2 ) == 0xe ) ;

        const boolT bNewTick      = bNewHour   || offTICK(   time1 ) != offTICK(   time1last ) ;
        const boolT bNewHour      = bNewDay    || offHOUR(   time1 ) != offHOUR(   time1last ) ;
        const boolT bNewDay       = bNewStrong || offDAY(    time2 ) != offDAY(    time2last ) ;
        const boolT bNewStrong    = bNewQtr    || offSTRONG( time2 ) != offSTRONG( time2last ) ;
        const boolT bNewQtr       = bNewDuck   || offQTR(    time2 ) != offQTR(    time2last ) ;
        const boolT bNewDuck      =               offDUCK(   time2 ) != offDUCK(   time2last ) ;

        etThread.osTimeNowF( tinP , time1 , time2 ) ;
        ZE( sCountT , time2 ) ;
        ZE( countT , time1 ) ;
    {
    while( !ether && !etThread )

    etThread.osTimeNowF( tinP , time1last , time2last ) ;
    ZE( sCountT , time2last ) ;
    ZE( countT , time1last ) ;

    const countT ccRace = ( 1 + cSourceFiles ) * 5 ;
    const countT cSourceFiles = processGlobal7I.source.cFilesF( tinP ) ;

    switchC& sw_pcRace  = *(switchC*)pTaskP->c3 ;
    countT*& pcRaceId   = *(countT**)pTaskP->c2 ;
    batonC&  b_pcRaceId = *(batonC*) pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmRaceReportsF )

}
    b_idcHirerP.ungrabF( tinP ) ;
    }
        }
            pCar->baton.ungrabF( tinP ) ;
            }
                etThread.delF( tinP , pbSoul ) ;
                }
                    etThread.delF( tinP , psttnu ) ;
                    etThread.boxPutUniqueF( tinP , psttnu , tArchiveLike , pbSoul , cbSoul ) ;
                    ZE( strokeS* , psttnu ) ;
                    //etThread.strokeF( tinP , T("writing soul: cbSoul = ")+TF1(cbSoul)+T("\r\n") ) ;
                {
                if( !etThread )

                __Z( cbSoul ) ;
                __Z( pbSoul ) ;
                countT cbSoul = pCar->soulF( tinP , pbSoul , 1 ) ;
                ZE( byteT* , pbSoul ) ;
            {
            if( pCar->cDatum )
            pCar->baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( pCar )
        __Z( pCar ) ;
        carC* pCar = (carC*)(countT)swCarP ;
        idcHirerP = swCarP.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swCarP.cFlavorsF( tinP ) ;
    b_idcHirerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    TN( tArchiveLike , "///ideafarm/ephemeral/domains/com/ideafarm/3f30104/carC/carC" ) ;
{
voidT toArchiveF( tinS& tinP , etherC& etThread , batonC& b_idcHirerP , countT& idcHirerP , switchC& swCarP )

;
}
    countT  cResourceId ;
    nicNameC nicName ;
    countT  idiOwner ;
    countT  idComputer ;
    countT  flags2 ;
    countT  flags1 ;
    countT  amount ;
    countT  cbd ;
    countT  idPoolClient ;
    sCountT time2 ;
    countT  time1 ;
    countT  idCitizenHirer ;
    countT  cbOutNet ;
{
struct headerS
// ASSUME: KEEP THIS IN SYNC WITH 103008d.*.ifcDatumF

//U:UNTESTED MIGRATED TO 64 BIT PAIR OF FLAGS OBJECTS.  CODE WAS WRITTEN WITH A SINGLE flagsT OBJECT IN MIND

/*1*/WAKEhIDE( "city.data.eater" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

