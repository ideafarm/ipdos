
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return id ;
    _OUT_

    }
        idSlotP = idSlotMin ;_WQ
        sttQuoteP = sttqMin ;_WQ
        idFirstP = idfMin ;_WQ

        st_psttSmallP.ungrabF( tinP ) ;_WQ
        while( !POOP && !st_psttSmallP.third && ~hDown ) ;_WQ
        }
            }
                idSlotMin = idSlot ;_WQ
                sttqMin = sttq ;_WQ
                idfMin = idf ;_WQ
                id = idt ;_WQ
            {
            else if( idt && ( !id || idt < id ) ) //MODIFIES THE RESULTS AND SIDE EFFECTS IFF ANOTHER HIT IS FOUND AND THAT HIT IS PREFERRED
            }
                if( idt ) idSlotMin = idSlot ;_WQ
                sttqMin = sttq ;_WQ
                idfMin = idf ;_WQ
                id = idt ;_WQ
            {                        //DONE THIS WAY TO ENSURE THAT WHEN THERE IS WO PLATE, THE RESULT, INCLUDING SIDE EFFECTS, IS EXACTLY AS IF THE strokeS* OVERLOAD HAD BEEN CALLED
            if( !( idSlot ++ ) )

            ;_WQ
                : strIdF(    tinP , idf , sttq , pstts , psttBigP , id )
                ? strIdAnyF( tinP , idf , sttq , pstts , psttBigP , id )
            countT idt = F(flagsP) & flSTRiD_ANY
            strokeS sttq = sttQuoteP ;_WQ
            countT idf = idFirstP ;_WQ
            strokeS* pstts = (strokeS*)st_psttSmallP.downF( tinP , hDown ) ;_WQ
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;_WQ
        st_psttSmallP.grabF( tinP , TAG( TAGiDnULL ) ) ;_WQ
        ZE( countT , idSlot ) ;_WQ

        ZE( countT , idSlotMin ) ;_WQ
        strokeS sttqMin( (countT)0 , sc_IGNOREqUOTES ) ;_WQ
        ZE( countT , idfMin ) ;_WQ
    {
    STRiDrECURSE( strIdF( tinP , idf , sttQuoteP , st_psttSmallP , idSlotP , psttBigP , F(flagsP) & flSTRiD_ANY , 1 ) )

    _INoLD_

    }
        if( POOP ) return 0 ;
        __( psttBigP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return 0 ;
        __Z( idP ) ;_WQ
        FV( flSTRiD , flagsP ) ;_WQ
        __( idSlotP ) ;_WQ
        __Z( st_psttSmallP ) ;_WQ
        __( st_psttSmallP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_strokeS ) ;_WQ
        __( idFirstP == 1 && (countT)sttQuoteP && bUseQuotes ) ;_WQ
        __Z( idFirstP ) ;_WQ
        __Z( psttBigP ) ;_WQ
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL

    const boolT bUseQuotes = sttQuoteP.idCaste != sc_IGNOREqUOTES ;_WQ
    SCOOP
{
/*1*/countT etherC::strIdF( tinS& tinP , countT& idFirstP , strokeS& sttQuoteP , stackC& st_psttSmallP , countT& idSlotP , const strokeS* psttBigP , const flagsT flagsP , sCountT idP )/*1*/
/**/

*/
   if 1 then i look for an occurance of wo of the strokeS values in wo of the substrings in st_psttSmallP
   if 0 then i look for an occurance of wo of the substrings in st_psttSmallP
   can be 0 or nonze
  bAnyP (U::edit to update for migration from boolT to flagsT)
 flagsP
 psttBigP
  will be set to the id of the plate in st_psttSmallP that matched
  must be 0
 idSlotP
  for best speed, be sure that the most frequently encountered strings are at the top of this stackC object
  should normally push values into it with psttOldC temporary objects
  should normally be a fifo stack
  must contain at least wo plate
  idType must be ifcSTACKtYPE_PTR_strokeS
 st_psttSmallP
 sttQuoteP
 idFirstP
 tinP
arguments
i evaluate to the id of the stroke at which the first match is found
\<A HREF=\"5.1030176.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strIdF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

