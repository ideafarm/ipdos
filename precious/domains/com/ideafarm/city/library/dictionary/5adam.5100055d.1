
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

    
REST
//if( IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 == etThread.diskIdF( tinP , T("///c") ) ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;

etThread.delF( tinP , psttOffUp   ) ;
etThread.delF( tinP , psttOffDown ) ;
etThread.delF( tinP , psttOnUp    ) ;
etThread.delF( tinP , psttOnDown  ) ;
etThread.delF( tinP , psttAbsent  ) ;
etThread.delF( tinP , psttAbsent2 ) ;

etThread.strokeF( tinP , tPrefix+T("done 0")+tSuffix ) ;
THREADmODE2rESTORE
}
    etThread.strokeF( tinP , tPrefix+T("done 1")+tSuffix ) ;
    //}
    //    etThread.delF( tinP , psttfn ) ;
    //    QUITR
    //    etThread.boxPutGenerationF( tinP , psttfn , T("///ideafarm/ephemeral/domains/com/ideafarm/data/out") , 0x1000 , tNote , tNote.csF( tinP ) ) ; ___( psttfn ) ;
    //    QUITOZ
    //    ZE( strokeS* , psttfn ) ;
    //
    //    tNote += T(" [totalSessionDuration: ")+TT(timeSessionTotal1,timeSessionTotal2)+T("]") ;
    //
    //    tNote += T(" [cSessions: ")+TF1(idSession)+T("]") ;
    //
    //    tNote += T(" [duration: ")+TT(timeStop1,timeStop2)+T("]") ;
    //    etThread.osTimeSubtractF( tinP , timeStop1 , timeStop2 , timeStart1 , timeStart2 ) ;
    //
    //    ;
    //
    //        TT(timeStop1,timeStop2)
    //        T(": console stopped at ")+
    //        TF1(etThread.diskIdF(tinP))+
    //        T("Subject: ")+
    //
    //    TN( tNote , "" ) ; tNote =
    //{
    //etThread.osTimeNowF( tinP , timeStop1 , timeStop2 ) ;
    //ZE( sCountT , timeStop2 ) ;
    //ZE( countT  , timeStop1 ) ;
    //U::SPEED THIS UP BEFORE USING
    //U::MOVE THIS TO key_o so does not slow down quit
    etThread.strokeF( tinP , tPrefix+T("done 2")+tSuffix ) ;
    
    THREADmODE1rESTORE
    }
        }
            for( countT off = 0 ; off < cElts ; off ++ ) delete (tcButtonC*)ppbTcButtonTool[ off ] ;
            countT cElts = sizeof ppbTcButtonTool / sizeof ppbTcButtonTool[ 0 ] ;
        {
        etThread( tinP , pStkClone        ) ;
        etThread( tinP , pStkActionMemory ) ;
        }
            pBatonTree->ungrabF( tinP ) ;
            }
                etThread.strokeF( tinP , tPrefix+T("done 3")+tSuffix ) ;
                writeStateF( tinP , etThread , tree ) ;
                etThread.strokeF( tinP , tPrefix+T("saving the state of your knowledge tree")+tSuffix ) ;
            {
            else
            if( !bStateHasChanged ) etThread.strokeF( tinP , tf ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    
            //}
            //    etThread.delF( tinP , psttfn ) ;
            //    QUITR
            //    etThread.boxPutGenerationF( tinP , psttfn , T("///ideafarm/ephemeral/domains/com/ideafarm/data/out") , 0x1000 , tNote , tNote.csF( tinP ) ) ; ___( psttfn ) ;
            //    QUITOZ
            //    ZE( strokeS* , psttfn ) ;
            //
            //    ;
            //
            //        TT(timeFlush1,timeFlush2)
            //        T(": console fired; flush beginning at ")+
            //        TF1(etThread.diskIdF(tinP))+
            //        T("Subject: ")+
            //
            //    TN( tNote , "" ) ; tNote =
            //    etThread.osTimeNowF( tinP , timeFlush1 , timeFlush2 ) ;
            //    ZE( sCountT , timeFlush2 ) ;
            //    ZE( countT  , timeFlush1 ) ;
            //{
            //U::SPEED THIS UP BEFORE USING
            //U::MOVE THIS TO key_o so does not slow down quit
    
            LOGrAW( "saw sign\r\n" ) ; //U::
            sgnDone_tmGiveSignF.waitF( tinP ) ;
            LOGrAW( "waiting for sign\r\n" ) ; //U::
            }
                }
                    //doCloseSessionF( tinP , etThread , win , 1 ) ;
                    //U::BEFORE HERE
                    win.fireAnimatorIfF( tinP ) ;
                    //U::AFTER HERE
                    sadam.flags |= flSADAM_SUPPRESSaNIMATION ;
                    THREADmODE2rESTORE
                    }
                        }
                            ++ s ; etThread.osSleepF( tinP , TUCK * 0x20 ) ;
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
    
                        }
                            sadam.flags &= ~( F(flSADAM_SUPPRESSaNIMATION) ) ;
                            }
                                etThread.winPostMessageAfterNapF( tinP , TOCK , win , idwm_BECOMEaCTIVE ) ;
                                ((thirdC&)etThread).winShowWindowF( tinP , win , idcWINsHOW_SHOW ) ;
                                bShowWhenFresh = 0 ;
                            {
                            if( bShowWhenFresh )
    
                            }
                                bToolTest = 1 ;
                                bToolTestHire = 0 ;
                            {
                            if( bToolTestHire )
                
                            etThread.delF( tinP , psttTalk ) ;
    
                            win.baton.ungrabF( tinP ) ;

                            etThread.strokeF( tinP , psttTalk ) ;

                            }
                                bEntry = bFind = 0 ;
                                win.purgeSadamStatesF( tinP ) ;
                                etThread.strokeF( tinP , T("\f") ) ;
                            {
                            if( bTestingTools && !bToolTest && !bToolTestHire )

                            tTutorMemory = T("") ;
                            win.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            //etThread.strokeF( tinP , tStutter ) ;
                            
                            //while( cTries -- ) tStutter += T(psttTalk) ;
                            //countT cTries = 8 ;
                            //TN( tStutter , "" ) ;

                            }
                                etThread.delF( tinP , psttr ) ;
                                etThread.strFuseF( tinP , psttTalk , psttr ) ;//U::ELIMINATE psttr
            
                                etThread.strFuseF( tinP , psttr , tn+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME) ) ;

                                }
                                    etThread.strFuseF( tinP , psttr , tn+S3((measure04T)(2+cColsBody),scOld_mmFRAMEcELLS,1.0)+tcButton_toolMouse+S2(0,scOld_POPfRAME)+S2(3,scOld_cPUSHoFFfRAME)+T("\r\n")+S2(0,scOld_POPoFFfRAME) ) ;
                                    countT cColsBody = 0x3e ; //SAME VALUE AS FOR JOYSTICK SO ICON IS SAME SIZE
                                    if( !sttw ) sttw = S1C(' ') ;
                                    strokeS sttw = strokeS::strokeIF( tinP , idTool ) ;
                                    countT idTool = ifcIDtYPEtOOL_MOUSEpOSITION ;
                                {
                                /*B2*/
            
                                }
                                    }
                                        etThread.strFuseF( tinP , psttr , tn+S3((measure04T)(2+cColsBody),scOld_mmFRAMEcELLS,1.0)+(idTool==ifcIDtYPEtOOL_JOY1pOSITION?tcButton_toolJoy1:tcButton_toolJoy2)+S2(0,scOld_POPfRAME)+S2(3,scOld_cPUSHoFFfRAME)+T("\r\n")+S2(0,scOld_POPoFFfRAME) ) ;
                                        countT cColsBody = 0x3e ;
                                        if( !sttw ) sttw = S1C(' ') ;
                                        strokeS sttw = strokeS::strokeIF( tinP , idTool ) ;
                                    {
                                    for( countT idTool = ifcIDtYPEtOOL_JOY1pOSITION ; idTool <= ifcIDtYPEtOOL_JOY2pOSITION ; idTool ++ )
                                {
                                /*B1*/
            
                                etThread.strFuseF( tinP , psttr , tn+S2(1,scOld_cPUSHoFFfRAME)+S3(1.0,scOld_mmFRAMEtO,(measure04T)MAXmEASUREt)+S2(0,scOld_POPoFFfRAME) ) ;

                                if( cDone % cColsRpt ) etThread.strFuseF( tinP , psttr , tn+S2(2,scOld_cPUSHoFFfRAME)+T("\r\n")+S2(0,scOld_POPoFFfRAME) ) ;
                                }
                                    if( !( ( ++ cDone ) % cColsRpt ) ) etThread.strFuseF( tinP , psttr , tcrc ) ;

                                    etThread.strFuseF( tinP , psttr , tn+S3(11.0,scOld_mmFRAMEcELLS,1.0)+*(tcButtonC*)ppbTcButtonTool[idTool-ifcIDtYPEtOOL_begin-1]+S2(0,scOld_POPfRAME)+S3(1.0,scOld_mmMOVE,0.0)+S2(0,scOld_MOVEpADrIGHT) ) ;
            
                                    }
                                        case ifcIDtYPEtOOL_x2End        : { continue ; }
                                        case ifcIDtYPEtOOL_x7End        :
                                        case ifcIDtYPEtOOL_x7Begin      :
                                        case ifcIDtYPEtOOL_x2Begin      :
                                        case ifcIDtYPEtOOL_CONTROLeND   :
                                        case ifcIDtYPEtOOL_CONTROLbEGIN :
                                        case ifcIDtYPEtOOL_JOY2pOSITION :
                                        case ifcIDtYPEtOOL_JOY1pOSITION :
                                        case ifcIDtYPEtOOL_MOUSEpOSITION :
                                    {
                                    switch( idTool ) /*A*/
                                {
                                for( countT idTool = ifcIDtYPEtOOL_begin + 1 ; idTool < ifcIDtYPEtOOL_end ; idTool ++ )
                                ZE( countT , cDone ) ;
            
                                etThread.strFuseF( tinP , psttr , tn+S3((measure04T)cColsRpt,scOld_mmFRAMEcELLS,(measure04T)cRowsRpt) ) ; //FRAME: CELL
            
                                etThread.strFuseF( tinP , psttr , tn+S2(1,scOld_cPUSHoFFfRAME)+S3(1.0,scOld_mmFRAMEtO,1.0)+S2(0,scOld_POPoFFfRAME) ) ; // FRAME: BRANCH CLIENT AREA
            
                                etThread.strMakeF( tinP , psttr , 0 , 0x10 * ( ifcIDtYPEtOOL_end - ifcIDtYPEtOOL_begin - 1 ) ) ; ___( psttr ) ;
                                ZE( strokeS* , psttr ) ;
            
                                for( countT ii = 1 ; ii <= cColsRpt ; ii ++ ) tcrc += tn+S3(-1.0,scOld_mmMOVEpEL,0.0)+S2(0,scOld_MOVEpADlEFT) ;
                                TN( tcrc , "" ) ; tcrc = tn+S3(-(measure04T)cColsRpt,scOld_mmMOVEtO,1.0)+S3(0.0,scOld_mmMOVEpEL,1.0)+S2(0,scOld_MOVEpADuP) ;
                                TN( tn  , "" ) ;

                                cRowsRpt += 0x2 ; //TO LEAVE ROOM FOR HINT, WHICH DISPLAYS NAME OF TOOL
                                countT cRowsRpt = 1 +/*B*/3 + ( ifcIDtYPEtOOL_end - ifcIDtYPEtOOL_begin - 1 - /*A*/9 - 1 ) / cColsRpt ;
                                countT cColsRpt = 8 ;
                            {
                            if( bToolTest || bToolTestHire )
    
                            }
                                }
                                    break ;
                                    tHollywoodSetF( tinP , tree , drawerHollywood ) ;
                                    tHollywoodNewF( tinP , etThread , psttTalk , drawerHollywood ) ;
                                {
                                case ifcIDtYPEdISPLAY_HOLLYWOODnEW :
                                case ifcIDtYPEdISPLAY_HOLLYWOOD    : { tHollywoodF( tinP , etThread , psttTalk , tree , drawerHollywood ) ; break ; }
                                case ifcIDtYPEdISPLAY_HUGE         : { tHugeF(      tinP , etThread , psttTalk , tree , drawerHuge      ) ; break ; }
                            {
                            switch( idTypeDisplay )
                            etThread.strFuseF( tinP , psttTalk , t3 ) ;

                            }
                                }
                                    if( bOutOk     ) { etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowOut   ) ; ___( psttTalk ) ; }
                                    if( bInOk      ) { etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowIn    ) ; ___( psttTalk ) ; }
                                    }
                                        etThread.strFuseF( tinP , psttTalk , tb+tcButton_home       ) ; ___( psttTalk ) ;
                                        etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowRight ) ; ___( psttTalk ) ;
                                    {
                                    if( bRightOk   )
                                    }
                                        etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowLeft  ) ; ___( psttTalk ) ;
                                        etThread.strFuseF( tinP , psttTalk , tb+tcButton_end  ) ; ___( psttTalk ) ;
                                    {
                                    if( bLeftOk    )
                                    if( bUpOk      ) { etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowUp    ) ; ___( psttTalk ) ; }
                                    if( bDownOk    ) { etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowDown  ) ; ___( psttTalk ) ; }
                                    if( *pStkClone ) { etThread.strFuseF( tinP , psttTalk , tb+tcButton_g         ) ; ___( psttTalk ) ; }
                                    if( *pStkClone ) { etThread.strFuseF( tinP , psttTalk , tb+tcButton_minus     ) ; ___( psttTalk ) ; }
                                    if( !bEmpty    ) { etThread.strFuseF( tinP , psttTalk , tb+tcButton_plus ) ; ___( psttTalk ) ; }
                                    if( !bEmpty    ) { etThread.strFuseF( tinP , psttTalk , tb+tcButton_p         ) ; ___( psttTalk ) ; }
                                {
                                else
                                }
                                    }
                                        if( pStkFind->upF(   tinP , 1 ) ) { etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowUp   ) ; ___( psttTalk ) ; }
                                        if( pStkFind->downF( tinP , 1 ) ) { etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowDown ) ; ___( psttTalk ) ; }
                                    {
                                    if( *pStkFind )
                                {
                                else if( bFind )
                                }
                                    }
                                        }
                                            etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowRight ) ; ___( psttTalk ) ;
                                            etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowLeft  ) ; ___( psttTalk ) ;
                                        {
                                        if( bDownOk )
                                        if( !bEmpty ) { etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowUp    ) ; ___( psttTalk ) ; }
                                        if( bDownOk ) { etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowDown  ) ; ___( psttTalk ) ; }
                                    {
                                    if( bHaveStrokes )
                                {
                                else if( bEntry )
                                }
                                    }
                                        etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowRight ) ; ___( psttTalk ) ;
                                        etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowLeft  ) ; ___( psttTalk ) ;
                                    {
                                    if( bDownOk )
                                    etThread.strFuseF( tinP , psttTalk , tb+tcButton_arrowUp    ) ; ___( psttTalk ) ;
                                {
                                if( bGraft ) //U::BUG: IF bGraft THEN NO BACKTAB DEFAULT IS DISPLAYED
                                pBatonTree->ungrabF( tinP ) ;
                                if( bStateHasChanged ) etThread.strFuseF( tinP , psttTalk , tb+tcButton_z ) ;
                                pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    
                                etThread.strFuseF( tinP , psttTalk , tb+t2 ) ;
                                etThread.strFuseF( tinP , psttTalk , tb+tcButton_find   ) ;
                                etThread.strFuseF( tinP , psttTalk , tb+tcButton_stroke ) ;
                                etThread.strFuseF( tinP , psttTalk , tb+tcButton_climb  ) ;
                            {
                            else
                            if( bToolTest || bToolTestHire ) etThread.strFuseF( tinP , psttTalk , tb+t2toolTest ) ;

                            etThread.strMakeF( tinP , psttTalk , t1 , 0x10000 ) ; ___( psttTalk ) ;
                            ZE( strokeS* , psttTalk ) ;

                            }
                                etThread.osTimeNowF( tinP , timeSessionStart1 , timeSessionStart2 ) ;
                                timeSessionStart2 = timeSessionStart1 = 0 ;
                                ++ idSession ;
                                bInSession = 1 ;
                            {
                            if( !bInSession )

                            flTcFeatureDisable       = bToolTest || bToolTestHire || bEntry || bFind ? flTCfEATURE_HOTkEY : flTCfEATURE_null ;
                            flTcFeatureDisableArrows = bToolTest || bToolTestHire                    ? flTCfEATURE_HOTkEY : flTCfEATURE_null ;
                        
                            pBatonTree->ungrabF( tinP ) ;
                            tree.ungrabF( tinP ) ;
                            }
                                if( pData && pData->psttb && pData->psttb->idAdam ) bHaveStrokes = 1 ;
                                branchDataOldS* pData = *pTree ;
                            {
                            bHaveStrokes = 0 ;
                            boolT bEmpty = tree.bEmptyF( tinP ) ;
                            bOutOk   = tree.outF(   tinP , 1 ) ;
                            bInOk    = tree.inF(    tinP , 1 ) ;
                            bRightOk = tree.rightF( tinP , 1 ) ;
                            bLeftOk  = tree.leftF(  tinP , 1 ) ;
                            bUpOk    = tree.upF(    tinP , 1 ) ;
                            bDownOk  = tree.downF(  tinP , 1 ) ;
                            tree.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                
                            sadam.flags |= flSADAM_SUPPRESSaNIMATION ;
                            cDone ++ ;
                        {
                        if( cNew )
    
                        }
                            if( cNew == setIfEqualsAM( cRequestFresh , 0 , cNew ) ) break ;
                            cNew = cRequestFresh ;
                        {
                        for(;;)
                        ZE( countT , cNew ) ;
                    {
                    while( !ether )
                    sadamC sadam( tinP , ether ) ;
                    windowOldC& win = *thirdC::pWinRootIF() ;
                    incv02AM( cRequestFresh ) ;
                    ZE( countT , cDone ) ;
                    idThreadRefresh = tinP.monitor.idThread ;
                    THREADmODE2oN( flTHREADmODE2_MYoWNrECYCLER )
                {
                THREADmODE2oN( flTHREADmODE2_POOLoLDtURBO )
                //if( IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 == etThread.diskIdF( tinP , T("///c") ) ) etThread.osThreadF( TaRG1( tmScriptF ) ) ;
                etThread.osThreadF( TaRG1( tmWatchKtDepositoryF ) ) ;
        
                if( IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 != etThread.diskIdF( tinP , T("///c") ) ) ether.ifcHireF( tinP , T("ifcIDaDAM_NEWcONSOLE") , ifcIDaDAM_DATA , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                //U::THE IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 CONDITION IS SO I CAN DEBUG THE CONSOLE WITHOUT FORGETTING TO ENABLE HIRE FOR RELEASE
    
                ;
        
                        S2(0,scOld_POPfRAME)
                        S3(9.0,scOld_mmMOVEpEL,-9.0)+
                        S2(0,scOld_MOVEdOWNrIGHTfORaDAMfRAME)+
                        S3(0.0,scOld_mmFRAMEpELtO,0.0)+
                        S2(0,scOld_cOVERRIDEnEXTsTROKE)+
                        S2(0,scOld_POPfRAMEdETACH)+
                        S3(-1.0,scOld_mmMOVEpEL,1.0)+
                        S3(1.0/128.0,scOld_mmMOVEtO,23.0/24.0)+
                        S2(0,scOld_PUSHoVERRIDEcOLrOW)+
                        S3(1.0,scOld_mmMOVEpEL,-1.0)+
                        S3(0.0,scOld_mmMOVEtO,1.0)+
                        S2(0,scOld_FRAMEdETACH)+
        
                        S3(0.0,scOld_mmFRAMEpELtO,0.0)+
                        S2(0,scOld_cOVERRIDEnEXTsTROKE)+
                        S3(1.0,scOld_mmMOVEtO,1.0)+
                        S2(0,scOld_POPfRAME)+
                        S2(0,scOld_PUSHoVERRIDEcOLrOW)+
                        S3(0.0,scOld_mmMOVEpEL,6.0)+
                        S2(0,scOld_WRAPoFF)+
                        tcr+
        
                TN( t3 , "" ) ; t3 =
        
                ;
        
                        tcButton_o
                        tb+
                        tcButton_k+
                        tb+
                        tcButton_t+
        
                TN( t2toolTest , "" ) ; t2toolTest =
        
                ;
        
                        tcButton_m
                        tb+
                        tcButton_h+
                        tb+
                        tcButton_newS+
                        tb+
                        tcButton_s+
                        tb+
                        tcButton_w+
                        tb+
                        tcButton_o+
                        tb+
                        tcButton_k+
                        tb+
                        tcButton_t+
        
                TN( t2 , "" ) ; t2 =

                ;
        
                        S2(0,scOld_POPcOLOR)
                        tcButtonLogo+
                        S2(0x00ffff,scOld_cPUSHcOLOR)+
                        tb+
                        tcButton_wheel+
                        tb+
                        tcButton_joy2+
                        tb+
                        tcButton_joy1+
                        ta_invisible+
                        S2(0,scOld_WRAPoN)+
                        S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)+
                        S3(1.0/128.0,scOld_mmFRAMEtO,1.0/32.0)+
                        S3(1.0,scOld_mmFRAMEtO,1.0)+ //SUPPORTS DISPLAY SHRINK (FOR DEBUGGING); IN PRODUCTION, MUST BE 1.0 1.0
                        //S3(0.8,scOld_mmFRAMEtO,0.8)+ //SUPPORTS DISPLAY SHRINK (FOR DEBUGGING); IN PRODUCTION, MUST BE 1.0 1.0
                        tf+
        
                TN( t1 , "" ) ; t1 =

                TN( tcr , "\r\n" ) ;
                TN( tn , "" ) ;
                TN( tb , " " ) ;
            {
            pDrawerHollywood = &drawerHollywood ;
            drawerHollywoodS drawerHollywood( tinP , etThread ) ;
            drawerHugeS      drawerHuge( tinP , etThread ) ;

            }
                }
                    new( 0 , tinP , ppbTcButtonTool[ off ] , sizeof ppbTcButtonTool[ off ] ) tcButtonC( tinP , tcButton_toolCBF , idTool , flTcFeatureTool , &flTcFeatureDisable , T("")+strokeS::strokeIF(tinP,idTool)+T(" ") , 8 ) ;
                    countT idTool = ifcIDtYPEtOOL_begin+1+off ;
                {
                for( countT off = 0 ; off < cElts ; off ++ )
                countT cElts = sizeof ppbTcButtonTool / sizeof ppbTcButtonTool[ 0 ] ;
            {

            pTcButton_toolMouse->setF( tinP , T("")+S3(64.0,scOld_mmFRAMEcELLS,1.0)+S2(0x0000ff,scOld_cPUSHcOLOR)+T("  ABSENT")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
            pTcButton_toolJoy2->setF( tinP , T("")+S3(64.0,scOld_mmFRAMEcELLS,1.0)+S2(0x0000ff,scOld_cPUSHcOLOR)+T("  ABSENT")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
            pTcButton_toolJoy1->setF( tinP , T("")+S3(64.0,scOld_mmFRAMEcELLS,1.0)+S2(0x0000ff,scOld_cPUSHcOLOR)+T("  ABSENT")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
            pTcButton_joy2->setF( tinP , T("")+S2(0,scOld_FRAMEdETACH)+S2(0x0000ff,scOld_cPUSHcOLOR)+S3(1.0,scOld_mmLINEtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEeNDtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmMOVEtO,1.0)+S3(1.0,scOld_mmLINEtO,0.0)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAMEdETACH)/*+S3(16.0,scOld_mmFRAMEcELLS,16.0)+S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)+TF1(pmxP[1])+T(",")+TF1(pmxP[2])+S2(0,scOld_POPfRAME)*/ ) ;
            pTcButton_joy1->setF( tinP , T("")+S2(0,scOld_FRAMEdETACH)+S2(0x0000ff,scOld_cPUSHcOLOR)+S3(1.0,scOld_mmLINEtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEeNDtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmMOVEtO,1.0)+S3(1.0,scOld_mmLINEtO,0.0)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAMEdETACH)/*+S3(16.0,scOld_mmFRAMEcELLS,16.0)+S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)+TF1(pmxP[1])+T(",")+TF1(pmxP[2])+S2(0,scOld_POPfRAME)*/ ) ;

            pTcButton_wheel     = &tcButton_wheel ;
            pTcButton_toolMouse = &tcButton_toolMouse ;
            pTcButton_toolJoy2  = &tcButton_toolJoy2 ;
            pTcButton_toolJoy1  = &tcButton_toolJoy1 ;
            pTcButton_joy2      = &tcButton_joy2  ;
            pTcButton_joy1      = &tcButton_joy1  ;

            tcButtonC tcButton_z(          tinP , tcButton_zCBF          , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2('z'               ,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_wheel(      tinP , tcButton_wheelCBF      , 0 , flTcFeatureWheel  , &flTcFeatureDisable       , T("")                                                                                         , 1 ) ;
            tcButtonC tcButton_w(          tinP , tcButton_wCBF          , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2('w'               ,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_toolMouse(  tinP , tcButton_toolMouseCBF  , 0 , flTcFeatureTool   , &flTcFeatureDisable       , T("")+strokeS::strokeIF(tinP,ifcIDtYPEtOOL_MOUSEpOSITION)+T(" ")                              , 0x3e ) ;
            tcButtonC tcButton_toolJoy2(   tinP , tcButton_toolJoy2CBF   , 0 , flTcFeatureTool   , &flTcFeatureDisable       , T("")+strokeS::strokeIF(tinP,ifcIDtYPEtOOL_JOY2pOSITION)+T(" ")                               , 0x3e ) ;
            tcButtonC tcButton_toolJoy1(   tinP , tcButton_toolJoy1CBF   , 0 , flTcFeatureTool   , &flTcFeatureDisable       , T("")+strokeS::strokeIF(tinP,ifcIDtYPEtOOL_JOY1pOSITION)+T(" ")                               , 0x3e ) ;
            tcButtonC tcButton_t(          tinP , tcButton_tCBF          , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+T("tutor")                         +S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_stroke(     tinP , tcButton_strokeCBF     , 0 , flTcFeatureTabber , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+T("enter")                         +S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_newS(       tinP , tcButton_newSCBF       , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+T("newS")                          +S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_s(          tinP , tcButton_sCBF          , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2('s'               ,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_plus(       tinP , tcButton_plusCBF       , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2('+'               ,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_p(          tinP , tcButton_pCBF          , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2('p'               ,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_o(          tinP , tcButton_oCBF          , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2('o'               ,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_minus(      tinP , tcButton_minusCBF      , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2('-'               ,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_m(          tinP , tcButton_mCBF          , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2('m'               ,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_k(          tinP , tcButton_kCBF          , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2('k'               ,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButtonLogo(        tinP , tcButton_iCBF          , 0 , flTcFeatureWheel  , &flTcFeatureDisable       , tLogo ) ;
            tcButtonC tcButton_joy2(       tinP , tcButton_joy2CBF       , 0 , flTcFeatureWheel  , &flTcFeatureDisable       , T("")                                                                                         , 4 ) ;
            tcButtonC tcButton_joy1(       tinP , tcButton_joy1CBF       , 0 , flTcFeatureWheel  , &flTcFeatureDisable       , T("")                                                                                         , 4 ) ;
            tcButtonC tcButton_home(       tinP , tcButton_homeOld20190809CBF       , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2(saA1_TOOLHOME,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_h(          tinP , tcButton_hCBF          , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2('h'               ,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_g(          tinP , tcButton_gCBF          , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2('g'               ,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_find(       tinP , tcButton_findCBF       , 0 , flTcFeatureTabber , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+T("find")                          +S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_end(        tinP , tcButton_endCBF        , 0 , flTcFeature       , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2(saA1_TOOLEND,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_climb(      tinP , tcButton_climbCBF      , 0 , flTcFeatureTabber , &flTcFeatureDisable       , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+T("climb")                         +S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_arrowUp(    tinP , tcButton_arrowUpCBF    , 0 , flTcFeature       , &flTcFeatureDisableArrows , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2(saA1_TOOLUP,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_arrowRight( tinP , tcButton_arrowRightCBF , 0 , flTcFeature       , &flTcFeatureDisableArrows , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2(saA1_TOOLRIGHT,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_arrowOut(   tinP , tcButton_arrowOutCBF   , 0 , flTcFeature       , &flTcFeatureDisableArrows , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2(saA1_TOOLPAGEuP,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_arrowLeft(  tinP , tcButton_arrowLeftCBF  , 0 , flTcFeature       , &flTcFeatureDisableArrows , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2(saA1_TOOLLEFT,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_arrowIn(    tinP , tcButton_arrowInCBF    , 0 , flTcFeature       , &flTcFeatureDisableArrows , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2(saA1_TOOLPAGEdOWN,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;
            tcButtonC tcButton_arrowDown(  tinP , tcButton_arrowDownCBF  , 0 , flTcFeature       , &flTcFeatureDisableArrows , T("")+S2(0x00ffff,scOld_cPUSHcOLOR)+S2(saA1_TOOLDOWN,sc_cALPHABET1)+S2(0,scOld_POPcOLOR) ) ;

            const flagsT flTcFeatureTool   = flTcFeature & ~( F(flTCfEATURE_FRAME) ) ;
            const flagsT flTcFeatureWheel  = flTcFeature & ~( F(flTCfEATURE_FRAME) ) ;
            const flagsT flTcFeatureTabber = flTCfEATURE_defaultButton | flTCfEATURE_FLYOVER | flTCfEATURE_DRAGGABLE | flTCfEATURE_TABpARTICIPANT | flTCfEATURE_KEYaCTION ;
            const flagsT flTcFeature       = flTCfEATURE_defaultButton | flTCfEATURE_FLYOVER | flTCfEATURE_DRAGGABLE /*| flTCfEATURE_TABpARTICIPANT*/ ;
        
            etThread.osThreadF( tinP , countTC() , tmGiveSignF , &sgnDone_tmGiveSignF ) ;
            signC sgnDone_tmGiveSignF( tinP , TAG( TAGiDnULL ) ) ;
    
            readStateF( tinP , etThread , tree ) ;
            etThread.strokeF( tinP , tPrefix+T("reading the state of your knowledge tree")+tSuffix ) ;
    
            pBatonTree = &batonTree ;
            batonC batonTree( tinP , TAG( TAGiDnULL ) ) ;
            pTree = &tree ;
            treeOldC tree( tinP , TAG( TAGiDnULL ) , idCursor ) ;
    
            pStkFind = &stFind ;
            stackC stFind( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO |  flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_BLOB , cbHandle ) ;
            }
                cbHandle = (byteT*)&foo.after - (byteT*)&foo.handle ;
                foo( tinP ) ;
                }
                    inline fooC( tinS& tinP ) : handle( TAG( TAGiDnULL ) ) {}

                    countT  after ;
                    handleC handle ;
                {
                struct fooC
            {
            ZE( countT , cbHandle ) ; //THIS IS DONE RATHER THAN sizeof( handleC ) TO AVOID COMPILER WARNING
    
            pTxtToolsMemory = &tToolsMemory ;
            pTxtTools       = &tTools ;
            pTxtTutorMemory = &tTutorMemory ;
            pTxtTutor       = &tTutor ;
            TN( tToolsMemory , "" ) ; //MUST BE NULL LENGTH FOR CODE TO WORK
            TN( tTools       , "" ) ;
            TN( tTutorMemory , "" ) ; //MUST BE NULL LENGTH FOR CODE TO WORK
            TN( tTutor       , "explore with mouse and keys!" ) ;
        {
        if( pStkClone && pStkActionMemory )
        etThread( tinP , pStkActionMemory , TAG( TAGiDnULL ) , flSTACKc_XRAY , ifcSTACKtYPE_countT ) ;
        etThread( tinP , pStkClone        , TAG( TAGiDnULL ) , flSTACKc_XRAY , ifcSTACKtYPE_PTR_soulC ) ;

        pTxtFind = &tFind ;
        TN( tFind , "" ) ;

        pTxtLogo = &tLogo ;
        ;
    
            S2(0,scOld_POPcOLOR)
            S3(0.0,scOld_mmMOVEpELtO,0.0)+
            S2(0,scOld_cOVERRIDEnEXTsTROKE)+
            S2(0,scOld_POPfRAME)+
            S2(0,scOld_PUSHoVERRIDEcOLrOW)+
            S2(saA1_TRADEmARK,sc_cALPHABET1)+
            S3(2.0,scOld_mmFRAMEtO,0.25)+
            T("IdeaFarm")+
            S2(0x00ffff,scOld_cPUSHcOLOR)+
            T("")+
    
        TN( tLogo , "" ) ; tLogo =

        }
            ta_invisible = T("")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;

            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)flFEATUREsADAMjOYsTICK_null ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_JOYsTICK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_invisibleCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_ANIMATE ; //BECAUSE I WANT TO GET RENDERoFF RENDERoN CALLS
                *psFeature << (strokeS*)T("saOLD_invisibleCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_invisible , "" ) ;
    {
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    
    }
        etThread.delF( tinP , psttfn ) ;
        etThread.boxPutGenerationF( tinP , psttfn , T("///ideafarm/ephemeral/domains/com/ideafarm/data/out") , 0x1000 , tNote , tNote.csF( tinP ) ) ; ___( psttfn ) ;
        ZE( strokeS* , psttfn ) ;
    
        ;
    
            TT(timeStart1,timeStart2)
            T(": console started at ")+
            TF1(etThread.diskIdF(tinP))+
            T("Subject: ")+
    
        TN( tNote , "" ) ; tNote =
    {
    etThread.osTimeNowF( tinP , timeStart1 , timeStart2 ) ;
    ZE( sCountT , timeStart2 ) ;
    ZE( countT  , timeStart1 ) ;
    
    pEtPrime = &etherC::etPrimeIF() ;
{
THREADmODE2oN( flTHREADmODE2_MYoWNrECYCLER )

pTxtBlank = &tBlank ;
pTxtNull = &tNull ;
TN( tBlank , " " ) ;
TN( tNull , "" ) ;

etThread.strMakeF( tinP , psttOffUp   , tn+S3(9.0,scOld_mmFRAMEcELLS,1.0)                          +T("         ")                          +S2(0,scOld_POPfRAME) ) ; ___( psttOffUp   ) ;
etThread.strMakeF( tinP , psttOffDown , tn+S3(9.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+T("     DOWN")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ; ___( psttOffDown ) ;
etThread.strMakeF( tinP , psttOnUp    , tn+S3(9.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+T("  ON     ")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ; ___( psttOnUp    ) ;
etThread.strMakeF( tinP , psttOnDown  , tn+S3(9.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+T("  ON DOWN")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ; ___( psttOnDown  ) ;
etThread.strMakeF( tinP , psttAbsent  , tn+S3(9.0,scOld_mmFRAMEcELLS,1.0)+S2(0x0000ff,scOld_cPUSHcOLOR)+T("  ABSENT ")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ; ___( psttAbsent  ) ;
etThread.strMakeF( tinP , psttAbsent2 , tn+S3((measure04T)0x3e,scOld_mmFRAMEcELLS,1.0)+S2(0x0000ff,scOld_cPUSHcOLOR)+T(" ABSENT")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ; ___( psttAbsent  ) ;
TN( tn , "" ) ;

//if( IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 == etThread.diskIdF( tinP , T("///c") ) ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , 1 ) ;
etThread.strokeF( tinP , tPrefix+T("getting ready to go to work")+tSuffix ) ;
;
    
        S2(0,scOld_POPfRAME)
        T("")+
    
TN( tSuffix , "" ) ; tSuffix =
;
    
        S3(1.0/128.0,scOld_mmFRAMEtO,1.0/16.0)
        tf+
    
TN( tPrefix , "" ) ; tPrefix =
TN( tf , "\f" ) ;

win.baton.ungrabF( tinP ) ;
win.pAnimateCBF = animateCBF ;
win.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
windowOldC& win = *thirdC::pWinRootIF() ;

pButtonDebug = &buttonDebug ;
tcButtonC buttonDebug( tinP , 0 , 0 , flTCfEATURE_DRAGGABLE | flTCfEATURE_FLYOVER | flTCfEATURE_FLYOVERhIGHLIGHT | flTCfEATURE_MOUSE | flTCfEATURE_HOTkEY | flTCfEATURE_FRAME , 0 , T("\\") ) ;

TODO

DONE( tmFlushStateF )
THREADmODE1rESTORE
doFlushStateF( tinP , etThread ) ;
THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
TASK( tmFlushStateF )

DONE( tmScriptF )

incv02AM( cRequestFresh ) ;
etherC::etherFireImpersonateMonitorIF( tinP ) ;

}
    }
        ++ s ; etThread.osSleepF( tinP , TUCK * 0x80 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    incv02AM( cRequestFresh ) ;
{
while( cTries -- )
countT cTries = 0x3f ;
//countT cTries = 0x4 ;

}
    ++ s ; etThread.osSleepF( tinP , TOCK * 2 ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{

TASK( tmScriptF )

DONE( tmGiveSignF )
incv02AM( cRequestFresh ) ;
etThread.loafIF( tinP ) ;
TASK( tmGiveSignF )

DONE( tmWatchKtDepositoryF )
THREADmODE2rESTORE
}
    }
        etThread.diskWaitDirF( tinP , hDirChange , ether , tDepository , flWAITdIR_FILEnAME | flWAITdIR_DIRnAME ) ;
    
        etThread.delF( tinP , pstt1m ) ;
        }
            }
                etThread.delF( tinP , psttNameShort ) ;
                }
                    POPUP( tMsg ) ;
    
                    if( bLoaded ) tMsg += T("\r\n\r\nI was able to graft it onto your knowledge tree but was not able to delete it from the depository.") ;
                    TN( tMsg , "" ) ; tMsg = T("I have moved, to your desk, an object named \"")+tReject+T("\".") ;
    
                    }
                        }
                            idDup ++ ;
                            POOPR
                        {
                        else
                        if( !POOP ) break ;
                        tinP.pEtScratch->diskMoveFileOrDirF( tinP , tDesk+tReject , psttc1 ) ;
                        tReject = T("ideafarm.kt.reject.")+(idDup?TF1(idDup)+T("."):T(""))+T(psttNameShort) ;
                    {
                    while( !ether && idDup < 0x100 )
                    TN( tReject , "" ) ;
                    ZE( countT , idDup ) ;
    
                    }
                        pBatonTree->ungrabF( tinP ) ;
                        pTree->upF( tinP ) ;
                        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    if( bWentDown )
                    POOPR
                {
                else
                }
                    incv02AM( cRequestFresh ) ;
                    pBatonTree->ungrabF( tinP ) ;
                    bStateHasChanged = 1 ;
                    bShowWhenFresh = 1 ;
                    pTree->ungrabF( tinP ) ;
                    pTree->rightF( tinP ) ;
                    pTree->upF( tinP ) ;
                    pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( !POOP )
    
                }
                    cFilesIn ++ ;
                    tinP.pEtScratch->boxZapF( tinP , psttc1 , 1 ) ;
                {
                if( !POOP )
                boolT bLoaded = !POOP ;
    
                }
                    pBatonTree->ungrabF( tinP ) ;
                    pTree->ungrabF( tinP ) ;
                    THREADmODE1rESTORE
                    readF( tinP , *tinP.pEtScratch , *pTree , psttc1 , countTC() ) ;
                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                    bWentDown = pTree->downF( tinP ) ;
                    pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( !POOP )
                ZE( boolT , bWentDown ) ;
    
                __( 1 != tinP.pEtScratch->strIdF( tinP , T("ideafarm.kt.") , psttNameShort ) ) ;
                __( psttNameShort && !psttNameShort->idAdam ) ;
                __Z( psttNameShort ) ;
                __( bDir ) ;
        
                tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttNameShort ) ;
                }
                    }
                        etThread.strMakeF( tinP , psttNameShort , T("rejected") ) ; ___( psttNameShort ) ;
                        etThread.delF( tinP , psttNameShort ) ;
                    {
                    if( !psttNameShort || !psttNameShort->idAdam )
    
                    tinP.pEtScratch->strWordF( tinP , psttNameShort , psttc1 , sttq , S1C('/') , - 2 ) ; ___( psttNameShort ) ;
                    etThread.delF( tinP , psttNameShort ) ;
                {
                if( bDir )
                boolT bDir = psttNameShort && !psttNameShort->idAdam ;
                tinP.pEtScratch->strWordF( tinP , psttNameShort , psttc1 , sttq , S1C('/') , - 1 ) ; ___( psttNameShort ) ;
                strokeS sttq ;
                ZE( strokeS* , psttNameShort ) ;
        
                SCOOPS
            {
            IFsCRATCH
        {
        FORsTRINGSiN1( pstt1m )
        etThread.boxMenuF( tinP , soul , tDepository+T("*") , 0 , 1 ) ; ___( pstt1m ) ;
        ZE( strokeS* , pstt1m ) ;
    {
    while( !ether && !etThread )
    handleC hDirChange( tinP , TAG( TAGiDnULL ) ) ;
    
    etThread.diskMakeDirIfNeededF( tinP , tDepository ) ;
    }
        tDepository = tDesk+tDepositoryShort+T("/") ;
        etThread.delF( tinP , psttm ) ;
        tDesk = T(psttm) ;
        etThread.diskMapFileNameF( tinP , psttm , T("///desk/") ) ; ___( psttm ) ;
        ZE( strokeS* , psttm ) ;
    {
    TN( tDepository , "" ) ;
    TN( tDesk , "" ) ;
    TN( tDepositoryShort , "IdeaFarm " "(tm) KT Depository") ;
{
THREADmODE2oN( flTHREADmODE2_MYoWNrECYCLER ) //U:: TO CATCH A BUG
TASK( tmWatchKtDepositoryF )

}
    QUITR
    }
        }
            }
                break ;
                POOPR
            {
            if( POOP )

            tinP.pEtScratch->boxZapF( tinP , TsTATEfILE+T(".")+TF3(idMin++,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObIGITvALUES,8) ) ;
        {
        else while( idMin < idMinKeep )
        if( POOP ) POOPR

        countT idMinKeep = idMax > CgENSsTATE ? idMax - CgENSsTATE + 1 : 1 ;
        tinP.pEtScratch->boxMenuIdRangeF( tinP , idMin , idMax , TsTATEfILE+T(".*") , TUCK * CgENSsTATE ) ;
        ZE( countT , idMax ) ;
        ZE( countT , idMin ) ;
        SCOOPS
    {
    IFsCRATCH

    pBatonTree->ungrabF( tinP ) ;
    }
        bStateHasChanged = 0 ;
        writeF( tinP , etherP , TsTATEfILE , treeP , 1 ) ;
    {
    if( bStateHasChanged )
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    QUITOZ
{
voidT writeStateF( tinS& tinP , etherC& etherP , treeOldC& treeP )

}
    _OUT_
    pBatonTree->ungrabF( tinP ) ;
    if( bWholeP ) etherP( tinP , pStkDirections ) ;
    etherP( tinP , psFile ) ;
    }
        }
            _OUT_
            etherP.delF( tinP , psttf ) ;
            if( !bWholeP ) { POPUP( T("The current branch has been written to file\r\n\r\n    ")+T(psttf)+T("\r\n\r\n(KT file names must begin with \"ideafarm.kt.\".)") ) ; }
            tinP.pEtScratch->boxPutGenerationF( tinP , psttf , psttP , TUCK * 0x10 , *psFile , psFile->cbF( tinP ) ) ;
            ZE( strokeS* , psttf ) ;
            SCOOPS
            _INoLD_
        {
        IFsCRATCH
    
        }
            _OUT_
            treeP.writeF( tinP , *psFile ) ;//U::ENHANCE TO STORE ALL CURSORING INFORMATION SO CURSORS WILL PERSIST
            _INoLD_
        {

        }
            _OUT_
            }
                *psFile << idBro ;
                *pStkDirections >> idBro ;
                ZE( countT , idBro ) ;
            {
            if( bWholeP ) while( *pStkDirections )
            *psFile << ( bWholeP ? (countT)*pStkDirections : (countT)0 ) ;
            _INoLD_
        {

        }
            _OUT_
            }
                treeP.downF( tinP ) ;
                *pStkDirections << idBro ;
                while( treeP.leftF( tinP ) ) idBro ++ ;
                countT idBro = 1 ;
            {
            if( bWholeP ) while( treeP.downF( tinP , 1 ) )
            _INoLD_
        {

        *psFile << ( bWholeP ? idTypeDisplay : (countT)0 ) ;
        *psFile << ( bWholeP ? idCursor      : (countT)0 ) ;
    {
    if( psFile && ( !bWholeP || pStkDirections ) )
    if( bWholeP ) etherP( tinP , pStkDirections , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_countT ) ;
    etherP( tinP , psFile , TAG( TAGiDnULL ) ) ;
    ZE( stackC* , pStkDirections ) ;
    ZE( soulC* , psFile ) ;
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    _INoLD_
{
voidT writeF( tinS& tinP , etherC& etherP , const strokeS* const psttP , treeOldC& treeP , const boolT bWholeP )

}
    QUITR
    pBatonTree->ungrabF( tinP ) ;
    }
        }
            treeP.ungrabF( tinP ) ;
            treeP.rightF( tinP ) ;
            treeP.upF( tinP ) ;
            treeP.walkF( tinP , hWalk , etherP , countTC() , treeOldCBF , countTC() , flTREEwALK_REVERSE ) ; //CURSOR THE ELDEST KID OF EACH BRANCH
            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_TREEwALK ) ;
            while( treeP.downF( tinP ) ) ;
            
            etherP.delF( tinP , pstt1l ) ;
            }
                etherP.delF( tinP , psttb ) ;
                treeP.newKidF( tinP , psttb ) ;
                etherP.strTrimF( tinP , psttb , psttc1 , T(TbLACKnEWlINE) ) ; ___( psttb ) ;
                ZE( strokeS* , psttb ) ;
                    
                }
                    idLevel -- ;
                    treeP.downF( tinP ) ;
                {
                else while( idLevelRequested < idLevel )
                }
                    idLevel ++ ;
                    treeP.upF( tinP ) ;
                {
                if( idLevelRequested == idLevel + 1 )

                if( POOP ) break ;
                __( idLevel + 1 < idLevelRequested ) ; //INDENTATION IS NOT ALLLOWED TO INCREASE BY MORE THAN 1 OVER PRIOR INPUT LINE
                __Z( idLevelRequested ) ; //INPUT LINE DOES NOT CONTAIN NONBLANKS
                countT idLevelRequested = idBlanks != 1 ? 1 : idf ;
                    
                countT idBlanks = etherP.strIdAnyF( tinP , idf , sttq , sttb , psttc1 ) ;
                countT idf = 1 ;
            {
            FORsTRINGSiN1( pstt1l )
            treeP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            countT idLevel = 1 ;
            strokeS sttb( ' ' ) ;
            etherP.strWordsOldF( tinP , pstt1l , tTutor , sttq , T("\r\n") ) ; ___( pstt1l ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1l ) ;
            TN( tqq , "\"\"" ) ;
            TN( tq , "\"" ) ;
        {
        if( tTutor.csF( tinP ) )
        TN( tTutor , postTutor ) ;
    {
    if( !bLoaded )
    
    }
        else       bLoaded = 1 ;
        if( POOP ) POOPR
        readF( tinP , *tinP.pEtScratch , treeP , TsTATEfILE , idGeneration ) ; //U::EDIT TO USE PRIOR GENS UNTIL READ IS OK
        countT idGeneration = 1 ;
        SCOOPS
    {
    IFsCRATCH
    ZE( boolT , bLoaded ) ;
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    QUITOZ
{
voidT readStateF( tinS& tinP , etherC& etherP , treeOldC& treeP )

}
    if( bWhole ) etherP( tinP , pStkDirections ) ;
    etherP( tinP , psFile ) ;
    pBatonTree->ungrabF( tinP ) ;
    }
        }
            }
                while( -- idBro ) treeP.rightF( tinP ) ;
                *pStkDirections >> idBro ;
                ZE( countT , idBro ) ;
                treeP.upF( tinP ) ;
            {
            if( bWhole ) while( *pStkDirections )
                    
            treeP.walkF( tinP , hWalk , etherP , countTC() , treeOldCBF , countTC() , flTREEwALK_REVERSE ) ; //CURSOR THE ELDEST KID OF EACH BRANCH
            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_TREEwALK ) ;
            if( bWhole ) while( treeP.downF( tinP ) ) ;

            //LOGrAW3( "i read " , cBranches , " branches into the tree\r\n" ) ; //U::
            //}
            //    LOGrAWtID( "------------------- END -----------------------------" ) ;
            //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
            //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_DISABLE ) ;
            //{
            //if( idIn == 2 )
            countT cBranches = treeP.readF( tinP , *psFile , *pEtPrime ) ;
            //}
            //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_ENABLE ) ;
            //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
            //    LOGrAWtID( "------------------- BEGIN -----------------------------" ) ;
            //{
            //if( idIn == 2 )
            //countT idIn = 1 + incv02AM( idInLath ) ;
            //static countT idInLath ;
            //U::

            }
                *pStkDirections << idBro ;
                *psFile >> idBro ;
                ZE( countT , idBro ) ;
            {
            if( bWhole ) while( cDirections -- )

            *psFile >> cDirections ;
            ZE( countT , cDirections ) ;

            if( bWhole && idTypeDisplayNew ) idTypeDisplay = idTypeDisplayNew ;
            *psFile >> idTypeDisplayNew ;
            ZE( countT , idTypeDisplayNew ) ;

            if( bWhole && idCursorNew ) idCursor = idCursorNew ;
            *psFile >> idCursorNew ;
            ZE( countT , idCursorNew ) ;
        {
        if( !POOP )

        }
            etherP.delF( tinP , pbi ) ;
            if( pbi ) psFile->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbi , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
            etherP.delF( tinP , psttfn ) ;
            __Z( pbi ) ;
            etherP.boxGetShadowGenerationF( tinP , pbi , cbi , psttfn , psttP , TUCK * 0x10 , 0 , 1 ) ;
            ZE( strokeS* , psttfn ) ;
            ZE( countT , cbi ) ;
            ZE( byteT* , pbi ) ;
        {
        else
        if( !idGenerationP ) etherP.boxGetShadowF( tinP , *psFile , psttP , 1 ) ;
    {
    if( psFile && ( pStkDirections || !bWhole ) )
    if( bWhole ) etherP( tinP , pStkDirections , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_XRAY , ifcSTACKtYPE_countT ) ;
    ZE( stackC* , pStkDirections ) ;
    etherP( tinP , psFile , TAG( TAGiDnULL ) ) ;
    ZE( soulC* , psFile ) ;

    boolT bWhole = !treeP.downF( tinP , 1 ) ;
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT readF( tinS& tinP , etherC& etherP , treeOldC& treeP , const strokeS* const psttP , countT& idGenerationP )

}
    if( tinP.fingerprint && etherP && idTypeP && flagsP && pbP && cbP && cArgP && !handleP ) ;
    _OUT_
    }
        if( tCopy.csF( tinP ) && pData && pData->psttb && etherP.strIdF( tinP , tCopy , pData->psttb ) ) *pStkFind << (byteT*)&handleP ; //ASSUME: HANDLE IS CLONEABLE VIA MEMCOPY
        branchDataOldS* pData = (branchDataOldS*)pbP ;
    
        TN( tCopy , "" ) ; tCopy = *pTxtFind ; //U::O: ELIMINATE THE NEED FOR THIS BY SERIALIZING
    {
    if( idTypeP == ifcIDtYPEtREEwALKcb_BRANCHbEGIN )

    _INoLD_
{
voidT treeFindCBF( tinS& tinP , etherC& etherP , const countT idTypeP , const flagsT flagsP , const handleC& handleP , byteT* pbP , countT cbP , countT& cArgP )

}
    if( tinP.fingerprint && etherP && idTypeP && flagsP && pbP && cbP && cArgP && !handleP ) ;
    _OUT_
    _INoLD_
{
voidT treeOldCBF( tinS& tinP , etherC& etherP , const countT idTypeP , const flagsT flagsP , const handleC& handleP , byteT* pbP , countT cbP , countT& cArgP )

}
    return 0 ;
    _OUT_
    if( tinP.fingerprint && etherP && wP.bDoomed && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchStrokeP.mIdColHot ) ;

    }
        }
            break ;
            }
                }
                    break ;
                    }
                        }
                            break ;

                            (off?pTcButton_joy2:pTcButton_joy1)->setF( tinP , *pTxtNull+S2(0,scOld_FRAMEdETACH)+S2(0x00ff00,scOld_cPUSHcOLOR)+S3(1.0,scOld_mmLINEtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,0.0)+S3(0.5,scOld_mmMOVEtO,0.0)+S3(0.5,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmMOVEtO,0.5)+S3(1.0,scOld_mmLINEtO,0.5)+S2(0,scOld_POPcOLOR)+S3(pmxP[1],scOld_mmMOVEtO,pmxP[2])+S3(pmxP[1],scOld_mmLINEeNDtO,pmxP[2])+S2(0,scOld_POPfRAMEdETACH)/*+S3(16.0,scOld_mmFRAMEcELLS,16.0)+S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)+TF1(pmxP[1])+T(",")+TF1(pmxP[2])+S2(0,scOld_POPfRAME)*/ ) ;

                            countT off = !( idTool == ifcIDtYPEtOOL_JOY1bUTTON1 ) ;
                        {
                        case ifcIDtYPEtOOL_JOY2bUTTON1 :
                        case ifcIDtYPEtOOL_JOY1bUTTON1 :
                    {
                    switch( idTool )
                {
                case ifcIDtYPEaCTION_DOWN :
                }
                    break ;
                    }
                        }
                            break ;
                            (off?pTcButton_toolJoy2:pTcButton_toolJoy1)->setF( tinP , *pTxtNull+S3(64.0,scOld_mmFRAMEcELLS,1.0)+S2(0x0000ff,scOld_cPUSHcOLOR)+T("  ABSENT")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
                            (off?pTcButton_joy2:pTcButton_joy1)->setF( tinP , *pTxtNull+S2(0,scOld_FRAMEdETACH)+S2(0x0000ff,scOld_cPUSHcOLOR)+S3(1.0,scOld_mmLINEtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEeNDtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmMOVEtO,1.0)+S3(1.0,scOld_mmLINEtO,0.0)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAMEdETACH)/*+S3(16.0,scOld_mmFRAMEcELLS,16.0)+S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)+TF1(pmxP[1])+T(",")+TF1(pmxP[2])+S2(0,scOld_POPfRAME)*/ ) ;
                            pbJoy[ off ] = 0 ;
                            countT off = idTool - ifcIDtYPEtOOL_JOY1pOSITION ;
                            etherP.beeClickF( tinP ) ; //U::
                        {
                        case ifcIDtYPEtOOL_JOY2pOSITION :
                        case ifcIDtYPEtOOL_JOY1pOSITION :
                    {
                    switch( idTool )
                {
                case ifcIDtYPEaCTION_DETACH :
                }
                    break ;
                    }
                        }
                            break ;

                            if( !pbJoy[ off ] ) pbJoy[ off ] = 1 ;
                            (off?pTcButton_joy2:pTcButton_joy1)->setF( tinP , *pTxtNull+S2(0,scOld_FRAMEdETACH)+S2(bDown?0x00ff00:0x004400,scOld_cPUSHcOLOR)+S3(1.0,scOld_mmLINEtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,0.0)+S3(0.5,scOld_mmMOVEtO,0.0)+S3(0.5,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmMOVEtO,0.5)+S3(1.0,scOld_mmLINEtO,0.5)+S2(0,scOld_POPcOLOR)+S3(pmxP[1],scOld_mmMOVEtO,pmxP[2])+S3(pmxP[1],scOld_mmLINEeNDtO,pmxP[2])+S2(0,scOld_POPfRAMEdETACH)/*+S3(16.0,scOld_mmFRAMEcELLS,16.0)+S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)+TF1(pmxP[1])+T(",")+TF1(pmxP[2])+S2(0,scOld_POPfRAME)*/ ) ;

                            boolT   bDown = F(*pFlags) & flTOOL_DOWN ;
                            flagsT* pFlags = (flagsT*)pcNotesP[ 5 ] ;
                            countT off = idTool - ifcIDtYPEtOOL_JOY1pOSITION ;
                        {
                        case ifcIDtYPEtOOL_JOY2pOSITION :
                        case ifcIDtYPEtOOL_JOY1pOSITION :
                    {
                    switch( idTool )
                {
                case ifcIDtYPEaCTION_ATTACH :
                case ifcIDtYPEaCTION_MOVE :
            {
            switch( idAction )

            const measureT* pmxP   = pcNotesP ? (const measureT*)pcNotesP[ 4 ] : 0 ;
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_JOYsTICK :
        }
            break ;
            *pTxtToolsMemory = T("") ;
            *pTxtTutorMemory = T("") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_DESTROY :
        }
            break ;
            else                etherC::ether_cUtility_IF( tinP ) = 1 ; //U::
            if( bToolTestHire ) bTestingTools = 1 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_RENDERoFF :
        }
            break ;
            if( bTestingTools ) bTestingTools = 0 ;
            bNewFace = 1 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_RENDERoN :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_invisibleCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , sadamStateOldS& scratchStrokeP )/*1*/

}
    return 0 ;
    _OUT_
    if( tinP.fingerprint && etherP && wP.bDoomed && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchStrokeP.mIdColHot ) ;

    }
        }
            break ;
            *pTxtTutor = T(pbJoy[1]?"move joystick 2 through its full range to calibrate":"joystick 2 is absent") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saJoy2CBF( tinS& tinP , etherC& etherP , windowOldC& wP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , sadamStateOldS& scratchStrokeP )/*1*/

}
    return 0 ;
    _OUT_
    if( tinP.fingerprint && etherP && wP.bDoomed && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchStrokeP.mIdColHot ) ;

    }
        }
            break ;
            *pTxtTutor = T(pbJoy[0]?"move joystick 1 through its full range to calibrate":"joystick 1 is absent") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saJoy1CBF( tinS& tinP , etherC& etherP , windowOldC& wP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , sadamStateOldS& scratchStrokeP )/*1*/

}
    return cFound ;
    }
        while( ~hWalk ) ;
        }
            if( vv == cP ) cFound ++ ;
            countT vv = stP.downF( tinP , hWalk ) ;
        {
        do
        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stP )
    ZE( boolT , cFound ) ;
{
boolT cFoundF( tinS& tinP , stackC& stP , const countT cP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doGraftF( tinP , etherP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("'g' then arrow to \"graft\"  a copy of the top branch of the clone stack") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_gCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY      : { doStrokingF( tinP , etherP , idTypeCallP , pcNotesP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_KEYBOARD    :
        case ifcIDtYPEsTROKEcALLbACK_TABlEAVING  :
        case ifcIDtYPEsTROKEcALLbACK_TABaRRIVING :
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER     : { *pTxtTutor = T("to stroke the tree, tab to me, then key text") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_strokeCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doPlusF( tinP , etherP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("\"push clone\": pushes a clone to the clone stack") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_plusCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doMinusF( tinP , etherP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("\"pop clone\": discards the top clone on the clone stack") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_minusCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP && etherP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doNumericToggleF( tinP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("interpreting bigit keys as ")+T(bNumericEntry?"bigits":"alphabetics") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_mCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP && etherP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doToolTestToggleF( tinP , *thirdC::pWinRootIF() ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("toggle between normal display and tool test (keyboard mouse joystick)") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_kCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP && etherP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doHomeF( tinP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("climb right to youngest idea") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_homeOld20190809CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY      : { doFindF( tinP , etherP , idTypeCallP , pcNotesP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_KEYBOARD    :
        case ifcIDtYPEsTROKEcALLbACK_TABlEAVING  :
        case ifcIDtYPEsTROKEcALLbACK_TABaRRIVING :
        case ifcIDtYPEsTROKEcALLbACK_MOUSE       : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER     : { *pTxtTutor = T("to find text, tab to me, key text, then key Enter") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_findCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP && etherP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doEndF( tinP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("climb left to eldest idea") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_endCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY      : { doClimbF( tinP , etherP , idTypeCallP , pcNotesP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_KEYBOARD    :
        case ifcIDtYPEsTROKEcALLbACK_TABlEAVING  :
        case ifcIDtYPEsTROKEcALLbACK_TABaRRIVING :
        case ifcIDtYPEsTROKEcALLbACK_MOUSE       : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER     : { *pTxtTutor = T("tab to me; press arrow keys to climb the tree") ; break ; } //U:: LATER: *pTxtTutor = T("press bigit key to select climber: numeric key or 'a'-'f'") ;
    {
    switch( idTypeCallP )
{
voidT tcButton_climbCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP && etherP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doArrowOutF( tinP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("climb out to the next facet") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_arrowOutCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP && etherP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doArrowInF( tinP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("climb in to the preceding facet") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_arrowInCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doArrowRightF( tinP , etherP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        }
            break ;
            ) ;
    
                        : "climb right to the next idea"
                        ? "jump to the next branch found"
                    : bFind
                    ? "graft a new, null younger brother branch"
                bEntry
    
            *pTxtTutor = T(
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
{
voidT tcButton_arrowRightCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doArrowLeftF( tinP , etherP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        }
            break ;
            ) ;
    
                        : "climb left to the preceding idea"
                        ? "jump to the previous branch found"
                    : bFind
                    ? "graft a new, null elder brother branch"
                bEntry
    
            *pTxtTutor = T(
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
{
voidT tcButton_arrowLeftCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP && etherP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doArrowDownF( tinP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        }
            break ;
            ) ;
    
                        : "climb down out of detail"
                        ? "jump to the next branch found"
                    : bFind
                    ? "climb down out of detail"
                bEntry
            *pTxtTutor = T(
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
{
voidT tcButton_arrowDownCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doArrowUpF( tinP , etherP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        }
            break ;
            ) ;
    
                        : "climb up into detail"
                        ? "jump to the previous branch found"
                    : bFind
                    ? "graft a new, null kid branch"
                bEntry
    
            *pTxtTutor = T(
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
{
voidT tcButton_arrowUpCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { etherP.osThreadF( TaRG1( tmFlushStateF ) ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("save my state and reload to verify saved ok") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_zCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { etherP.beeClickF( tinP , TUCK ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("this animation indicator should move at a constant rate") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_wheelCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doWriteFileF( tinP , etherP , *thirdC::pWinRootIF() ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("\"write\": create an ideafarm.kt.anyname file") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_wCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { etherP.beeClickF( tinP , TUCK ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("mouse") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_toolMouseCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { etherP.beeClickF( tinP , TUCK ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("joystick 2: ")+T(pbJoy[1]?"move through full range to calibrate":"not plugged in") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_toolJoy2CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { etherP.beeClickF( tinP , TUCK ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("joystick 1: ")+T(pbJoy[0]?"move through full range to calibrate":"not plugged in") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_toolJoy1CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { etherP.beeClickF( tinP , TUCK ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        }
            break ;
            etherP.delF( tinP , psttw ) ;
            *pTxtTutor = T("")+S3(8.0,scOld_mmFRAMEtO,1.0)+sttw+T(": ")+T(psttw)+S2(0,scOld_POPfRAME) ;
            strokeS sttw = strokeS::strokeIF( tinP , cArgP ) ;
            else                      { etherP.strMakeF(               tinP , psttw , T(postw) ) ; ___( psttw ) ; }
            if( postw && postw[ 1 ] ) { etherP.strConvertToOtherCaseF( tinP , psttw , T(postw) ) ; ___( psttw ) ; }
            ZE( strokeS* , psttw ) ;
            const osTextT* postw = processGlobal3I.mapTool(cArgP) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
{
voidT tcButton_toolCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP && etherP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doSayHintF( tinP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T(bToolTest?"click me for a suggestion (keying 't' won't work!)":"click me or key 't' for a suggestion") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_tCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP && etherP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doHollywoodNewF( tinP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("\"new squares\": display ni branches using tcButtonC") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_newSCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP && etherP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doHollywoodF( tinP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("\"squares\": display ni branches") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_sCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP && etherP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { doPruneF( tinP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("\"prune\": discards this branch") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_pCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY : { doCloseSessionF( tinP , etherP , *thirdC::pWinRootIF() , 1 ) ; break ; }
        }
            break ;
            )
                F(flTcStateNewP) & flTCsTATE_DOWN
                ||
                ( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT && idTool != ifcIDtYPEtOOL_MOUSEpOSITION )
            (
            if

            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("display the base operating system") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_oCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { etherP.beeClickF( tinP , TUCK ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T(pbJoy[1]?"move joystick 2 through its full range to calibrate":"joystick 2 is absent") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_joy2CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { etherP.beeClickF( tinP , TUCK ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T(pbJoy[0]?"move joystick 1 through its full range to calibrate":"joystick 1 is absent") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_joy1CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY : {  doInviteF( tinP , etherP , *thirdC::pWinRootIF() ) ; break ; }
        }
            break ;
            )
                F(flTcStateNewP) & flTCsTATE_DOWN
                ||
                ( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT && idTool != ifcIDtYPEtOOL_MOUSEpOSITION )
            (
            if

            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            ;
        
                T(" contact information")
                *pTxtLogo+
                T("press the 'I' key for ")+
        
            *pTxtTutor = 
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
{
voidT tcButton_iCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )


}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP && etherP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { static countT idInLath ; countT idIn = 1 + incv02AM( idInLath ) ; etherP.beeClickF( tinP , TUCK * idIn , TOCK ) ; doHugeF( tinP ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("\"huge\": display wo branch") ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_hCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    }
        _OUT_
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_KEY_w ;
        writeF( tinP , etherP , T("///desk/")+tShort , *pTree ) ;
    
        //}
        //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
        //
        //    //LOGrAW( "------------------------- END ------------------------\r\n" ) ;
        //    etherP.beeClickF( tinP , TOCK * 0x20 ) ;
        //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_DISABLE ) ;
        //
        //    while( cToDo -- ) writeF( tinP , etherP , T("///desk/")+tShort , *pTree ) ;
        //    countT cToDo = 0x1 ;
        //    
        //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_ENABLE ) ;
        //    etherP.beeClickF( tinP , TOCK * 0x20 ) ;
        //    //LOGrAW( "------------------------- BEGIN ------------------------\r\n" ) ;
        //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
        //{
        //USE TO STUDY WHERE WHILE WRITING FILE
    
        TN( tShort , "ideafarm.kt.append.any.name.here" ) ;
        doCloseSessionF( tinP , etherP , wP , 1 ) ;
        _INoLD_
    {
    if( !bToolTest && !bToolTestHire )
{
voidT doWriteFileF( tinS& tinP , etherC& etherP , windowOldC& wP )

}
    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
    *pStkActionMemory << (countT)IDoP_KEY_k ;

    wP.baton.ungrabF( tinP ) ;

    }
        *pTxtTutor = T("tool test display") ;
        doHugeF( tinP ) ;
        idTypeDisplaySave = idTypeDisplay ;
        bToolTestHire = 1 ;
    {
    else
    }
        *pTxtTools = *pTxtToolsMemory = T("") ;
        *pTxtTutor = T("normal display") ;
        }
            case ifcIDtYPEdISPLAY_HOLLYWOODnEW : { doHollywoodNewF( tinP ) ; break ; }
            case ifcIDtYPEdISPLAY_HOLLYWOOD    : { doHollywoodF( tinP ) ; break ; }
            case ifcIDtYPEdISPLAY_HUGE         : { doHugeF( tinP ) ; break ; }
        {
        switch( idTypeDisplaySave )
        bToolTest = 0 ;
    {
    if( bToolTest )

    wP.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;

    static countT idTypeDisplaySave ;
{
voidT doToolTestToggleF( tinS& tinP , windowOldC& wP )

}
    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
    *pStkActionMemory << (countT)IDoP_KEY_t ;

    else *pTxtTutor = T("press arrow keys to climb the knowledge tree") ;
    }
        else             *pTxtTutor = T("press arrow keys or backspace key") ;
        if( !*pStkFind ) *pTxtTutor = T("tab to climb, or enter text, or press Enter key to search") ;
    {
    else if( bFind )
    else if( bEntry ) *pTxtTutor = T("tab to climb, or enter text, or press arrow key to creat new branch") ;
    if( bToolTest || bToolTestHire ) *pTxtTutor = T("mouse click 'k' to return to the normal display (pressing 'k' key won't work!)") ;
{
voidT doSayHintF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_KEY_p ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->delF( tinP ) ;

        }
            while( ~hWalk ) ;
            }
                }
                    break ;
                    pStkFind->extractF( 0 , tinP , 0 ) ;
                {
                if( hEnv.osF( ifcIDtYPEhANDLE_TREEwALK ) == (countT)pHdrDoomed )
                handleC& hEnv = *(handleC*)&pStkFind->downF( tinP , hWalk ) ;
            {
            do
            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            branchHeaderOldS* pHdrDoomed = (branchHeaderOldS*)(branchDataOldS*)*pTree - 1 ;
        {
        if( *pStkFind )

        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT doPruneF( tinS& tinP )

}
    }
        }
            pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
            *pStkActionMemory << (countT)IDoP_PLUS ;
            incv02AM( cRequestFresh ) ;
            *pStkClone << psClone ;
            pBatonTree->ungrabF( tinP ) ;
            pTree->writeF( tinP , *psClone ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( psClone )
        etherP( tinP , psClone , TAG( TAGiDnULL ) ) ;
        ZE( soulC* , psClone ) ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT doPlusF( tinS& tinP , etherC& etherP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_KEY_m ;
        *pTxtTutor = T(bNumericEntry?"numeric":"alphabetic")+T(" interpretation of digit keys and keys 'a'-'f'") ;
        bNumericEntry = !bNumericEntry ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT doNumericToggleF( tinS& tinP )

}
    }
        pStkClone->ungrabF( tinP ) ;
        }
            pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
            *pStkActionMemory << (countT)IDoP_MINUS ;
            incv02AM( cRequestFresh ) ;
            etherP( tinP , psClone ) ;
            *pStkClone >> psClone ;
            ZE( soulC* , psClone ) ;
        {
        if( *pStkClone )
        pStkClone->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT doMinusF( tinS& tinP , etherC& etherP )

}
    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
    *pStkActionMemory << (countT)IDoP_KEY_i ;
    POPUPiNVITE
    //DOES NOT WORK WHEN AM SERVICE: etherP.osHttpViewF( tinP , T("www.ideafarm.com//http/id15.html") , 1 ) ;
    ((thirdC&)etherP).winShowWindowF( tinP , wP , idcWINsHOW_HIDE ) ;
{
voidT doInviteF( tinS& tinP , etherC& etherP , windowOldC& wP )

}
    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
    *pStkActionMemory << (countT)IDoP_KEY_h ;
    incv02AM( cRequestFresh ) ;
    pBatonTree->ungrabF( tinP ) ;
    bStateHasChanged = 1 ;
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    idTypeDisplay = ifcIDtYPEdISPLAY_HUGE ;
{
voidT doHugeF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_HOME ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        while( pTree->rightF( tinP ) ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bRightOk )
    if( bToolTest || bToolTestHire ) ;
{
voidT doHomeF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_KEY_s ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        idTypeDisplay = ifcIDtYPEdISPLAY_HOLLYWOODnEW ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT doHollywoodNewF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_KEY_s ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        idTypeDisplay = ifcIDtYPEdISPLAY_HOLLYWOOD ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT doHollywoodF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_KEY_g ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        if( !bDownOk ) doArrowUpF( tinP , etherP ) ;
        bGraft = 1 ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT doGraftF( tinS& tinP , etherC& etherP )

}
    }
        pBatonTree->ungrabF( tinP ) ;
        }
            pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
            *pStkActionMemory << (countT)IDoP_KEY_z ;
        
            *pTxtTutor = T("done") ;
            incv02AM( cRequestFresh ) ;
            readStateF( tinP , etherP , *pTree ) ;
            pTree->delF( tinP ) ;
            pStkFind->purgeF( tinP ) ;
            while( pTree->downF( tinP ) ) ;
            //U::ELIMINATE THE READ, AND INSTEAD JUST RESTORE MY DIRECTIONS
            //THIS BLOCK TAKES TIME AND CAN BE ELIMINATED WHEN HAVE CONFIDENCE IN writeStateF
        
            *pTxtTutor = T("reloading from my newly written state file...") ;
            writeStateF( tinP , etherP , *pTree ) ;
            *pTxtTutor = T("writing my state...") ;
        {
        if( bStateHasChanged )
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT doFlushStateF( tinS& tinP , etherC& etherP )

}
    }
        }
            break ;
            }
                }
                    }
                        }
                            break ;
    
                            }
                                }
                                    incv02AM( cRequestFresh ) ;
                                    *pTxtTutor = T("find: \"")+*pTxtFind+T("\"") ;
                                    *pTxtFind += T(psttn) ;
                                {
                                if( psttn[ CSpREFIX ].idAdam )
        
                                else           psttn[ CSpREFIX ] = S2( vv | sscDIGIT | SDBITS( 4 ) , sc_cALPHABET1 ) ;
                                if( !bUse_vv ) psttn[ CSpREFIX ] = strokeS::strokeIF( tinP , idTool ) ;
        
                                }
                                    }
                                        break ;
                                        bUse_vv = 1 ;
                                        vv = 0xa + idTool - ifcIDtYPEtOOL_a ;
                                    {
                                    case ifcIDtYPEtOOL_f :
                                    case ifcIDtYPEtOOL_e :
                                    case ifcIDtYPEtOOL_d :
                                    case ifcIDtYPEtOOL_c :
                                    case ifcIDtYPEtOOL_b :
                                    case ifcIDtYPEtOOL_a :
                                    }
                                        break ;
                                        bUse_vv = 1 ;
                                        vv = idTool - ifcIDtYPEtOOL_PAD0 ;
                                    {
                                    case ifcIDtYPEtOOL_PAD9 :
                                    case ifcIDtYPEtOOL_PAD8 :
                                    case ifcIDtYPEtOOL_PAD7 :
                                    case ifcIDtYPEtOOL_PAD6 :
                                    case ifcIDtYPEtOOL_PAD5 :
                                    case ifcIDtYPEtOOL_PAD4 :
                                    case ifcIDtYPEtOOL_PAD3 :
                                    case ifcIDtYPEtOOL_PAD2 :
                                    case ifcIDtYPEtOOL_PAD1 :
                                    }
                                        break ;
                                        bUse_vv = 1 ;
                                        vv = idTool - ifcIDtYPEtOOL_0 ;
                                    {
                                    case ifcIDtYPEtOOL_9 :
                                    case ifcIDtYPEtOOL_8 :
                                    case ifcIDtYPEtOOL_7 :
                                    case ifcIDtYPEtOOL_6 :
                                    case ifcIDtYPEtOOL_5 :
                                    case ifcIDtYPEtOOL_4 :
                                    case ifcIDtYPEtOOL_3 :
                                    case ifcIDtYPEtOOL_2 :
                                    case ifcIDtYPEtOOL_1 :
                                {
                                if( bNumericEntry ) switch( idTool )
                                ZE( boolT , bUse_vv ) ;
                                ZE( countT , vv ) ;
                                SETpREFIX( psttn , 1 , 0 ) ;
                                strokeS psttn[ CSpREFIX + 1 ] ;
                            {
                            if( idTool < ifcIDtYPEtOOL_CONTROLbEGIN || idTool > ifcIDtYPEtOOL_CONTROLeND )
                        {
                        default :
                        }
                            break ;
    
                            }
                                incv02AM( cRequestFresh ) ;
    
                                }
                                    pTree->jumpF( tinP , *(handleC*)&(*pStkFind)[ 1 ] ) ;
                                {
                                if( *pStkFind )
                                //U::ORTHOGONALIZE: PROVIDE A SEPARATE BUTTON(S) TO WALK THE STACK OF FOUND BRANCHES
    
                                etherP.beeClickF( tinP ) ;
                                pTree->walkF( tinP , hWalk , etherP , countTC() , treeFindCBF , countTC() , flTREEwALK_null ) ;
                                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_TREEwALK ) ;
                                etherP.beeClickF( tinP ) ;
                                pStkFind->purgeF( tinP ) ; //U::ORTHOGONALIZE THIS BY PROVIDING A SEPARATE BUTTON TO CLEAR THE FIND LIST
                            {
                            if( pTxtFind->csF( tinP ) )
                        {
                        case ifcIDtYPEtOOL_ENTERnUM :
                        case ifcIDtYPEtOOL_ENTER :
                        }
                            break ;
    
                            incv02AM( cRequestFresh ) ;
                            etherP.delF( tinP , psttw ) ;
                            *pTxtTutor = T("find: \"")+*pTxtFind+T("\"") ;
                            *pTxtFind = T(psttw) ;
    
                            }
                                etherP.strTrimF( tinP , psttw , 0 , T(TbLACKnEWlINE) ) ; ___( psttw ) ;
                                etherP.strSubstringF( tinP , psttw , idf , idl , *pTxtFind ) ; ___( psttw ) ;
                                countT idl = csOld - 1 ;
                                countT idf = 1 ;
                            {
                            else
                            if( csOld == 1 ) { etherP.strMakeF( tinP , psttw , T("") ) ; ___( psttw ) ; }
                            countT csOld = pTxtFind->csF( tinP ) ;
                            ZE( strokeS* , psttw ) ;
                        {
                        case ifcIDtYPEtOOL_BACKSPACE :
                    {
                    switch( idTool )
                {
                if( idAction == ifcIDtYPEaCTION_DOWN )
            {
            if( idTypeCallP == ifcIDtYPEsTROKEcALLbACK_KEYBOARD || idTool == ifcIDtYPEtOOL_MOUSEbUTTONlEFT )
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            incv02AM( cRequestFresh ) ;
            bFind = 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_TABlEAVING :
        }
            break ;
            }
                incv02AM( cEntryArrivals ) ;
                incv02AM( cRequestFresh ) ;
                bFind = 1 ;
            {
            if( tinP.monitor.idThread != idThreadRefresh ) //I WANT TO DO THIS ONLY IN RESPONSE TO A KEYSTROKE
        {
        case ifcIDtYPEsTROKEcALLbACK_TABaRRIVING :
    {
    switch( idTypeCallP )
{
voidT doFindF( tinS& tinP , etherC& etherP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP )

}
    }
        }
            break ;
            }
                }
                    }
                        }
                            break ;
                            }
                                }
                                    pBatonTree->ungrabF( tinP ) ;
                                    pTree->ungrabF( tinP ) ;
                                    }
                                        incv02AM( cRequestFresh ) ;
                                        bStateHasChanged = 1 ;
                                        pData->psttb = psttw ; psttw = 0 ;
                                        etherP.delF( tinP , pData->psttb ) ;
                                        etherP.strFuseF( tinP , psttw , psttn[ CSpREFIX ] ) ;
                                        etherP.strMakeF( tinP , psttw , pData->psttb , 1 ) ; ___( psttw ) ;
                                        ZE( strokeS* , psttw ) ;
                                    {
                                    if( pData )
                                    
                                    }
                                        etherP( tinP , psClone ) ;
                                        }
                                            pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
                                            *pStkActionMemory << (countT)IDoP_STROKEeNTRY ;
                                            incv02AM( cRequestFresh ) ;
                                            bStateHasChanged = 1 ;
                                            pTree->rightF( tinP ) ;
                                            pTree->upF( tinP ) ;
                                            pTree->readF( tinP , *psClone , *pEtPrime ) ;
                                            pTree->downF( tinP ) ;
                                            
                                            pTree->writeF( tinP , *psClone , psttn ) ;
                                        {
                                        if( psClone )
                                        etherP( tinP , psClone , TAG( TAGiDnULL ) ) ;
                                        ZE( soulC* , psClone ) ;
                                    {
                                    if( !pData )
                                    branchDataOldS* pData = *pTree ;
                                    pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                                    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                                {
                                if( psttn[ CSpREFIX ].idAdam )
        
                                else           psttn[ CSpREFIX ] = S2( vv | sscDIGIT | SDBITS( 4 ) , sc_cALPHABET1 ) ;
                                if( !bUse_vv ) psttn[ CSpREFIX ] = strokeS::strokeIF( tinP , idTool ) ;
        
                                }
                                    }
                                        break ;
                                        bUse_vv = 1 ;
                                        vv = 0xa + idTool - ifcIDtYPEtOOL_a ;
                                    {
                                    case ifcIDtYPEtOOL_f :
                                    case ifcIDtYPEtOOL_e :
                                    case ifcIDtYPEtOOL_d :
                                    case ifcIDtYPEtOOL_c :
                                    case ifcIDtYPEtOOL_b :
                                    case ifcIDtYPEtOOL_a :
                                    }
                                        break ;
                                        bUse_vv = 1 ;
                                        vv = idTool - ifcIDtYPEtOOL_PAD0 ;
                                    {
                                    case ifcIDtYPEtOOL_PAD9 :
                                    case ifcIDtYPEtOOL_PAD8 :
                                    case ifcIDtYPEtOOL_PAD7 :
                                    case ifcIDtYPEtOOL_PAD6 :
                                    case ifcIDtYPEtOOL_PAD5 :
                                    case ifcIDtYPEtOOL_PAD4 :
                                    case ifcIDtYPEtOOL_PAD3 :
                                    case ifcIDtYPEtOOL_PAD2 :
                                    case ifcIDtYPEtOOL_PAD1 :
                                    }
                                        break ;
                                        bUse_vv = 1 ;
                                        vv = idTool - ifcIDtYPEtOOL_0 ;
                                    {
                                    case ifcIDtYPEtOOL_9 :
                                    case ifcIDtYPEtOOL_8 :
                                    case ifcIDtYPEtOOL_7 :
                                    case ifcIDtYPEtOOL_6 :
                                    case ifcIDtYPEtOOL_5 :
                                    case ifcIDtYPEtOOL_4 :
                                    case ifcIDtYPEtOOL_3 :
                                    case ifcIDtYPEtOOL_2 :
                                    case ifcIDtYPEtOOL_1 :
                                {
                                if( bNumericEntry ) switch( idTool )
                                ZE( boolT , bUse_vv ) ;
                                ZE( countT , vv ) ;
                                SETpREFIX( psttn , 1 , 0 ) ;
                                strokeS psttn[ CSpREFIX + 1 ] ;
                            {
                            if( idTool < ifcIDtYPEtOOL_CONTROLbEGIN || idTool > ifcIDtYPEtOOL_CONTROLeND )
                        {
                        default :
                        }
                            break ;
                            pBatonTree->ungrabF( tinP ) ;
                            pTree->ungrabF( tinP ) ;
                            }
                                incv02AM( cRequestFresh ) ;
                                bStateHasChanged = 1 ;
                                pData->psttb = psttw ; psttw = 0 ;
                                etherP.delF( tinP , pData->psttb ) ;
                                }
                                    etherP.strSubstringF( tinP , psttw , idf , idl , pData->psttb ) ; ___( psttw ) ;
                                    countT idl = pData->psttb->idAdam - 1 ;
                                    countT idf = 1 ;
                                {
                                else
                                if( pData->psttb->idAdam == 1 ) etherP.strMakeF( tinP , psttw , T("") ) ;
                                ZE( strokeS* , psttw ) ;
                            {
                            if( pData && pData->psttb && pData->psttb->idAdam )
                            branchDataOldS* pData = *pTree ;
                            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        case ifcIDtYPEtOOL_BACKSPACE :
                    {
                    switch( idTool )
                {
                if( idAction == ifcIDtYPEaCTION_DOWN )
            {
            if( idTypeCallP == ifcIDtYPEsTROKEcALLbACK_KEYBOARD || idTool == ifcIDtYPEtOOL_MOUSEbUTTONlEFT )
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            incv02AM( cRequestFresh ) ;
            bEntry = 0 ;
            pBatonTree->ungrabF( tinP ) ;
            pTree->ungrabF( tinP ) ;
            }
                bStateHasChanged = 1 ;
                pTree->delF( tinP ) ;

                }
                    while( ~hWalk ) ;
                    }
                        }
                            break ;
                            pStkFind->extractF( 0 , tinP , 0 ) ;
                        {
                        if( hEnv.osF( ifcIDtYPEhANDLE_TREEwALK ) == (countT)pHdrDoomed )
                        handleC& hEnv = *(handleC*)&pStkFind->downF( tinP , hWalk ) ;
                    {
                    do
                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    branchHeaderOldS* pHdrDoomed = (branchHeaderOldS*)pData - 1 ;
                {
                if( *pStkFind )
            {
            if( pData && pData->psttb && !pData->psttb->idAdam )
            branchDataOldS* pData = *pTree ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_TABlEAVING :
        }
            break ;
            }
                incv02AM( cEntryArrivals ) ;
                incv02AM( cRequestFresh ) ;
                bEntry = 1 ;
            {
            if( tinP.monitor.idThread != idThreadRefresh ) //I WANT TO DO THIS ONLY IN RESPONSE TO A KEYSTROKE
        {
        case ifcIDtYPEsTROKEcALLbACK_TABaRRIVING :
    {
    switch( idTypeCallP )
{
voidT doStrokingF( tinS& tinP , etherC& etherP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP )

voidT treeFindCBF( tinS& tinP , etherC& etherP , const countT idTypeP , const flagsT flagsP , const handleC& handleP , byteT* pbP , countT cbP , countT& cArgP ) ;

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_END ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        while( pTree->leftF( tinP ) ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bLeftOk )
    if( bToolTest || bToolTestHire ) ;
{
voidT doEndF( tinS& tinP )

}
    etherP.osThreadF( TaRG1( tmFlushStateF ) ) ;
    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
    *pStkActionMemory << (countT)IDoP_KEY_o ;

    }
        }
            }
                etherP.boxPutF( tinP , TmESSAGEtIMElATHfILE , (byteT*)&timeLath , sizeof timeLath ) ;
                timeLath.time2 = timeN2 ;
                timeLath.time1 = timeN1 ;

                POPUPiNVITE                    
                //DOES NOT WORK WHEN AM SERVICE: etherP.osHttpViewF( tinP , T("www.ideafarm.com//http/id15.html") , 1 ) ;
            {
            if( timeD2 >= 8 )
                    
            etherP.osTimeSubtractF( tinP , timeD1 , timeD2 , timeLath.time1 , timeLath.time2 ) ;
            sCountT timeD2 = timeN2 ;
            countT  timeD1 = timeN1 ;
                    
            etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
                    
            }
                etherP.delF( tinP , pbTimeLath ) ;
                else if( cbTimeLath == sizeof timeLath ) etherP.memCopyF( tinP , (byteT*)&timeLath , pbTimeLath , sizeof timeLath ) ;
                if( POOP ) POOPR
                tinP.pEtScratch->boxGetShadowF( tinP , pbTimeLath , cbTimeLath , TmESSAGEtIMElATHfILE , 1 ) ; ___( pbTimeLath ) ; //U::A soulC SHOULD BE USED TO STORE THIS TIME ON DISK, SO WILL WORK ON EITHER ENDIAN BASE O.S.'S
                ZE( countT , cbTimeLath ) ;
                ZE( byteT* , pbTimeLath ) ;
                    
                SCOOPS
            {
            timeS timeLath ;
        {
        IFsCRATCH
            
        etherP.osTimeAddF( tinP , timeSessionTotal1 , timeSessionTotal2 , timeSessionEnd1 , timeSessionEnd2 ) ;
        etherP.osTimeSubtractF( tinP , timeSessionEnd1 , timeSessionEnd2 , timeSessionStart1 , timeSessionStart2 ) ;
        etherP.osTimeNowF( tinP , timeSessionEnd1 , timeSessionEnd2 ) ;
        ZE( sCountT , timeSessionEnd2 ) ;
        ZE( countT  , timeSessionEnd1 ) ;
    
        bInSession = 0 ;
    {
    else if( !bContinueSessionP )
    if( bSuppressSessionEnd ) bSuppressSessionEnd = 0 ;

{
voidT doCloseSessionF( tinS& tinP , etherC& etherP , windowOldC& wP , const boolT bContinueSessionP = 0 )

TASK0PROTO( tmFlushStateF ) ;

}
    }
        }
            break ;
            }
                break ;
                }
                    }
                        //#endif
                        }
                            break ;
                            //incv02AM( cRequestFresh ) ;
                            //idCursor = 0xa + idTool - ifcIDtYPEtOOL_a ;
                            //sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
                        {
                        case ifcIDtYPEtOOL_f :
                        case ifcIDtYPEtOOL_e :
                        case ifcIDtYPEtOOL_d :
                        case ifcIDtYPEtOOL_c :
                        case ifcIDtYPEtOOL_b :
                        case ifcIDtYPEtOOL_a :
                        }
                            break ;
                            //incv02AM( cRequestFresh ) ;
                            //idCursor = idTool - ifcIDtYPEtOOL_PAD0 ;
                            //sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
                        {
                        case ifcIDtYPEtOOL_PAD9 :
                        case ifcIDtYPEtOOL_PAD8 :
                        case ifcIDtYPEtOOL_PAD7 :
                        case ifcIDtYPEtOOL_PAD6 :
                        case ifcIDtYPEtOOL_PAD5 :
                        case ifcIDtYPEtOOL_PAD4 :
                        case ifcIDtYPEtOOL_PAD3 :
                        case ifcIDtYPEtOOL_PAD2 :
                        case ifcIDtYPEtOOL_PAD1 :
                        }
                            break ;
                            //incv02AM( cRequestFresh ) ;
                            //idCursor = idTool - ifcIDtYPEtOOL_0 ;
                            //sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
                            //DO NOT ENABLE THIS UNTIL THIS MODULE IS REWRITTEN
                            //U::ENABLE AFTER THOROUGH TESTING INCL SAVE AND RESTORE TO/FROM STATE FILE
                        {
                        case ifcIDtYPEtOOL_9 :
                        case ifcIDtYPEtOOL_8 :
                        case ifcIDtYPEtOOL_7 :
                        case ifcIDtYPEtOOL_6 :
                        case ifcIDtYPEtOOL_5 :
                        case ifcIDtYPEtOOL_4 :
                        case ifcIDtYPEtOOL_3 :
                        case ifcIDtYPEtOOL_2 :
                        case ifcIDtYPEtOOL_1 :
                        }
                            break ;
                            }
                                incv02AM( cRequestFresh ) ;
                                etherC::etherFireImpersonateMonitorIF( tinP ) ;
                            {
                            if( IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 == etherP.diskIdF( tinP , T("///c") ) )
                            etherP.beeClickF( tinP ) ; //U::
                        {
                        case ifcIDtYPEtOOL_q :
                    {
                    switch( idTool )
        
                    }
                        //LOGrAW( T("\r\n") ) ;
                        //if( !( state & 0x80000000 ) ) { LOGrAW( T(" (no vk value matches)") ) ; }
        
                        }
                            }
                                break ;
                                //LOGrAW( T(" (found correct state by trying vk value ")+TF1(vki)+T(")") ) ;
                            {
                            if( state & 0x80000000 )
                            state = tinP.brcRaw ;
                            BOSdOnOTtEST( WHATgbo , GetKeyState( vki ) )
            
                            if( vki == 0x10 || vki == 0xa0 ) continue ;
                        {
                        if( !( state & 0x80000000 ) ) for( countT vki = 0 ; vki <= 0xff ; vki ++ )
        
                        }
                            }
                                break ;
                                }
                                    //if( state & 0x80000000 ) { LOGrAW( T(" (found correct state using table)") ) }
                                    state = tinP.brcRaw ;
                                    BOSdOnOTtEST( WHATgbo , GetKeyState( vk ) )
                                    //LOGrAW( T(" (in table)") )
                                {
                                if( vk )
                                vk = pVkTool[ off ].vk ;
                            {
                            if( pVkTool[ off ].id == idTool )
                        {
                        for( countT off = 0 ; off < sizeof pVkTool / sizeof pVkTool[ 0 ] ; off ++ )
                        ZE( countT , state ) ;
                        ZE( countT , vk ) ;
                    {
                    if( idAction == ifcIDtYPEaCTION_DOWN && !bToolTest && !bToolTestHire )
                {
                if( idTypeCallP == ifcIDtYPEsTROKEcALLbACK_KEYBOARD || idTool == ifcIDtYPEtOOL_MOUSEbUTTONlEFT )
            
                const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
                const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
            {
            if( !bToolTest && !bToolTestHire && pcNotesP )
        {
        default :
        }
            break ;
        {
        case ifcIDtYPEsTROKEcALLbACK_TABaRRIVING :
        case ifcIDtYPEsTROKEcALLbACK_TABlEAVING :
    {
    switch( idTypeCallP )
{
voidT doClimbF( tinS& tinP , etherC& etherP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_OUTaRROW ;

        }
            default                            : { incv02AM( cRequestFresh )                             ; break ; }
            case ifcIDtYPEdISPLAY_HOLLYWOODnEW : { tHollywoodSetF( tinP , *pTree , *pDrawerHollywood ) ; break ; }
        {
        switch( idTypeDisplay )

        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->outF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bOutOk )
    if( bToolTest || bToolTestHire ) ;
{
voidT doArrowOutF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_INaRROW ;

        }
            default                            : { incv02AM( cRequestFresh )                             ; break ; }
            case ifcIDtYPEdISPLAY_HOLLYWOODnEW : { tHollywoodSetF( tinP , *pTree , *pDrawerHollywood ) ; break ; }
        {
        switch( idTypeDisplay )

        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->inF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bInOk )
    if( bToolTest || bToolTestHire ) ;
{
voidT doArrowInF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_RIGHTaRROW ;

        }
            default                            : { incv02AM( cRequestFresh )                             ; break ; }
            case ifcIDtYPEdISPLAY_HOLLYWOODnEW : { tHollywoodSetF( tinP , *pTree , *pDrawerHollywood ) ; break ; }
        {
        switch( idTypeDisplay )

        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->rightF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bRightOk )
    }
        }
            pBatonTree->ungrabF( tinP ) ;
            pTree->ungrabF( tinP ) ;
            }
                etherP( tinP , psClone ) ;
                }
                    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
                    *pStkActionMemory << (countT)IDoP_RIGHTaRROW ;
                    incv02AM( cRequestFresh ) ;
                    bStateHasChanged = 1 ;
                    pTree->upF( tinP ) ;
                    pTree->readF( tinP , *psClone , *pEtPrime ) ;
                    pTree->downF( tinP ) ;
                                
                    pTree->writeF( tinP , *psClone , T("") ) ;
                {
                if( psClone )
                etherP( tinP , psClone , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psClone ) ;
            {
            if( pData )
            branchDataOldS* pData = *pTree ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( bHaveStrokes )
    {
    else if( bEntry )
    }
        pStkClone->ungrabF( tinP ) ;
        }
            incv02AM( cRequestFresh ) ;
            pBatonTree->ungrabF( tinP ) ;
            bStateHasChanged = 1 ;
            pTree->ungrabF( tinP ) ;
            pTree->upF( tinP ) ;
            pTree->readF( tinP , sClone , *pEtPrime ) ;
            pTree->downF( tinP ) ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            soulC& sClone = *(soulC*)(*pStkClone)[ 1 ] ;
        {
        if( *pStkClone )
        pStkClone->grabF( tinP , TAG( TAGiDnULL ) ) ;
        bGraft = 0 ;
    {
    else if( bGraft )
    if( bToolTest || bToolTestHire ) ;
{
voidT doArrowRightF( tinS& tinP , etherC& etherP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_LEFTaRROW ;

        }
            default                            : { incv02AM( cRequestFresh )                             ; break ; }
            case ifcIDtYPEdISPLAY_HOLLYWOODnEW : { tHollywoodSetF( tinP , *pTree , *pDrawerHollywood ) ; break ; }
        {
        switch( idTypeDisplay )

        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->leftF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bLeftOk )
    }
        }
            pBatonTree->ungrabF( tinP ) ;
            pTree->ungrabF( tinP ) ;
            }
                etherP( tinP , psClone ) ;
                }
                    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
                    *pStkActionMemory << (countT)IDoP_RIGHTaRROW ;
                    incv02AM( cRequestFresh ) ;
                    bStateHasChanged = 1 ;
                    pTree->upF( tinP ) ;
                    pTree->readF( tinP , *psClone , *pEtPrime , 0 , 1 ) ;
                    pTree->downF( tinP ) ;
                                
                    pTree->writeF( tinP , *psClone , T("") ) ;
                {
                if( psClone )
                etherP( tinP , psClone , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psClone ) ;
            {
            if( pData )
            branchDataOldS* pData = *pTree ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( bHaveStrokes )
    {
    else if( bEntry )
    }
        pStkClone->ungrabF( tinP ) ;
        }
            incv02AM( cRequestFresh ) ;
            pBatonTree->ungrabF( tinP ) ;
            bStateHasChanged = 1 ;
            pTree->ungrabF( tinP ) ;
            pTree->upF( tinP ) ;
            pTree->readF( tinP , sClone , *pEtPrime , 0 , 1 ) ;
            pTree->downF( tinP ) ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            soulC& sClone = *(soulC*)(*pStkClone)[ 1 ] ;
        {
        if( *pStkClone )
        pStkClone->grabF( tinP , TAG( TAGiDnULL ) ) ;
        bGraft = 0 ;
    {
    else if( bGraft )
    if( bToolTest || bToolTestHire ) ;
{
voidT doArrowLeftF( tinS& tinP , etherC& etherP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_DOWNaRROW ;

        }
            default                            : { incv02AM( cRequestFresh )                             ; break ; }
            case ifcIDtYPEdISPLAY_HOLLYWOODnEW : { tHollywoodSetF( tinP , *pTree , *pDrawerHollywood ) ; break ; }
        {
        switch( idTypeDisplay )

        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->downF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bDownOk )
    else if( bToolTest || bToolTestHire ) ;
    }
        incv02AM( cRequestFresh ) ;
        pTree->jumpF( tinP , *(handleC*)&(*pStkFind)[ 0 ] ) ;
        pStkFind->downF( tinP ) ;
    {
    if( bFind )
{
voidT doArrowDownF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)IDoP_UPaRROW ;

        }
            default                            : { incv02AM( cRequestFresh )                             ; break ; }
            case ifcIDtYPEdISPLAY_HOLLYWOODnEW : { tHollywoodSetF( tinP , *pTree , *pDrawerHollywood ) ; break ; }
        {
        switch( idTypeDisplay )

        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->upF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bUpOk )
    }
        }
            pBatonTree->ungrabF( tinP ) ;
            pTree->ungrabF( tinP ) ;
            }
                etherP( tinP , psClone ) ;
                }
                    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
                    *pStkActionMemory << (countT)IDoP_UPaRROW ;
                    incv02AM( cRequestFresh ) ;
                    bStateHasChanged = 1 ;
                    pTree->rightF( tinP ) ;
                    pTree->upF( tinP ) ;
                    pTree->readF( tinP , *psClone , *pEtPrime ) ;
                                
                    pTree->writeF( tinP , *psClone , T("") ) ;
                {
                if( psClone )
                etherP( tinP , psClone , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psClone ) ;
            {
            if( pData )
            branchDataOldS* pData = *pTree ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( bHaveStrokes )
    {
    else if( bEntry )
    }
        pStkClone->ungrabF( tinP ) ;
        }
            incv02AM( cRequestFresh ) ;
            pBatonTree->ungrabF( tinP ) ;
            bStateHasChanged = 1 ;
            pTree->ungrabF( tinP ) ;
            pTree->upF( tinP ) ;
            pTree->readF( tinP , sClone , *pEtPrime ) ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            soulC& sClone = *(soulC*)(*pStkClone)[ 1 ] ;
        {
        if( *pStkClone )
        pStkClone->grabF( tinP , TAG( TAGiDnULL ) ) ;
        bGraft = 0 ;
    {
    else if( bGraft )
    else if( bToolTest || bToolTestHire ) ;
    }
        incv02AM( cRequestFresh ) ;
        pTree->jumpF( tinP , *(handleC*)&(*pStkFind)[ 0 ] ) ;
        pStkFind->upF( tinP ) ;
    {
    if( bFind )
{
voidT doArrowUpF( tinS& tinP , etherC& etherP )

voidT readStateF( tinS& tinP , etherC& etherP , treeOldC& treeP ) ;
voidT writeStateF( tinS& tinP , etherC& etherP , treeOldC& treeP ) ;

}
    etherP.strFuseF( tinP , psttP , drawerP.pstt3 ) ; ___( psttP ) ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonBro[ 1 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW7 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW6 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonBro[ 2 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW7 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW6 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonBro[ 0 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW7 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW6 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
    
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonMom[ 2 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW6 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW5 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonMom[ 0 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW6 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW5 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonMom[ 1 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW6 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW5 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
    
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonDad[ 2 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW5 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW4 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonDad[ 0 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW5 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW4 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonDad[ 1 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW5 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW4 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonGMom[ 2 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW4 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW3 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonGMom[ 0 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW4 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW3 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonGMom[ 1 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW4 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW3 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonGDad[ 2 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW3 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW2 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonGDad[ 0 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW3 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW2 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonGDad[ 1 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW3 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW2 ;
    *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
    
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonGGMom[ 2 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW2 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW1 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonGGMom[ 0 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW2 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW1 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;

    etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
    etherP.strFuseF( tinP , psttP , *(tcButtonC*)drawerP.ppbTcButtonGGMom[ 1 ] ) ;
    etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW2 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW1 ;
    *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;

    etherP.strFuseF( tinP , psttP , drawerP.pstt2 ) ;

    if( bUpOk ) etherP.strFuseF( tinP , psttP , drawerP.psttUpHint ) ;

    etherP.strFuseF( tinP , psttP , drawerP.psttHighBorder ) ; //GIVES TOP CENTER A YELLOW BORDER

    etherP.strFuseF( tinP , psttP , drawerP.pstt1 ) ;
{
voidT tHollywoodNewF( tinS& tinP , etherC& etherP , strokeS*& psttP , drawerHollywoodS& drawerP )

}
    }
        ((tcButtonC*)drawerP.ppbTcButtonBro[ 2 ])->setF( tinP , *pTxtNull ) ;
        ((tcButtonC*)drawerP.ppbTcButtonBro[ 1 ])->setF( tinP , *pTxtNull ) ;
        ((tcButtonC*)drawerP.ppbTcButtonBro[ 0 ])->setF( tinP , *pTxtNull ) ;
    {
    else
    }
        ((tcButtonC*)drawerP.ppbTcButtonBro[ 2 ])->setF( tinP , !bs.cUpBros || !bs.ppsttzUpBros[ 1 ] ? *pTxtNull : T(drawerP.psttSetPrefixMale)+T(bs.ppsttzUpBros[1])+T(drawerP.psttSetSuffix) ) ;
        ((tcButtonC*)drawerP.ppbTcButtonBro[ 1 ])->setF( tinP ,                !bs.ppsttzDnBros[ 0 ] ? *pTxtNull : T("")+T(drawerP.psttSetPrefixMale)+T(bs.ppsttzDnBros[0])+T(drawerP.psttSetSuffix) ) ;
        ((tcButtonC*)drawerP.ppbTcButtonBro[ 0 ])->setF( tinP , !bs.cDnBros || !bs.ppsttzDnBros[ 1 ] ? *pTxtNull : T(drawerP.psttSetPrefixMale)+T(bs.ppsttzDnBros[1])+T(drawerP.psttSetSuffix) ) ;
    {
    if( bs.ppsttzDnBros )

    }
        ((tcButtonC*)drawerP.ppbTcButtonMom[ 2 ])->setF( tinP , *pTxtNull ) ;
        ((tcButtonC*)drawerP.ppbTcButtonMom[ 1 ])->setF( tinP , *pTxtNull ) ;
        ((tcButtonC*)drawerP.ppbTcButtonMom[ 0 ])->setF( tinP , *pTxtNull ) ;
    {
    else
    }
        ((tcButtonC*)drawerP.ppbTcButtonMom[ 2 ])->setF( tinP , !bs.cUpMoms || !bs.ppsttzUpMoms[ 1 ] ? *pTxtNull : T(drawerP.psttSetPrefixFemale)+T(bs.ppsttzUpMoms[1])+T(drawerP.psttSetSuffix) ) ;
        ((tcButtonC*)drawerP.ppbTcButtonMom[ 1 ])->setF( tinP ,                !bs.ppsttzDnMoms[ 0 ] ? *pTxtNull : T(drawerP.psttSetPrefixFemale)+T(bs.ppsttzDnMoms[0])+T(drawerP.psttSetSuffix) ) ;
        ((tcButtonC*)drawerP.ppbTcButtonMom[ 0 ])->setF( tinP , !bs.cDnMoms || !bs.ppsttzDnMoms[ 1 ] ? *pTxtNull : T(drawerP.psttSetPrefixFemale)+T(bs.ppsttzDnMoms[1])+T(drawerP.psttSetSuffix) ) ;
    {
    if( bs.ppsttzDnMoms )

    }
        ((tcButtonC*)drawerP.ppbTcButtonDad[ 2 ])->setF( tinP , *pTxtNull ) ;
        ((tcButtonC*)drawerP.ppbTcButtonDad[ 1 ])->setF( tinP , *pTxtNull ) ;
        ((tcButtonC*)drawerP.ppbTcButtonDad[ 0 ])->setF( tinP , *pTxtNull ) ;
    {
    else
    }
        ((tcButtonC*)drawerP.ppbTcButtonDad[ 2 ])->setF( tinP , !bs.cUpDads || !bs.ppsttzUpDads[ 1 ] ? *pTxtNull : T(drawerP.psttSetPrefixMale)+T(bs.ppsttzUpDads[1])+T(drawerP.psttSetSuffix) ) ;
        ((tcButtonC*)drawerP.ppbTcButtonDad[ 1 ])->setF( tinP ,                !bs.ppsttzDnDads[ 0 ] ? *pTxtNull : T(drawerP.psttSetPrefixMale)+T(bs.ppsttzDnDads[0])+T(drawerP.psttSetSuffix) ) ;
        ((tcButtonC*)drawerP.ppbTcButtonDad[ 0 ])->setF( tinP , !bs.cDnDads || !bs.ppsttzDnDads[ 1 ] ? *pTxtNull : T(drawerP.psttSetPrefixMale)+T(bs.ppsttzDnDads[1])+T(drawerP.psttSetSuffix) ) ;
    {
    if( bs.ppsttzDnDads )

    }
        ((tcButtonC*)drawerP.ppbTcButtonGMom[ 2 ])->setF( tinP , *pTxtNull ) ;
        ((tcButtonC*)drawerP.ppbTcButtonGMom[ 1 ])->setF( tinP , *pTxtNull ) ;
        ((tcButtonC*)drawerP.ppbTcButtonGMom[ 0 ])->setF( tinP , *pTxtNull ) ;
    {
    else
    }
        ((tcButtonC*)drawerP.ppbTcButtonGMom[ 2 ])->setF( tinP , !bs.cUpGMoms || !bs.ppsttzUpGMoms[ 1 ] ? *pTxtNull : T(drawerP.psttSetPrefixFemale)+T(bs.ppsttzUpGMoms[1])+T(drawerP.psttSetSuffix) ) ;
        ((tcButtonC*)drawerP.ppbTcButtonGMom[ 1 ])->setF( tinP ,                 !bs.ppsttzDnGMoms[ 0 ] ? *pTxtNull : T(drawerP.psttSetPrefixFemale)+T(bs.ppsttzDnGMoms[0])+T(drawerP.psttSetSuffix) ) ;
        ((tcButtonC*)drawerP.ppbTcButtonGMom[ 0 ])->setF( tinP , !bs.cDnGMoms || !bs.ppsttzDnGMoms[ 1 ] ? *pTxtNull : T(drawerP.psttSetPrefixFemale)+T(bs.ppsttzDnGMoms[1])+T(drawerP.psttSetSuffix) ) ;
    {
    if( bs.ppsttzDnGMoms )

    }
        ((tcButtonC*)drawerP.ppbTcButtonGDad[ 2 ])->setF( tinP , *pTxtNull ) ;
        ((tcButtonC*)drawerP.ppbTcButtonGDad[ 1 ])->setF( tinP , *pTxtNull ) ;
        ((tcButtonC*)drawerP.ppbTcButtonGDad[ 0 ])->setF( tinP , *pTxtNull ) ;
    {
    else
    }
        ((tcButtonC*)drawerP.ppbTcButtonGDad[ 2 ])->setF( tinP , !bs.cUpGDads || !bs.ppsttzUpGDads[ 1 ] ? *pTxtNull : T(drawerP.psttSetPrefixMale)+T(bs.ppsttzUpGDads[1])+T(drawerP.psttSetSuffix) ) ;
        ((tcButtonC*)drawerP.ppbTcButtonGDad[ 1 ])->setF( tinP ,                 !bs.ppsttzDnGDads[ 0 ] ? *pTxtNull : T(drawerP.psttSetPrefixMale)+T(bs.ppsttzDnGDads[0])+T(drawerP.psttSetSuffix) ) ;
        ((tcButtonC*)drawerP.ppbTcButtonGDad[ 0 ])->setF( tinP , !bs.cDnGDads || !bs.ppsttzDnGDads[ 1 ] ? *pTxtNull : T(drawerP.psttSetPrefixMale)+T(bs.ppsttzDnGDads[1])+T(drawerP.psttSetSuffix) ) ;
    {
    if( bs.ppsttzDnGDads )

    }
        ((tcButtonC*)drawerP.ppbTcButtonGGMom[ 2 ])->setF( tinP , *pTxtNull ) ;
        ((tcButtonC*)drawerP.ppbTcButtonGGMom[ 1 ])->setF( tinP , *pTxtNull ) ;
        ((tcButtonC*)drawerP.ppbTcButtonGGMom[ 0 ])->setF( tinP , *pTxtNull ) ;
    {
    else
    }
        ((tcButtonC*)drawerP.ppbTcButtonGGMom[ 2 ])->setF( tinP , !bs.cUpGGMoms || !bs.ppsttzUpGGMoms[ 1 ] ? *pTxtNull : T(drawerP.psttSetPrefixFemale)+T(bs.ppsttzUpGGMoms[1])+T(drawerP.psttSetSuffix) ) ;
        ((tcButtonC*)drawerP.ppbTcButtonGGMom[ 1 ])->setF( tinP ,                  !bs.ppsttzDnGGMoms[ 0 ] ? *pTxtNull : T(drawerP.psttSetPrefixFemale)+T(bs.ppsttzDnGGMoms[0])+T(drawerP.psttSetSuffix) ) ;
        ((tcButtonC*)drawerP.ppbTcButtonGGMom[ 0 ])->setF( tinP , !bs.cDnGGMoms || !bs.ppsttzDnGGMoms[ 1 ] ? *pTxtNull : T(drawerP.psttSetPrefixFemale)+T(bs.ppsttzDnGGMoms[1])+T(drawerP.psttSetSuffix) ) ;
    {
    if( bs.ppsttzDnGGMoms ) //FEMALE VALUES CAN BE 0; MALE VALUES CANNOT

    pBatonTree->ungrabF( tinP ) ;
    treeP.nearbyF( tinP , bs ) ;
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    bs.cUpGKids = 1 ;
    bs.cDnGKids =
    bs.cUpKids =
    bs.cDnKids =
    bs.cUpWives =
    bs.cDnWives =
    bs.cUpBros =
    bs.cDnBros =
    bs.cUpMoms =
    bs.cDnMoms =
    bs.cUpDads =
    bs.cDnDads =
    bs.cUpGMoms =
    bs.cDnGMoms =
    bs.cUpGDads =
    bs.cDnGDads =
    bs.cUpGGMoms =
    bs.cDnGGMoms =
    branchesOldS bs ;
{
voidT tHollywoodSetF( tinS& tinP , treeOldC& treeP , drawerHollywoodS& drawerP )

}
    etherP.strFuseF( tinP , psttP , drawerP.pstt3 ) ; ___( psttP ) ;

    }
        etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
        etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW7 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW6 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        //THE PRECEDING COMMENT IS OBSOLETED BY ANIMATION CODE
        //BRO2 (MUST BE LATH RENDERED SO STROKE ENTRY CAN STROKE IMMEDIATE INTO MY AREA
    {
    else
    }
        etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
        etherP.strFuseF( tinP , psttP , bs.ppsttzDnBros[ 0 ] ) ;
        etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW7 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW6 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        //THE PRECEDING COMMENT IS OBSOLETED BY ANIMATION CODE
        //BRO2 (MUST BE LATH RENDERED SO STROKE ENTRY CAN STROKE IMMEDIATE INTO MY AREA

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzUpBros[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW7 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW6 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;
            //BRO3
        {
        if( bs.cUpBros   )
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnBros[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW7 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW6 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
            //BRO1
        {
        if( bs.cDnBros   )
    {
    if( bs.ppsttzDnBros  )
    
    }
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzUpMoms[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW6 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW5 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;
        {
        if( bs.cUpMoms && bs.ppsttzUpMoms[ 1 ] )
        //MOM3

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnMoms[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW6 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW5 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
        {
        if( bs.cDnMoms && bs.ppsttzDnMoms[ 1 ] )
        //MOM1

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnMoms[ 0 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW6 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW5 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        {
        if( bs.ppsttzDnMoms[ 0 ] )
        //MOM2
    {
    if( bs.ppsttzDnMoms )
    
    }
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzUpDads[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW5 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW4 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;
            //DAD3
        {
        if( bs.cUpDads   )
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnDads[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW5 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW4 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
            //DAD1
        {
        if( bs.cDnDads   )

        etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
        etherP.strFuseF( tinP , psttP , bs.ppsttzDnDads[ 0 ] ) ;
        etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW5 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW4 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        //DAD2
    {
    if( bs.ppsttzDnDads  )
    
    }
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzUpGMoms[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW4 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW3 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;
        {
        if( bs.cUpGMoms  && bs.ppsttzUpGMoms[ 1 ] )
        //GmOM3

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnGMoms[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW4 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW3 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
        {
        if( bs.cDnGMoms  && bs.ppsttzDnGMoms[ 1 ] )
        //GmOM1

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnGMoms[ 0 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW4 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW3 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        {
        if( bs.ppsttzDnGMoms[ 0 ] )
        //GmOM2
    {
    if( bs.ppsttzDnGMoms )
    
    }
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzUpGDads[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW3 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW2 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;
            //GdAD3
        {
        if( bs.cUpGDads  )
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnGDads[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW3 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW2 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
            //GdAD1
        {
        if( bs.cDnGDads  )

        etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
        etherP.strFuseF( tinP , psttP , bs.ppsttzDnGDads[ 0 ] ) ;
        etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW3 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW2 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        //GdAD2
    {
    if( bs.ppsttzDnGDads )
    
    }
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzUpGGMoms[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW2 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW1 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;
        {
        if( bs.cUpGGMoms && bs.ppsttzUpGGMoms[ 1 ] )
        //GGmOM3

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnGGMoms[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW2 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW1 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
        {
        if( bs.cDnGGMoms && bs.ppsttzDnGGMoms[ 1 ] )
        //GGmOM1

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnGGMoms[ 0 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW2 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW1 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        {
        if( bs.ppsttzDnGGMoms[ 0 ] )
        //GGmOM2
    {
    if( bs.ppsttzDnGGMoms )
    //FEMALE VALUES CAN BE 0; MALE VALUES CANNOT; THAT IS WHY THE CHECK IS MADE FOR FEMALES ONLY

    etherP.strFuseF( tinP , psttP , drawerP.pstt2 ) ;

    if( bUpOk ) etherP.strFuseF( tinP , psttP , drawerP.psttUpHint ) ;

    etherP.strFuseF( tinP , psttP , drawerP.psttHighBorder ) ; //GIVES TOP CENTER A YELLOW BORDER
    etherP.strFuseF( tinP , psttP , drawerP.pstt1 ) ;

    pBatonTree->ungrabF( tinP ) ;
    treeP.nearbyF( tinP , bs ) ;
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    bs.cUpGKids = 1 ;
    bs.cDnGKids =
    bs.cUpKids =
    bs.cDnKids =
    bs.cUpWives =
    bs.cDnWives =
    bs.cUpBros =
    bs.cDnBros =
    bs.cUpMoms =
    bs.cDnMoms =
    bs.cUpDads =
    bs.cDnDads =
    bs.cUpGMoms =
    bs.cDnGMoms =
    bs.cUpGDads =
    bs.cDnGDads =
    bs.cUpGGMoms =
    bs.cDnGGMoms =
    branchesOldS bs ;
{
voidT tHollywoodF( tinS& tinP , etherC& etherP , strokeS*& psttP , treeOldC& treeP , drawerHollywoodS& drawerP )

}
    if( cArgP && etherP ) ;

    }
        }
            if( !( F(pxNew[0]) & flTOOL_NOTpRESENT ) ) pTcButton_toolMouse->setF( tinP , *pTxtNull+S3(64.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+TP("",2)+TF3(pxNew[1],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxNew[2],flFORMAT_UNSIGNED,8)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
    
            thirdC::c_memcpyIF( tinP , (byteT*)pxLag , (byteT*)pxNew , sizeof pxLag ) ;
        {
        if( thirdC::c_memcmpIF( tinP , (byteT*)pxLag , (byteT*)pxNew , sizeof pxLag ) )
        static countT pxLag[ 3 ] ;
    
        ;
        }
            wP.pcToolState_22[ ifcIDtYPEtOOL_MOUSEpOSITION - ifcIDtYPEtOOL_x2Begin - 1 ] ,
            wP.pcToolState_12[ ifcIDtYPEtOOL_MOUSEpOSITION - ifcIDtYPEtOOL_x2Begin - 1 ] ,
            wP.pfToolState_f[  ifcIDtYPEtOOL_MOUSEpOSITION - ifcIDtYPEtOOL_begin   - 1 ] ,
        {
        countT pxNew[ 3 ] =
        //U::O: THIS WOULD BE FASTER IF TOOL STATE INFO WAS CONTIGUOUS

        }
            }
                else if( !( F(pxNew[0]) & flTOOL_NOTpRESENT ) )                                    pTcButton_toolJoy2->setF( tinP , *pTxtNull+S3(64.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+TP("",2)+TF3(pxRpt[1],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[2],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[3],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[4],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[5],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[6],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[7],flFORMAT_UNSIGNED,8)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
                if( !( F(pxNew[0]) & flTOOL_NOTpRESENT ) && idTool == ifcIDtYPEtOOL_JOY1pOSITION ) pTcButton_toolJoy1->setF( tinP , *pTxtNull+S3(64.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+TP("",2)+TF3(pxRpt[1],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[2],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[3],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[4],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[5],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[6],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[7],flFORMAT_UNSIGNED,8)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;

                }
                    ;
                        : ( pxNew[ off ] - pxMin[ off ] ) * 0x100 / range
                        ? 0
                    pxRpt[ off ] = !range
                    countT range = pxMax[ off ] - pxMin[ off ] ;
                {
                for( countT off = 1 ; off <= 7 ; off ++ )
                countT pxRpt[ 8 ] ;

                ;
                }
                    wP.pcToolState_77MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ]
                    wP.pcToolState_67MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                    wP.pcToolState_57MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                    wP.pcToolState_47MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                    wP.pcToolState_37MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                    wP.pcToolState_27MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                    wP.pcToolState_17MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                    0 ,
                {
                countT pxMax[ 8 ] =
                //U::O: THIS WOULD BE FASTER IF TOOL STATE INFO WAS CONTIGUOUS

                ;
                }
                    wP.pcToolState_77MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ]
                    wP.pcToolState_67MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                    wP.pcToolState_57MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                    wP.pcToolState_47MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                    wP.pcToolState_37MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                    wP.pcToolState_27MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                    wP.pcToolState_17MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                    0 ,
                {
                countT pxMin[ 8 ] =
                //U::O: THIS WOULD BE FASTER IF TOOL STATE INFO WAS CONTIGUOUS

                thirdC::c_memcpyIF( tinP , (byteT*)pxLag , (byteT*)pxNew , sizeof pxLag ) ;
            {
            if( thirdC::c_memcmpIF( tinP , (byteT*)pxLag , (byteT*)pxNew , sizeof pxLag ) )
            static countT pxLag[ 8 ] ;

            ;
            }
                wP.pcToolState_77I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ]
                wP.pcToolState_67I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                wP.pcToolState_57I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                wP.pcToolState_47I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                wP.pcToolState_37I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                wP.pcToolState_27I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                wP.pcToolState_17I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                wP.pfToolState_fI[  idTool - ifcIDtYPEtOOL_begin   - 1 ] ,
            {
            countT pxNew[ 8 ] =
            //U::O: THIS WOULD BE FASTER IF TOOL STATE INFO WAS CONTIGUOUS
        {
        for( countT idTool = ifcIDtYPEtOOL_JOY1pOSITION ; idTool <= ifcIDtYPEtOOL_JOY2pOSITION ; idTool ++ )
        //A:ASSUME: JOYSTICK POSITION TOOLS ARE CONTIGUOUS

        }
            }
                }
                    }
                        continue ;
                        else                    ((tcButtonC*)ppbTcButtonTool[ idTool - ifcIDtYPEtOOL_begin - 1 ])->setF( tinP , psttOffUp   ) ;
                        else if( bDown        ) ((tcButtonC*)ppbTcButtonTool[ idTool - ifcIDtYPEtOOL_begin - 1 ])->setF( tinP , psttOffDown ) ;
                        else if( bOn          ) ((tcButtonC*)ppbTcButtonTool[ idTool - ifcIDtYPEtOOL_begin - 1 ])->setF( tinP , psttOnUp    ) ;
                        else if( bOn && bDown ) ((tcButtonC*)ppbTcButtonTool[ idTool - ifcIDtYPEtOOL_begin - 1 ])->setF( tinP , psttOnDown  ) ;
                             if( bAbsent      ) ((tcButtonC*)ppbTcButtonTool[ idTool - ifcIDtYPEtOOL_begin - 1 ])->setF( tinP , psttAbsent  ) ;
        
                        boolT bOn     = F(wP.pfToolState_f[idTool-ifcIDtYPEtOOL_begin-1]) & flTOOL_ON ;
                        boolT bDown   = F(wP.pfToolState_f[idTool-ifcIDtYPEtOOL_begin-1]) & flTOOL_DOWN ;
                        boolT bAbsent = F(wP.pfToolState_f[idTool-ifcIDtYPEtOOL_begin-1]) & flTOOL_NOTpRESENT ;
                    {
                    default :
                    }
                        continue ;
                        if( bAbsent ) ((tcButtonC*)ppbTcButtonTool[ idTool - ifcIDtYPEtOOL_begin - 1 ])->setF( tinP , psttAbsent2 ) ;

                        boolT bAbsent = F(wP.pfToolState_f[idTool-ifcIDtYPEtOOL_begin-1]) & flTOOL_NOTpRESENT ;
                    {
                    case ifcIDtYPEtOOL_JOY2pOSITION :
                    case ifcIDtYPEtOOL_JOY1pOSITION :
                    case ifcIDtYPEtOOL_MOUSEpOSITION :
                    case ifcIDtYPEtOOL_x2End        : { continue ; }
                    case ifcIDtYPEtOOL_x7End        :
                    case ifcIDtYPEtOOL_x7Begin      :
                    case ifcIDtYPEtOOL_x2Begin      :
                    case ifcIDtYPEtOOL_CONTROLeND   :
                    case ifcIDtYPEtOOL_CONTROLbEGIN :
                {
                switch( idTool ) /*A*/
            {
            for( countT idTool = ifcIDtYPEtOOL_begin + 1 ; idTool < ifcIDtYPEtOOL_end ; idTool ++ )
            ZE( countT , cDone ) ;

            thirdC::c_memcpyIF( tinP , pbSave_f , (byteT*)wP.pfToolState_f , sizeof pbSave_f ) ;
        {
        if( thirdC::c_memcmpIF( tinP , pbSave_f , (byteT*)wP.pfToolState_f , sizeof pbSave_f ) )

        static byteT pbSave_f[ sizeof wP.pfToolState_f ] ;
    {
    if( bToolTest )

    if( timeN1 > TOCK * 8 ) *pTxtTutor = T("") ;
    etherP.osTimeSubtractF( tinP , timeN1 , timeN2 , timeTutorAge1 , timeTutorAge2 ) ;
    etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT , timeN1 ) ;

    }
        etherP.osTimeNowF( tinP , timeTutorAge1 , timeTutorAge2 ) ;
        timeTutorAge2 = timeTutorAge1 = 0 ;

        thirdC::winBitBltIF( tinP , wP , mIdColMinTutor , mIdRowMinTutor , mColsTutorBitBlt , mRowsTutor ) ;
        *pTxtTutorMemory = *pTxtTutor ;
        }
            etherP.delF( tinP , psttSay ) ;
            wP.wrapRenderF( tinP , psttSay ) ;

            etherP.strFuseF( tinP , psttSay , S2(0,scOld_POPfRAME) ) ;
            etherP.strFuseF( tinP , psttSay , S2(0,scOld_POPfRAME) ) ;
            etherP.strFuseF( tinP , psttSay , tSay ) ;
            etherP.strFuseF( tinP , psttSay , S3(mIdColMinTutor-1.0+mColsTutor,scOld_mmFRAMEpELtO,mIdRowMinTutor-1.0+mRowsTutor) ) ;
            etherP.strFuseF( tinP , psttSay , S3(mIdColMinTutor,scOld_mmMOVEpELtO,mIdRowMinTutor) ) ;
            etherP.strFuseF( tinP , psttSay , S3(1.0,scOld_mmFRAMEtO,1.0) ) ;
            etherP.strFuseF( tinP , psttSay , S3(0.0,scOld_mmMOVEtO,0.0) ) ; //TO PREVENT AFFECTING HIGH WATER

            etherP.strMakeF( tinP , psttSay , 0 , 0x10 + tSay.csF( tinP ) ) ;
            ZE( strokeS* , psttSay ) ;

            textC& tSay = idPass == 1 ? *pTxtTutorMemory : *pTxtTutor ;
        {
        for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
    {
    if( *pTxtTutorMemory != *pTxtTutor )

    wP.baton.ungrabF( tinP ) ;
    }
        mIdRowMinTools = ( sf.mIdRow - 1.0 ) + (measureT)0x10 ;
        mRowsTools = sf.mRows / (measureT)0x20 ;
        mColsToolsBitBlt += 0x10 ; //TO TAKE CARE OF STROKING BEYOND RIGHT BOUNDARY (SINCE AM NOT CLIPPING)
        mIdColMinTools = sf.mIdCol + 0x10 ;
        mColsTools = mColsToolsBitBlt / (measureT)0xc0 ;
        mColsToolsBitBlt = sf.mCols - 0x20 ;

        mIdRowMinTutor = ( sf.mIdRow - 1.0 + sf.mRows ) - (measureT)0x10 - mRowsTutor ;
        mRowsTutor = sf.mRows / (measureT)0x20 ;
        mColsTutorBitBlt += 0x10 ; //TO TAKE CARE OF STROKING BEYOND RIGHT BOUNDARY (SINCE AM NOT CLIPPING)
        mIdColMinTutor = sf.mIdCol + 0x10 ;
        mColsTutor = mColsTutorBitBlt / (measureT)0xc0 ;
        mColsTutorBitBlt = sf.mCols - 0x20 ;

        strokingFrameS& sf = *(strokingFrameS*)&wP.pPaperShow->stqr_strokingFrame[ wP.pPaperShow->stqr_strokingFrame ] ;

        bNewFace = 0 ;
    {
    if( bNewFace )
    wP.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        pTcButton_wheel->setF( tinP , *pTxtNull+S3(1.0,scOld_mmFRAMEcELLS,1.0)+S2(0,scOld_FRAMEdETACH)+S3(0.0,scOld_mmMOVEtO,mRowWhere)+S3(1.0,scOld_mmLINEtO,mRowWhere)+S2(0,scOld_POPfRAMEdETACH)+S2(0,scOld_POPfRAME) ) ;

        }
            if( !( idCycleP % WHEELpERIOD ) ) bLeft = !bLeft ;
            else         mRowWhere = (measure04T)( ( WHEELpERIOD - idCycleP % WHEELpERIOD ) % WHEELpERIOD ) / (measure04T)( WHEELpERIOD - 1 ) ;
            if( !bLeft ) mRowWhere = (measure04T)( ( - 1         + idCycleP               ) % WHEELpERIOD ) / (measure04T)( WHEELpERIOD - 1 ) ;
            static boolT bLeft ;
        {
        ZE( measure04T , mRowWhere ) ;
        //MOVE A VERTICAL LINE BACK AND FORTH HORIZONTALLY 1 PEL PER ANIMATION CYCLE
    {

    }
        //etherP.etherFireImpersonateMonitorIF( tinP ) ;
    {
    if( idIn == 8 )
    //U::

    countT idIn = ++ idInLath ;
    static countT idInLath ;
    static measureT mColsToolsBitBlt ;
    static measureT mRowsTools ;
    static measureT mColsTools ;
    static measureT mIdRowMinTools ;
    static measureT mIdColMinTools ;

    static measureT mColsTutorBitBlt ;
    static measureT mRowsTutor ;
    static measureT mColsTutor ;
    static measureT mIdRowMinTutor ;
    static measureT mIdColMinTutor ;
{
voidT animateCBF( tinS& tinP , etherC& etherP , paperBackC& backP , const countT idCycleP , const countT cArgP )

}
    ) ; ___( pstt3 ) ;
    
        S2(0,scOld_WRAPoFF)
        T("")+
    
    etherP.strMakeF( tinP , pstt3 , 

    ) ; ___( psttHighBorder ) ;

        S2(0,scOld_POPfRAMEdETACH)
        S2(0,scOld_POPcOLOR)+
        S3(COL2,scOld_mmLINEtO,ROW6)+
        S3(COL2,scOld_mmLINEtO,ROW7)+
        S3(COL3,scOld_mmLINEtO,ROW7)+
        S3(COL3,scOld_mmLINEtO,ROW6)+
        S3(COL2,scOld_mmMOVEtO,ROW6)+
        S2(0x008080,scOld_cPUSHcOLOR)+
        S2(0,scOld_POPcOLOR)+
        S3(COL2,scOld_mmLINEtO,ROW6)+
        S3(COL2,scOld_mmLINEtO,ROW7)+
        S3(COL3,scOld_mmLINEtO,ROW7)+
        S3(COL3,scOld_mmLINEtO,ROW6)+
        S3(COL2,scOld_mmMOVEtO,ROW6)+
        S2(0x000080,scOld_cPUSHcOLOR)+
        S2(0,scOld_FRAMEdETACH)+
        T("")+

    etherP.strMakeF( tinP , psttHighBorder , 

    ) ; ___( psttBranchEpilog ) ;

        S2(0,scOld_POPfRAME)
        //S2(0,scOld_POPcLIP)+
        S3(0.0,scOld_mmPADfORsADAMfRAMES,0.0)+
        //S2(0,scOld_POPfRAME)+
        //S2(0,scOld_WRAPoFF)+
        T("")+

    etherP.strMakeF( tinP , psttBranchEpilog , 

    ) ; ___( psttBranchPrologMale ) ;

        //S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)
        //S2(0,scOld_WRAPoN)+
        //S3(MSC,scOld_mmFRAMEtO,MSR)+
        //CONTENT
        S3(1.0,scOld_mmPADfORsADAMfRAMES,1.0)
        //S3(1.0,scOld_mmCLIPtO,1.0)+
        S3(0.0,scOld_mmFRAMEpELtO,0.0)+
        S2(0,scOld_cOVERRIDEnEXTsTROKE)+
        S2(0,scOld_POPfRAMEdETACH)+
        S3(-9.0,scOld_mmMOVEpEL,-9.0)+
        S3(COL2,scOld_mmMOVEtO,ROW3)+                                //5: PATCH idAdam,cNote
        S2(0,scOld_PUSHoVERRIDEcOLrOW)+   //4
        S3(9.0,scOld_mmMOVEpEL,9.0)+                                 //3
        S3(COL1,scOld_mmMOVEtO,ROW2)+                                //2: PATCH idAdam,cNote
        S2(0,scOld_FRAMEdETACH)+                       //1
        T("")+

    etherP.strMakeF( tinP , psttBranchPrologMale , 

    ) ; ___( psttBranchPrologFemale ) ;

        //S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)
        //S2(0,scOld_WRAPoN)+
        //S3(FSC,scOld_mmFRAMEtO,FSR)+
        //CONTENT
        S3(1.0,scOld_mmPADfORsADAMfRAMES,1.0)
        //S3(1.0,scOld_mmCLIPtO,1.0)+
        S3(0.0,scOld_mmFRAMEpELtO,0.0)+
        S2(0,scOld_cOVERRIDEnEXTsTROKE)+
        S2(0,scOld_POPfRAMEdETACH)+
        S3(-9.0,scOld_mmMOVEpEL,-3.0)+
        S3(COL2,scOld_mmMOVEtO,ROW2)+                                //5: PATCH idAdam,cNote
        S2(0,scOld_PUSHoVERRIDEcOLrOW)+                       //4
        S3(9.0,scOld_mmMOVEpEL,3.0)+                                 //3
        S3(COL1,scOld_mmMOVEtO,ROW1)+                                //2: PATCH idAdam,cNote
        S2(0,scOld_FRAMEdETACH)+                              //1
        T("")+

    etherP.strMakeF( tinP , psttBranchPrologFemale , 

    ) ; ___( pstt2 ) ;

        S2(0,scOld_POPfRAME)
        S2(0,scOld_POPfRAMEdETACH)+
        S2(0,scOld_POPcOLOR)+
        T("")+
        //CLEANUP FOR HINTS

    etherP.strMakeF( tinP , pstt2 , 

    ) ; ___( psttUpHint ) ;

        S3(16.0,scOld_mmLINEeNDpEL,-16.0)
        S3(16.0,scOld_mmLINEpEL,16.0)+
        S3(-16.0,scOld_mmMOVEpEL,-16.0)+
        S3(0.0,scOld_mmLINEpEL,32.0)+
        S3(-32.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL3,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttUpHint , 

    ) ; ___( pstt1 ) ;

        S2(0x00ffff,scOld_cPUSHcOLOR)
       S2(0,scOld_FRAMEdETACH)+
        S3(1.0,scOld_mmFRAMEtO,1.0)+
        S3(0.0,scOld_mmMOVEtO,0.0)+
        //SET UP FOR HINTS

        S2(0,scOld_POPfRAMEdETACH)+
        S2(0,scOld_POPcOLOR)+

        S3(1.0,scOld_mmLINEtO,2.0/3.0+1.0/32.0)+
        S3(0.0,scOld_mmMOVEtO,2.0/3.0+1.0/32.0)+

        S3(1.0,scOld_mmLINEtO,2.0/3.0)+
        S3(0.0,scOld_mmMOVEtO,2.0/3.0)+

        S3(1.0,scOld_mmLINEtO,1.0/3.0+1.0/32.0)+
        S3(0.0,scOld_mmMOVEtO,1.0/3.0+1.0/32.0)+

        S3(1.0,scOld_mmLINEtO,1.0/3.0)+
        S3(0.0,scOld_mmMOVEtO,1.0/3.0)+

        S3(1.0,scOld_mmLINEtO,1.0/32.0)+
        S3(0.0,scOld_mmMOVEtO,1.0/32.0)+

        S3(2.0/3.0,scOld_mmLINEtO,1.0)+
        S3(2.0/3.0,scOld_mmMOVEtO,0.0)+
        S3(1.0/3.0,scOld_mmLINEtO,1.0)+
        S3(1.0/3.0,scOld_mmMOVEtO,0.0)+

        S3(0.0,scOld_mmLINEtO,0.0)+
        S3(0.0,scOld_mmLINEtO,1.0)+
        S3(1.0,scOld_mmLINEtO,1.0)+
        S3(1.0,scOld_mmLINEtO,0.0)+

        S2(0x000080,scOld_cPUSHcOLOR)+
        S2(0,scOld_FRAMEdETACH)+

        //RED GRID

        T("")+

    etherP.strMakeF( tinP , pstt1 , 

    }
        for( countT off = 0 ; off < cElts ; off ++ ) new( 0 , tinP , ppbTcButtonBro[ off ] , sizeof ppbTcButtonBro[ off ] ) tcButtonC( tinP , tcButton_broCBF , off - 1 , flTcFeature , &flTcFeatureDisable , 0 , 1 ) ;
        countT cElts = sizeof ppbTcButtonBro / sizeof ppbTcButtonBro[ 0 ] ;
    {

    }
        for( countT off = 0 ; off < cElts ; off ++ ) new( 0 , tinP , ppbTcButtonMom[ off ] , sizeof ppbTcButtonMom[ off ] ) tcButtonC( tinP , tcButton_momCBF , off - 1 , flTcFeature , &flTcFeatureDisable , 0 , 1 ) ;
        countT cElts = sizeof ppbTcButtonMom / sizeof ppbTcButtonMom[ 0 ] ;
    {

    }
        for( countT off = 0 ; off < cElts ; off ++ ) new( 0 , tinP , ppbTcButtonDad[ off ] , sizeof ppbTcButtonDad[ off ] ) tcButtonC( tinP , tcButton_dadCBF , off - 1 , flTcFeature , &flTcFeatureDisable , 0 , 1 ) ;
        countT cElts = sizeof ppbTcButtonDad / sizeof ppbTcButtonDad[ 0 ] ;
    {

    }
        for( countT off = 0 ; off < cElts ; off ++ ) new( 0 , tinP , ppbTcButtonGMom[ off ] , sizeof ppbTcButtonGMom[ off ] ) tcButtonC( tinP , tcButton_gMomCBF , off - 1 , flTcFeature , &flTcFeatureDisable , 0 , 1 ) ;
        countT cElts = sizeof ppbTcButtonGMom / sizeof ppbTcButtonGMom[ 0 ] ;
    {

    }
        for( countT off = 0 ; off < cElts ; off ++ ) new( 0 , tinP , ppbTcButtonGDad[ off ] , sizeof ppbTcButtonGDad[ off ] ) tcButtonC( tinP , tcButton_gDadCBF , off - 1 , flTcFeature , &flTcFeatureDisable , 0 , 1 ) ;
        countT cElts = sizeof ppbTcButtonGDad / sizeof ppbTcButtonGDad[ 0 ] ;
    {

    }
        for( countT off = 0 ; off < cElts ; off ++ ) new( 0 , tinP , ppbTcButtonGGMom[ off ] , sizeof ppbTcButtonGGMom[ off ] ) tcButtonC( tinP , tcButton_ggMomCBF , off - 1 , flTcFeature , &flTcFeatureDisable , 0 , 1 ) ;
        countT cElts = sizeof ppbTcButtonGGMom / sizeof ppbTcButtonGGMom[ 0 ] ;
    {

    etherP.strMakeF( tinP , psttSetSuffix       , *pTxtNull+S2(0,scOld_WRAPoFF)+S2(0,scOld_POPfRAME)+S3(1.0,scOld_mmPADfORsADAMfRAMES,1.0)+S2(0,scOld_POPfRAME) ) ; ___( psttSetSuffix       ) ;
    etherP.strMakeF( tinP , psttSetPrefixMale   , *pTxtNull+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(1.0,scOld_mmPADfORsADAMfRAMES,1.0)+S3(MSC,scOld_mmFRAMEcELLS,MSR)+S2(0,scOld_WRAPoN) )   ; ___( psttSetPrefixMale   ) ;
    etherP.strMakeF( tinP , psttSetPrefixFemale , *pTxtNull+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(1.0,scOld_mmPADfORsADAMfRAMES,1.0)+S3(FSC,scOld_mmFRAMEcELLS,FSR)+S2(0,scOld_WRAPoN) )   ; ___( psttSetPrefixFemale ) ;
{
psttSetSuffix( 0 )
psttSetPrefixMale( 0 ) ,
psttSetPrefixFemale( 0 ) ,
flTcFeatureDisable( flTCfEATURE_null ) ,
flTcFeature( ( flTCfEATURE_defaultButton | flTCfEATURE_FLYOVER ) & ~( F(flTCfEATURE_FRAME) ) ) ,
pstt3( 0 ) ,
psttHighBorder( 0 ) ,
psttBranchPrologMale( 0 ) ,
psttBranchPrologFemale( 0 ) ,
psttBranchEpilog( 0 ) ,
pstt2( 0 ) ,
psttUpHint( 0 ) ,
pstt1( 0 ) ,
drawerHollywoodS::drawerHollywoodS( tinS& tinP , etherC& etherP ) :

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { static countT idInLath ; countT idIn = 1 + incv02AM( idInLath ) ; etherP.beeClickF( tinP , TUCK * idIn ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("this is brother ")+TF1((sCountT)cArgP) ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_broCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { static countT idInLath ; countT idIn = 1 + incv02AM( idInLath ) ; etherP.beeClickF( tinP , TUCK * idIn ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("this is mom ")+TF1((sCountT)cArgP) ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_momCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { static countT idInLath ; countT idIn = 1 + incv02AM( idInLath ) ; etherP.beeClickF( tinP , TUCK * idIn ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("this is dad ")+TF1((sCountT)cArgP) ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_dadCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { static countT idInLath ; countT idIn = 1 + incv02AM( idInLath ) ; etherP.beeClickF( tinP , TUCK * idIn ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("this is grandmom ")+TF1((sCountT)cArgP) ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_gMomCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { static countT idInLath ; countT idIn = 1 + incv02AM( idInLath ) ; etherP.beeClickF( tinP , TUCK * idIn ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("this is granddad ")+TF1((sCountT)cArgP) ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_gDadCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( cArgP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;
    }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY  : { static countT idInLath ; countT idIn = 1 + incv02AM( idInLath ) ; etherP.beeClickF( tinP , TUCK * idIn ) ; break ; }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE   : { if( !( F(flTcStateNewP) & flTCsTATE_DOWN ) || F(flTcStateOldP) & flTCsTATE_DOWN ) break ; }
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER : { *pTxtTutor = T("this is great grandmom ")+TF1((sCountT)cArgP) ; break ; }
    {
    switch( idTypeCallP )
{
voidT tcButton_ggMomCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    PUSE( tinP , *(voidT**)&psttSetSuffix ) ;
    PUSE( tinP , *(voidT**)&psttSetPrefixMale ) ;
    PUSE( tinP , *(voidT**)&psttSetPrefixFemale ) ;
    PUSE( tinP , *(voidT**)&pstt3 ) ;
    PUSE( tinP , *(voidT**)&psttHighBorder ) ;
    PUSE( tinP , *(voidT**)&psttBranchEpilog ) ;
    PUSE( tinP , *(voidT**)&psttBranchPrologMale ) ;
    PUSE( tinP , *(voidT**)&psttBranchPrologFemale ) ;
    PUSE( tinP , *(voidT**)&pstt2 ) ;
    PUSE( tinP , *(voidT**)&psttUpHint ) ;
    PUSE( tinP , *(voidT**)&pstt1 ) ;

    }
        for( countT off = 0 ; off < cElts ; off ++ ) delete (tcButtonC*)ppbTcButtonBro[ off ] ;
        countT cElts = sizeof ppbTcButtonBro / sizeof ppbTcButtonBro[ 0 ] ;
    {

    }
        for( countT off = 0 ; off < cElts ; off ++ ) delete (tcButtonC*)ppbTcButtonMom[ off ] ;
        countT cElts = sizeof ppbTcButtonMom / sizeof ppbTcButtonMom[ 0 ] ;
    {

    }
        for( countT off = 0 ; off < cElts ; off ++ ) delete (tcButtonC*)ppbTcButtonDad[ off ] ;
        countT cElts = sizeof ppbTcButtonDad / sizeof ppbTcButtonDad[ 0 ] ;
    {

    }
        for( countT off = 0 ; off < cElts ; off ++ ) delete (tcButtonC*)ppbTcButtonGMom[ off ] ;
        countT cElts = sizeof ppbTcButtonGMom / sizeof ppbTcButtonGMom[ 0 ] ;
    {

    }
        for( countT off = 0 ; off < cElts ; off ++ ) delete (tcButtonC*)ppbTcButtonGDad[ off ] ;
        countT cElts = sizeof ppbTcButtonGDad / sizeof ppbTcButtonGDad[ 0 ] ;
    {

    }
        for( countT off = 0 ; off < cElts ; off ++ ) delete (tcButtonC*)ppbTcButtonGGMom[ off ] ;
        countT cElts = sizeof ppbTcButtonGGMom / sizeof ppbTcButtonGGMom[ 0 ] ;
    {

    TINSL
{
drawerHollywoodS::~drawerHollywoodS( voidT )

}
    etherP.strFuseF( tinP , psttP , drawerP.pstt3 ) ; ___( psttP ) ;

    }
        if( bs.ppsttzDnBros ) { etherP.strFuseF( tinP , psttP , *bs.ppsttzDnBros ) ; ___( psttP ) ; }
        pBatonTree->ungrabF( tinP ) ;
        treeP.nearbyF( tinP , bs ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        branchesOldS bs ;
    {
    if( !bToolTest && !bToolTestHire )

    etherP.strFuseF( tinP , psttP , drawerP.pstt2 ) ; ___( psttP ) ;

    }
        if( bOutOk   ) { etherP.strFuseF( tinP , psttP , drawerP.psttOutHint   ) ; ___( psttP ) ; }
        if( bInOk    ) { etherP.strFuseF( tinP , psttP , drawerP.psttInHint    ) ; ___( psttP ) ; }
        if( bRightOk ) { etherP.strFuseF( tinP , psttP , drawerP.psttRightHint ) ; ___( psttP ) ; }
        if( bLeftOk  ) { etherP.strFuseF( tinP , psttP , drawerP.psttLeftHint  ) ; ___( psttP ) ; }
        if( bUpOk    ) { etherP.strFuseF( tinP , psttP , drawerP.psttUpHint    ) ; ___( psttP ) ; }
        if( bDownOk  ) { etherP.strFuseF( tinP , psttP , drawerP.psttDownHint  ) ; ___( psttP ) ; }
    {
    if( !bToolTest && !bToolTestHire )

    etherP.strFuseF( tinP , psttP , drawerP.pstt1 ) ; ___( psttP ) ;
{
voidT tHugeF( tinS& tinP , etherC& etherP , strokeS*& psttP , treeOldC& treeP , drawerHugeS& drawerP )

}
    //) ; ___( pstt2 ) ;
    //
    //    S2(0,scOld_POPfRAME)
    //    S2(0,scOld_WRAPoFF)+
    //    T("")+
    //
    //etherP.strMakeF( tinP , pstt2 , 
    //THIS IS THE OLD EPILOG; NOW I DON'T DO THIS TO ALLOW STROKE ENTRY TO APPEND STROKES TO MY IMAGE

    ) ; ___( pstt3 ) ;
    
        S2(0,scOld_WRAPoFF)
        T("")+
    
    etherP.strMakeF( tinP , pstt3 , 

    ) ; ___( pstt2 ) ;

        S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)
        S2(0,scOld_WRAPoN)+
        S3(1.0/220.0,scOld_mmFRAMEtO,1.0/24.0)+
        //STROKING FRAME SETUP
        
        S3(0.0,scOld_mmFRAMEpELtO,0.0)+
        S2(0,scOld_cOVERRIDEnEXTsTROKE)+
        S2(0,scOld_POPfRAMEdETACH)+
        S3(-9.0,scOld_mmMOVEpEL,-9.0)+
        S3(1.0,scOld_mmMOVEtO,1.0)+
        S2(0,scOld_PUSHoVERRIDEcOLrOW)+
        S3(9.0,scOld_mmMOVEpEL,9.0)+
        S2(0,scOld_FRAMEdETACH)+
        //CONTENT FRAME

        S2(0,scOld_POPfRAME)+
        S2(0,scOld_POPfRAMEdETACH)+
        S2(0,scOld_POPcOLOR)+
        T("")+
        //CLEANUP FOR HINTS

    etherP.strMakeF( tinP , pstt2 , 

    ) ; ___( psttOutHint ) ;

        S3(16.0,scOld_mmLINEpEL,16.0)
        S3(-48.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL4,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttOutHint , 

    ) ; ___( psttInHint ) ;

        S3(-16.0,scOld_mmLINEpEL,-16.0)
        S3(-48.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL4,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttInHint , 

    ) ; ___( psttRightHint ) ;

        S3(-12.0,scOld_mmLINEeNDpEL,12.0)
        S3(12.0,scOld_mmLINEpEL,12.0)+
        S3(-12.0,scOld_mmMOVEpEL,-12.0)+
        S3(32.0,scOld_mmLINEpEL,0.0)+
        S3(-48.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL4,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttRightHint , 

    ) ; ___( psttLeftHint ) ;

        S3(12.0,scOld_mmLINEeNDpEL,12.0)
        S3(-12.0,scOld_mmLINEpEL,12.0)+
        S3(12.0,scOld_mmMOVEpEL,-12.0)+
        S3(-32.0,scOld_mmLINEpEL,0.0)+
        S3(-48.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL4,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttLeftHint , 

    ) ; ___( psttUpHint ) ;

        S3(12.0,scOld_mmLINEeNDpEL,-12.0)
        S3(12.0,scOld_mmLINEpEL,12.0)+
        S3(-12.0,scOld_mmMOVEpEL,-12.0)+
        S3(0.0,scOld_mmLINEpEL,32.0)+
        S3(-48.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL4,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttUpHint , 

    ) ; ___( psttDownHint ) ;

        S3(12.0,scOld_mmLINEeNDpEL,12.0)
        S3(12.0,scOld_mmLINEpEL,-12.0)+
        S3(-12.0,scOld_mmMOVEpEL,12.0)+
        S3(0.0,scOld_mmLINEpEL,-32.0)+
        S3(-48.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL4,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttDownHint , 

    ) ; ___( pstt1 ) ;

        S2(0x00ffff,scOld_cPUSHcOLOR)
        S2(0,scOld_FRAMEdETACH)+
        S3(1.0,scOld_mmFRAMEtO,1.0)+
        //SET UP FOR HINTS

        S2(0,scOld_POPfRAMEdETACH)+
        S2(0,scOld_POPcOLOR)+
        S3(0.0,scOld_mmLINEtO,0.0)+
        S3(0.0,scOld_mmLINEtO,1.0)+
        S3(1.0,scOld_mmLINEtO,1.0)+
        S3(1.0,scOld_mmLINEtO,0.0)+
        S2(0x0000ff,scOld_cPUSHcOLOR)+
        S2(0,scOld_FRAMEdETACH)+
        //RED BORDER

        T("")+

    etherP.strMakeF( tinP , pstt1 , 
{
pstt3( 0 )
pstt2( 0 ) ,
pstt1( 0 ) ,
psttOutHint( 0 ) ,
psttInHint( 0 ) ,
psttRightHint( 0 ) ,
psttLeftHint( 0 ) ,
psttUpHint( 0 ) ,
psttDownHint( 0 ) ,
drawerHugeS::drawerHugeS( tinS& tinP , etherC& etherP ) :

voidT writeF( tinS& tinP , etherC& etherP , const strokeS* const psttP , treeOldC& treeP , const boolT bWholeP = 0 ) ;

}
    PUSE( tinP , *(voidT**)&pstt3 ) ;
    PUSE( tinP , *(voidT**)&pstt2 ) ;
    PUSE( tinP , *(voidT**)&pstt1 ) ;
    PUSE( tinP , *(voidT**)&psttOutHint ) ;
    PUSE( tinP , *(voidT**)&psttInHint ) ;
    PUSE( tinP , *(voidT**)&psttRightHint ) ;
    PUSE( tinP , *(voidT**)&psttLeftHint ) ;
    PUSE( tinP , *(voidT**)&psttUpHint ) ;
    PUSE( tinP , *(voidT**)&psttDownHint ) ;
    TINSL
{
drawerHugeS::~drawerHugeS( voidT )

;
}
    drawerHugeS( tinS& tinP , etherC& etherP ) ;
    ~drawerHugeS( voidT ) ;

    strokeS* pstt3 ;
    strokeS* pstt2 ;
    strokeS* pstt1 ;
    strokeS* psttOutHint ;
    strokeS* psttInHint ;
    strokeS* psttRightHint ;
    strokeS* psttLeftHint ;
    strokeS* psttUpHint ;
    strokeS* psttDownHint ;
{
struct drawerHugeS

//;
//
//    " ac\r\n"
//    "  abc\r\n"
//    "  abb\r\n"
//    "  aba\r\n"
//    " ab\r\n"
//    " aa\r\n"
//    "a\r\n"
//
//osTextT postTutor[] =

//;
//
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    " aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "this is a very large kt\r\n"
//
//osTextT postTutor[] =

;

    " final tips: remember to check your caps lock key and to use the mouse when not climbing!\r\n"
    "  to return to the editor, click its icon, a black rectangle, in the taskbar near the current time\r\n"
    "  to view the display of your base os, click the 'o' button\r\n"
    "  that is why it runs as a Service\r\n"
    "  when it grows up, it will be the IdeaFarm " "(tm) IPDOS Piggyback Distributed Operating System\r\n"
    " this editor is a \"tip of the iceberg\" software product\r\n"
    "  the narrow rectangles are currently not used but will be used in a future release\r\n"
    "   in this way, a two dimensional tree of ideas can be constructed and presented\r\n"
    "   the root branch has no brothers\r\n"
    "   each branch in the tree has ze""ro or more kids\r\n"
    "   its \"younger brother\" is to its right\r\n"
    "   its \"elder brother\" is to its left\r\n"
    "   it is a \"kid\" of the center center branch\r\n"
    "   the top center branch, which you should be reading now, is your current location in the tree\r\n"
    "  the nearby branches of the knowledge tree are displayed above the button row\r\n"
    "    then click the button to see what it does\r\n"
    "    first, place the mouse pointer over the button to see the \"tutor's comment\"\r\n"
    "   after reading this introduction, play with each control to learn what it does\r\n"
    "   case is always significant in this editor, so check your caps lock key!\r\n"
    "   when entering text or searching, hotkeys are ignored so the mouse must be used\r\n"
    "   when reading a tree, they can also be actuated using hotkeys\r\n"
    "   the buttons can always be actuated by clicking with the mouse\r\n"
    "    when the hotkey is another stroke in th name, that stroke is highlighted\r\n"
    "    for example, the hotkey for \"IdeaFarm\" is capital 'I' (case matters)\r\n"
    "    the hot key of a control is usually the first stroke of its name\r\n"
    "    you can also actuate the control by pressing its \"hotkey\"\r\n"
    "    you can actuate a control by using the left mouse button to click it\r\n"
    "    all of the remaining items in the button row are controls\r\n"
    "     the joystick indicator for your joystick should display its position\r\n"
    "     this action calibrates the editor for that joystick\r\n"
    "     if you have a joystick plugged in, move the joystick its full range\r\n"
    "     if you do not have a joystick, these indicators are red\r\n"
    "    at left are two indicators for joystick position and state\r\n"
    "   the button list contains both indicators and controls\r\n"
    "   as you work with the editor, the button list will change\r\n"
    "  the button row at the bottom lists the actions that you can take\r\n"
    " you are now looking at nine branches above a row of buttons\r\n"
    " the next idea will have detail that you can climb up into\r\n"
    " use the up arrow key to climb up into more detail on the current idea\r\n"
    " use the right arrow key to advance to the next idea\r\n"
    " when reading, focus on the \"branch\" at top center\r\n"
    " you can then learn to use the editor by playing with it\r\n"
    " this brief tutorial will introduce you to the features that you now see\r\n"
    " you are now reading a knowledge tree\r\n"
    " welcome to the IdeaFarm " "(tm) Knowledge Tree Editor\r\n"
    " use the right arrow key to continue reading\r\n"
    "press the right arrow key\r\n"

osTextT postTutor[] =

byteT ppbTcButtonTool[ ifcIDtYPEtOOL_end - ifcIDtYPEtOOL_begin - 1 ] [ sizeof( tcButtonC ) ] ;


tcButtonC* pButtonDebug ; //U::

drawerHollywoodS* pDrawerHollywood ;
tcButtonC* pTcButton_toolMouse ;
tcButtonC* pTcButton_toolJoy2 ;
tcButtonC* pTcButton_toolJoy1 ;
tcButtonC* pTcButton_wheel ;
tcButtonC* pTcButton_joy2 ;
tcButtonC* pTcButton_joy1 ;
flagsT flTcFeatureDisableArrows = flTCfEATURE_null ;
flagsT flTcFeatureDisable       = flTCfEATURE_null ;
boolT  pbJoy[ 2 ] ;
boolT  bNewFace ;
boolT  bSuppressSessionEnd ;
textC* pTxtBlank ;
textC* pTxtNull ;
strokeS* psttOffUp ;
strokeS* psttOffDown ;
strokeS* psttOnUp ;
strokeS* psttOnDown ;
strokeS* psttAbsent2 ;
strokeS* psttAbsent ;
sCountT timeSessionTotal2 ;
countT  timeSessionTotal1 ;
sCountT timeSessionStart2 ;
countT  timeSessionStart1 ;
boolT   bInSession ;
countT  idSession ;
etherC* pEtPrime ;
boolT   bStateHasChanged ;
stackC* pStkFind ;
textC*  pTxtFind ;
boolT   bTestingTools ;
boolT   bToolTestHire ;
boolT   bToolTest ;
boolT   bNumericEntry ;
textC* pTxtLogo ;
sCountT timeTutorAge2 ;
countT  timeTutorAge1 ;
textC* pTxtToolsMemory ;
textC* pTxtTools ;
textC* pTxtTutorMemory ;
textC* pTxtTutor ;
countT cEntryArrivals ;//JUST USED BY TUTORIAL
boolT  bHaveStrokes ;
boolT  bFind ;
boolT  bEntry ;
boolT  bGraft ;
countT idThreadRefresh ;
countT cFilesIn ;
stackC* pStkActionMemory ;
stackC* pStkClone ;
countT idCursor = 1 ; //ALLOWABLE RANGE: [1,f]
countT idTypeDisplay = ifcIDtYPEdISPLAY_HOLLYWOOD ;
countT cRequestFresh ;
boolT bShowWhenFresh ;
boolT bOutOk ;
boolT bInOk ;
boolT bRightOk ;
boolT bLeftOk ;
boolT bUpOk ;
boolT bDownOk ;
batonC* pBatonTree ;
treeOldC* pTree ;

#define CaCTIONmEMORY 0x40

#define IDoP_HOME                          0x18
#define IDoP_END                           0x17
#define IDoP_KEY_m                         0x16
#define IDoP_STROKEeNTRY                   0x15
#define IDoP_MINUS                         0x14
#define IDoP_PLUS                          0x13
#define IDoP_TUTOR                         0x12
#define IDoP_KEY_z                         0x11
#define IDoP_KEY_w                         0x10
#define IDoP_KEY_t                         0xf
#define IDoP_KEY_s                         0xe
#define IDoP_KEY_p                         0xd
#define IDoP_KEY_i                         0xc
#define IDoP_KEY_k                         0xb
#define IDoP_KEY_h                         0xa
#define IDoP_KEY_g                         0x8
#define IDoP_KEY_o                         0x7
#define IDoP_OUTaRROW                      0x6
#define IDoP_INaRROW                       0x5
#define IDoP_RIGHTaRROW                    0x4
#define IDoP_LEFTaRROW                     0x3

#define IDoP_UPaRROW                       0x2
#define IDoP_DOWNaRROW                     0x1

#define MSR 8.0
#define FSR 1.0
#define MSC 32.0
#define FSC 32.0
//U::EDIT TO USE CELLS FRAMING
//'C''R':COL/ROW
//'S': SCALE
//'F''M': FEMALE/MALE

#define ROW7 (1.0)
#define ROW6 (ROW5+SHIFT)
#define ROW5 (2.0/3.0)
#define ROW4 (ROW3+SHIFT)
#define ROW3 (1.0/3.0)
#define ROW2 (ROW1+SHIFT)
#define ROW1 (0.0)

#define COL4 (1.0)
#define COL3 (2.0/3.0)
#define COL2 (1.0/3.0)
#define COL1 (0.0)

#define SHIFT (1.0/32.0)

#define CgENSsTATE 0x10

#define TmESSAGEtIMElATHfILE T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF2(DDNUMB,flFORMAT_NObIGITvALUES)+T("/time.message.lath")
#define TsTATEfILE           T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF2(DDNUMB,flFORMAT_NObIGITvALUES)+T("/ideafarm.kt.console.state")

;
}
    VK_CONTROL          , ifcIDtYPEtOOL_CONTROL
    VK_LWIN             , ifcIDtYPEtOOL_BASEoSlEFT ,
    VK_MENU             , ifcIDtYPEtOOL_ALT ,
    VK_SHIFT            , ifcIDtYPEtOOL_SHIFT ,
    VK_CAPITAL          , ifcIDtYPEtOOL_LOCKcAPS ,
    VK_TAB              , ifcIDtYPEtOOL_TAB ,
    VK_ESCAPE           , ifcIDtYPEtOOL_ESCAPE ,
    VK_F1               , ifcIDtYPEtOOL_F1 ,
    VK_F2               , ifcIDtYPEtOOL_F2 ,
    VK_F3               , ifcIDtYPEtOOL_F3 ,
    VK_F4               , ifcIDtYPEtOOL_F4 ,
    VK_F5               , ifcIDtYPEtOOL_F5 ,
    VK_F6               , ifcIDtYPEtOOL_F6 ,
    VK_F7               , ifcIDtYPEtOOL_F7 ,
    VK_F8               , ifcIDtYPEtOOL_F8 ,
    VK_F9               , ifcIDtYPEtOOL_F9 ,
    VK_F10              , ifcIDtYPEtOOL_F10 ,
    VK_F11              , ifcIDtYPEtOOL_F11 ,
    VK_F12              , ifcIDtYPEtOOL_F12 ,
    VK_SCROLL           , ifcIDtYPEtOOL_LOCKsCROLL ,
    VK_PAUSE            , ifcIDtYPEtOOL_PAUSE ,
    VK_CANCEL           , ifcIDtYPEtOOL_BREAK ,
    VK_INSERT           , ifcIDtYPEtOOL_INSERT ,
    VK_HOME             , ifcIDtYPEtOOL_HOME ,
    VK_PRIOR            , ifcIDtYPEtOOL_PAGEuP ,
    VK_DELETE           , ifcIDtYPEtOOL_DELETE ,
    VK_END              , ifcIDtYPEtOOL_END ,
    VK_NEXT             , ifcIDtYPEtOOL_PAGEdOWN ,
    VK_LEFT             , ifcIDtYPEtOOL_LEFT ,
    VK_DOWN             , ifcIDtYPEtOOL_DOWN ,
    VK_RIGHT            , ifcIDtYPEtOOL_RIGHT ,
    VK_UP               , ifcIDtYPEtOOL_UP ,
    VK_MENU             , ifcIDtYPEtOOL_ALTrIGHT ,
    VK_RWIN             , ifcIDtYPEtOOL_BASEoSrIGHT ,
    VK_APPS             , ifcIDtYPEtOOL_BASEoScELLlIST ,
    VK_CONTROL          , ifcIDtYPEtOOL_CONTROLrIGHT ,
    VK_SHIFT            , ifcIDtYPEtOOL_SHIFTrIGHT ,
    VK_RETURN           , ifcIDtYPEtOOL_ENTER ,
    VK_BACK             , ifcIDtYPEtOOL_BACKSPACE ,
    VK_SCROLL           , ifcIDtYPEtOOL_LOCKsCROLL ,
    VK_CAPITAL          , ifcIDtYPEtOOL_LOCKcAPS ,
    VK_INSERT           , ifcIDtYPEtOOL_INSERTnUM ,
    VK_DELETE           , ifcIDtYPEtOOL_DELETEnUM ,
    VK_RETURN           , ifcIDtYPEtOOL_ENTERnUM ,
    VK_NEXT             , ifcIDtYPEtOOL_PAGEdOWNnUM ,
    VK_DOWN             , ifcIDtYPEtOOL_DOWNnUM ,
    VK_END              , ifcIDtYPEtOOL_ENDnUM ,
    VK_LEFT             , ifcIDtYPEtOOL_LEFTnUM ,
    VK_CLEAR            , ifcIDtYPEtOOL_NULLnUM ,
    VK_RIGHT            , ifcIDtYPEtOOL_RIGHTnUM ,
    VK_PRIOR            , ifcIDtYPEtOOL_PAGEuPnUM ,
    VK_UP               , ifcIDtYPEtOOL_UPnUM ,
    VK_HOME             , ifcIDtYPEtOOL_HOMEnUM ,
    VK_EXECUTE          , ifcIDtYPEtOOL_PLUSnUM ,
    VK_INSERT           , ifcIDtYPEtOOL_MINUSnUM ,
    VK_PRINT            , ifcIDtYPEtOOL_MULTIPLYnUM ,
    VK_HELP             , ifcIDtYPEtOOL_DIVIDEnUM ,
    VK_NUMLOCK          , ifcIDtYPEtOOL_LOCKnUM ,
    VK_DELETE           , ifcIDtYPEtOOL_PERIODnUM ,
    VK_RETURN           , ifcIDtYPEtOOL_ENTERnUM ,
    VK_HELP             , ifcIDtYPEtOOL_DIVIDEnUM ,
    VK_PRINT            , ifcIDtYPEtOOL_MULTIPLYnUM ,
    VK_INSERT           , ifcIDtYPEtOOL_MINUSnUM ,
    VK_NUMLOCK          , ifcIDtYPEtOOL_LOCKnUM ,
    VK_ESCAPE           , ifcIDtYPEtOOL_ESCAPE ,
    VK_SPACE            , ifcIDtYPEtOOL_SPACE ,
    'Z'                 , ifcIDtYPEtOOL_z ,
    'Y'                 , ifcIDtYPEtOOL_y ,
    'X'                 , ifcIDtYPEtOOL_x ,
    'W'                 , ifcIDtYPEtOOL_w ,
    'V'                 , ifcIDtYPEtOOL_v ,
    'U'                 , ifcIDtYPEtOOL_u ,
    'T'                 , ifcIDtYPEtOOL_t ,
    'S'                 , ifcIDtYPEtOOL_s ,
    'R'                 , ifcIDtYPEtOOL_r ,
    'Q'                 , ifcIDtYPEtOOL_q ,
    'P'                 , ifcIDtYPEtOOL_p ,
    'O'                 , ifcIDtYPEtOOL_o ,
    'N'                 , ifcIDtYPEtOOL_n ,
    'M'                 , ifcIDtYPEtOOL_m ,
    'L'                 , ifcIDtYPEtOOL_l ,
    'K'                 , ifcIDtYPEtOOL_k ,
    'J'                 , ifcIDtYPEtOOL_j ,
    'I'                 , ifcIDtYPEtOOL_i ,
    'H'                 , ifcIDtYPEtOOL_h ,
    'G'                 , ifcIDtYPEtOOL_g ,
    'F'                 , ifcIDtYPEtOOL_f ,
    'E'                 , ifcIDtYPEtOOL_e ,
    'D'                 , ifcIDtYPEtOOL_d ,
    'C'                 , ifcIDtYPEtOOL_c ,
    'B'                 , ifcIDtYPEtOOL_b ,
    'A'                 , ifcIDtYPEtOOL_a ,
    'Z'                 , ifcIDtYPEtOOL_Z ,
    'Y'                 , ifcIDtYPEtOOL_Y ,
    'X'                 , ifcIDtYPEtOOL_X ,
    'W'                 , ifcIDtYPEtOOL_W ,
    'V'                 , ifcIDtYPEtOOL_V ,
    'U'                 , ifcIDtYPEtOOL_U ,
    'T'                 , ifcIDtYPEtOOL_T ,
    'S'                 , ifcIDtYPEtOOL_S ,
    'R'                 , ifcIDtYPEtOOL_R ,
    'Q'                 , ifcIDtYPEtOOL_Q ,
    'P'                 , ifcIDtYPEtOOL_P ,
    'O'                 , ifcIDtYPEtOOL_O ,
    'N'                 , ifcIDtYPEtOOL_N ,
    'M'                 , ifcIDtYPEtOOL_M ,
    'L'                 , ifcIDtYPEtOOL_L ,
    'K'                 , ifcIDtYPEtOOL_K ,
    'J'                 , ifcIDtYPEtOOL_J ,
    'I'                 , ifcIDtYPEtOOL_I ,
    'H'                 , ifcIDtYPEtOOL_H ,
    'G'                 , ifcIDtYPEtOOL_G ,
    'F'                 , ifcIDtYPEtOOL_F ,
    'E'                 , ifcIDtYPEtOOL_E ,
    'D'                 , ifcIDtYPEtOOL_D ,
    'C'                 , ifcIDtYPEtOOL_C ,
    'B'                 , ifcIDtYPEtOOL_B ,
    'A'                 , ifcIDtYPEtOOL_A ,
    0xdb                , ifcIDtYPEtOOL_SQUAREoPEN ,
    0xdd                , ifcIDtYPEtOOL_SQUAREcLOSE ,
    0xbc                , ifcIDtYPEtOOL_COMMA ,
    0xbe                , ifcIDtYPEtOOL_PERIOD ,
    0xbf                , ifcIDtYPEtOOL_DIVIDE ,
    0xde                , ifcIDtYPEtOOL_QUOTEsINGLE ,
    0xba                , ifcIDtYPEtOOL_SEMICOLON ,
    0xdc                , ifcIDtYPEtOOL_BACKsLASH ,
    0xbb                , ifcIDtYPEtOOL_EQUALS ,
    0xbd                , ifcIDtYPEtOOL_MINUS ,
    0xc0                , ifcIDtYPEtOOL_ACCENT ,
    0x30                , ifcIDtYPEtOOL_PARENcLOSE ,
    0x39                , ifcIDtYPEtOOL_PARENoPEN ,
    0x38                , ifcIDtYPEtOOL_MULTIPLY ,
    0x37                , ifcIDtYPEtOOL_AND ,
    0x36                , ifcIDtYPEtOOL_CARET ,
    0x35                , ifcIDtYPEtOOL_PERCENT ,
    0x34                , ifcIDtYPEtOOL_DOLLAR ,
    0x33                , ifcIDtYPEtOOL_POUND ,
    0x32                , ifcIDtYPEtOOL_AT ,
    0x31                , ifcIDtYPEtOOL_EXCLAIM ,
    0xbf                , ifcIDtYPEtOOL_QUESTION ,
    0xbe                , ifcIDtYPEtOOL_GREATERtHAN ,
    0xbc                , ifcIDtYPEtOOL_LESStHAN ,
    0xde                , ifcIDtYPEtOOL_QUOTEdOUBLE ,
    0xba                , ifcIDtYPEtOOL_COLON ,
    0xdc                , ifcIDtYPEtOOL_OR ,
    0xdd                , ifcIDtYPEtOOL_CURLEYcLOSE ,
    0xdb                , ifcIDtYPEtOOL_CURLEYoPEN ,
    0xbb                , ifcIDtYPEtOOL_PLUS ,
    0xbd                , ifcIDtYPEtOOL_UNDERSCORE ,
    0xc0                , ifcIDtYPEtOOL_TILDE ,
    0x6a                , ifcIDtYPEtOOL_MULTIPLYnUM ,
    0x6b                , ifcIDtYPEtOOL_PLUSnUM ,
    0x6d                , ifcIDtYPEtOOL_MINUSnUM ,
    0x6e                , ifcIDtYPEtOOL_PERIODnUM ,
    0x6f                , ifcIDtYPEtOOL_DIVIDEnUM ,
    0x69                , ifcIDtYPEtOOL_PAD9 ,
    0x68                , ifcIDtYPEtOOL_PAD8 ,
    0x67                , ifcIDtYPEtOOL_PAD7 ,
    0x66                , ifcIDtYPEtOOL_PAD6 ,
    0x65                , ifcIDtYPEtOOL_PAD5 ,
    0x64                , ifcIDtYPEtOOL_PAD4 ,
    0x63                , ifcIDtYPEtOOL_PAD3 ,
    0x62                , ifcIDtYPEtOOL_PAD2 ,
    0x61                , ifcIDtYPEtOOL_PAD1 ,
    0x60                , ifcIDtYPEtOOL_PAD0 ,
{
vkToolS pVkTool[] =
//U::MOVE THIS TO A BASE API (0b5)

;
}
    drawerHollywoodS( tinS& tinP , etherC& etherP ) ;
    ~drawerHollywoodS( voidT ) ;

    strokeS* psttSetSuffix ;
    strokeS* psttSetPrefixMale ;
    strokeS* psttSetPrefixFemale ;
    byteT ppbTcButtonBro[ 3 ] [ sizeof( tcButtonC ) ] ;
    byteT ppbTcButtonMom[ 3 ] [ sizeof( tcButtonC ) ] ;
    byteT ppbTcButtonDad[ 3 ] [ sizeof( tcButtonC ) ] ;
    byteT ppbTcButtonGMom[ 3 ] [ sizeof( tcButtonC ) ] ;
    byteT ppbTcButtonGDad[ 3 ] [ sizeof( tcButtonC ) ] ;
    byteT ppbTcButtonGGMom[ 3 ] [ sizeof( tcButtonC ) ] ;
    flagsT flTcFeatureDisable ;
    const flagsT flTcFeature ;
    strokeS* pstt3 ;
    strokeS* psttHighBorder ;
    strokeS* psttBranchEpilog ;
    strokeS* psttBranchPrologMale ;
    strokeS* psttBranchPrologFemale ;
    strokeS* pstt2 ;
    strokeS* psttUpHint ;
    strokeS* pstt1 ;
{
struct drawerHollywoodS

;
}
    countT id ;
    countT vk ;
{
struct vkToolS

#define WHEELpERIOD 0x10
#define POPUPiNVITE POPUP( T("IdeaFarm " "(tm) IPDOS is published by Wo'O Ideafarm:\r\n\r\n    http://www.ideafarm.com\r\n\r\n    " ifcEMAIL_OLDfROM "\r\n\r\nBug reports, comments, and especially subscribers are welcome.") ) ;

/*1*/WAKEsHOW( "code.mine.copy.of.a450104.for.rewrite.to.4650104" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

