
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#undef PUSHrEPLY
#undef PUSHsNIP
#undef REPLY
#undef PUSHK
#undef PEEP

DONEdRIVENsERVER( tmcHttpServerF )
}
    //etThread.traceF( tinP , T("tmcHttpServerF / ---- ") ) ;
    //tinP.pAdamGlobal1->pEtThreadMain->etherTestF( tinP ) ; //U:: TO FIND A BUG

    //}
    //    thirdC::osFireIF( tinP ) ;
    //    etThread.traceF( tinP , T("calling osFireIF") ) ;
    //{
    //if( bOsFire )

    TELL( "tmcHttpServerF: cleaning up (part 2)" ) ;
    }
        //LOGrAW( tLog ) ;
        //tLog += T("\r\n") ;
        //TELL( "appending log entry to log file" ) ;
    {
    if( !bDeadman ) //VISITORS CAN CONCEAL THEIR VISIT BY ASKING FOR DEADMAN URL

    { _IO_ etThread( tinP , pswTally ) ; }
    }
        }
            //else tLog += t2+TF2(*pswTally,flFORMAT_NObIGITvALUES)+t1+T(psttLeverUrlTally)+tcr ;
            if( psttLeverUrlTally && !etThread.strCompareF( tinP , psttLeverUrlTally , tSlashDeadman ) ) bDeadman = 1 ;
            psttLeverUrlTally = (strokeS*)pswTally->leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = pswTally->cFlavorsF( tinP ) ;
        TN( tcr , "\r\n" ) ;
        TN( t2 , "    " ) ;
        TN( t1 , ": " ) ;
    {
    ZE( boolT , bDeadman ) ;

    ;
    //
    //    +T("\r\n")
    //    +TF2(cHamburgersThisSession,flFORMAT_NObIGITvALUES)
    //    +T(" total:")
    //    +TF2(nnPeerP.pcId[0],flFORMAT_NObIGITvALUES)
    //    +T("| http 05 session peer:")
    //    TT(timeA1,timeA2)
    //
    //TN( tLog , "" ) ; tLog =
    etThread.osTimeNowF( tinP , timeA1 , timeA2 ) ;
    ZE( sCountT , timeA2 ) ;
    ZE( countT , timeA1 ) ;
    { _IO_ etThread( tinP , pswKV ) ; }
    TELL( "tmcHttpServerF: cleaning up (part 1)" ) ;

    }
        if( idEscaped ) (*pHttpRawCommandServerCBFP)( tinP , etThread , bQuitP , cArgAppP , *psoP , time1idleTimeoutReadP , time1idleTimeoutWriteP , sessionsP , nnPeerP , idEscaped ) ;
        TELL( "maybe calling raw command server" ) ;

        //LOGrAW( T("------------------------- E N D   O F   S E S S I O N -------------------------------------------------------\r\n") ) ;
        //CONoUTrAW( T("------------------------- E N D   O F   S E S S I O N -------------------------------------------------------\r\n") ) ;
        }
            if( bClose ) break ;

            etThread.traceF( tinP , T("accumulated time pending [nnPeer,time]:    ")+T(nnPeerP)+T("    ")+TT(timeTotalPending1,timeTotalPending2) , flTRACE_null , idTraceDivert ) ;
            etThread.osTimeAddF(      tinP , timeTotalPending1 , timeTotalPending2 , timeElapsed1 , timeElapsed2 ) ;
            etThread.osTimeSubtractF( tinP , timeElapsed1 , timeElapsed2 , timeStart1 , timeStart2 ) ;
            etThread.osTimeNowF(      tinP , timeElapsed1 , timeElapsed2 ) ;
            ZE( sCountT , timeElapsed2 ) ;
            ZE( countT  , timeElapsed1 ) ;

            if( idDesireOld ) etThread.osThreadSwitchingDesireF( tinP , idDesireOld ) ;

            etThread.delF( tinP , postBody    ) ;
            etThread.delF( tinP , psttAgent   ) ;
            etThread.delF( tinP , psttName    ) ;
            etThread.delF( tinP , psttQueryKV ) ;
            }
                }
                    //etThread.traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(nnPeerP)+T("    nonfile response has been written") , flTRACE_null , idTraceDivert ) ;

                    etThread.delF( tinP , psttKVReport ) ;
                    pswKV->freeNullsF( tinP ) ;
                    TELL( "cleaning up 5" ) ;
                    }
                        etThread.delF( tinP , psttv ) ;
                        strokeS*& psttv = *(strokeS**)&(countT&)*pswKV ;
                        psttLeverKV = (strokeS*)pswKV->leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = pswKV->cFlavorsF( tinP ) ;
                    TELL( "cleaning up 4" ) ;

                    etThread( tinP , pStkBodyDynamic ) ;
                    etThread( tinP , pStkBody ) ;
                    }
                        meP.swReply.ungrabF( tinP ) ;
                        ++ *pswTally ;
                        psttLeverUrlTally = psttName ;
                        meP.swReply.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        TELL( "tallying" ) ;
       
                        else etThread.delF( tinP , postsReply ) ;
                        }
                            //U:: LATER, PURGE BY NUMBER OF PLATES, BY AGE, AND/OR BY SIZE

                            pzCache->pushF( tinP , psttn , postsReply , costo , bTalkBody ? maxAgeMsNotFileTalkBody : maxAgeMsNotFileNotTalkBody , 1 ) ; // "1": "LENGTH PREFIXED, SO NEED TO USE POSTS( pb )"
                            boolT bTalkBody = psttName && !etThread.strCompareF( tinP , tSlashTalkBody , psttName ) ;

                            countT costo = COSTS( postsReply ) ;
                            etThread.strMakeF( tinP , psttn , tNameCache ) ; ___( psttn ) ;
                            ZE( strokeS* , psttn ) ;
                        {
                        if( pzCache && !bQuery )

                        }
                            }
                                bClose = 1 ;
                                //etThread.traceF( tinP , T("tmcHttpServerF: could not write to socket 109 [nnPeer]:    ")+T(nnPeerP) , flTRACE_null , idTraceDivert ) ;
                                POOPRqUIET
                            {
                            if( POOP )
                            psoP->writeF( tinP , POSTS( postsReply ) , COSTS( postsReply ) ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        TELL( "writing reply" ) ;

                        //}
                        //    LOGrAW( "\"\r\n" ) ;
                        //    LOGrAW( POSTS( postsReply ) ) ;
                        //    LOGrAW( "postsReply:\r\n\"" ) ;
                        //{
                        //if( bDebugLog )
                        //U::

                        }
                            }
                                pStkBody->extractF( 0 , tinP , 1 ) ;
                                DELzOMBIE( prPosts ) ;
                                pbRefC* prPosts = (pbRefC*)&(*pStkBody)[ 1 ] ;
                            {
                            while( !POOP && *pStkBody )
                            TELL( "cleaning up 3" ) ;

                            DEL( prPostsMugShot         ) ;
                            DEL( prPostsBarBrown        ) ;
                            DEL( prPostsBarGreen        ) ;
                            DEL( prPostsBarOrange       ) ;
                            DEL( prPostsBarGray         ) ;
                            DEL( prPostsBarMaroon2      ) ;
                            DEL( prPostsIdSession       ) ;
                            DEL( prPostsIdPort2         ) ;
                            DEL( prPostsIdPort1         ) ;
                            DEL( prPostsPort            ) ;

                            DEL( pRefReply ) ;
                            bOsFire = F(REPLY.flagsHttpReply) & flHTTPrEPLY_OSfIRE ;

                            DEL( prPostsCostBody ) ;
                            DEL( prPostsHttpLocation ) ;
                            }
                                DEL( prPostsHttp ) ;
                                }
                                    }
                                        while( !POOP && ~hWalk ) ;
                                        }
                                            etThread.memCopyF( tinP , postc , POSTS( rPosts ) , COSTS( rPosts ) ) ; postc += COSTS( rPosts ) ;
                                            pbRefC& rPosts = *(pbRefC*)&pStkBody->downF( tinP , hWalk ) ;
                                        {
                                        do
                                        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    if( *pStkBody )
            
                                    etThread.memCopyF( tinP , postc , "\r\n\r\n" , 4                                                                         ) ; postc += 4                                    ;

                                    if( bClose ) { etThread.memCopyF( tinP , postc , postOldConnectionClose , sizeof postOldConnectionClose - 1              ) ; postc += sizeof postOldConnectionClose - 1    ; }

                                    }
                                        }
                                            etThread.memCopyF( tinP , postc , tKV , tKV.csF( tinP ) ) ; postc += tKV.csF( tinP ) ;
                                            TN( tKV , "?" ) ; tKV += T(psttQueryKV) ;
                                        {
                                        if( bQuery )

                                        etThread.memCopyF( tinP , postc , POSTS( *prPostsHttpLocation ) , COSTS( *prPostsHttpLocation ) ) ; postc += COSTS( *prPostsHttpLocation ) ;
                                        etThread.memCopyF( tinP , postc , postLocationKey               , sizeof postLocationKey - 1    ) ; postc += sizeof postLocationKey - 1    ;
                                    {
                                    if( prPostsHttpLocation )

                                    if( prPostsCostBody ) { etThread.memCopyF( tinP , postc , POSTS( *prPostsCostBody ) , COSTS( *prPostsCostBody ) ) ; postc += COSTS( *prPostsCostBody ) ; }
                                    if( prPostsHttp     ) { etThread.memCopyF( tinP , postc , POSTS( *prPostsHttp     ) , COSTS( *prPostsHttp     ) ) ; postc += COSTS( *prPostsHttp     ) ; }
                                    *(countT*)postc = costReply ; postc += sizeof( countT ) ;
                                    osTextT* postc = postsReply ;
                                {
                                if( postsReply )
                                etThread.newF( tinP , LF , postsReply , sizeof( countT ) + costReply + 1 ) ; ___( postsReply ) ;

                                if( bClose ) costReply += sizeof postOldConnectionClose - 1 ;
                                if( prPostsHttpLocation ) costReply += sizeof postLocationKey - 1 + COSTS( *prPostsHttpLocation ) + ( bQuery ? 1 + psttQueryKV->idAdam : 0 ) ;

                                }
                                    etThread.strMakeFromOsTextF( tinP , psttQueryKV , "rc=" postREFERRALcHAMPIONiD ) ; ___( psttQueryKV) ;
                                    etThread.delF( tinP , psttQueryKV ) ;
                                {
                                if( !psttQueryKV || !psttQueryKV->idAdam )

                                ;
                                    + costBody
                                    + 4
                                    + ( !prPostsCostBody ? 0 : COSTS( *prPostsCostBody ) )
                                      ( !prPostsHttp     ? 0 : COSTS( *prPostsHttp     ) )
                                countT costReply =

                                const osTextT postLocationKey[] = { "\r\nLocation: " } ;
                                const osTextT postOldConnectionClose[] = { "\r\nConnection: close" } ;

                                meP.getSnipF( tinP , prPostsHttp , REPLY.idSnipHttpPrefix ) ; ___( prPostsHttp ) ;
                                ZE( pbRefC* , prPostsHttp ) ;
                            {
                            TELL( "building postsReply" ) ;
        
                            }
                                etThread.strMakeF( tinP , prPostsCostBody , TF4(costBody,flFORMAT_NObASE|flFORMAT_FOREIGN,0,0xa) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsCostBody ) ;

                                }
                                    while( !POOP && ~hWalk ) ;
                                    }
                                        costBody += COSTS( rPosts ) ;
                                        pbRefC& rPosts = *(pbRefC*)&pStkBody->downF( tinP , hWalk ) ;
                                    {
                                    do
                                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( *pStkBody )
                            {                                                                           
                            ZE( countT , costBody ) ;
                            ZE( pbRefC* , prPostsCostBody ) ;
                            TELL( "getting prPostsCostBody" ) ;

                            }
                                PUSHK( prPostsHttpLocation ) ;
                            {
                            if( REPLY.idSnipHttpPrefix == ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP && !*pStkBody )

                            }
                                meP.getSnipF( tinP , prPostsHttpLocation , idSnip ) ; ___( prPostsHttpLocation ) ;
                                if( !idSnip ) idSnip =  ifcIDsNIPpREDEFINED_HTTPlOCATIONrOOT ;
                                countT idSnip = REPLY.idSnipHttpLocation ;
                            {
                            if( REPLY.idSnipHttpPrefix == ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP )
                            ZE( pbRefC* , prPostsHttpLocation ) ;

                            }
                                }
                                    break ;
                                    BLAMMO ;
                                {
                                default :
                                }
                                    break ;

                                    }
                                        }
                                            break ;
                                            BLAMMO ;
                                        {
                                        default :
                                        }
                                            break ;

                                            DEL( prPostsLathPeanut ) ;

                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_FOOT3        ) ;
                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_FOOTaDlINKS  ) ;
                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_FOOTiMAGEaDS ) ;
                                            PUSHsNIP( meP , !sessionP.getIdAccountCommissionF( tinP ) ? ifcIDsNIPpREDEFINED_FOOT1 : ifcIDsNIPpREDEFINED_FOOT2 ) ;

                                            }
                                                pStkBodyDynamic->extractF( (byteT*)&(*pStkBody)[ - 1 ] , tinP , 1 ) ;
                                                *pStkBody << (byteT*)0 ;
                                            {
                                            while( !POOP && *pStkBodyDynamic )
                                            PUSHrEPLY( prPostBody ) ;
                            
                                            }
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD61         ) ;
                                                PUSHrEPLY( prPostDescription ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD51         ) ;
                                                PUSHrEPLY( prPostTitle ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD41         ) ;
                                            {
                                            if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 

                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD31         ) ;
                
                                            //}
                                            //    ) ;
                                            //            : ifcIDsNIPpREDEFINED_HEADfDlINKSgOOGLE
                                            //            ? ifcIDsNIPpREDEFINED_HEADfDlINKSbLANK
                                            //        F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DOnOTdISPLAYtHIRDpARTYaDS
                                            //    *pStkBody << (countT)meP.getSnipF( tinP ,
                                            //{
                                            //if( bShowAdLinks )
                                            //}
                                            //    ) ;
                                            //            : ifcIDsNIPpREDEFINED_HEADiMAGEaDSgOOGLE
                                            //            ? ifcIDsNIPpREDEFINED_HEADiMAGEaDSbLANK
                                            //        F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DOnOTdISPLAYtHIRDpARTYaDS
                                            //    *pStkBody << (countT)meP.getSnipF( tinP ,
                                            //{
                                            //if( bShowImageAds )
                                            //OBSOLETE: NOT EDITED TO USE pbRefC
              
                                            if( idBannerAd ) PUSHsNIP( meP , ifcIDsNIPrESERVEDbANNER - 1 + idBannerAd ) ;
                                            PUSHK( prPostsBarBrown  ) ;
                                            PUSHK( prPostsBarGreen  ) ;

                                            }
                                                if( idBannerAd == 8 ) PUSHK( prPostsBarOrange ) ;
                                                PUSHK( prPostsBarGray   ) ;
                                            {
                                            if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 

                                            PUSHK( prPostsBarMaroon2 ) ;
                                            }
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD21         ) ;
                                                PUSHK( prPostsIdSession ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD11         ) ;
                                                PUSHK( prPostsPort ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD01         ) ;
                                                PUSHK( prPostsIdPort2 ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADf         ) ;
                                            {
                                            if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 

                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADe         ) ;
                                            PUSHK( prPostsMugShot ) ;
                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADd         ) ;

                                            }
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD91        ) ;
                                                PUSHrEPLY( prPostDescription ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD81        ) ;
                                                PUSHrEPLY( prPostTitle ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD71        ) ;
                                            {
                                            else
                                            }
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADc         ) ;
                                                PUSHK( prPostsLathPeanut ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADb         ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADa         ) ;
                                                PUSHrEPLY( prPostUrl ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD9         ) ;
                                                PUSHK( prPostsIdPort1 ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD8         ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD7         ) ;
                                                PUSHrEPLY( prPostSlogan ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD6         ) ;
                                            {
                                            if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 

                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD5         ) ;
                                            //reserved: error message goes here
                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD4         ) ;
                                            PUSHrEPLY( prPostKeywords ) ;
                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD3         ) ;
                                            PUSHrEPLY( prPostMetaDescription ) ;
                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD2         ) ;
                                            PUSHrEPLY( prPostTitle ) ;
                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD1         ) ;
                                            TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/pushing snips" ) ;

                                            }
                                                etThread.delF( tinP , pczName ) ;

                                                THREADmODE2rESTORE
                                                }
                                                    etThread.delF( tinP , postLathPeanut ) ;
                                                    if( postLathPeanut ) { etThread.strMakeF( tinP , prPostsLathPeanut , T(postLathPeanut) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsLathPeanut ) ; }
                                                    puseC puseWork1( tinP , ifcIDpOOL_ADAMtEMP ) ; //--------------------------------------------------------------------------------------
                                                    //PUSE.list_osTextTstrz_Old 2012F( tinP , postLathPeanut , pczName ) ; //A:ASSUME: ANOTHER THREAD MIGHT REPLACE THIS VALUE WHILE I AM USING THIS POINTER, BUT THIS POINTER WILL REMAIN POINTING TO VALID STORAGE
                                                    puseC pusePeanut( pusePeanutP ) ;
                                                    ZE( osTextT* , postLathPeanut ) ;
                                                {
                                                THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                                                { countT pczFrom[] = { LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION , idPortMe | BM_HIGH , 0 } ; etThread.strStretchIF( tinP , pczName , pczFrom , T(POSTS(*REPLY.prPostUrl)) ) ; ___( pczName ) ; }
                                                ZE( countT* , pczName ) ;
                                            {
                                            if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                            ZE( pbRefC* , prPostsLathPeanut ) ;
                                            TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/making posts 4" ) ;
            
                                            //;
                                            //)
                                            //                : "have neither"
                                            //                ? "have green"
                                            //            : prPostsBarGreen
                                            //            ? "have brown"
                                            //        : prPostsBarBrown
                                            //        ? "have both"
                                            //    prPostsBarBrown && prPostsBarGreen
                                            //(
                                            //POPUP

                                            }
                                                ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarBrown ) ;
                
                                                        "</tr>\r\n"
                                                            "</td>\r\n"
                                                                "</SPAN>\r\n"
                                                                    "<B>IdeaFarm</B> (tm) <B>Space</B>\r\n"
                                                                "<SPAN class=spaXXSmall>\r\n"
                                                            "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTbROWN  " ; color=#840\">\r\n"
                                                        "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyBrownF() ;\">\r\n"
                
                                                etThread.strMakeF( tinP , prPostsBarBrown , T(
                                            {
                                            else
                                            }
                                                ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarGreen ) ;
                                            
                                                        "</tr>\r\n"
                                                            "</td>\r\n"
                                                                "</SPAN>\r\n"
                                                                    " <> <B>Federal Constitutional Protectorate of the United States of America</B>\r\n"
                                                                    "<B>IdeaFarm</B> (tm) <B>City</B>"
                                                                "<SPAN class=spaXXSmall>\r\n"
                                                            "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ; color=#060\">\r\n"
                                                        "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyGreenF() ;\">\r\n"
                                            
                                                etThread.strMakeF( tinP , prPostsBarGreen , T(
                                            {
                                            if( idPortMe == ifcIDpORT_DOOR || idPortMe == ifcIDpORT_PANICdOOR )
            
                                            }
                                                }
                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarOrange ) ;
                    
                                                            "</A>\r\n"
                                                                "</tr>\r\n"
                                                                    "</td>\r\n"
                                                                        "</SPAN>\r\n"
                                                                            "ALERT: Price Doubling for <B>IdeaFarm</B> (tm) <B>Basic Privileges</B> will occur within 0-64 days.<BR><CENTER><I>Click here or you'll regret it!</I></CENTER>\r\n "
                                                                        "<SPAN class=spaLarge>\r\n"
                                                                    "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaLERT " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL "\">\r\n"
                                                                "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyOrangeF() ;\">\r\n"
                                                            "<A HREF=\"/header/action/alert.html\">\r\n"
        
                                                    etThread.strMakeF( tinP , prPostsBarOrange , T(
                                                {
                                                if( idBannerAd == 8 )
        
                                                ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarGray ) ;
                
                                                        "</tr>\r\n"
                                                            "</td>\r\n"
                                                                "</SPAN>\r\n"
                                                                    "<BR>system status: occasional service interruptions (2 per day), each lasting about 5 minutes\r\n "
                                                                    //"<BR>system status: irregular service interruptions (1 to 3 per hour), each lasting about 1 minute\r\n "
                                                                    //"<BR>system status: frequent service interruptions (8 per hour), each lasting about 1 minute\r\n "
                                                                    "<A HREF=\"/nobot/header/calendar.html\"  onMouseOut=\"swatF() ;\" onMouseOver=\"flyTimeF() ;\">")+TnOWtICK+T("</A>\r\n"
                                                                "<SPAN class=spaXXSmall>\r\n"
                                                            "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnOTEdIM " ; color=#ccc\">\r\n"
                                                        "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyGrayF() ;\">\r\n"
                
                                                etThread.strMakeF( tinP , prPostsBarGray , T(
                                            {
                                            if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                            TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/making posts 3" ) ;

                                            }
                                                etThread.delF( tinP , psttEmail ) ;
                                                ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarMaroon2 ) ;
                
                                                        "</tr>\r\n"
                                                            "</td>\r\n"
                                                                "</SPAN>\r\n"
                                                                    +T("\r\n "
                                                                    + tLinks
                                                                "<SPAN class=spaXXSmall>\r\n")
                                                            "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTrED   " ; color:" ifcCOLORhTMLwHAT_FOREaCCENTrED    "\">\r\n"
                                                        "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyMaroon2F() ;\">\r\n"
        
                                                etThread.strMakeF( tinP , prPostsBarMaroon2 , T(

                                                if( !tLinks.csF( tinP ) ) tLinks += T("Connecting People Wholesomely") ;

                                                }
                                                    }
                                                        tLinks += tLinkMore ;
                                                    
                                                        ) ;
                                                    
                                                            : "verbose\" onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'This page header is abbreviated.  Click here to indicate that you want to see full page headers during this session.' );\">more</A>"
                                                            ? "terse\"   onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'This is the full page header.  Click here to indicate that you want to see brief page headers during this session.' );\">less</A>"
                                                    
                                                        tLinkMore += T( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE
                                                        TN( tLinkMore , "<A HREF=\"" ) ; tLinkMore += T(POSTS(*REPLY.prPostUrl))+T("?headflavor=") ;
                                                        if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                    {
                                                    if( bAllowBigHead )
                                                {
                                                //if( sessionP.getIdAccountF( tinP ) == 1 )
                                                //BEFORE MAKING THIS VISIBLE, THE ENTIRE "MORE" WEB SITE MUST BE EDITED TO ELIMINATE INACCURACIES (E.G. DISCUSSING FREEBIES WHEN THERE AREN'T ANY YET)
                                                //THIS ALL WORKS BUT IS HIDDEN TO KEEP THE WEB SITE SIMPLE AND TO LIMIT THE SCOPE OF CUSTOMER SERVICE DURING LAUNCH OF THE MAIN PRODUCT (DIRECTORY)

                                                }
                                                    tLinks += T("<A HREF=\"http://ideafarm.com/\" onMouseOut=\"swatF() ;\" onMouseOver=\"flyF( 'Click to display the IDEAFARM.COM domain root (home) page.' ) ;\">IDEAFARM.COM</A>\r\n") ;
                                                    if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                {
                                                if( !bIsRootPage && !bIsHelpPage )

                                                }
                                                    }
                                                        tLinks += T("<A HREF=\"/nobot/help/help.html?url=")+T(POSTS(*REPLY.prPostUrl))+T("\"")+T(bIsHelpPage?"":" TARGET=\"_blank\"")+tFlyHelp+T(">")+tHelp+T("</A>\r\n") ;
                                                        if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                    {
                                                    if( psttEmail )
        
                                                    }
                                                        tLinks += T("<A HREF=\"/header/do.html\"    onMouseOut=\"swatF() ;\" onMouseOver=\"flyF( this , 'Work and play and live in IdeaFarm " "(tm) City!' ) ;\">do</A>\r\n") ;
                                                        if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                    {
                                                    if( psttEmail && idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE )
                                                {
                                                if( sessionP.getIdAccountF( tinP ) == 1 )
                                                //THIS ALL WORKS BUT IS HIDDEN TO KEEP THE WEB SITE SIMPLE AND TO LIMIT THE SCOPE OF CUSTOMER SERVICE DURING LAUNCH OF THE MAIN PRODUCT (DIRECTORY)

                                                }
                                                    ;

                                                        : T("<A HREF=\"/header/action/login.html\"  onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'Click here to log in.  Anywo with an email address can log in; you do not need to open an account or create a password.  A login link that can only be used wo time will be sent to your email address immediately.' );\">login</A>")
                                                        ? T("<A HREF=\"/header/action/logout.html\" onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'Click here to log out.  This is important if you are using a public computer or if your computer can be accessed by others.');\">logout</A> <> ")+T(psttEmail)

                                                    tLinks += psttEmail

                                                    if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                {
                                                if( sessionP.getIdAccountCommissionF( tinP ) || sessionP.getIdAccountF( tinP ) ) // MIGHT HAVE LOGGED IN BY CLICKING AN OLD EMAIL LINK AND HAS NOT SELECTED A RECRUITER

                                                TN( tSpace , " <> " ) ;
                                                TN( tLinks , "" ) ;

                                                sessionP.getEmailF( tinP , psttEmail ) ; ___( psttEmail ) ;
                                                ZE( strokeS* , psttEmail ) ;
                                            {
                                            TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/making posts 2" ) ;

                                            ) ;

                                                : " onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'A helpful information page is NOT available for the page that you are viewing, but click here anyway to view the general helpful information page for IdeaFarm " "(tm) City.' );\""
                                                ? " onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'A helpful information page is available for the page that you are viewing.' );\""

                                            TN( tFlyHelp , bExistHelp

                                            ) ;
                                                    : "help"
                                                    ? "HELP"
                                                : bExistHelp
                                                ? "aboutHelp"
                                            TN( tHelp , bIsHelpPage

                                            const boolT bExistHelp  = REPLY.prPostPageHelp && COSTS( REPLY.prPostPageHelp ) ;
                                            const boolT bIsHelpPage = !!etThread.strIdF( tinP , T("/nobot/help/") , tUrl ) ;
                                            //const boolT bIsLogoutPage = 1 == etThread.strIdF( tinP , T("/header/action/logout.html") , tUrl ) ;

                                            ;
                                                )
                                                    1 == etThread.strIdF( tinP , T("/?") , tUrl )
                                                    !etThread.strCompareF( tinP , tSlash , tUrl ) ||
                                                (
                                                idPortMe == ifcIDpORT_HTTP                      &&
                                            const boolT bIsRootPage =

                                            TN( tUrl , POSTS( *REPLY.prPostUrl ) ) ;

                                            }
                                                , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsMugShot ) ;
        
                                                    : T("<IMG onMouseOut=\"swatF();\" onMouseOver=\"flyF( this , 'The Earth, depicted with the Sun and Moon on a field of stars, is the official symbol for IdeaFarm " "(tm) Associates.  The lower hand, Youth, receives Earth from the upper hand, Elders.   A female breast appears in the place of a continent.  The wise infant does not bite his mother while suckling, and the wise elder never forgets his debt.  Love your Mother!' );\" SRC=\"/blob/ifc.ico\" alt=\"\" border=\"0\">\r\n")
                                                    ? T("<IMG SRC=\"/blob/user.")+TF4(idAccCommission,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(".64x48.jpeg\" alt=\"\" border=\"0\">\r\n")
        
                                                etThread.strMakeF( tinP , prPostsMugShot , idAccCommission
        
                                                idAccCommission      = session.getIdAccountCommissionF( tinP ) ; //MUST BE DONE AFTER DYNAMIC CONTENT CALL HAS BEEN MADE
                                                sessionC& session = sessionsP( tinP , nnPeerP ) ;
                                                ZE( countT , idAccCommission ) ;
                                            {

                                            }
                                                etThread.strMakeF( tinP , prPostsPort            , T((const strokeS*)*psoP)    , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsPort            ) ;
                                                etThread.strMakeF( tinP , prPostsIdPort2         , TF1(idPortMe)               , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdPort2         ) ;
                                                etThread.strMakeF( tinP , prPostsIdPort1         , TF1(idPortMe)               , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdPort1         ) ;
                                                etThread.strMakeF( tinP , prPostsIdSession       , TF1((countT)sessionP)       , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdSession       ) ;
                                            {
                                            if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                            TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/making posts" ) ;
            
                                            //}
                                                //}
                                                //    bShowImageAds = etherC::ranUniI_IF( tinP ) <= mProb ; //"=" IS REDUNDANT BECAUSE ranUniC GUARANTEES RESULT STRICTLY LESS THAN RANGE 
                                                //    measure04T mProb = !etThread.strCompareF( tinP , psttName , tSlash ) ? 1.0 / 8.0 : 1.0 / 4.0 ;
                                                //{
                                                //if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_HIDEiMAGEaDS ) )
                
                                                //if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_HIDEaDlINKS ) ) bShowAdLinks = 1 ;
                                            //{
                                            //if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                            //ZE( boolT , bShowImageAds ) ;
                                            //ZE( boolT , bShowAdLinks ) ;

                                            else if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) idHeadFlavor = ifcIDhEADfLAVOR_TERSE ;
                                            if( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_FULLhEADER ) bAllowBigHead = 1 ;
                                            ZE( boolT , bAllowBigHead ) ;
            
                                            }
                                                (*REPLY.pCBF)( tinP , etThread , bQuitP , meP , cArgAppP , REPLY , *pStkBodyDynamic , psttKVReport , *pswKV , psttLeverKV , sessionsP , nnPeerP , psttName , psttQueryKV , psttAgent , postBody ) ;
                                                TELL( T(psttName) ) ;
                                                _IO_
                                            {
                                            if( REPLY.pCBF )
                                            //DONE EARLY TO GIVE CBF AN EARLY CHANCE TO CHANGE STATE IN WAYS THAT WILL AFFECT BUILDING OF HEADER

                                            }
                                                }
                                                    etThread.traceF( tinP , T("tmcHttpServerF: could not obtain socket my name 611") ) ;
                                                    POOPRqUIET
                                                {
                                                if( POOP )
                                                psoP->myNameF( tinP , idPortMe , nnMe ) ;
                                                SCOOPS
                                            {
                                            IFsCRATCH
                                            nicNameC nnMe ;
                                            ZE( countT , idPortMe ) ;
                                            TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/getting nnMe" ) ;
            
                                            }
                                            
                                                }
                                                    }
                                                        }
                                                            idBannerAd = 1 + (countT)( mSwitch / mCutSwitch ) ;
                                                            measureT mCutSwitch = (measureT)1.0 / (measureT)cAd ;
                                                            measureT mSwitch = etherC::ranUniI_IF( tinP ) ;
                                                        {
                                                        if( mDo < mCutDo )
                                                        measureT mCutDo = 1.0 / 4.0 ;
                                                        measureT mDo    = etherC::ranUniI_IF( tinP ) ;
                                                    {
                                                    else if( idAd > cAd * 2 )
                                                    else if( idAd <= 4 + cAd ) idBannerAd = idAd - 4 ;
                                                    if( idAd <= 4 ) ;
                                                    const countT cAd = 8 ; //CS:CODEsYNC: 1d20003 0b5000d
                                                    countT idAd = session.dispenseIdF( tinP , 1 ) ;
            
                                                {
                                            {
                                            )
                                                etThread.strCompareF( tinP , psttName , T("/header/idea/slideshow.regrets.html") )
                                                etThread.strCompareF( tinP , psttName , T("/header/idea/slideshow.tellin.it.html") )    &&
                                                etThread.strCompareF( tinP , psttName , T("/"                          ) )              &&
                                                psttName                                                                                &&
                                                idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE                                            &&
                                            (
                                            if
                                            ZE( countT , idBannerAd ) ;
                                            sessionC& session = sessionsP( tinP , nnPeerP ) ;
                                            TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD" ) ;
                                        {
                                        case ifcIDfORMhTTPrEPLY_BIGhEAD :
                                        case ifcIDfORMhTTPrEPLY_PINhEAD :
                                        }
                                            break ;
                                        {
                                        case ifcIDfORMhTTPrEPLY_DEBUG :
                                        }
                                            break ;

                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_FOOT3        ) ;
                                            PUSHsNIP( meP , !sessionP.getIdAccountCommissionF( tinP ) ? ifcIDsNIPpREDEFINED_FOOT1 : ifcIDsNIPpREDEFINED_FOOT2 ) ;
                                            //THESE WERE REMOVED IN 2019. 20200729@1734: ENABLED WITHOUT ANALYSIS
                            
                                            }
                                                (*REPLY.pCBF)( tinP , etThread , bQuitP , meP , cArgAppP , REPLY , *pStkBody , psttKVReport , *pswKV , psttLeverKV , sessionsP , nnPeerP , psttName , psttQueryKV , psttAgent , postBody ) ;
                                                _IO_
                                            {
                                            if( REPLY.pCBF )

                                            PUSHrEPLY( prPostBody ) ;
                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD4         ) ;
                                            PUSHrEPLY( prPostKeywords ) ;
                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD3         ) ;
                                            PUSHrEPLY( prPostMetaDescription ) ;
                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD2         ) ;
                                            PUSHrEPLY( prPostTitle ) ;
                                            PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD1         ) ;
                                            TELL( "ifcIDfORMhTTPrEPLY_FULLcUSTOM/pushing snips" ) ;
            
                                            }
                                                ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarBrown ) ;
                
                                                        "</tr>\r\n"
                                                            "</td>\r\n"
                                                                "</SPAN>\r\n"
                                                                    "<B>IdeaFarm</B> (tm) <B>Space</B>\r\n"
                                                                "<SPAN class=spaXXSmall>\r\n"
                                                            "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTbROWN  " ; color=#840\">\r\n"
                                                        "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyBrownF() ;\">\r\n"
                
                                                etThread.strMakeF( tinP , prPostsBarBrown , T(
                                            {
                                            else
                                            }
                                                ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarGreen ) ;
                                            
                                                        "</tr>\r\n"
                                                            "</td>\r\n"
                                                                "</SPAN>\r\n"
                                                                    " <> <B>Federal Constitutional Protectorate of the United States of America</B>\r\n"
                                                                    "<B>IdeaFarm</B> (tm) <B>City</B>"
                                                                "<SPAN class=spaXXSmall>\r\n"
                                                            "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ; color=#060\">\r\n"
                                                        "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyGreenF() ;\">\r\n"
                                            
                                                etThread.strMakeF( tinP , prPostsBarGreen , T(
                                            {
                                            if( idPortMe == ifcIDpORT_DOOR || idPortMe == ifcIDpORT_PANICdOOR )
            
                                            ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarGray ) ;
            
                                                    "</tr>\r\n"
                                                        "</td>\r\n"
                                                            "</SPAN>\r\n"
                                                                "<>\r\n "
                                                            "<SPAN class=spaXXSmall>\r\n"
                                                        "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnOTEdIM " ; color:" ifcCOLORhTMLwHAT_FOREnOTEbRIGHT "\">\r\n"
                                                    "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyGrayF() ;\">\r\n"
            
                                            etThread.strMakeF( tinP , prPostsBarGray , T(
                                            etThread.strMakeF( tinP , prPostsPort            , T((const strokeS*)*psoP)    , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsPort            ) ;
                                            etThread.strMakeF( tinP , prPostsIdPort2         , TF1(idPortMe)               , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdPort2         ) ;
                                            etThread.strMakeF( tinP , prPostsIdPort1         , TF1(idPortMe)               , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdPort1         ) ;
                                            etThread.strMakeF( tinP , prPostsIdSession       , TF1((countT)sessionP)       , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdSession       ) ;
                                            TELL( "ifcIDfORMhTTPrEPLY_FULLcUSTOM/making posts" ) ;
            
                                            //}
                                            //    bShowImageAds = etherC::ranUniI_IF( tinP ) <= mProb ; //"=" IS REDUNDANT BECAUSE ranUniC GUARANTEES RESULT STRICTLY LESS THAN RANGE 
                                            //    measure04T mProb = !etThread.strCompareF( tinP , psttName , tSlash ) ? 1.0 / 8.0 : 1.0 / 4.0 ;
                                            //{
                                            //if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_HIDEiMAGEaDS ) )
                                            //ZE( boolT , bShowImageAds ) ;
            
                                            //if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_HIDEaDlINKS ) ) bShowAdLinks = 1 ;
                                            //ZE( boolT , bShowAdLinks ) ;

                                            }
                                                }
                                                    etThread.traceF( tinP , T("tmcHttpServerF: could not obtain socket my name 734") ) ;
                                                    POOPRqUIET
                                                {
                                                if( POOP )
                                                psoP->myNameF( tinP , idPortMe , nnMe ) ;
                                                SCOOPS
                                            {
                                            IFsCRATCH
                                            nicNameC nnMe ;
                                            ZE( countT , idPortMe ) ;
                                            TELL( "ifcIDfORMhTTPrEPLY_FULLcUSTOM/getting nnMe" ) ;
            
                                            }
                                            
                                                }
                                                    }
                                                        }
                                                            idBannerAd = 1 + (countT)( mSwitch / mCutSwitch ) ;
                                                            measureT mCutSwitch = (measureT)1.0 / (measureT)cAd ;
                                                            measureT mSwitch = etherC::ranUniI_IF( tinP ) ;
                                                        {
                                                        if( mDo < mCutDo )
                                                        measureT mCutDo = 1.0 / 4.0 ;
                                                        measureT mDo    = etherC::ranUniI_IF( tinP ) ;
                                                    {
                                                    else if( idAd > cAd * 2 )
                                                    else if( idAd <= 4 + cAd ) idBannerAd = idAd - 4 ;
                                                    if( idAd <= 4 ) ;
                                                    const countT cAd = 8 ; //CS:CODEsYNC: 1d20003 0b5000d
                                                    countT idAd = session.dispenseIdF( tinP , 1 ) ;
            
                                                    sessionC& session = sessionsP( tinP , nnPeerP ) ;
                                                {
                                            {
                                            )
                                                etThread.strCompareF( tinP , psttName , T("/header/idea/slideshow.regrets.html") )
                                                etThread.strCompareF( tinP , psttName , T("/header/idea/slideshow.tellin.it.html") )    &&
                                                etThread.strCompareF( tinP , psttName , T("/"                          ) )              &&
                                                psttName                                                                                &&
                                            (
                                            if
                                            ZE( countT , idBannerAd ) ;
                                            TELL( "ifcIDfORMhTTPrEPLY_FULLcUSTOM" ) ;
                                        {
                                        case ifcIDfORMhTTPrEPLY_FULLcUSTOM :
                                        }
                                            break ;

                                            }
                                                (*REPLY.pCBF)( tinP , etThread , bQuitP , meP , cArgAppP , REPLY , *pStkBody , psttKVReport , *pswKV , psttLeverKV , sessionsP , nnPeerP , psttName , psttQueryKV , psttAgent , postBody ) ;
                                                _IO_
                                            {
                                            if( REPLY.pCBF )

                                            PUSHrEPLY( prPostBody ) ;

                                            httpReplyS& info = *(httpReplyS*)&(baseRefC&)*pRefReply ;
            
                                            psoP->myNameF( tinP , idPortMe , nnMe ) ;
                                            nicNameC nnMe ;
                                            ZE( countT , idPortMe ) ;
                                            TELL( "ifcIDfORMhTTPrEPLY_RAW" ) ;
                                        {
                                        case ifcIDfORMhTTPrEPLY_RAW :
                                    {
                                    switch( REPLY.idForm )
                                {
                                case ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP :
                                case ifcIDsNIPpREDEFINED_HTTPfAILmOVED :
                                case ifcIDsNIPpREDEFINED_HTTPfAILnOTfOUND :
                                case ifcIDsNIPpREDEFINED_HTTPoKtEXThTML :
                                }
                                    break ;
                                    PUSHrEPLY( prPostBody ) ;
                                {
                                case ifcIDsNIPpREDEFINED_HTTPoKmP3 :
                                case ifcIDsNIPpREDEFINED_HTTPoKiMAGEjPEG :
                                case ifcIDsNIPpREDEFINED_HTTPoKiMAGEgIF :
                                case ifcIDsNIPpREDEFINED_HTTPoKiMAGEiCON :
                                }
                                    break ;
                                {
                                case ifcIDsNIPpREDEFINED_HTTPcONTINUEwELCOME :
                            {
                            switch( REPLY.idSnipHttpPrefix )
                            ZE( pbRefC* , prPostsMugShot         ) ;
                            ZE( pbRefC* , prPostsBarBrown        ) ;
                            ZE( pbRefC* , prPostsBarGreen        ) ;
                            ZE( pbRefC* , prPostsBarOrange       ) ;
                            ZE( pbRefC* , prPostsBarGray         ) ;
                            ZE( pbRefC* , prPostsBarMaroon2      ) ;
                            ZE( pbRefC* , prPostsIdSession       ) ;
                            ZE( pbRefC* , prPostsIdPort2         ) ;
                            ZE( pbRefC* , prPostsIdPort1         ) ;
                            ZE( pbRefC* , prPostsPort            ) ;

                            //POPUPcOUNT( "idHeadFlavor after: " , idHeadFlavor ) ;
                            ;
                                    : ifcIDhEADfLAVOR_VERBOSE
                                    ? ifcIDhEADfLAVOR_TERSE
                                : REPLY.idForm == ifcIDfORMhTTPrEPLY_PINhEAD
                                ? idHeadFlavorOverride
                            countT idHeadFlavor = idHeadFlavorOverride

                            //bDebugLog = REPLY.idSnipHttpPrefix == ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP ; //U::

                            if( !pRefReply ) { BLAMMO ; }
                            //else             { CONoUTrAW( "FOUND AOK\r\n" ) ; }
                            if( !pRefReply ) { CONoUTrAW( "NOT FOUND so will try to obtain !nf\r\n" ) ; meP.getReplyF( tinP , pRefReply , T("!nf") ) ; ___( pRefReply ) ; }
                            meP.getReplyF( tinP , pRefReply , psttName ) ; ___( pRefReply ) ;
                            ZE( httpReplySrefC* , pRefReply ) ;
                        {
                        ZE( osTextT* , postsReply ) ;
                        ZE( boolT , bDebugLog ) ;
                        TELL( "preparing to compile the reply" ) ;
                    {
                    if( pStkBody && pStkBodyDynamic )

                    etThread( tinP , pStkBodyDynamic , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_ALLOWzE | flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , sizeof( pbRefC ) ) ;
                    ZE( stackC* , pStkBodyDynamic ) ;

                    etThread( tinP , pStkBody , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_ALLOWzE | flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , sizeof( pbRefC ) ) ;
                    ZE( stackC* , pStkBody ) ; //EVERYTHING AFTER THE HTTP HEADER AND ITS TRAILING "\r\n\r\n"
                    TELL( "getting recycled items" ) ;

                    (*pHttpEatKeyValuePairsCBFP)( tinP , etThread , bQuitP , psttKVReport , 0 /*DISABLED TO PREVENT ATTACK: T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(ifcIDaDAM_ROOTfORMdATAeATER)+T("/in/form") */ , *pswKV , psttLeverKV , sessionsP , nnPeerP , psttName , psttQueryKV , psttAgent , postBody ) ;
                    ZE( strokeS* , psttKVReport ) ;
                    TELL( "calling keyvalue eater" ) ;

                    }
                        session.privilegesF( tinP , flSESSIONpRIVILEGE_HIDEiMAGEaDS | flSESSIONpRIVILEGE_HIDEaDlINKS ) ;
                        )
                            )
                                !etThread.strCompareF( tinP , psttName , T("/robots.txt") )
                                !etThread.strCompareF( tinP , psttName , T("/nobot/noads.html") ) ||
                            (
                            &&
                            psttName
                        (
                        if
                        TELL( "maybe changing privileges to hide ads" ) ;
        
                        }
                            break ;
                            etThread.delF( tinP , postBody ) ;
                            etThread.delF( tinP , psttAgent ) ;
                            etThread.delF( tinP , psttName ) ;
                        {
                        if( idEscaped || POOP )
                        TELL( "inspecting idEscaped" ) ;
        
                        }
                            }
                                }
                                    //if( nnMe != nnPeerP && nnPeerP != nnLocal ) etThread.boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/ipdos/attackers/")+T(nnPeerP) ) ; 
                                    //nicNameC nnLocal( NICnAMElOCAL ) ;
                                    //nicNameC nnMe = socketC::nicNameIF( tinP , etThread ) ;
                                {
                                if( /*U::TO FIND A BUG: cTock &&*/ cTouch / cTock )
                                countT cTock = timeAge.time1 / TOCK ;
                            {
                            if( cTouch > TUCK && !timeAge.time2 )
        
                            timeS timeAge = session.ageF( tinP ) ;
                            countT cTouch = session.cTouchF( tinP ) ;
                        {
                        TELL( "inspecting session age" ) ;
        
                        //POPUPcOUNT( "idHeadFlavorOverride after: " , idHeadFlavorOverride ) ;
                        }
                            }
                                }
                                    break ;
                                    }
                                        if( idHeadFlavorOverride ) session.setIdHeadFlavorOverrideF( tinP , idHeadFlavorOverride ) ;

                                        else if( !etThread.strCompareF( tinP , psttv , T("terse"  ) ) ) idHeadFlavorOverride = ifcIDhEADfLAVOR_TERSE   ;
                                             if( !etThread.strCompareF( tinP , psttv , T("verbose") ) ) idHeadFlavorOverride = ifcIDhEADfLAVOR_VERBOSE ;
                                    {
                                    if( psttv )
                                    strokeS* psttv = *(strokeS**)&(countT&)*pswKV ;
                                {
                                if( !etThread.strCompareF( tinP , psttLeverKV , tKeyHeadFlavor ) )
                                psttLeverKV = (strokeS*)pswKV->leverF( tinP , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            countT cFlavors = pswKV->cFlavorsF( tinP ) ;
                        
                            TN( tKeyHeadFlavor , "headflavor" ) ;
                        {

                        //POPUPcOUNT( "idHeadFlavorOverride before: " , idHeadFlavorOverride ) ;
                        idHeadFlavorOverride = session.getIdHeadFlavorOverrideF( tinP ) ;
                        session.touchF( tinP , psttName ) ;    
                        sessionC& session = sessionsP( tinP , nnPeerP ) ;
                        TELL( "getting idHeadFlavorOverride" ) ;
                    {
                    ZE( countT , idHeadFlavorOverride ) ;

                    //}
                    //    if( tSay.csF( tinP ) ) { POPUP( tSay ) ; }
                    //    }
                    //        tSay += T("[")+T(psttLeverKV)+T("]: \"")+T(zsttv)+T("\"\r\n") ;
                    //
                    //        strokeS*& zsttv = *(strokeS**)&(countT&)*pswKV ;
                    //        psttLeverKV = (strokeS*)pswKV->leverF( tinP , idf ) ;
                    //    {
                    //    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    //    countT cFlavors = pswKV->cFlavorsF( tinP ) ;
                    //
                    //    TN( tSay , "" ) ;
                    //{
                    //COMMENT OUT IN PRODUCTION: USED TO SEE KEYVALUES SUBMITTED USING FORMS

                    //CONoUTrAW( T(DASH127 "\r\n")+T(psttName)+T("\r\n") ) ;

                    //}
                    //    countT foo = 2 ;
                    //{
                    //if( bDebug )
                    //const boolT bDebug = 1 ;
                    //const boolT bDebug = psttName && !etThread.strCompareF( tinP , psttName , T("/nobot/action/myaccount.html") ) ;

                    //etThread.traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(nnPeerP)+T("    preparing nonfile response") , flTRACE_null , idTraceDivert ) ;
                {
                else
                }
                    //if( bClose ) etThread.traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(nnPeerP)+T("    closing connection") , flTRACE_null , idTraceDivert ) ;

                    }
                        DEL( pFW ) ;
                        }
                            }
                                }
                                    }
                                        }
                                            //U:: LATER, PURGE BY NUMBER OF PLATES, BY AGE, AND/OR BY SIZE

                                            pzCache->pushF( tinP , psttn , pbBlob , cbBlob , maxAgeMsFile , 0 ) ; // "0": "NOT LENGTH PREFIXED"

                                            etThread.memCopyF( tinP , pbc , pbw              , cbw  ) ;
                                            etThread.memCopyF( tinP , pbc , (osTextT*)tReply , cbDo ) ; pbc += cbDo ;
                                            countT cbDo = cbBlob - cbw ;
                                            byteT* pbc = pbBlob ;
                                        {
                                        if( pbBlob )
                                        etThread.newF( tinP , LF , pbBlob , cbBlob ) ; ___( pbBlob ) ;
                                        countT       cbBlob = tReply.csF( tinP ) + cbw ;
                                        ZE( byteT* , pbBlob ) ;

                                        etThread.strMakeF( tinP , psttn , tNameCache ) ; ___( psttn ) ;
                                        ZE( strokeS* , psttn ) ;
                                    {
                                    if( pzCache && !bQuery )

                                    bCacheThis = 0 ;
                                {
                                if( bCacheThis )

                                //etThread.traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(nnPeerP)+T("    wrote   file window [cbw]:    ")+TF2(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , idTraceDivert ) ;

                                }
                                    }
                                        bClose = 1 ;
                                        //etThread.traceF( tinP , T("tmcHttpServerF: could not write to socket 965") , flTRACE_null , idTraceDivert ) ;
                                        POOPRqUIET
                                    {
                                    if( POOP )
                                    psoP->writeF( tinP , pbw , cbw ) ;
                                    SCOOPS
                                {
                                IFsCRATCH

                                //etThread.traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(nnPeerP)+T("    writing file window [cbw]:    ")+TF2(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , idTraceDivert ) ;
                            {
                            else
                            }
                                break ;
                                //etThread.traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(nnPeerP)+T("    all file windows have been written") , flTRACE_null , idTraceDivert ) ;
                            {
                            if( !pbw || !cbw )

                            pFW->getF( tinP , pbw , cbw , cbWindow ) ;
                            ZE( countT , cbw ) ;
                            ZE( byteT* , pbw ) ;
                        {
                        while( !POOP )

                        }
                            }
                                bClose = 1 ;
                                //etThread.traceF( tinP , T("tmcHttpServerF: could not write to socket 980") , flTRACE_null , idTraceDivert ) ;
                                POOPRqUIET
                            {
                            if( POOP )
                            psoP->writeF( tinP , (osTextT*)tReply , tReply.csF( tinP ) ) ;
                            SCOOPS
                        {
                        IFsCRATCH

                        TN( tReply , "" ) ; tReply = T("HTTP/1.1 200 OK\r\nServer: IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System (tm)\r\nContent-Type: ")+tContentType+T("\r\nContent-Length: ")+TF4(cbBody,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;

                        }
                            etThread.delF( tinP , psttLower ) ;

                            else if( psttLower->idAdam - 4 == etThread.strIdF( tinP , T(".jpeg") , psttLower , - 1 ) ) tContentType = T("image/jpeg") ;
                            else if( psttLower->idAdam - 3 == etThread.strIdF( tinP , T(".jpg" ) , psttLower , - 1 ) ) tContentType = T("image/jpeg") ;
                            else if( psttLower->idAdam - 3 == etThread.strIdF( tinP , T(".png" ) , psttLower , - 1 ) ) tContentType = T("image/png" ) ;
                            else if( psttLower->idAdam - 3 == etThread.strIdF( tinP , T(".mp3" ) , psttLower , - 1 ) ) tContentType = T("audio/mp3" ) ;
                            else if( psttLower->idAdam - 3 == etThread.strIdF( tinP , T(".mp4" ) , psttLower , - 1 ) ) tContentType = T("video/mp4" ) ;
                                 if( psttLower->idAdam - 3 == etThread.strIdF( tinP , T(".avi" ) , psttLower , - 1 ) ) tContentType = T("video/avi" ) ;

                            etThread.strConvertToLowerCaseF( tinP , psttLower , psttName ) ; ___( psttLower ) ;
                            ZE( strokeS* , psttLower ) ;
                        {
                        TN( tContentType , "" ) ;

                        boolT bCacheThis = !pcLoHi[ 1 ] && pcLoHi[ 0 ] <= cbWindow ;

                        const countT cbWindow = TICK >> 2 ;

                        sCountC cbBody( tinP , etThread , pcLoHi , SC << 1 ) ;
                        countT pcLoHi[] = { pFW->cbFileLoF() , pFW->cbFileHiF() } ;
                        //etThread.traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(nnPeerP)+T("    serving file [cbFileLo,cbFileHi]:    ")+TF3(pFW->cbFileLoF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pFW->cbFileHiF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9) ) ;
                    {
                    else
                    }
                        }
                            }
                                //etThread.traceF( tinP , T("tmcHttpServerF: could not write to socket 1004") , flTRACE_null , idTraceDivert ) ;
                                POOPRqUIET
                            {
                            if( POOP )
                            psoP->writeF( tinP , (osTextT*)tReply , tReply.csF( tinP ) ) ;
                            SCOOPS
                        {
                        IFsCRATCH

                        TN( tReply , "" ) ; tReply = T("HTTP/1.1 404 Not Found\r\nServer: IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System (tm)\r\nContent-Type: text")+T("\r\nContent-Length: ")+TF4(tBody.csF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;

                        TN( tBody , "The page (or other resource) that you requested does not exist here.\r\n\r\nIf you think that this is our error, please let us know.\r\n" ) ;

                        }
                            etThread.traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(nnPeerP)+T("    error: could not open file:    ")+*pptFileIn[offf] , flTRACE_null , idTraceDivert ) ;
                        {
                        for( countT offf = 0 ; offf < sizeof pptFileIn / sizeof pptFileIn[ 0 ] ; offf ++ )
                    {
                    if( !pFW )

                    }
                        }
                            }
                                DEL( pFW ) ;
                                POOPRqUIET
                            {
                            else
                            if( !POOP ) break ;
                            tinP.pcUtility[ 0 ] -- ; //U:: TO FIND A BUG
                            pFW = new( 0 , tinP , LF ) fileWindowsC( tinP , *tinP.pEtScratch , *pptFileIn[ offf ] , flFILEwINDOW_DOnOTvALIDATE | flFILEwINDOW_DOnOTmAKEdIRiFnEEDED , 1 ) ; ___( pFW ) ; //DOnOTvALIDATE IS A WORKAROUND TO PREVENT dosOpenIF FROM USING THE WRONG poopC INSTANCE (THIS IS A CODE DESIGN ERROR: NO IMAGE FUNCTION SHOULD ASSUME A PARTICULAR thirdC OR etherC INSTANCE TO USE WHEN CALLING NONIMAGE FUNCTIONS)
                            tinP.pcUtility[ 0 ] ++ ; //U:: TO FIND A BUG
                            _IO_
                            SCOOPS
                        {
                        IFsCRATCH
                        //etThread.traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(nnPeerP)+T("    attempting to open file:    ")+*pptFileIn[offf] , flTRACE_null , idTraceDivert ) ;
                    {
                    for( countT offf = 0 ; offf < sizeof pptFileIn / sizeof pptFileIn[ 0 ] ; offf ++ )

                    } ;
                        &tFileIn9z ,
                        &tFileIn9y ,
                        &tFileIn9x ,
                        &tFileIn3e ,
                    {
                    textC* pptFileIn[]=

                    TN( tFileIn9z , "" ) ; tFileIn9z = T("////factory8/z/archive")+T(psttName) ;
                    TN( tFileIn9y , "" ) ; tFileIn9y = T("////factory8/y/archive")+T(psttName) ;
                    TN( tFileIn9x , "" ) ; tFileIn9x = T("////factory8/x/archive")+T(psttName) ;
                    TN( tFileIn3e , "" ) ; tFileIn3e = T("////factory2/e/archive")+T(psttName) ;

                    ZE( fileWindowsC* , pFW ) ;
                {
                else if( bFile )
                }
                    //if( bClose ) etThread.traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(nnPeerP)+T("    closing connection") , flTRACE_null , idTraceDivert ) ;

                    etThread.delF( tinP , pbIcon ) ;

                    }
                        }
                            //U:: LATER, PURGE BY NUMBER OF PLATES, BY AGE, AND/OR BY SIZE

                            pzCache->pushF( tinP , psttn , pbBlob , cbBlob , maxAgeMsFileFavIcon , 0 ) ; // "0": "NOT LENGTH PREFIXED"

                            etThread.memCopyF( tinP , pbc , pbIcon           , cbIcon ) ;
                            etThread.memCopyF( tinP , pbc , (osTextT*)tReply , cbDo   ) ; pbc += cbDo ;
                            countT cbDo = cbBlob - cbIcon ;
                            byteT* pbc = pbBlob ;
                        {
                        if( pbBlob )
                        etThread.newF( tinP , LF , pbBlob , cbBlob ) ; ___( pbBlob ) ;
                        countT       cbBlob = tReply.csF( tinP ) + cbIcon ;
                        ZE( byteT* , pbBlob ) ;

                        etThread.strMakeF( tinP , psttn , tNameCache ) ; ___( psttn ) ;
                        ZE( strokeS* , psttn ) ;
                    {
                    if( pzCache && !bQuery )

                    }
                        }
                            bClose = 1 ;
                            //etThread.traceF( tinP , T("tmcHttpServerF: could not write to socket 980") , flTRACE_null , idTraceDivert ) ;
                            POOPRqUIET
                        {
                        if( POOP )
                        psoP->writeF( tinP , pbIcon , cbIcon ) ;
                        psoP->writeF( tinP , (osTextT*)tReply , tReply.csF( tinP ) ) ;
                        SCOOPS
                    {
                    IFsCRATCH

                    TN( tReply , "" ) ; tReply = T("HTTP/1.1 200 OK\r\nServer: IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System (tm)\r\nContent-Type: image/x-icon\r\nContent-Length: ")+TF4(cbIcon,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;

                    etThread.boxGetShadowF( tinP , pbIcon , cbIcon , tFileFavIcon ) ; ___( pbIcon ) ;
                    ZE( countT , cbIcon ) ;
                    ZE( byteT* , pbIcon ) ;
                {
                if( bFavIcon )

                idDesireOld = etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZY ) ;
            {
            else
            }
                pzCache->ungrabF( tinP ) ;

                }
                    }
                        bClose = 1 ;
                        //etThread.traceF( tinP , T("tmcHttpServerF: could not write to socket 96 [nnPeer]:    ")+T(nnPeerP) , flTRACE_null , idTraceDivert ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    else                 psoP->writeF( tinP ,        pzCached->pbBlob   ,        pzCached->cbBlob   ) ;
                    if( pzCached->cArg ) psoP->writeF( tinP , POSTS( pzCached->pbBlob ) , COSTS( pzCached->pbBlob ) ) ;
                    SCOOPS
                {
                IFsCRATCH
                TELL( "writing reply" ) ;
            {
            if( pzCached )

            }
                else           pzCache->ungrabF( tinP ) ;
                if( pzCached ) etThread.traceF( tinP , T("found in cache:    ")+T(pzCached->psttName) , flTRACE_null , idTraceDivert ) ;
                pzCached = (*pzCache)( tinP , tNameCache ) ;
                pzCache->grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( pzCache && !bQuery )
            ZE( cachedS* , pzCached ) ;

            etThread.traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(nnPeerP)+T("    request:    \"")+T(psttName)+T("\"")+(psttQueryKV?T("    ")+T(psttQueryKV):T("")) , flTRACE_null , idTraceDivert ) ;

            ;
                            : ifcIDtRACEdIVERT_6
                            ? ifcIDtRACEdIVERT_5
                        : !bFile
                        ? ifcIDtRACEdIVERT_4
                    : !etThread.strCompareF( tinP , psttName , tSlash )
                    ? ifcIDtRACEdIVERT_3
                : !etThread.strCompareF( tinP , psttName , tSlashDeadman )
                ? ifcIDtRACEdIVERT_2
            const countT idTraceDivert = !psttName
            //CS:CODEsYNC: 3300005b 3600212d

            }
                bFile = 1 == etThread.strIdF( tinP , tPattern , psttName ) ;

                ;

                    +S2(sa_SSSaNDeND,sc_ccSSS)
                        +T("/!ideafarm.")
                            +S2(sa_SSSoReND,sc_ccSSS)
                                +T("x")                                                 // "x" IS ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
                                +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
                            +S2(sa_SSSoR,sc_ccSSS)
                        +S3(3,sc_ccSSSrEPEAT,3)
                        +tSlash
                    +S2(sa_SSSaND,sc_ccSSS)
                    T("")

                TN( tPattern , "" ) ; tPattern =
                // "2013/!ideafarm."
                //  yyyy
            {
            if( !bDeadman && psttName && psttName->idAdam )
            ZE( boolT , bFile ) ;

            }
                etThread.delF( tinP , psttLower ) ;
                tNameCache = T(psttLower) ;
                bFavIcon = !etThread.strCompareF( tinP , psttLower , tNameTestFavIcon ) ;
                etThread.strConvertToLowerCaseF( tinP , psttLower , psttName ) ; ___( psttLower ) ;
                ZE( strokeS* , psttLower ) ;
            {
            if( !bDeadman )
            ZE( boolT , bFavIcon ) ;

            }
                break ;

                etThread.traceF( tinP , T("tmcHttpServerF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                etThread.traceF( tinP , T("tmcHttpServerF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                etThread.traceF( tinP , T("tmcHttpServerF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                etThread.traceF( tinP , T("tmcHttpServerF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                etThread.traceF( tinP , T("tmcHttpServerF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                //CS:CODEsYNC: 3300005b 3600212d

                //}
                //    }
                //        if( POOP ) { POOPRqUIET ; }
                //        tinP.pEtScratch->boxPutF( tinP , tListBlock , tSay , tSay.csF( tinP ) ) ;
                //        SCOOPS
                //    {
                //    IFsCRATCH
                //
                //    TN( tSay , "blocked because readRequestF failed, which is attacker behavior" ) ;
                //{
                //if( !bHuman && !bWhite && !bWoMore )    //U::20200804@2120: I'VE SEEN THIS BLOCK FACTORY 3-5, SO THIS IS TOO STRICT; WITH THIS CODE, I AM BLOCKING INNOCENT PEERS
                //
                //boolT bWoMore = etThread.diskFileExistsF( tinP , tListAllowWoMore ) ;
                //boolT bWhite  = etThread.diskFileExistsF( tinP , tListWhite  ) ;
                //boolT bHuman  = etThread.diskFileExistsF( tinP , tListHuman  ) ;
                //
                //tListWhite += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(nnPeerP) ;
                //tListWhite += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(nnPeerP) ;
                //tListWhite += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(nnPeerP) ;
                //TlIST( tListWhite ) ;
                //
                //tListBlock += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(nnPeerP) ;
                //tListBlock += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(nnPeerP) ;
                //tListBlock += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(nnPeerP) ;
                //TlIST( tListBlock ) ;
                //
                //tListAllowWoMore += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(nnPeerP) ;
                //tListAllowWoMore += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(nnPeerP) ;
                //tListAllowWoMore += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(nnPeerP) ;
                //TlIST( tListAllowWoMore ) ;
                //
                //tListHuman += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(nnPeerP) ;
                //tListHuman += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(nnPeerP) ;
                //tListHuman += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(nnPeerP) ;
                //TlIST( tListHuman ) ;
            {
            if( bFail )

            //etThread.traceF( tinP , T(psttName)+T(!bClose?"        connection will be kept open":"        CONNECTION WILL BE CLOSED") ) ;

            etThread.osTimeNowF( tinP , timeStart1 , timeStart2 ) ;
            ZE( sCountT , timeStart2 ) ;
            ZE( countT  , timeStart1 ) ;

            }
                else if( bQuery ) tNameCache += tQuest+T(psttQueryKV) ; // DEADMAN QUERY IS SUPPRESSED BECAUSE ITS ONLY FUNCTION IS TO UNIQUELY IDENTIFY THE DEADMAN REQUEST
                }
                    bClose = 1 ; //O:OPTIMIZATION
                    idDesireOld = etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;      // DEADMAN TESTS ARE TO DETECT THAT I AM DEAD, NOT THAT I AM OVERWHELMED
                {
                if( bDeadman )                                                                              // A:ASSUME: I AM RUNNING AT RUSH PRIORITY

                bDeadman = psttName && !etThread.strCompareF( tinP , psttName  , tSlashDeadman ) ;
            {
            TN( tNameCache , psttName ) ;
            ZE( countT , idDesireOld ) ;
            ZE( boolT , bDeadman ) ;
            const boolT bQuery = psttQueryKV && psttQueryKV->idAdam ;

            // LAZY   : CONSTRUCTING AND SERVING NONCACHED RESPONSES
            // NORMAL : GENERAL SERVER WORKLOAD
            // RUSH   : ACCEPTING CONNECTIONS, LAUNCHING MY THREAD, SERVING CACHED RESPONSES
            // RUDE   : SERVING DEADMAN
            // SCHEDULING PRIORITY

            ___( postBody ) ;
            ___( psttAgent ) ;
            ___( psttLeverKV ) ;
            ___( psttName ) ;
            idEscaped = meP.readRequestF( tinP , bFail , psttName , psttQueryKV , *pswKV , psttLeverKV , psttAgent , postBody , bClose , psoP , pHttpRawCommandServerCBFP ? "!@" : 0 ) ;
            ZE( boolT , bFail ) ;
            ZE( boolT , bClose ) ;
            ZE( osTextT* , postBody ) ;
            ZE( strokeS* , psttAgent ) ;
            ZE( strokeS* , psttQueryKV ) ;
            ZE( strokeS* , psttName ) ;
            TELL( "reading a request" ) ;
        {
        while( !etThread && !POOP )
        const countT maxAgeMsNotFileNotTalkBody = etThread.osTimeToOldTimeMsF( tinP , TICK << 4 ) ;
        const countT maxAgeMsNotFileTalkBody    = etThread.osTimeToOldTimeMsF( tinP , TOCK << 2 ) ;
        const countT maxAgeMsFile               = etThread.osTimeToOldTimeMsF( tinP , TICK << 4 ) ;
        const countT maxAgeMsFileFavIcon        = etThread.osTimeToOldTimeMsF( tinP , - 1       ) ;
        ZE( sCountT , timeTotalPending2 ) ;
        ZE( countT  , timeTotalPending1 ) ;
        TN( tFileFavIcon     , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/7reso.71000002.favicon.ico" ) ;
        TN( tNameTestFavIcon , "/favicon.ico" ) ;
        TN( tQuest           , "?"           ) ;
        TN( tSlashTalkBody   , "/talk.body"  ) ;
        TN( tSlash           , "/"           ) ;
        ZE( countT , idEscaped ) ;
        //LOGrAW( T("------------------------- B E G I N   S E S S I O N -------------------------------------------------------\r\n") ) ;
        //CONoUTrAW( T("------------------------- B E G I N   S E S S I O N -------------------------------------------------------\r\n") ) ;

        }
            DEL( prPosts ) ;
            if( prPosts && COSTS( *prPosts ) ) psoP->writeF( tinP , POSTS( *prPosts ) , COSTS( *prPosts ) ) ;
            meP.getSnipF( tinP , prPosts , ifcIDsNIPpREDEFINED_HTTPcONTINUEwELCOME ) ; ___( prPosts ) ;
            ZE( pbRefC* , prPosts ) ;
        {
        if( pHttpRawCommandServerCBFP )

        cacheC* pzCache = meP.pzCacheF() ;

        puseC& pusePeanutP = *(puseC*)c8P.c1 ;
        count8S& c8P = *(count8S*)cArgAppP ;
    {
    else
    }
        etThread.traceF( tinP , T("tmcHttpServerF / error: recycler failure") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
        etThread.traceF( tinP , T("tmcHttpServerF / error: recycler failure") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
        etThread.traceF( tinP , T("tmcHttpServerF / error: recycler failure") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
        etThread.traceF( tinP , T("tmcHttpServerF / error: recycler failure") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
        etThread.traceF( tinP , T("tmcHttpServerF / error: recycler failure") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
        //CS:CODEsYNC: 3300005b 3600212d
    {
    if( !pswKV || !pswTally )
    TN( tSlashDeadman    , "/deadman"    ) ;

    etThread( tinP , pswTally , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , psttLeverUrlTally ) ; ___( pswTally ) ;
    ZE( switchC* , pswTally ) ;
    ZE( strokeS* , psttLeverUrlTally ) ;

    etThread( tinP , pswKV , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , psttLeverKV ) ; ___( pswKV ) ;
    ZE( switchC* , pswKV ) ;
    ZE( strokeS* , psttLeverKV ) ;

    ZE( countT , cHamburgersThisSession ) ;
    ZE( countT , idPortPeer ) ;
    ZE( boolT , bOsFire ) ;

    if( !pHttpEatKeyValuePairsCBFP ) pHttpEatKeyValuePairsCBFP = httpEatKeyValuePairsDefaultCBF ;
    HTTPsYSpARAMS( cArg )

    //tinP.pAdamGlobal1->pEtThreadMain->etherTestF( tinP ) ; //U:: TO FIND A BUG

    etThread.traceF( tinP , T("tmcHttpServerF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
    etThread.traceF( tinP , T("tmcHttpServerF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
    etThread.traceF( tinP , T("tmcHttpServerF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
    etThread.traceF( tinP , T("tmcHttpServerF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
    etThread.traceF( tinP , T("tmcHttpServerF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
    //CS:CODEsYNC: 3300005b 3600212d
{
if( cArg )
_IO_
TELL( "preparing for work" ) ;
/*1*/TASKdRIVENsERVER( tmcHttpServerF )/*1*/

#define REPLY REF( httpReplyS , *pRefReply )

#define PUSHrEPLY(prPostP) PUSHK( REPLY.##prPostP ) ;

    }
        PUSHD( prPosts ) ;                                                                          \
        (meP).getSnipF( tinP , prPosts , (idSnipP) ) ; ___( prPosts ) ;                             \
        ZE( pbRefC* , prPosts ) ;                                                                   \
    {                                                                                               \
                                                                                                    \
#define PUSHsNIP(meP,idSnipP)                                                                       \

    }
        DEL( prDoomed )                                                                             \
        pbRefC* prDoomed = (prPostsP) ;                                                             \
        new( 0 , tinP , (byteT*)&(*pStkBody)[ - 1 ] , sizeof( pbRefC ) ) pbRefC( *prPostsP ) ;      \
        *pStkBody << (byteT*)0 ;                                                                    \
    {                                                                                               \
    if( prPostsP )                                                                                  \
                                                                                                    \
#define PUSHD(prPostsP)                                                                             \
//'D': "DELETE"

    }
        new( 0 , tinP , (byteT*)&(*pStkBody)[ - 1 ] , sizeof( pbRefC ) ) pbRefC( *prPostsP ) ;      \
        *pStkBody << (byteT*)0 ;                                                                    \
    {                                                                                               \
    if( prPostsP )                                                                                  \
                                                                                                    \
#define PUSHK(prPostsP)                                                                             \
//'K': "KEEP"

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

