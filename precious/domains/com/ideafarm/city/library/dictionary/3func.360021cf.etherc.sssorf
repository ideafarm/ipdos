
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bMatch ;

    if( !bMatch ) idbDoP = idbDoSave ;

    }
        idsDoP = ++ idsMax ; // ')'

        }
            }
                if( cArmLiterals ) cArmLiterals -- ;
                idsDoP ++ ;
            {
            else
            if( idsDoP == idsMax ) break ;      // WE ARE DONE

            }
                }
                    break ;
                    bMatch = !bNot ;
                {
                if( bHit )

                bCeiling = !bCeiling ;

                }
                    bHit = bFloorPass && bCeilingPass ;
                    boolT bCeilingPass = psttSmallP[ CSpREFIX - 1 + idsDoP ] >= psttBigP[ CSpREFIX - 1 + idbDoP ] ;
                {
                else
                else if( !bCeiling    ) bFloorPass = psttSmallP[ CSpREFIX - 1 + idsDoP ] <= psttBigP[ CSpREFIX - 1 + idbDoP ] ;
                }
                    ;
                        : sssTestF( tinP , bDoNotAdvanceBigNU , psttSmallP , psttBigP , idsDoP , idbDoP , tBlack , tPunctuation )
                        ? psttSmallP[ CSpREFIX - 1 + idsDoP ] == psttBigP[ CSpREFIX - 1 + idbDoP ]
                    bHit = cArmLiterals
                {
                if( !bRangePairs )
                ZE( boolT , bHit ) ;
            {
            else
            }
                }
                    break ;
                    bMatch = !bNot ;
                {
                if( bHit )

                boolT bHit = sssOrF( tinP , psttSmallP , psttBigP ,  idsDoP ,  idbDoP ) ;
            {
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam  == sa_SSSoR )
            }
                }
                    break ;
                    bMatch = !bNot ;
                {
                if( bHit )

                boolT bHit = sssAndF( tinP , psttSmallP , psttBigP ,  idsDoP ,  idbDoP ) ;
            {
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSaND )
            else if(                  psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERALeND   ) cArmLiterals =   0 ;
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERALbEGIN ) cArmLiterals = - 1 ;
                 if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERAL      ) cArmLiterals =   1 ;

            ZE( boolT , bDoNotAdvanceBigNU ) ;
        {
        if( idsDoP <= idsMax && idbDoP <= psttBigP->idAdam ) for(;;)

        TN( tPunctuation , TpUNCTUATION ) ;
        TN( tBlack , TbLACKeXCLUDINGnEWlINE ) ;

        ZE( boolT , cArmLiterals ) ;
        ZE( boolT , bFloorPass ) ; // IF bRangePairs THEN FLOOR PASS/FAIL IS STORED HERE TO BE INSPECTED WHEN TESTING CEILING
        ZE( boolT , bCeiling   ) ; // IF bRangePairs THEN INDIVIDUAL STROKES ARE ALTERNATELY INTERPRETED AS FLOOR,CEILING,FLOOR,CEILING,...
        idsMax -- ; // LATH BEFORE ']'
    {
    if( !POOP )

    // --------------------------------------------------------------------------------------------------------------------------------------------------
    // SET bMatch
    // --------------------------------------------------------------------------------------------------------------------------------------------------

    __Z( idsMax ) ;
    }
        if( idsMax > psttSmallP->idAdam ) idsMax = 0 ;

        }
            }
                if( bFound ) break ;

                }
                    }
                        break ;
                        if( !( -- cLevels ) ) bFound = 1 ;
                    {
                    case sa_SSSoReND :
                    }
                        break ;
                        ++ cLevels ;
                    {
                    case sa_SSSoR :
                    }
                        break ;
                        cArmLiterals = 0 ;
                    {
                    case sa_SSSlITERALeND :
                    }
                        break ;
                        cArmLiterals = - 1 ; //A:ASSUME: STRING LENGTH CANNOT EXCEED maxCountTT
                    {
                    case sa_SSSlITERALbEGIN :
                    }
                        break ;
                        cArmLiterals = 1 ;
                    {
                    case sa_SSSlITERAL :
                {
                switch( psttSmallP[ CSpREFIX - 1 + idsMax ].idAdam )
                ZE( boolT , bFound ) ;
            {
            else if( psttSmallP[ CSpREFIX - 1 + idsMax ].idCaste == sc_ccSSS )
            else if( cArmLiterals                                            ) cArmLiterals -- ;
                 if( psttSmallP[ CSpREFIX - 1 + idsMax ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsMax ].idAdam == sa_SSSlITERALeND ) cArmLiterals = 0 ;
        {
        for( ; idsMax <= psttSmallP->idAdam ; idsMax ++ )
        ZE( boolT , cArmLiterals ) ;
        countT cLevels = 1 ;
    {
    countT idsMax = idsDoP ;
    idsDoP ++ ;                           // WOTH AFTER '['

    // --------------------------------------------------------------------------------------------------------------------------------------------------
    // FIND THE MATCHING END
    // --------------------------------------------------------------------------------------------------------------------------------------------------

    boolT bMatch = bNot ;
    const boolT bNot = !!( psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote & sp_SSSfLAGnOT ) ;
    const boolT bRangePairs = !!( psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote & sp_SSSfLAGrANGEpAIRS ) ;
    const countT idbDoSave = idbDoP ;

    }
        if( POOP ) return 0 ;
        __NZ( psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam  - sa_SSSoR ) ;
        __NZ( psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste - sc_ccSSS ) ;
        if( POOP ) return 0 ;
        __Z( psttBigP->idAdam ) ;
        __( psttSmallP->idAdam < idsDoP + 1 ) ; // NULL LENGTH SPECS ARE ALLOWED
        if( POOP ) return 0 ;
        __Z( idbDoP ) ;
        __Z( idsDoP ) ;
        __Z( psttBigP ) ;
        __Z( psttSmallP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL

{
/*1*/boolT etherC::sssOrF( tinS& tinP , const strokeS* const psttSmallP , const strokeS* const psttBigP ,  countT& idsDoP ,  countT& idbDoP )/*1*/

/**/

*/
  when i return, will point to the lath position done
  the position in psttBigP at which to look for the specified OR pattern
  must be nonze
 idbDoP
  when i return, will point to the lath position done
  position idsDoP in psttSmallP must be sc_ccSSS(sa_SSSoR,?)
  must be nonze
 idsDoP
 psttBigP
  must have sc_ccSSS(sa_SSSoR) at position idsDoP
 psttSmallP
 tinP
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

