
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    if( !cDeleted ) break ;

    }
        swsFileName.purgeF( tinP ) ;

        }
            etThread.delF( tinP , pb600 ) ;
            }
                while( ~hWalk ) ;
                }
                    }
                        etThread.delF( tinP , pb0600 ) ;

                        }
                            break ;
                            etThread.delF( tinP , pb0600 ) ;
                            cDeleted ++ ;
                            etThread.diskFileOrDirDeleteF( tinP , psttz600 ) ;
                            etThread.traceF( tinP , T("deleting ")+T(psttz600) ) ;
                        {
                        if( !POOP && !etThread.memCompareF( tinP , pb600 , pb0600 , cLeverFileSize ) )

                        __( cb0600 - cLeverFileSize ) ;
                        etThread.boxGetShadowF( tinP , pb0600 , cb0600 , psttfn ) ;
                        ZE( countT , cb0600 ) ;
                        ZE( byteT* , pb0600 ) ;
                    {
                    if( etThread.strCompareF( tinP , psttz600 , psttfn ) && etThread.strIdF( tinP , t0600 , psttfn ) )

                    strokeS* psttfn = (strokeS*)swsFileName.downF( tinP , hWalk ) ;
                {
                do
                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( !POOP )

            __( cb600 - cLeverFileSize ) ;
            etThread.boxGetShadowF( tinP , pb600 , cb600 , psttz600 ) ;
            ZE( countT , cb600 ) ;
            ZE( byteT* , pb600 ) ;
        {
        if( psttz600 )

        }
            while( ~hWalk ) ;
            }
                }
                    break ;
                    psttz600 = psttfn ;
                {
                if( etThread.strIdF( tinP , t600 , psttfn ) )
                strokeS* psttfn = (strokeS*)swsFileName.downF( tinP , hWalk ) ;
            {
            do
            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        ZE( strokeS* , psttz600 ) ;

        if( !( cRemain % TUCK ) ) etThread.traceF( tinP , T("remaining flavors: ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
        countT cRemain = cFlavors - idf ;
        cLeverFileSize = swsFileName.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swsFileName.cFlavorsF( tinP ) ;
    TN( t0600 , ".0600x" ) ;
    TN( t600  , ".600x"  ) ;
    ZE( countT , cDeleted ) ;
    etThread.traceF( tinP , T("inspecting size filesets") ) ;

    etThread.diskWalkF( tinP , cDirs , cFiles , T("///a/ideafarm.home.101/IdeaFarm (tm)/Drop Files Here To Archive/") , bQuit , diskWalkZapDupsCBF , pcArg ) ;
    etThread.traceF( tinP , T("walking archive") ) ;
    ZE( boolT , bQuit ) ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs ) ;
{
for(;;)

countT pcArg[] = { (countT)&cLeverFileSize , (countT)&swsFileName } ;
switchStackC swsFileName( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cLeverFileSize , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
ZE( countT , cLeverFileSize ) ;

TODO

}
    return 1 ;

    DEL( pInfo ) ;

    }
        if( !ids ) tinP.pEther->delF( tinP , psttFileName ) ;
        swsFileNameP.sinkF( tinP , ids , psttFileName , flSTACKsINK_UNIQUE ) ;
        ZE( countT , ids ) ;
        tinP.pEther->strMakeF( tinP , psttFileName , tFileName ) ; ___( psttFileName ) ;
        ZE( strokeS* , psttFileName ) ;

        cLeverFileSizeP = pInfo->cbUsed ;
    {
    if( pInfo )

    tinP.pEther->diskFileQueryF( tinP , pInfo , hFile ) ; ___( pInfo ) ;
    ZE( infoFileS* , pInfo ) ;
    tinP.pEther->fileOpenF( tinP , hFile , countTC() , tFileName , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO ) ;
    handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;

    TN( tFileName , ifFileNameC( tinP , *tinP.pEther , postNameP ) ) ;

    if( !( cFilesP % TUCK ) ) tinP.pEther->traceF( tinP , T("[cDirs,cFiles]: ")+TF2(cDirsP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" ")+TF2(cFilesP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

    switchStackC& swsFileNameP    = *(switchStackC*)pcArgP[ 1 ] ;
    countT&       cLeverFileSizeP =       *(countT*)pcArgP[ 0 ] ;
{
boolT diskWalkZapDupsCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

//20140915@1840: MOVED FROM SCRATCH d TO PERMANENT ADAM ID

/*1*/WAKEsHOWtEXT( "scr" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

