
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        ++ s ; ether.osSleepF( tinP , TOCK * 0x10 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {

    //LOGrAW3( "ifcIDaDAM_HOMEfLAGS [home.flags]: " , home.flags , "\r\n" ) ;

    //tinP.zEtScratch->delF( tinP , psttRoster ) ;
    //rosterF( tinP , *tinP.zEtScratch , psttRoster ) ; ___( psttRoster ) ;
    //ZE( strokeS* , psttRoster ) ;

    }
        while( flagsOld != setIfEqualsAM( home.flags , flagsNew , flagsOld ) ) ;
        }
            flagsNew = flagsOld | flHOMEs_VERSIONrEFUSED ;
            flagsOld = home.flags ;
        {
        do
        ZE( flagsT , flagsNew ) ;
        ZE( flagsT , flagsOld ) ;

        etThread.traceF( tinP , T("error:  IPDOS (tm) on this computer is stale.  please obtain a fresh (current) copy") ) ;
    {
    if( bDnsRefusedVersionF( tinP , tVersionMe ) )

    //OLD PRODUCTION: if( bOkDnsValueF( tinP , tTime ) || bOkDnsValueF( tinP , tGoogle ) ) flagsNew |= flHOMEs_ONLINE ;

    }
        while( flagsOld != setIfEqualsAM( home.flags , flagsNew , flagsOld ) ) ;
        }
            flagsNew = flagsOld | flHOMEs_ONLINE ;
            flagsOld = home.flags ;
        {
        do
        ZE( flagsT , flagsNew ) ;
        ZE( flagsT , flagsOld ) ;
    {
    if( bOkDnsValueF( tinP , tIdeafarm ) )

    //tmWatchF WILL QUIT IF IT EVER SEES THE flHOMEs_VERSIONrEFUSED FLAG
{
while( !etThread && !ether )
etherC& etRock = etherC::etRockIF( tinP ) ;
TN( tTimeHttp , "www.time.gov//http//" ) ;
TN( tGoogleHttp , "www.google.com//http//" ) ;
TN( tRosterHttp  , "www.ideafarm.com//http//" ) ;
TN( tTime , "www.time.gov" ) ;
TN( tGoogle , "www.google.com" ) ;
TN( tRoster  , "www.ideafarm.com" ) ;
TN( tIdeafarm  , "ideafarm.com" ) ;

  TN( tVersionMe , "20141209.1044.version.ipdos.ideafarm.com" ) ; //PRODUCTION
//TN( tVersionMe , "20141115.1852.version.ipdos.ideafarm.com" ) ;
//TN( tVersionMe , "1.version.ipdos.ideafarm.com" ) ;
//TN( tVersionMe , "2.version.ipdos.ideafarm.com" ) ;
//ENABLE WO OF THESE LINES TO VERIFY THAT THE IPDOS SYSTEM SHUTS DOWN AS SOON AS THE COMPUTER IS ONLINE

THREADmODE1oN( flTHREADmODE1_QUIETiMPOTENCE )
etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIEST ) ;

if( etThread.diskIdF( tinP , T("///c") ) == IDcOMPUTER_IPDOSmASTERcRAFTWORK ) etThread.osThreadF( TaRG1( tmUpd8PaidHListF ) ) ; //U:: USE A SETTINGS FILE
//U:: 20200920@1855: THIS SHOULD BE DONE BY factory3-5, AND IT SHOULD BE DONE IN A WAY THAT AVOIDS SPF (SINGLE POINT OF FAILURE) SO THAT IT WORKS EVEN IF ALL BUT WO FACTORY IS DOWN

etThread.osThreadF( TaRG1( tmGetIdHomeF ) ) ;

homeS& home = homeS::homeIF() ;

TODO

DONE( tmUpd8PaidHListF )

}
    ether.osSleepF( tinP , TOCK << 4 ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    //etThread.traceF( tinP , T("napping for 01 tock") ) ;

    //etThread.traceF( tinP , T("cHomes: ")+TF2(cHomes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    
    }
        while( ~hFind && !ether && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                etThread.delF( tinP , psttShorter ) ;
                etThread.fileWriteF( tinP , fiPaid , tOut , tOut.csF( tinP ) ) ;
                TN( tOut , psttShorter ) ; tOut += tcr ;
        
                etThread.delF( tinP , psttShort ) ;
                etThread.strSubstringF( tinP , psttShorter , idf , idl , psttShort ) ; ___( psttShorter ) ;
                countT idl = psttShort->idAdam - 9 ; // REMOVE ".home.txt"
                countT idf = 1 ;
                ZE( strokeS* , psttShorter ) ;
        
                if( !( cHomes % TUCK ) ) etThread.traceF( tinP , psttShort ) ;
        
                etThread.delF( tinP , psttPath ) ;
                ___( psttShort ) ;
                ___( psttPath ) ;
                etThread.strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttPath ) ;
            {
            if( pInfo && pInfo->psttIfoName && pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam != '/' )
            etThread.diskFindFileOrDirF( tinP , pInfo , hFind , fnLike.pathF() , &pat ) ; ___( pInfo ) ;
            ZE( infoFileS* , pInfo ) ;
        
            cHomes ++ ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        TN( tSlash , "/" ) ;
        TN( tcr , "\r\n" ) ;
        fileC fiPaid( tinP , (strokeS*)T("///ideafarm/tmp/ipdos.home.privileges/!paid.txt") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

        patternC pat( tinP , etThread , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        fileNameC fnLike( tinP , etThread , tLike ) ;
    {
    if( etThread.diskFileExistsF( tinP , tLike ) )
    TN( tLike , "///ideafarm/tmp/ipdos.home.registry/*.home.txt" ) ;
    ZE( countT , cHomes ) ;
{
while( !ether && !POOP )
etherC& etRock = etherC::etRockIF( tinP ) ;

TASK( tmUpd8PaidHListF )

DONE( tmGetIdHomeF )

}
    }
        }
            ether.osSleepF( tinP , bPaid ? TICK << 7 : TOCK << 4 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            etThread.traceF( tinP , T(bPaid?"home privileges check / napping for 01 tick before checking again":"home privileges check / napping for 01 tock before checking again") ) ;

            }
                }
                    etThread.delF( tinP , postPaidList ) ;
                    }
                        }
                            ether.ifcHireF( tinP , T("HOMEfLAGS") , ifcIDaDAM_PISS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; //MUST HIRE PISS EVEN IF NO PAID PRIVILEGES IN ORDER TO ALLOW USER TO UPDATE SETTINGS
                            bPissHired = 1 ;
                        {
                        if( !bPissHired )

                        }
                            while( flagsOld != setIfEqualsAM( home.flags , flagsNew , flagsOld ) ) ;
                            }
                                flagsNew = flagsOld & ~( F(flHOMEs_PAIDpRIVILEGES) ) ;
                                flagsOld = home.flags ;
                            {
                            do
                            ZE( flagsT , flagsNew ) ;
                            ZE( flagsT , flagsOld ) ;

                            }
                                etThread.traceF( tinP , T("this home does NOT have paid privileges") ) ;
                                bSaidPaid    = 0 ;
                                bSaidNotPaid = 1 ;
                            {
                            if( !bSaidNotPaid )
                        {
                        else
                        }
                            //break ;
                            //ether.ifcHireF( tinP , T("HOMEfLAGS") , ifcIDaDAM_PISS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                            //TO SUPPRESS CONTINUED CHECKING, HIRE AND BREAK HERE

                            while( flagsOld != setIfEqualsAM( home.flags , flagsNew , flagsOld ) ) ;
                            }
                                flagsNew = flagsOld | flHOMEs_PAIDpRIVILEGES ;
                                flagsOld = home.flags ;
                            {
                            do
                            ZE( flagsT , flagsNew ) ;
                            ZE( flagsT , flagsOld ) ;

                            bPaid = 1 ;

                            }
                                etThread.traceF( tinP , T("this home has paid privileges") ) ;
                                bSaidNotPaid = 0 ;
                                bSaidPaid    = 1 ;
                            {
                            if( !bSaidPaid )
                        {
                        if( thirdC::c_strstrIF( tinP , postPaidList , home.postIdHomeGlobal ) )

                        LOGrAW( "\r\n\r\n" ) ;
                        LOGrAW( postPaidList ) ;
                        LOGrAW( "\r\n\r\npostPaidList:\r\n" ) ;
                        LOGrAW( home.postIdHomeGlobal ) ;
                        LOGrAW( "\r\nhome.postIdHomeGlobal:\r\n" ) ;
                    {
                    else if( postPaidList && costPaidList )
                    }
                        etThread.traceF( tinP , T("home privileges check / could not download \"")+tShort+T("\" from \"")+tRemoteHomePrivileges+T("\" / will nap for 01 tock and then retry") ) ;
                        POOPR
                    {
                    if( POOP )
                    cloud.pullFileF( tinP , postPaidList , costPaidList , tRemoteHomePrivileges , tShort , 1 ) ; ___( postPaidList ) ;
                    ZE( countT , costPaidList ) ;
                    ZE( byteT* , postPaidList ) ;
                {
                else
                }
                    etThread.traceF( tinP , T("home privileges check / cannot connect") ) ;
                    POOPR
                {
                if( POOP )

                cloudC cloud( tinP , tName , ifcIDdOcLOUDiFdIFFER_NOTHING , flCLOUDc_NOcOPY | flCLOUDc_DOnOTlOADlOCAL | flCLOUDc_DOnOTlOADrEMOTE , ifcIDcLOUD_RACKSPACE , tBuilding , tUser , tPassword , tRemoteHomePrivileges ) ;
                etThread.traceF( tinP , T("querying privileges") ) ;
            {
            else
            }
                }
                    ether.ifcHireF( tinP , T("HOMEfLAGS") , ifcIDaDAM_PISS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; //MUST HIRE PISS EVEN IF NO PAID PRIVILEGES IN ORDER TO ALLOW USER TO UPDATE SETTINGS
                    etThread.traceF( tinP , T("hiring PISS") ) ;
                    bPissHired = 1 ;
                {
                if( !bPissHired )

                while( flagsOld != setIfEqualsAM( home.flags , flagsNew , flagsOld ) ) ;
                }
                    flagsNew = flagsOld | flHOMEs_PAIDpRIVILEGES ;
                    flagsOld = home.flags ;
                {
                do
                ZE( flagsT , flagsNew ) ;
                ZE( flagsT , flagsOld ) ;

                bPaid = 1 ;
                etThread.traceF( tinP , T("home privileges check / this is IDcOMPUTER_IPDOSmASTERcRAFTWORK so has paid privileges") ) ;
            {
            if( idComputer == IDcOMPUTER_IPDOSmASTERcRAFTWORK )
            etThread.traceF( tinP , T("[idComputer,idComputerCraftwork]:    ")+TF2(idComputer,flFORMAT_NObIGITvALUES|flFORMAT_FILLzE|flFORMAT_FOREIGN)+tb4+TF2(IDcOMPUTER_IPDOSmASTERcRAFTWORK,flFORMAT_NObIGITvALUES|flFORMAT_FILLzE|flFORMAT_FOREIGN) ) ;
            countT idComputer = etThread.diskIdF( tinP , T("///c") ) ;

            ZE( boolT , bPaid ) ;
        {
        while( !ether && !POOP )
        etherC& etRock = etherC::etRockIF( tinP ) ;
        TN( tb4 , "    " ) ;
        TN( tShort , "!paid.txt" ) ;
        ZE( boolT , bSaidPaid ) ;
        ZE( boolT , bSaidNotPaid ) ;

        SCOOPS
    {
    IFsCRATCH
    //INSPECT !paid.txt TO DISCOVER WHETHER home.postIdHomeGlobal IS LISTED
{
if( bApproved )

}
    etThread.delF( tinP , psttArbitraryUniquifier1 ) ;
    etThread.delF( tinP , psttIdHomeDisk           ) ;
    etThread.delF( tinP , psttIdComputer           ) ;
    etThread.delF( tinP , psttUserName             ) ;
    etThread.delF( tinP , psttUserEmail            ) ;
    
    }
        }
            }
                }
                    ether.osSleepF( tinP , TOCK << 4 ) ;
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    etThread.traceF( tinP , T("home registration check / napping for 01 tock before retrying") ) ;
                {
                else if( !bUploadedOk )
                if( bDone ) break ;

                }
                    etThread.delF( tinP , postHe ) ;
                    }
                        LOGrAW( postHe ) ;

                        }
                            bDone = 1 ;
                            etThread.traceF( tinP , T("file name collision:  please stop IPDOS (tm), edit your settings file to change the value of the arbitrary.uniquifier.1 setting, and then start IPDOS (tm)") ) ;
                        {
                        else
                        }
                            thirdC::c_strcpyIF( tinP , home.postIdHomeGlobal , tPostIdHomeGlobal ) ;
                            bApproved = bDone = 1 ;
                        {
                        if( costHe == costzMe && !thirdC::c_memcmpIF( tinP , postHe , postzMe , costHe ) )
                    {
                    else if( postHe && costHe )
                    }
                        }
                            etThread.traceF( tinP , T("home registration check / could not upload / will nap for 01 tock and then retry") ) ;
                            POOPR
                        {
                        else
                        if( !POOP ) bUploadedOk = 1 ;

                        cloud.pushFileF( tinP , tRemoteHomeRegistry , tShort , postzMe , costzMe ) ; //U:: cTries = 1
                        POOPR
                    {
                    if( POOP )
                    cloud.pullFileF( tinP , postHe , costHe , tRemoteHomeRegistry , tShort , 1 ) ; ___( postHe ) ;
                    ZE( countT , costHe ) ;
                    ZE( byteT* , postHe ) ;
                    etThread.traceF( tinP , T("home registration file: ")+tShort ) ;
                {
                else
                }
                    }
                        ether.ifcHireF( tinP , T("HOMEfLAGS") , ifcIDaDAM_PISS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; // IdeaFarm (tm) Bundle IS FREEWARE WHEN IdeaFarm (tm) ADMINISTRATIVE CLOUD IS NOT VISIBLE (E.G. IF I DIE AND MY RACKSPACE ACCOUNTS ARE CLOSED)
                        bPissHired = 1 ;
                    {
                    if( !bPissHired )

                    etThread.traceF( tinP , T("home registration check / cannot connect") ) ;
                    POOPR
                {
                if( POOP )
                ZE( boolT  , bUploadedOk ) ;
    
                cloudC cloud( tinP , tName , ifcIDdOcLOUDiFdIFFER_NOTHING , flCLOUDc_NOcOPY | flCLOUDc_DOnOTlOADlOCAL | flCLOUDc_DOnOTlOADrEMOTE , ifcIDcLOUD_RACKSPACE , tBuilding , tUser , tPassword , tRemoteHomeRegistry ) ;
            {
            while( !ether && !POOP && !bDone )
            etherC& etRock = etherC::etRockIF( tinP ) ;
            ZE( boolT , bDone ) ;
    
            SCOOPS
        {
        IFsCRATCH

        }
            psttBuilding = psttUser = psttPassword = psttRemoteHomeRegistry = 0 ;
            etThread.osThreadF( TaRG1( tmWatchIdeafarmF ) , (countT)psttBuilding , (countT)psttUser , (countT)psttPassword , (countT)psttRemoteHomeRegistry ) ;

            etThread.strMakeF( tinP , psttRemoteHomeRegistry , tRemoteHomeRegistry ) ; ___( psttRemoteHomeRegistry ) ;
            etThread.strMakeF( tinP , psttPassword           , tPassword           ) ; ___( psttPassword           ) ;
            etThread.strMakeF( tinP , psttUser               , tUser               ) ; ___( psttUser               ) ;
            etThread.strMakeF( tinP , psttBuilding           , tBuilding           ) ; ___( psttBuilding           ) ;
            ZE( strokeS* , psttRemoteHomeRegistry ) ;
            ZE( strokeS* , psttPassword ) ;
            ZE( strokeS* , psttUser ) ;
            ZE( strokeS* , psttBuilding ) ;
        {

        TN( tShort            , "" ) ; tShort            = tPostIdHomeGlobal+tShortSuffix ;
        TN( tPostIdHomeGlobal , "" ) ; tPostIdHomeGlobal = tEmailCleaned+strokeS('.')+tHash ;
    
        }
            etThread.delF( tinP , psttc ) ;
            tEmailCleaned = T(psttc) ;
    
            }
                etThread.delF( tinP , psttd ) ;
                etThread.strSubstringF( tinP , psttc , idf , idl , psttd ) ; ___( psttc ) ;
                countT idl = costEmailMax ;
                countT idf = 1 ;
                                 psttc = 0 ;
                strokeS* psttd = psttc ;
            {
            if( psttc->idAdam > costEmailMax )

            const countT costEmailMax = COSTiDhOMEgLOBALmAX - COSTpOSThASHmD5 - tShortSuffix.csF( tinP ) - 1 ;
    
            etThread.strReplaceF( tinP , psttc , psttUserEmail , tSmallOld , tn ) ; ___( psttc ) ;
            TN( tn , "" ) ;
            ZE( strokeS* , psttc ) ;
    
            ;
        
                +S2(sa_SSSaNDeND,sc_ccSSS)
                    +S2(sa_SSSoReND,sc_ccSSS)
            
                        +T("az09")
            
                    +S3(sa_SSSoR,sc_ccSSS,sp_SSSfLAGrANGEpAIRS|sp_SSSfLAGnOT)
                +S2(sa_SSSaND,sc_ccSSS)
                T("")
        
            TN( tSmallOld , "" ) ; tSmallOld =
        {
        TN( tShortSuffix , ".home.txt" ) ;
        TN( tEmailCleaned , "" ) ;
    
        }
            etThread.delF( tinP , psttHash ) ;
            tHash = T(psttHash) ;
            hasher.queryStringF( tinP , psttHash ) ; ___( psttHash ) ;
            ZE( strokeS* , psttHash ) ;

            hasher.eatF( tinP , postzMe , costzMe ) ;
            hasherC hasher( tinP , etThread ) ;
        {
        TN( tHash , "" ) ;
   
        //LOGrAW( postzMe ) ;
    
        countT   costzMe = thirdC::c_strlenIF( tinP , postzMe ) ;       // DONE THIS WAY BECAUSE csF() COUNT WILL DIFFER IF SOME STROKES WERE SUPPRESSED WHEN CONVERTING TO osTextT
        osTextT* postzMe = tMe ;
    
        etThread.delF( tinP , psttMe ) ;
        TN( tMe , psttMe ) ;
    
        etThread.strFuseF( tinP , psttMe , tcr ) ;
        etThread.strFuseF( tinP , psttMe , psttArbitraryUniquifier1 ) ;
        etThread.strFuseF( tinP , psttMe , tcr ) ;
        etThread.strFuseF( tinP , psttMe , psttIdHomeDisk ) ;
        etThread.strFuseF( tinP , psttMe , tcr ) ;
        etThread.strFuseF( tinP , psttMe , psttIdComputer ) ;
        etThread.strFuseF( tinP , psttMe , tcr ) ;
        etThread.strFuseF( tinP , psttMe , psttUserName ) ;
        etThread.strFuseF( tinP , psttMe , tcr ) ;
        etThread.strFuseF( tinP , psttMe , psttUserEmail ) ;
        etThread.strFuseF( tinP , psttMe , T("ideafarm.com\r\nIPDOS (tm) - IdeaFarm (tm) Piggyback Distributed Operating System\r\nHome Folder Registration\r\nformat:1\r\n") ) ;
    
        TN( tcr , "\r\n" ) ;
    
        ) ; ___( psttMe ) ;
    
            TUCK
            psttArbitraryUniquifier1->idAdam                        +
            psttIdHomeDisk->idAdam                                  +
            psttIdComputer->idAdam                                  +
            psttUserName->idAdam                                    +
            psttUserEmail->idAdam                                   +
    
        etThread.strMakeF( tinP , psttMe , 0 , 
        ZE( strokeS* , psttMe ) ;

        thirdC::c_strcpyIF( tinP , home.postIdHomeGlobal , "!registering" ) ;
    {
    else
    }
        ether.ifcHireF( tinP , T("HOMEfLAGS") , ifcIDaDAM_PISS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; //MUST HIRE PISS EVEN IF NO PAID PRIVILEGES IN ORDER TO ALLOW USER TO UPDATE SETTINGS
        thirdC::c_strcpyIF( tinP , home.postIdHomeGlobal , "!settingsAreInvalid" ) ;
    {
    if( bSettingsAreBad )

    }
             if( !psttArbitraryUniquifier1 ) { bSettingsAreBad |= 1 ; etThread.traceF( tinP , (strokeS*)( T("invalid setting: the ")+tSuffixArbitraryUniquifier1+T(" setting is missing (it should normally be set to \"\", the null string)") ) ) ; }

        else if( !psttUserName->idAdam     ) { bSettingsAreBad |= 1 ; etThread.traceF( tinP , (strokeS*)( T("invalid setting: the ")+tSuffixPrimaryEndUserName+T(" setting must be at least 1 character"                                     ) ) ) ; }
             if( !psttUserName             ) { bSettingsAreBad |= 1 ; etThread.traceF( tinP , (strokeS*)( T("invalid setting: the ")+tSuffixPrimaryEndUserName+T(" setting is missing"                                                       ) ) ) ; }

        else if( !psttUserEmail->idAdam    ) { bSettingsAreBad |= 1 ; etThread.traceF( tinP , (strokeS*)( T("invalid setting: the ")+tSuffixPrimaryEndUserEmail+T(" setting must be at least 1 character"                                    ) ) ) ; }
             if( !psttUserEmail            ) { bSettingsAreBad |= 1 ; etThread.traceF( tinP , (strokeS*)( T("invalid setting: the ")+tSuffixPrimaryEndUserEmail+T(" setting is missing"                                                      ) ) ) ; }
    {
    ZE( boolT , bSettingsAreBad ) ;

    etThread.strFromF( tinP , psttIdHomeDisk , idHomeDisk , flFORMAT_NObIGITvALUES | flFORMAT_UNSIGNED | flFORMAT_FILLzE , 2 * sizeof( countT ) ) ; ___( psttIdHomeDisk ) ;
    ZE( strokeS* , psttIdHomeDisk ) ;
    countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;
    
    etThread.strFromF( tinP , psttIdComputer , idComputer , flFORMAT_NObIGITvALUES | flFORMAT_UNSIGNED | flFORMAT_FILLzE , 2 * sizeof( countT ) ) ; ___( psttIdComputer ) ;
    ZE( strokeS* , psttIdComputer ) ;
    countT idComputer = etThread.diskIdF( tinP , T("///c") ) ;

    if( psttUserEmail ) { etThread.strConvertToLowerCaseF( tinP , psttUserEmail ) ; ___( psttUserEmail ) ; }
    
    ZE( strokeS* , psttArbitraryUniquifier1 ) ; etThread.querySettingF( tinP , psttArbitraryUniquifier1 , tSettingPrefix+tSuffixArbitraryUniquifier1 ) ; ___( psttArbitraryUniquifier1 ) ;
    ZE( strokeS* , psttUserName             ) ; etThread.querySettingF( tinP , psttUserName             , tSettingPrefix+tSuffixPrimaryEndUserName   ) ; ___( psttUserName             ) ;
    ZE( strokeS* , psttUserEmail            ) ; etThread.querySettingF( tinP , psttUserEmail            , tSettingPrefix+tSuffixPrimaryEndUserEmail  ) ; ___( psttUserEmail            ) ;

    TN( tSuffixArbitraryUniquifier1 , "arbitrary.uniquifier.1" ) ;
    TN( tSuffixPrimaryEndUserName   , "primary.end.user.name"  ) ;
    TN( tSuffixPrimaryEndUserEmail  , "primary.end.user.email" ) ;
    TN( tSettingPrefix , "!ipdos." ) ;

    thirdC::c_strcpyIF( tinP , home.postIdHomeGlobal , "!queryingSettings" ) ;
{
ZE( boolT , bPissHired ) ;
ZE( boolT , bApproved ) ;

TN( tRemoteHomePrivileges , "ipdos.home.privileges" ) ;
TN( tRemoteHomeRegistry , "ipdos.home.registry" ) ;

secretF( tinP , etThread , tUser , tPassword ) ;
TN( tPassword , "" ) ;
TN( tUser , "" ) ;

TN( tBuilding , "IAD" ) ;
}
    etThread.delF( tinP , psttu ) ;
    tName = T(psttu) ;
    etThread.strUniqueF( tinP , psttu ) ; ___( psttu ) ;
    ZE( strokeS* , psttu ) ;
{
TN( tName , "" ) ;

homeS& home = homeS::homeIF() ;

TASK( tmGetIdHomeF )

DONE( tmWatchIdeafarmF )
}
    etThread.delF( tinP , psttRemoteHomeRegistryP ) ;
    etThread.delF( tinP , psttPasswordP           ) ;
    etThread.delF( tinP , psttUserP               ) ;
    etThread.delF( tinP , psttBuildingP           ) ;
    }
        }
            //etRock.traceF( tinP , T("tmWatchIdeafarmF / loop /-") ) ;
            ++ s ; ether.osSleepF( tinP , TICK << 7 ) ;                                         //20181110@1429: "TOCK << 4" -> "TICK << 7" TO REDUCE BANDWIDTH CHARGES; MIGHT NEED TO MAKE THIS MORE FREQUENT WHEN HAVE NEW USERS
            //etRock.traceF( tinP , T("tmWatchIdeafarmF / loop / napping for tick << 7") ) ;

            }
                //etRock.traceF( tinP , T("tmWatchIdeafarmF / loop /0") ) ;
                }
                    }
                        if( ii > TUCK ) etRock.traceF( tinP , tStuck2 ) ;
                        if( flagso == setIfEqualsAM( home.flags , flagsn , flagso ) ) break ;
                        flagsT flagsn = flagso & ~(F(flHOMEs_IDEAFARMcLOUDiSgONE)) ;
                        flagsT flagso = home.flags ;
                    {
                    if( F(home.flags) & flHOMEs_IDEAFARMcLOUDiSgONE ) for( countT ii = 0 ;; ii ++ )

                    //etRock.traceF( tinP , T("tmWatchIdeafarmF / connected aok to the IdeaFarm (tm) accounting cloud") ) ;
                {
                else
                }
                    }
                        if( ii > TUCK ) etRock.traceF( tinP , tStuck1 ) ;
                        if( flagso == setIfEqualsAM( home.flags , flagsn , flagso ) ) break ;
                        flagsT flagsn = flagso | flHOMEs_IDEAFARMcLOUDiSgONE ;
                        flagsT flagso = home.flags ;
                    {
                    if( !( F(home.flags) & flHOMEs_IDEAFARMcLOUDiSgONE ) ) for( countT ii = 0 ;; ii ++ )

                    etRock.traceF( tinP , T("tmWatchIdeafarmF / the IdeaFarm (tm) accounting cloud is not visible") ) ;
                    POOPR
                {
                if( POOP )
                TN( tStuck2 , "setIfEqualsAM is stuck 2" ) ;
                TN( tStuck1 , "setIfEqualsAM is stuck 1" ) ;
        
                //etRock.traceF( tinP , T("tmWatchIdeafarmF / loop /1") ) ;
                cloudC cloud( tinP , tName , ifcIDdOcLOUDiFdIFFER_NOTHING , flCLOUDc_NOcOPY | flCLOUDc_DOnOTlOADlOCAL | flCLOUDc_DOnOTlOADrEMOTE , ifcIDcLOUD_RACKSPACE , psttBuildingP , psttUserP , psttPasswordP , psttRemoteHomeRegistryP ) ;
                //etRock.traceF( tinP , T("tmWatchIdeafarmF / loop /2") ) ;
            {

            }
                etThread.delF( tinP , psttu ) ;
                tName = T(psttu) ;
                etThread.strUniqueF( tinP , psttu ) ; ___( psttu ) ;
                ZE( strokeS* , psttu ) ;
            {
            TN( tName , "" ) ;

            //etRock.traceF( tinP , T("tmWatchIdeafarmF / loop /+") ) ;
        {
        while( !ether && !etThread && !POOP )
        etherC& etRock = etherC::etRockIF( tinP ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;

        SCOOPS
    {
    IFsCRATCH

    etherC& etRock = etherC::etRockIF( tinP ) ;
    homeS& home = homeS::homeIF() ;

    strokeS* psttRemoteHomeRegistryP = (strokeS*)pTaskP->c4 ;
    strokeS* psttPasswordP           = (strokeS*)pTaskP->c3 ;
    strokeS* psttUserP               = (strokeS*)pTaskP->c2 ;
    strokeS* psttBuildingP           = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmWatchIdeafarmF )

}
    }
        tPasswordP += T(postWo) ;
        osTextT postWo[] = { (osTextT)( pcPassword[ offi ] SUBfLAK ) , 0 } ;
    {
    for( countT offi = 0 ; offi < sizeof pcPassword / sizeof pcPassword[ 0 ] ; offi ++ )

    }
        tUserP += T(postWo) ;
        osTextT postWo[] = { (osTextT)( pcUser[ offi ] SUBfLAK ) , 0 } ;
    {
    for( countT offi = 0 ; offi < sizeof pcUser / sizeof pcUser[ 0 ] ; offi ++ )

    countT pcPassword[] = { '8' ADDfLAK , 'd' ADDfLAK , 'b' ADDfLAK , 'b' ADDfLAK , '3' ADDfLAK , '6' ADDfLAK , 'b' ADDfLAK , 'a' ADDfLAK , '0' ADDfLAK , '3' ADDfLAK , 'd' ADDfLAK , 'a' ADDfLAK , '4' ADDfLAK , '0' ADDfLAK , '0' ADDfLAK , 'c' ADDfLAK , '8' ADDfLAK , 'f' ADDfLAK , 'c' ADDfLAK , 'f' ADDfLAK , '3' ADDfLAK , '6' ADDfLAK , '4' ADDfLAK , 'a' ADDfLAK , 'b' ADDfLAK , '9' ADDfLAK , 'c' ADDfLAK , 'e' ADDfLAK , 'e' ADDfLAK , 'f' ADDfLAK , 'b' ADDfLAK , '5' ADDfLAK } ;
    countT pcUser[]     = { 'i' ADDfLAK , 'p' ADDfLAK , 'd' ADDfLAK , 'o' ADDfLAK , 's' ADDfLAK , '.' ADDfLAK , '0' ADDfLAK , '1' ADDfLAK } ;
{
voidT secretF( tinS& tinP , etherC& etherP , textC& tUserP , textC& tPasswordP )

#define SUBfLAK & ~0x84c73d00
#define ADDfLAK |  0x84c73d00

}
    }
        }
            tinP.pEtScratch->delF( tinP , psttP ) ;
            POOPR
        {
        if( POOP )
    
        tinP.pEtScratch->delF( tinP , psttAll ) ;
        }
            tinP.pEtScratch->delF( tinP , psttSection ) ;
            else                    tinP.pEtScratch->strokeF( tinP , T("<<<<")+T(psttSection)+T(">>>>") ) ;
            if( cSkip && cSkip -- ) ;
            tinP.pEtScratch->strSubstringF( tinP , psttSection , idf , sttq , T("<hr>") , psttAll ) ; ___( psttSection ) ;
            ZE( strokeS* , psttSection ) ;
        {
        while( idf && !POOP )
        etherC& etRock = etherC::etRockIF( tinP ) ;
        countT cSkip = 1 ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;
    
        tinP.pEtScratch->delF( tinP , pbAll  ) ;
        tinP.pEtScratch->strMakeF( tinP , psttAll , T(pbAll) ) ; ___( psttAll ) ;
        ZE( strokeS* , psttAll ) ;
    
        tinP.pEtScratch->boxPutF( tinP , T("///d/tmp.ideafarm.txt") , pbAll , cbAll ) ;
    
        tinP.pEtScratch->boxGetShadowF( tinP , pbAll , cbAll , tRosterHttp ) ; ___( pbAll  ) ;
        ZE( countT , cbAll ) ;
        ZE( byteT* , pbAll  ) ;
        //TN( tRosterHttp  , "www.fuckyourbrain.com//http//index.htm" ) ;
        TN( tRosterHttp  , "www.ideafarm.com//http//index.htm" ) ;
        SCOOPS
    {
    IFsCRATCH
{
voidT rosterF( tinS& tinP , strokeS*& psttP )

}
    return bOk ;
    //LOGrAW3( "bOkHttpPageF [bOk]: " , bOk , "\r\n" ) ;

    }
        else bOk = 1 ;
        }
            //CONoUTrAW( "F" ) ;
            POOPR
        {
        if( POOP )
        tinP.pEtScratch->delF( tinP , pbHome  ) ;
        tinP.pEtScratch->boxGetShadowF( tinP , pbHome  , cbHome  , psttP  ) ; ___( pbHome  ) ;
        ZE( countT , cbHome ) ;
        ZE( byteT* , pbHome  ) ;
        SCOOPS
    {
    IFsCRATCH
    ZE( boolT , bOk ) ;
{
boolT bOkHttpPageF( tinS& tinP , const strokeS* const psttP )

}
    return bRefused ;
    //LOGrAW3( "bDnsRefusedVersionF [bRefused]: " , bRefused , "\r\n" ) ;

    }
        else if( nn.pcId[ 0 ] == 0xff00ff00 ) bRefused = 1 ;
        if( POOP ) POOPR
        nicNameC nn = tinP.pEtScratch->sockNicNameF( tinP , psttP ) ;
        SCOOPS
    {
    IFsCRATCH
    ZE( boolT , bRefused ) ; //VERSION REFUSED FLAG WILL BE SET ONLY IF I GET A POSITIVE DENIAL FROM THE DNS
{
boolT bDnsRefusedVersionF( tinS& tinP , const strokeS* const psttP )

}
    return bOk ;
    //LOGrAW3( "bOkDnsValueF [bOk]: " , bOk , "\r\n" ) ;

    }
        else  bOk = 1 ;
        else if( !nn ) { /*CONoUTrAW( "F" ) ;*/ }
        }
            //CONoUTrAW( "F" ) ;
            POOPR
        {
        if( POOP )
        nicNameC nn = tinP.pEtScratch->sockNicNameF( tinP , psttP ) ;
        SCOOPS
    {
    IFsCRATCH
    ZE( boolT , bOk ) ;
{
boolT bOkDnsValueF( tinS& tinP , const strokeS* const psttP )

/*1*/WAKEhIDE( "ifcIDaDAM_HOMEfLAGS" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

