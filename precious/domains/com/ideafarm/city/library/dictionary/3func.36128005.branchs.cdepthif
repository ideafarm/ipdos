
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cDepth ;

    }
        ;
            : cDepthHe
            ? cDepthMe
        cDepth = cDepthMe > cDepthHe

        }
            }
                else             cDepthMe += cDepthKidMax ;
                if( !bFoundKid ) cDepthMe -- ;

                while( jc ) ;
                }
                    jc = jcRight ;

                    }
                        jcRight = B(brc).jbrRight ;
                        BSP( brc , jc ) ;
                    {
                    ZE( countT , jcRight ) ;

                    }
                        if( cDepthKidMax < cDepthKid ) cDepthKidMax = cDepthKid ;
                        if( !bFoundKid ) bFoundKid = 1 ;
                    {
                    if( cDepthKid != - 1 )
                    countT cDepthKid = cDepthIF( tinP , etherP , jc , cDepthMaxP - 1 , idEditionP ) ;
                {
                do
                const countT jStart = jc ;
                ZE( boolT ,  bFoundKid ) ;
                ZE( countT , cDepthKidMax ) ;

                cDepthMe ++ ; //TENTATIVE; WILL BE DECREMENTED IF ALL KIDS ARE NIXED

                jc = jcUp ;
            {
            if( jcUp )

            }
                jcUp = B(brc).jbrUp ;
                BSP( brc , jc ) ;
            {
            ZE( countT , jcUp ) ;

            countT jc = jMeP ;
        {
        if( cDepthMaxP )
        ZE( countT , cDepthMe ) ;
    {
    else
    if( bNix ) cDepth = - 1 ;

    }
        if( jHe ) cDepthHe = cDepthIF( tinP , etherP , jHe , cDepthMaxP , idEditionP ) ;

        }
            }
                valueHe  = B(brHe).value  ;
                idTypeHe = B(brHe).idType ;
                BSP( brHe , jHe ) ;
                jHe = valueHe ;
            {
            else
            }
                 valueHe = idTypeHe = jHe = 0 ;
                 etherP.traceF( tinP , T("branchS::cDepthIF: error: following a branch pointer led nowhere") ) ;
            {
            else if( !valueHe )                                          //20180420@0954:  ADDED WITHOUT ANALYSIS TO HANDLE !jHe WHEN etherSoilF PROCESSES A KT WITH AN INTENTIONAL MISSING LABEL
            if( jStart == valueHe ) valueHe = idTypeHe = jHe = 0 ;
        {
        while( idTypeHe == ifcIDtYPEbRANCHs_branchSptr )

        }
            valueHe  = B(brHe).value  ;
            idTypeHe = B(brHe).idType ;
            BSP( brHe , jHe ) ;
        {
        ZE( countT , valueHe  ) ;
        ZE( countT , idTypeHe ) ;

        countT jHe = jStart ;
        const countT jStart = jMeP ;
    {
    if( !bNix && idTypeMe == ifcIDtYPEbRANCHs_branchSptr )
    ZE( countT , cDepthHe ) ;

    boolT bNix = !!branchS::bEditionIF( tinP , etherP , jMeP , idEditionP ) ;

    }
        idTypeMe = B(brMe).idType ;
        flagsMe  = B(brMe).flags  ;
        BSP( brMe , jMeP ) ;
    {
    ZE( countT , idTypeMe ) ;
    ZE( flagsT , flagsMe ) ;

    ZE( countT , cDepth ) ;
{
/*1*/countT branchS::cDepthIF( tinS& tinP , etherC& etherP , const countT jMeP , const countT cDepthMaxP , const countT idEditionP )/*1*/

// IF I AM A REFERENCE, I RETURN THE MAXIMUM OF ITS DEPTH AND THE DEPTH OF THE BRANCH THAT I REFERENCE
// I HANDLE LOOPING SILENTLY, CONTAINING ONLY THE LOGIC THAT I NEED TO RETURN PROMPTLY AS SOON AS I KNOW THAT DEPTH IS NOT DEFINED

/**/
*/
  if not 0 then inspects branch values to detect branches that are suppressed for the specified edition
 idEditionP
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

