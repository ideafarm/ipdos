
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return *prc ;

    _OUTbATONsTACKc_
    }
        prc = &PLATE_countT_REF( ppTop ) ;
        adjustRefsF( tinP , 1 , ifcIDaCTIONsTACKaDJUSTrEFS_REFERENCE , ppTop ) ;
    {
    if( ppTop )
    if( tinP.fingerprint ) ;
    countT* prc = (countT*)pbnu ;

    LATHrEF
    _INbATONsTACKc_

    SCOOP
{
/*1*/countT& stackC::topF( tinS& tinP )/*1*/

/**/
*/
after calling this function, stackC::extractF( tinP ) can be used to remove the item that it references
 in a multithreaded app, it is possible to cause an access violation by calling this function on one thread while removing the last item on the stack on another thread
it is also not serialized
it is optimized for speed, does not check for errors, and does not perform the standard overhead functionality
this function is very fast
 example: myStack[ 1 ] is equivalent to myStack.topF(
this function is equivalent to stackC::operator[] with argument == 1
 this static object is shared by all threads and calls to this function
if the stack is empty, evaluates to a countT object local to this stackC object
evaluates to a reference to the countT object at the top of the stack
  \<A HREF=\"5.d230104.1.1.0.html\"\>d230104:  WAKEsHOW( "example.simplest.func.1150030.stackC.topF" )\</A\>
 simplest
examples
\<A HREF=\"5.1150030.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$topF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

