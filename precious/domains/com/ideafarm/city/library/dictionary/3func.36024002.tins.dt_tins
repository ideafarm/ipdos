
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //SAYnAME( "~tinS/-\r\n" )
    TELL( "~tinS: final tell tag in ~tinS" )
    TINSL

    }
        }
            if( F(flags) & flTINs_DELETEtLS ) { PUSE( tinP , *(byteT**)&pbTls           ) ; }
                                                PUSE( tinP , pbPendingInOutFramePackets ) ;
        {
        else          
        if( !pPoolUse ) processGlobal4I.heap.delF( tinP , pbPendingInOutFramePackets ) ;

        }
            LOGrAW( "-\r\n" ) ;
            LOGrAW( postThreadName ) ;
        {
        if( F(thirdC::third_flagsModeAdam2I_IF(*this)) & flADAMmODE2_THREADcHATTER )

        if( idTinNamed != ifcIDtINnAMED_tinHeartI && idTinNamed != ifcIDtINnAMED_tinBreakI ) unwatchedF() ;
        POOPIES
        dtTellCopyDoneF( (countT)this ) ;

        }
            TELLaPPc3LIFI( ifcIDtYPEtELLaPP_INoUTtINdT , (byteT*)&info , sizeof info , ifcLINE , DDNUMB ) ;
            THREADmODE4oN0( flTHREADmODE4_INoUTfRAMEdEFERwRITINGaPPtELEMETRY ) ;

                                                 cCpuCyclesWriteInOutTelemetry = 0 ;
            info.cCpuCyclesWriteInOutTelemetry = cCpuCyclesWriteInOutTelemetry ;
                          cTellsWriteInOutTelemetry = 0 ;
            info.cTells = cTellsWriteInOutTelemetry ;
            info.idThreadReporting = monitor.idThread ;
            tellInfoAppInOutFrameTinDtS info ;
            //PS:PSEUDOdUPLICATE CODE: 36024002 360fc002

            }
                }
                    cPending = 0 ;

                    }
                        thirdC::dosTellMonitorIF( tinP , tell , ifcIDbOOKStELL_APP ) ;
                        tellC tell( tinP , LF , 0 , ifcIDtYPEtELLaPP_INoUTaRRAY , tinP.pbPendingInOutFramePackets , sizeof( countT ) + cPending * sizeof( tellInfoAppInOutFrameS ) ) ;
                    {

                    }
                        BLAMMO ;
                        LOGrAW5(    "~tinS error: [cPending,cMax]: " , cPending , " " , CmAXpENDINGiNoUTfRAMEpACKETS , "\r\n" ) ;
                        CONoUTrAW5( "~tinS error: [cPending,cMax]: " , cPending , " " , CmAXpENDINGiNoUTfRAMEpACKETS , "\r\n" ) ;
                    {
                    if( cPending > CmAXpENDINGiNoUTfRAMEpACKETS )

                    tellInfoAppInOutFrameS* pPending = (tellInfoAppInOutFrameS*)( tinP.pbPendingInOutFramePackets + sizeof( countT ) ) ;
                {
                if( cPending )

                countT& cPending = *(countT*)tinP.pbPendingInOutFramePackets ;
            {
            if( tinP.pbPendingInOutFramePackets )
            //PSEUDOdUPLICATEcODE 360fc002 33000065

            THREADmODE4oN0( flTHREADmODE4_INoUTfRAMEdOnOTcOLLECTaPPtELEMETRY | flTHREADmODE4_DOnOTfLUSHpENDINGaPPtELEMETRY ) ;
        {
        if( monitor.idThread > 3 ) // FOR THREAD 1, SEE doC::~doC; THREAD 2 AND 3 ARE tinHeart AND tinBreak, WHICH NORMALLY ACCUMULATE NO TELEMETRY

        TINSL       // I CANNOT USE MYSELF BECAUSE I MIGHT BE tinHeart OR tinBreak
    {
    else
    }
        if( pTinF() != pTinOld ) { thirdC::dosExitProcessIF( ifcEXITcODEpROCESSiMPOTENT ) ; }

        if( thirdC::c_memcpyWithCallBackIF( (byteT*)pTinOld + CBtINpREFIX , (byteT*)this + CBtINpREFIX , sizeof( tinS ) - CBtINpREFIX - CBtINsUFFIX , dtTellCopyDoneF , (countT)this ) ) { CONoUTrAW( "I AM BLAMMOING  LA  TEEE  DAA!\r\n" ) ; thirdC::dosExitProcessIF( ifcEXITcODEpROCESSiMPOTENT ) ; } //CODE SYNC: 003002a 12f0002 12f0003

        }
            //SAYnAME( "~tinS/ " ) CONoUTrAW( "copying to " ) ; CONoUTrAW( NAME( pTinOld->idTinNamed ) ) ; ; CONoUTrAW( "\r\n" ) ;
            TINSL
        {
    {
    if( pTinOld )

    }
        DEL( pSwsRecycle ) ; //TO MAKE SURE THAT etRock EXISTS WHEN THESE ARE DELETED
        }
            THREADmODE1rESTORE
            }
                }
                    }
                        }
                            default                            : { thirdC::dosExitProcessIF( ifcEXITcODEpROCESSiMPOTENT ) ; break ; }
                            case ifcIDtYPErECYCLE_switchStackC : { DEL( *(switchStackC**)&pObject ) ; break ; }
                            case ifcIDtYPErECYCLE_switchC      : { DEL(      *(switchC**)&pObject ) ; break ; }
                            case ifcIDtYPErECYCLE_stackC       : { DEL(       *(stackC**)&pObject ) ; break ; }
                            case ifcIDtYPErECYCLE_soulC        : { DEL(        *(soulC**)&pObject ) ; break ; }
                        {
                        switch( *pczl_pSwsRecycle )
                    {
                    if( pczl_pSwsRecycle && pObject )

                    *pSwsRecycle >> *(countT*)&pObject ;
                    ZE( voidT* , pObject ) ;
                {
                while( *pSwsRecycle )
        
                pczl_pSwsRecycle = (countT*)pSwsRecycle->leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = pSwsRecycle->cFlavorsF( tinP ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        {
        if( pSwsRecycle )
        //PSEUDODUPLICATE CODE: 1450002 12f0002 1030003 1020171

        deregisterIfF( tinP ) ;
        TELL( "~tinS: deregistering" )

        }
            thirdC::dosExitProcessIF( ifcEXITcODEpROCESSiMPOTENT ) ;
            }
                }
                    LOGrAW5( "~tinS dying while this is grabbed [idLineCt,idiFileCt]: " , tinP.pPanLifiRecurseGrabbedLevel[ off + 1 ] , " " , tinP.pPanLifiRecurseGrabbedLevel[ off + 2 ] , "\r\n" ) ;
                {
                if( tinP.pPanLifiRecurseGrabbedLevel[ off ] )
            {
            for( countT off = 0 ; off < offEnd ; off += 5 )
            const countT offEnd = OFFgRABBEDmAX * 5 ;
        {
        if( tinP.monitor.cGrabbed )
        TELL( "verifying that nothing is now grabbed by this thread" )

        TELL( "~tinS: after setting processGlobal2I.flDt flag" )
        }
            }
                case ifcIDtINnAMED_tinInPoolMain             : { processGlobal2I.flDt |= flCTdTg_tinMainInPool             ; break ; }
                case ifcIDtINnAMED_tinVeryEarlyLateMainI     : { processGlobal2I.flDt |= flCTdTg_tinVeryEarlyLateMainI     ; break ; }
                case ifcIDtINnAMED_tinVeryVeryEarlyLateMainI : { processGlobal2I.flDt |= flCTdTg_tinVeryVeryEarlyLateMainI ; break ; }
            {
            switch( idTinNamed )

            if( pTinF() != this ) { thirdC::dosExitProcessIF( ifcEXITcODEpROCESSiMPOTENT ) ; }
        {
        if( idTinNamed != ifcIDtINnAMED_tinHeartI && idTinNamed != ifcIDtINnAMED_tinBreakI )
        TELL( "~tinS: setting processGlobal2I.flDt flag and testing pTinF()" )

        }
            }
                { ++ s ; thirdC::dosSleepWinkIF( tinP ) ; }
                //if( !cQuiet || !( -- cQuiet ) ) { LOGrAW5( postThreadName , cKidThreads , " ( pTinKid : " , (countT)pTinKid , " )\r\n" ) ; }

                }
                    thirdC::dosExitProcessIF( ifcEXITcODEpROCESSiMPOTENT ) ;
                    CONoUTrAW( "~tinS: calling ExitProcess because i am being cleaned up and i have kid threads.\r\n" ) ;
                {
                if( F(flagsThreadMode3) & flTHREADmODE3_EXCEPTIONcLEANUPdELETIONiNpROGRESS || F(processGlobal2I._thirdC_flagsProcessState) & flPROCESSsTATE_EXCEPTIONnOThANDLED )
            {
            while( cKidThreads ) //tmWindowsF must not put itself into this list because main CANNOT BLOCK HERE FOR tmWindowsF TO END BECAUSE tmWindowsF ENDS LATER
            countT cQuiet = 0x40 ; //INCR FROM 01 TO 04 TO AVOID LOGrAW
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
    
        POOPIES

        // ExitProcess RATHER THAN BLAMMO IS USED HERE BECAUSE I CAN BE CALLED BY EXCEPTION HANDLER CLEANUP LOOP

        //SAYnAME( "~tinS/+\r\n" )
        TINSL
    {
{
/*1*/tinS::~tinS( voidT )/*1*/

//#define SAYnAME(postP) { CONoUTrAW7( "[idTin,idThread,idSerial,name]: " , idTin , " " , monitor.idThread , " " , idSerial , " " ) ; CONoUTrAW( NAME( idTinNamed ) ) ; CONoUTrAW( " " postP ) ; }

//#define NAME(idP) processGlobal4I.mapTinName( idP )

/**/
*/
i work unconditionally so that the monitor receives notice of me and so that processGlobal5I.tinVeryEarlyLateMain is maintained even if impotence occurs
\<A HREF=\"5.12f0002.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

