
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    tinP.pAdamGlobal5->frPaper.grab.ungrabF( tinP ) ;

    etherP( tinP , pStk_pSadam ) ;
    }
        //LOGrAWtID( "----END--------------------------------------------------------------------------------------" ) ; //U::
        tinP.pAdamGlobal1->_pulpOldC_.flagsMode = saveModeI ;
        }
            }
                while( ~hWalk ) ;
                }
                    if( POOP ) POOPR
    
                    }
                        }
                            }
                                break ;
                                /*if( cpd && !( idCycleP % cpd ) )*/ sad.pStrike->sc.pPaper->moveGlyphF( tinP , sad , 0 ) ;
                                countT cpd = features.fc.cyclesPerDragRedraw ;
                            {
                            case 3 :
                            }
                                break ;
                                }
                                    vb.flags &= ~( F(flVbODYs_NEWsPEC) ) ;
                                    if( features.fc.pSadamAnimateCBF ) sad.doF( tinP , *tinP.pEtScratch , ifcIDtYPEsTROKEcALLbACK_VOLATILEtEXTcHANGED , idEvent , pcNotesP , 0 ) ;
                                    requestTabFreshIF( tinP ) ; //VOLATILE TEXT MIGHT CONTAIN BUTTONS THAT PARTICIPATE IN TABBING; MOVE TO sadamC::doF SO IS DONE ONLY WHEN TAB PARTICIPANT IS CT/DT
                                    sad.pStrike->sc.pPaper->renderVolatilesF( tinP , sad , 0 , flSTRIKEvOLATILE_LOADpOSITION | flSTRIKEvOLATILE_LOADsPEC , &vb ) ;
                                    sad.pStrike->rCacheVolatileSnap = sad.pStrike->sc.pPaper->x1.pPulp->rCache ;
                                    vb.flags &= ~( F(flVbODYs_STALEeRASED) ) ;
                                {
                                if( F(vb.flags) & flVbODYs_STALEeRASED )
                                vBodyS& vb = *(vBodyS*)&(countT&)*features.pswVolBody ; //THIS REFERENCE IS VOLATILE DUE TO SNAP/RESTORE DURING RENDERING
                            {
                            case 2 :
                            }
                                break ;

                                }
                                    vb.flags |= flVbODYs_STALEeRASED ;
                                    sad.pStrike->sc.pPaper->x1.pPulp->flagsMode = _saveMode ;
                                    sad.pStrike->sc.pPaper->renderVolatilesF( tinP , sad , 0 , flSTRIKEvOLATILE_null , &vb ) ;
                                    const flagsT _saveMode = sad.pStrike->sc.pPaper->x1.pPulp->flagsMode ;
                                    if( vb.psttDone ) sad.pStrike->sc.pPaper->x1.pPulp->rCache = sad.pStrike->rCacheVolatileSnap ;
                                
                                    if( features.fc.pSadamAnimateCBF ) sad.doF( tinP , *tinP.pEtScratch , ifcIDtYPEsTROKEcALLbACK_VOLATILEtEXTcHANGING , idEvent , pcNotesP , 0 ) ;
                                {
                                if( bStale )
                                if( F(vb.flags) & flVbODYs_STALEeRASED ) { BLAMMO ; }
                                
                                if( vb.zBaton_ppsttSpec ) vb.zBaton_ppsttSpec->ungrabF( tinP ) ;
                                ;
                                )
                                    (  *vb.ppsttSpec && etherP.strCompareF( tinP , *vb.ppsttSpec , vb.psttDone ) )
                                    ( !*vb.ppsttSpec &&  vb.psttDone ) ||
                                    (  *vb.ppsttSpec && !vb.psttDone ) ||
                                (
                                boolT bStale =
                                if( vb.zBaton_ppsttSpec ) vb.zBaton_ppsttSpec->grabF( tinP , TAG( TAGiDnULL ) ) ;
                                vBodyS& vb = *(vBodyS*)&(countT&)*features.pswVolBody ;
                                
                                if( features.fc.pSadamAnimateCBF ) sad.doF( tinP , *tinP.pEtScratch , ifcIDtYPEsTROKEcALLbACK_ANIMATE , idEvent , pcNotesP , 0 ) ;
                            {
                            case 1 :
                        {
                        switch( idPass )
                        //LOGrAWtID4( "pass " , idPass , " idvf " , idvf ) ;

                        features.cLeverVolBody = features.pswVolBody->leverF( tinP , idvf ) ;
                    {
                    for( countT idvf = 1 ; idvf <= cvFlavors ; idvf ++ )
                    countT cvFlavors = features.pswVolBody->cFlavorsF( tinP ) ;

                    //LOGrAWtID( TF1(features.fc.idTabClass)+T(".")+TF1(features.fc.idTab)+T(".")+TF1(features.fc.idAdam)+T(": \"")+T(features.fc.postOldComment)+T("\"") ) ; //U::

                    }
                        continue ;
                        pStk_pSadam->extractF( 0 , tinP ) ;
                    {
                    if( !sad.bAwakePresentF( tinP ) )

                    //U::NO EFFECT HERE

                    featuresS& features = *(featuresS*)&(const featuresS&)sad ;
                    sadamC& sad = *(sadamC*)pStk_pSadam->downF( tinP , hWalk ) ;
                {
                do
                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( *pStk_pSadam )

            //LOGrAWtID2( "pass " , idPass ) ; //U::
        {
        for( countT idPass = 1 ; idPass <= 3 ; idPass ++ )
        //LOGrAWtID( "----BEGIN------------------------------------------------------------------------------------" ) ; //U::
        tinP.pAdamGlobal1->_pulpOldC_.flagsMode |= flPAPERmODEi_SUPPRESStABfRESH ;
        flagsT saveModeI = tinP.pAdamGlobal1->_pulpOldC_.flagsMode ;
        const countT idEvent = 1 + incv02AM( tinP.pAdamGlobal1->idEventSadamsLath ) ;
    {
    if( pStk_pSadam && *pStk_pSadam )
    sadamsC::pSadamsIF( tinP )->getF( tinP , pStk_pSadam , flGETsADAMsTATES_FIFO ) ;
    ZE( stackC* , pStk_pSadam ) ;

    tinP.pAdamGlobal5->frPaper.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;

    //if( etherC::ether_cUtility_IF( tinP ) ) return ;
    //B eep( TUCK * ( 1 + etherC::ether_cUtility_IF( tinP ) ) , TUCK ) ; //U::TO STUDY CPU LOADING BY THIS FUNCTION
{
/*1*/voidT paperOldC::freshVolatileTextIF( tinS& tinP , etherC& etherP , const countT* const pcNotesP , const countT idCycleP )/*1*/

//U::EITHER PREVENT APP CODE IN CALLBACKS FROM CALLING SNAP/RESTORE OR REFRESH vb REFERENCES OR EDIT snapF TO DO RESTORE IN PLACE
//U::O: RESTORE vb IN PLACE SO CAN OBTAIN THIS REFERENCE WO TIME AND REUSE IT

// FOR EXAMPLE, ERASURES, RENDERS, PAPERBACK ABSENCE CHANGES, AND SADAM SLEEP/WAKE CHANGES ONLY OCCUR BETWEEN CALLS TO ME, NEVER DURING CALLS TO ME
// THIS IS ENFORCED BY DOING A GLOBAL GRAB AND ASSUMING THAT OTHER THREADS THAT MODIFY SADAM STATE ALSO DO A GLOBAL GRAB
// THIS CODE ASSUMES THAT STATE VALUES THAT IT LOOKS AT DO NOT CHANGE DURING THE CALL
// ALL STALE VALUES MUST BE ERASED BEFORE ANY REPLACEMENT VALUES ARE RENDERED

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

