
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    }
        }
            etThread.osSleepF( tinP , TOCK * 0x10 , TOCK * 0x10 ) ;
            etThread.strokeF( tinP , T("\r" BLANK79 "\r") ) ;
        {
        if( !ether )

        }
            etThread.strokeF( tinP , T("clock    updated at ")+TT(time1,time2)+T("-\r\n") ) ;
            etThread.delF( tinP , postc ) ;

            }
                sOut.writeF( tinP , postc  , costc ) ;
                { countT cbWrite = costc ; sOut.writeF( tinP , (byteT*)&cbWrite , sizeof cbWrite ) ; }
                { countT offTarget = 0x1ad ; sOut.writeF( tinP , (byteT*)&offTarget , sizeof offTarget ) ; }
                sOut.writeF( tinP , (byteT*)pcIdName  , ccIdName * sizeof( countT ) ) ;
                sOut.writeF( tinP , (byteT*)&ccIdName , sizeof ccIdName ) ;
                { countT idCmd = idCMDlAKEsERVER_WRITE ; sOut.writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ; }
                sOut.connectF( tinP , ifcPORToLD1lAKE , 0x01010102 ) ;
                socketC sOut( tinP , ether , TAG( TAGiDnULL ) ) ;
            {

            etThread.delF( tinP , psttc ) ;
            countT costc = etThread.strMakeF( tinP , postc , psttc ) ; ___( postc ) ;
            ZE( osTextT* , postc ) ;
            etThread.strClockOldF( tinP , psttc , time1 ) ; ___( psttc ) ;
            ZE( strokeS* , psttc ) ;

            etThread.strokeF( tinP , T("clock    updated at ")+TT(time1,time2)+T("+\r\n") ) ;
        {
        if( idCycle == 1 || bNewTick )

        time2last = time2 ;
        time1last = time1 ;

        const boolT bNewTick      = bNewHour   || offTICK(   time1 ) != offTICK(   time1last ) ;
        const boolT bNewHour      = bNewDay    || offHOUR(   time1 ) != offHOUR(   time1last ) ;
        const boolT bNewDay       = bNewStrong || offDAY(    time2 ) != offDAY(    time2last ) ;
        const boolT bNewStrong    = bNewQtr    || offSTRONG( time2 ) != offSTRONG( time2last ) ;
        const boolT bNewQtr       = bNewDuck   || offQTR(    time2 ) != offQTR(    time2last ) ;
        const boolT bNewDuck      =               offDUCK(   time2 ) != offDUCK(   time2last ) ;

        etThread.osTimeNowF( tinP , time1 , time2 ) ;
        ZE( sCountT , time2 ) ;
        ZE( countT , time1 ) ;
        idCycle ++ ;
    {
    while( !ether )
    ZE( countT , idCycle ) ;
    ZE( countT , idTry )

    etThread.osTimeNowF( tinP , time1last , time2last ) ;
    ZE( sCountT , time2last ) ;
    ZE( countT , time1last ) ;

    countT ccIdName   = etThread.strBodyLengthF( tinP , pcIdName ) ;    
    countT pcIdName[] = { 1 , 0x3f , 2 , 0 } ;

    { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmCalendarF ) ; }

    etThread.strokeF( tinP , T("IdeaFarm " "(tm) City Template Updater\r\ni overwrite revisions onto the template images in the lake\r\n\r\n") ) ;
{
else
}
    etThread.strokeF( tinP , T("Another ef30104 appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tinP , TAG( TAGiDnULL ) , T("ef30104") ) ;

TODO

DONE( tmCalendarF )
}
    }
        }
            etThread.osSleepF( tinP , TOCK * 0x40 , TOCK * 0x40 ) ;
            etThread.strokeF( tinP , T("\r" BLANK79 "\r") ) ;
        {
        if( !ether )

        }
            etThread.strokeF( tinP , T("calendar updated at ")+TT(time1,time2)+T("-\r\n") ) ;
            etThread.delF( tinP , postc ) ;

            }
                sOut.writeF( tinP , postc  , costc ) ;
                { countT cbWrite = costc ; sOut.writeF( tinP , (byteT*)&cbWrite , sizeof cbWrite ) ; }
                { countT offTarget = 0x1a7 ; sOut.writeF( tinP , (byteT*)&offTarget , sizeof offTarget ) ; }
                sOut.writeF( tinP , (byteT*)pcIdName  , ccIdName * sizeof( countT ) ) ;
                sOut.writeF( tinP , (byteT*)&ccIdName , sizeof ccIdName ) ;
                { countT idCmd = idCMDlAKEsERVER_WRITE ; sOut.writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ; }
                sOut.connectF( tinP , ifcPORToLD1lAKE , 0x01010102 ) ;
                socketC sOut( tinP , ether , TAG( TAGiDnULL ) ) ;
            {

            etThread.delF( tinP , psttc ) ;
            countT costc = etThread.strMakeF( tinP , postc , psttc ) ; ___( postc ) ;
            ZE( osTextT* , postc ) ;
            etThread.strCalendarF( tinP , psttc , time2 ) ; ___( psttc ) ;
            ZE( strokeS* , psttc ) ;

            etThread.strokeF( tinP , T("calendar updated at ")+TT(time1,time2)+T("+\r\n") ) ;
        {
        if( idCycle == 1 || bNewDay )

        time2last = time2 ;
        time1last = time1 ;

        const boolT bNewDay       = bNewStrong || offDAY(    time2 ) != offDAY(    time2last ) ;
        const boolT bNewStrong    = bNewQtr    || offSTRONG( time2 ) != offSTRONG( time2last ) ;
        const boolT bNewQtr       = bNewDuck   || offQTR(    time2 ) != offQTR(    time2last ) ;
        const boolT bNewDuck      =               offDUCK(   time2 ) != offDUCK(   time2last ) ;

        etThread.osTimeNowF( tinP , time1 , time2 ) ;
        ZE( sCountT , time2 ) ;
        ZE( countT , time1 ) ;
        idCycle ++ ;
    {
    while( !ether )
    ZE( countT , idCycle ) ;
    ZE( countT , idTry )

    etThread.osTimeNowF( tinP , time1last , time2last ) ;
    ZE( sCountT , time2last ) ;
    ZE( countT , time1last ) ;

    countT ccIdName   = etThread.strBodyLengthF( tinP , pcIdName ) ;    
    countT pcIdName[] = { 1 , 0x3f , 3 , 0 } ;
{
if( pTaskP )
TASK( tmCalendarF )

/*1*/WAKEhIDE( "city.template.updater" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

