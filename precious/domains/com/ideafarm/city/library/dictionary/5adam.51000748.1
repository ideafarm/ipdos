
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

//etThread.traceF( tinP , T("ok") ) ;

}
    }
        //etThread.traceF( tinP , T("napped") ) ;
        ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        //etThread.traceF( tinP , T("napping") ) ;

        if( bQuit ) break ;

        THREADmODE1rESTORE
        }
            }
                bPrefix = !bPrefix ;

                else          pbi = 0 ;
                if( bDelete ) PUSE( tinP , *(byteT**)&pbi ) ;

                ;
                    : sizeof( countT )
                    ? *(countT*)pbi
                cbi = bPrefix

                }
                    _OUT_

                    }
                        #endif

                        etThread.delF( tinP , psttBrowser ) ;
                        etThread.delF( tinP , psttProtocol ) ;
                        etThread.delF( tinP , psttQuery ) ;
                        etThread.delF( tinP , psttUri ) ;
                        etThread.delF( tinP , psttContainer ) ;
                        etThread.delF( tinP , psttLogBucket ) ;
                        etThread.delF( tinP , psttMethod ) ;

                        }
                            _OUT_

                            //}
                            //    etThread.traceF( tinP , T("[nnHe,time,method,bucket,container,uri,query,protocol,code,cb,browser]:    ")+tSay ) ;
                            //
                            //    ;
                            //
                            //        +tb4+tBrowser
                            //        +tb4+TF4(cbReply,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                            //        +tb4+TF4(code,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                            //        +tb4+tProtocol
                            //        +tb4+tQuery
                            //        +tb4+tUri
                            //        +tb4+tContainer
                            //        +tb4+tLogBucket
                            //        +tb4+tMethod
                            //        +tb4+TT(timeW1,timeW2)
                            //        T(nnHe)
                            //
                            //    TN( tSay , "" ) ; tSay =
                            //
                            //    TN( tBrowser   , psttBrowser   ) ;
                            //    TN( tProtocol  , psttProtocol  ) ;
                            //    TN( tQuery     , psttQuery     ) ;
                            //    TN( tUri       , psttUri       ) ;
                            //    TN( tContainer , psttContainer ) ;
                            //    TN( tLogBucket , psttLogBucket ) ;
                            //    TN( tMethod    , psttMethod    ) ;
                            //{

                            // A:ASSUME:  THIS CODE ASSUMES THAT EVENTS ARE UNIQUELY IDENTIFIED BY [hash,idJot,time,nn]; MULTIPLE EVENTS WILL RESULT IN MULTIPLE VALUES FOR THE FIELDS

                            //etThread.traceF( tinP , T(psttUri) ) ;

                            // *****************************************************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            // ********                         ********************************************************************************************************************************************************************************************************************
                            // ********  PROCESS WO BOOK ENTRY  ********************************************************************************************************************************************************************************************************************
                            // ********                         ********************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************

                            _INoLD_
                        {
                        else
                        if( getNegAM( finger ) != FINGERnEG_ACCESSeVENTrAW || idFormat != 1 ) etThread.traceF( tinP , T("unexpected format [finger,idFormat]:    ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        sBookEntryIn >> psttBrowser ;             ___( psttBrowser ) ;
                        sBookEntryIn >> cbReply ;
                        sBookEntryIn >> code ;
                        sBookEntryIn >> psttProtocol ;            ___( psttProtocol ) ;
                        sBookEntryIn >> psttQuery ;               ___( psttQuery ) ;
                        sBookEntryIn >> psttUri ;                 ___( psttUri ) ;
                        sBookEntryIn >> psttContainer ;           ___( psttContainer ) ;
                        sBookEntryIn >> psttLogBucket ;           ___( psttLogBucket ) ;
                        sBookEntryIn >> psttMethod ;              ___( psttMethod ) ;
                        sBookEntryIn >> nnHe ;
                        sBookEntryIn >> *(countT*)&timeW2 ;
                        sBookEntryIn >> timeW1 ;
                        sBookEntryIn >> idFormat ;
                        sBookEntryIn >> finger ;

                        ZE( strokeS* , psttBrowser   ) ;
                        ZE( countT   , cbReply       ) ;
                        ZE( countT   , code          ) ;
                        ZE( strokeS* , psttProtocol  ) ;
                        ZE( strokeS* , psttQuery     ) ;
                        ZE( strokeS* , psttUri       ) ;
                        ZE( strokeS* , psttContainer ) ;
                        ZE( strokeS* , psttLogBucket ) ;
                        ZE( strokeS* , psttMethod    ) ;
                        nicNameC       nnHe            ;
                        ZE( sCountT  , timeW2        ) ;
                        ZE( countT   , timeW1        ) ;
                        ZE( countT   , idFormat      ) ;
                        ZE( countT   , finger        ) ;

                        }
                            etThread.delF( tinP , pbPageCopy ) ;
                            }
                                sBookEntryIn.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbPageCopy , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;

                                bksAccessEvents.unlockF( tinP ) ;
                                etThread.memCopyF( tinP , pbPageCopy , pbzPage , cbzPage ) ;
                                const byteT* pbzPage = pageEvent ;
                                bksAccessEvents.lockF( tinP , TAG( TAGiDnULL ) ) ;
                            {
                            if( !POOP )

                            __Z( pbPageCopy ) ;
                            etThread.newF( tinP , LF , pbPageCopy , cbzPage ) ; ___( pbPageCopy ) ;
                            ZE( byteT* , pbPageCopy ) ;                                                 //U:: WHY DO I NEED TO MAKE A COPY?

                            countT cbzPage = pageEvent ;
                        {
                        soulC sBookEntryIn( tinP , TAG( TAGiDnULL ) ) ;

                        #if defined( NEVERdEFINED )

                        //if( !( ++ idIn % TOCK ) ) etThread.traceF( tinP , T("access event [idIn]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( !ether )

                    _INoLD_

                    __( (countT)pageEvent - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;
                        BLAMMO ;                        //SHOULD BE IMPOSSIBLE SINCE "ALL OR NONE" USED FOR WRITING BOOKTOGETHER AND I'VE ALREADY READ THE PREFIX
                    {
                    if( !(const byteT*)pageEvent )

                    bksAccessEvents.readF( tinP , pageEvent , hRead , flBOOKScrEAD_null , &bQuit , &hCursor ) ;
                    pageC pageEvent( tinP , bksAccessEvents , cbi ) ;
                {
                else
                }
                    __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;
                    {
                    if( !pbi )
                    bDelete = bksAccessEvents.readF( tinP , pbi , cbi , hRead , flBOOKScrEAD_STILLhUNGRYiSoK , &bQuit , &hCursor ) ;
                {
                if( bPrefix )
                ZE( boolT , bDelete ) ;

                HANDLEaPPnOTEScOUNTcLASS ch = hRead ;

                handleC hReadSave = hRead ;
                countT cbiSave = cbi ;
            {
            while( !bQuit && !bQuit2 && !POOP )
            handleC hCursor( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKSrEADcURSOR ) ;
            ZE( countT , idIn ) ;
            boolT bPrefix = 1 ;
            countT cbi = sizeof( countT ) ;
            ZE( const byteT* , pbi ) ;

            // *****************************************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
            // ********                    *************************************************************************************************************************************************************************************************************************
            // ********  EAT BOOK ENTRIES  *************************************************************************************************************************************************************************************************************************
            // ********                    *************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
        {
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

        handleC hRead( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
        //etThread.traceF( tinP , T("ACCESSeVENTS6aUDITbOOKS / enering loop to read events") ) ;

        TN( tb4 , "    " ) ;
        booksC bksAccessEvents( tinP , TAG( TAGiDnULL ) , "bksAccessEvents.1.raw" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_null , 0 , 1 , 0 , 0 , 0 , 0 , &bQuit ) ;
        //etThread.traceF( tinP , T("ACCESSeVENTS6aUDITbOOKS / ct bksAccessEvents") ) ;
    {
    while( !bQuit && !bQuit2 && !POOP )
    ZE( boolT , bQuit2 ) ;

    const boolT& bQuit = *(const boolT*)&(const countT&)ether ;
{

ether.ifcHireF( tinP , T("ifcIDaDAM_ACCESSeVENTS8aUDITbOOKS") , ifcIDaDAM_CLOUD , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; // flHIRE_DISPLAYaUTO CAN BE COMMENTED OUT TO AVOID WDW FOR ROOT CLOUD INSTANCE WHICH IS USUALLY NOT INTERESTING

TODO


/*1*/WAKEhIDE( "ifcIDaDAM_ACCESSeVENTS8aUDITbOOKS" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
