
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

THREADmODE1rESTORE
}
    ether.cioSetGetF( tinP ) ;
    ether.loafIF( tinP ) ;

    }
        ether.osSleepF( tinP , TUCK * 0x40 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        etThread.cioStrokeConsoleF( tinP , ether , tHead+tAdam ) ;
    {
    while( !ether && !etThread && !cIn )
    
    etThread.cioSetArgF( tinP , cArg ) ;
    countT cArg = (countT)&c8arg ;
    count8S c8arg( (countT)&tHead , (countT)&tIn , (countT)&tTree , (countT)&tree ) ;
    TN( tIn , "" ) ;
    
    }
        tAdam += T("")+SADAM(psFeatures) ;
        etThread( tinP , psFeature ) ;
    
        }
            psFeature->removeAllF( tinP ) ;
            *psFeatures << *psFeature ;
            *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
            *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
        {
    
        }
            psFeature->removeAllF( tinP ) ;
            *psFeatures << *psFeature ;
            *psFeature << (countT)( flFEATUREsADAMkEYBOARD_ACTIONdOWN ) ;
            *psFeature << (countT)ifcIDtYPEfEATUREsADAM_KEYBOARD ;
        {
    
        }
            psFeature->removeAllF( tinP ) ;
            *psFeatures << *psFeature ;
            *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
        {
    
        }
            psFeature->removeAllF( tinP ) ;
            *psFeatures << *psFeature ;
            *psFeature << (countT*)count8S( ifcOLDiDcHANNEL1_BYfUNCTION , ifcOLDiDcHANNELfUNCTION_SADAM0 , homeS::homeIF().iduuHome , etherC::ifc_idHomeI_IF() , DDNUMB ) ;
            *psFeature << (countT)ifcIDtYPEsADAMcHANNEL_OUT ;
            *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CIO ;
        {
    
        }
            psFeature->removeAllF( tinP ) ;
            *psFeatures << *psFeature ;
            *psFeature << (countT)ifcIDtYPEfEATUREsADAM_TABpARTICIPANT ;
        {
                
        }
            psFeature->removeAllF( tinP ) ;
            *psFeatures << *psFeature ;
            *psFeature << (countT)ifcIDtYPEfEATUREsADAM_ADAM ;
        {
    
        }
            psFeature->removeAllF( tinP ) ;
            *psFeatures << *psFeature ;
            *psFeature << (strokeS*)T("please key your name and then press the Enter key") ;
            *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
        {
    
        etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
        ZE( soulC* , psFeature ) ;
    
        *psFeatures << (countT)0 ;
        *psFeatures << (countT)sc_cADAM ;
        etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
        ZE( soulC* , psFeatures ) ;
    {
    TN( tAdam , "" ) ;
    
    ;
    
        S2(mRowScale,scOld_mRENDERrOWsCALEpUSH)
        S2(mColScale,scOld_mRENDERcOLsCALEpUSH)+
        ,scOld_cRENDERfLAGScONTROLpUSH)+
            flRENDERcONTROL_COLsCALE
            flRENDERcONTROL_ROWsCALE        |
        S2(
        T("\f")+
    
    TN( tHead , "" ) ; tHead =
    measureT mRowScale = 32.0 ;
    measureT mColScale = 8.0 ;
    
    ether.cioSetGetF( tinP , cioGetF ) ;
    
    count8S c8ChannelPublic( ifcOLDiDcHANNEL1_BYfUNCTION , ifcOLDiDcHANNELfUNCTION_STROKEcONSOLE ) ;
    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIEST ) ;
    
    pczChannel = c8channel ;
    count8S c8channel( ifcOLDiDcHANNEL1_BYfUNCTION , ifcOLDiDcHANNELfUNCTION_SADAM0 , homeS::homeIF().iduuHome , etherC::ifc_idHomeI_IF() , DDNUMB ) ;

    }
        etThread.delF( tinP , psttd ) ;
        tTree = T(psttd) ;
        strFaceF( tinP , etThread , psttd , bs ) ; ___( psttd ) ;
        ZE( strokeS* , psttd ) ;

        tree.nearbyF( tinP , bs ) ;
        branchesOldS bs ;
    {
    TN( tTree , "" ) ;

    while( tree.downF( tinP ) ) ;

    tree.walkF( tinP , hWalk , ether , countTC() , 1 ) ; //CURSOR THE ELDEST KID OF EACH BRANCH
    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_TREEwALK ) ;
    
    etThread.delF( tinP , pstt1l ) ;
    }
        etThread.delF( tinP , psttb ) ;
        tree.newKidF( tinP , psttb ) ;
        etThread.strTrimF( tinP , psttb , psttc1 , T(TbLACKnEWlINE) ) ; ___( psttb ) ;
        ZE( strokeS* , psttb ) ;

        }
            idLevel -- ;
            tree.downF( tinP ) ;
        {
        else while( idLevelRequested < idLevel )
        }
            idLevel ++ ;
            tree.upF( tinP ) ;
        {
        if( idLevelRequested == idLevel + 1 )
        if( POOP ) break ;
        __( idLevel + 1 < idLevelRequested ) ; //INDENTATION IS NOT ALLLOWED TO INCREASE BY MORE THAN 1 OVER PRIOR INPUT LINE
        __Z( idLevelRequested ) ; //INPUT LINE DOES NOT CONTAIN NONBLANKS
        countT idLevelRequested = idBlanks != 1 ? 1 : idf ;

        countT idBlanks = etThread.strIdAnyF( tinP , idf , sttq , sttb , psttc1 ) ;
        countT idf = 1 ;
    {
    FORsTRINGSiN1( pstt1l )
    countT idLevel = 1 ;
    strokeS sttb( ' ' ) ;
    etThread.strWordsOldF( tinP , pstt1l , tGuide , sttq , T("\r\n") ) ; ___( pstt1l ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , pstt1l ) ;
    TN( tGuide , postGuide ) ;

    treeOldC tree( tinP , TAG( TAGiDnULL ) ) ;
{
THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

TODO

;

    "  you have just climbed to the right in this knowledge tree\r\n"
    "  climb right again\r\n"
    "  press the RIGHT arrow\r\n"
    "  you have just climbed up into a knowledge tree\r\n"
    " climb up again\r\n"
    "press the UP arrow\r\n"

osTextT postGuide[] =

}
    if( cArgP && idptOriginP && bQuitP ) ;

    }
        }
            }
                }
                    }
                        }
                            etherP.cioStrokeConsoleF( tinP , etherC::etPrimeIF() , tHead+tAdam+tHint+tTree ) ;

                            }
                                case IDmODE_HELP : { tHint = T("  hint: climb with arrow keys") ; break ; }
                            {
                            switch( idMode )
                            TN( tHint , "" ) ;

                            }
                                tAdam += T("")+SADAM(psFeatures) ;
                                etherP( tinP , psFeature ) ;
                            
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
                                {
                            
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (countT)( flFEATUREsADAMkEYBOARD_ACTIONdOWN ) ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_KEYBOARD ;
                                {
                            
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
                                {
                            
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (countT*)count8S( ifcOLDiDcHANNEL1_BYfUNCTION , ifcOLDiDcHANNELfUNCTION_SADAM0 , homeS::homeIF().iduuHome , etherC::ifc_idHomeI_IF() , DDNUMB ) ;
                                    *psFeature << (countT)ifcIDtYPEsADAMcHANNEL_OUT ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CIO ;
                                {

                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_TABpARTICIPANT ;
                                {
                
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_ADAM ;
                                {
                            
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (strokeS*)T("guide") ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
                                {
                            
                                etherP( tinP , psFeature , TAG( TAGiDnULL ) ) ;
                                ZE( soulC* , psFeature ) ;
                            
                                *psFeatures << (countT)0 ;
                                *psFeatures << (countT)sc_cADAM ;
                                etherP( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
                                ZE( soulC* , psFeatures ) ;
                            {
                            TN( tAdam , "" ) ;

                            }
                                etherP.delF( tinP , psttd ) ;
                                tTree = T(psttd) ;
                                strFaceF( tinP , etherP , psttd , bs ) ; ___( psttd ) ;
                                ZE( strokeS* , psttd ) ;
                            
                                tree.nearbyF( tinP , bs ) ;
                                branchesOldS bs ;
                            {
                            if( bMoved )
                        {
                        case 2 :
                        }
                            break ;

                            etherP.cioStrokeConsoleF( tinP , etherC::etPrimeIF() , tHead+tAdam ) ;

                            }
                                tAdam += T("")+SADAM(psFeatures) ;
                                etherP( tinP , psFeature ) ;
                            
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
                                {
                            
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (countT)( flFEATUREsADAMkEYBOARD_ACTIONdOWN ) ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_KEYBOARD ;
                                {
                            
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
                                {
                            
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (countT*)count8S( ifcOLDiDcHANNEL1_BYfUNCTION , ifcOLDiDcHANNELfUNCTION_SADAM0 , homeS::homeIF().iduuHome , etherC::ifc_idHomeI_IF() , DDNUMB ) ;
                                    *psFeature << (countT)ifcIDtYPEsADAMcHANNEL_OUT ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CIO ;
                                {
                            
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_TABpARTICIPANT ;
                                {
                
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_ADAM ;
                                {
                            
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << (strokeS*)tIn ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
                                {
                            
                                etherP( tinP , psFeature , TAG( TAGiDnULL ) ) ;
                                ZE( soulC* , psFeature ) ;
                            
                                *psFeatures << (countT)0 ;
                                *psFeatures << (countT)sc_cADAM ;
                                etherP( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
                                ZE( soulC* , psFeatures ) ;
                            {
                            TN( tAdam , "" ) ;
                        {
                        case 1 :
                    {
                    switch( idPhase )
                {
                if( bRefresh )

                }
                    }
                        break ;

                        }
                            }
                                }
                                    break ;
                                    }
                                        bMoved = bRefresh = 1 ;
                                        tree.outF( tinP ) ;
                                    {
                                    if( tree.outF( tinP , 1 ) )
                                {
                                case ifcIDtYPEtOOL_PAGEuPnUM :
                                case ifcIDtYPEtOOL_PAGEuP :
                                }
                                    break ;
                                    }
                                        bMoved = bRefresh = 1 ;
                                        tree.inF( tinP ) ;
                                    {
                                    if( tree.inF( tinP , 1 ) )
                                {
                                case ifcIDtYPEtOOL_PAGEdOWNnUM :
                                case ifcIDtYPEtOOL_PAGEdOWN :
                                }
                                    break ;
                                    }
                                        bMoved = bRefresh = 1 ;
                                        tree.downF( tinP ) ;
                                        tree.rightF( tinP ) ;
                                        tree.upF( tinP ) ;
                                    {
                                    if( tree.upF( tinP , 1 ) )
                                {
                                case ifcIDtYPEtOOL_RIGHTnUM :
                                case ifcIDtYPEtOOL_RIGHT :
                                }
                                    break ;
                                    }
                                        bMoved = bRefresh = 1 ;
                                        tree.downF( tinP ) ;
                                        tree.leftF( tinP ) ;
                                        tree.upF( tinP ) ;
                                    {
                                    if( tree.upF( tinP , 1 ) )
                                {
                                case ifcIDtYPEtOOL_LEFTnUM :
                                case ifcIDtYPEtOOL_LEFT :
                                }
                                    break ;
                                    }
                                        bMoved = bRefresh = 1 ;
                                        tree.downF( tinP ) ;
                                    {
                                    if( tree.downF( tinP , 1 ) )
                                {
                                case ifcIDtYPEtOOL_DOWNnUM :
                                case ifcIDtYPEtOOL_DOWN :
                                }
                                    break ;
                                    }
                                        bMoved = bRefresh = 1 ;
                                        tree.upF( tinP ) ;
                                    {
                                    if( tree.upF( tinP , 1 , 1 ) )
                                {
                                case ifcIDtYPEtOOL_UPnUM :
                                case ifcIDtYPEtOOL_UP :
                                }
                                    break ;
                                    else                                                                                    etherP.etherFireImpersonateMonitorIF( tinP ) ;
                                    if( F(thirdC::third_flagsModeProcess1I_IF( tinP )) & flMODEpROCESS1_IGNOREfIREbYoPERATOR ) thirdC::dosBeepIF( tinP , 0x3800 , TUCK * 0x20 ) ;
                                {
                                case ifcIDtYPEtOOL_ESCAPE :
                            {
                            else switch( idTool )
                            }
                                bRefresh = 1 ;
                                idPhase = 2 ;
                            {
                            else if( idTool == ifcIDtYPEtOOL_ENTER )
                            }
                                bRefresh = 1 ;
                                tIn += T(post2) ;
                                osTextT post2[] = { (osTextT)( 'a' + idTool - ifcIDtYPEtOOL_a ) , 0 } ;
                            {
                            )
                                idTool <= ifcIDtYPEtOOL_z
                                idTool >= ifcIDtYPEtOOL_a &&
                            (
                            else if
                            }
                                bRefresh = 1 ;
                                tIn += T(post2) ;
                                osTextT post2[] = { (osTextT)( 'A' + idTool - ifcIDtYPEtOOL_A ) , 0 } ;
                            {
                            )
                                idTool <= ifcIDtYPEtOOL_Z
                                idTool >= ifcIDtYPEtOOL_A &&
                            (
                            if
                        {
                        if( idAction == ifcIDtYPEaCTION_DOWN )

                        *psPayloadP >> idAction ;
                        *psPayloadP >> idTool ;
                        *psPayloadP >> ids ;
                        *psPayloadP >> idSnip ;
                        ZE( countT , idAction ) ;
                        ZE( countT , idTool ) ;
                        ZE( countT , ids ) ;
                        ZE( countT , idSnip ) ;

                        cIn ++ ;
                    {
                    case ifcIDtYPEsTROKEcALLbACK_KEYBOARD :
                {
                switch( idTypeCall )
                ZE( boolT , bMoved ) ;
                ZE( boolT , bRefresh ) ;
                treeOldC& tree  = *(treeOldC*)c8arg.c4 ;
                textC& tTree = *(textC*)c8arg.c3 ;
                textC& tIn   = *(textC*)c8arg.c2 ;
                textC& tHead = *(textC*)c8arg.c1 ;
                count8S& c8arg = *(count8S*)cArgP ;

                *psPayloadP >> idTypeCall ;
                ZE( countT , idTypeCall ) ;
            {
            if( (countT)*psPayloadP )
        {
        if( pczChannelP && pczChannel && !etherP.strCompareF( tinP , pczChannelP , pczChannel ) && cArgP )
    {
    if( idPayloadTypeP == ifcOLDiDtYPEgIFT_APPLICATION )
{
voidT cioGetF( tinS& tinP , etherC& etherP , const boolT& bQuitP , const countT idPayloadTypeP , soulC*& psPayloadP , countT*& pczChannelP , countT& cArgP , const portTimeC& idptOriginP )

}
    }
        etherP.strFuseF( tinP , psttP , tIndicator ) ;

        ;
    
            S2(0,scOld_POPhIGHwATER)
            S2(0,scOld_OLDCMDpOPlOWwATER) +
            S2(0,scOld_OLDCMDpOPrIGHTwATER)+
            S2(0,scOld_OLDCMDpOPlEFTwATER) +

            S2(0,scOld_POPcOLOR)+
            OLDlINEeND( -8 , 8 ) +
            OLDmOVE( 8 , - 8 ) +
            OLDlINE( 8 , 8 ) +
            OLDmOVE( -8 , -8 ) +
            OLDlINE( 0 , 0x10 ) +
            S2(0x00ff00,scOld_cPUSHcOLOR) +

            OLDmOVE( -0x20 , -0x20 ) +
            //OLDmOVEtOrATIO(cColRelRightCenter,cRowRel7) +

            S2(0,scOld_OLDCMDpUSHlEFTwATER) +
            S2(0,scOld_OLDCMDpUSHrIGHTwATER) +
            S2(0,scOld_OLDCMDpUSHlOWwATER) +
            S2(0,scOld_PUSHhIGHwATER) +
            T("") +

        TN( tIndicator , "" ) ; tIndicator =
    {
    if( bP.ppsttzDnGrandKids )

    woLevelF( tinP , etherP , psttP , bP.ppsttzDnKids      , bP.cDnKids      , bP.ppsttzUpKids      , bP.cUpKids      , cRowRel6 , cRowRel7 , cColRelLeftEdge , cColRelLeftCenter , cColRelRightCenter , cColRelRightEdge , 1 ) ;
    woLevelF( tinP , etherP , psttP , bP.ppsttzDnWives     , bP.cDnWives     , bP.ppsttzUpWives     , bP.cUpWives     , cRowRel5 , cRowRel6 , cColRelLeftEdge , cColRelLeftCenter , cColRelRightCenter , cColRelRightEdge , 0 ) ;
    woLevelF( tinP , etherP , psttP , bP.ppsttzDnBros      , bP.cDnBros      , bP.ppsttzUpBros      , bP.cUpBros      , cRowRel4 , cRowRel5 , cColRelLeftEdge , cColRelLeftCenter , cColRelRightCenter , cColRelRightEdge , 1 ) ;
    woLevelF( tinP , etherP , psttP , bP.ppsttzDnMoms      , bP.cDnMoms      , bP.ppsttzUpMoms      , bP.cUpMoms      , cRowRel3 , cRowRel4 , cColRelLeftEdge , cColRelLeftCenter , cColRelRightCenter , cColRelRightEdge , 0 ) ;
    woLevelF( tinP , etherP , psttP , bP.ppsttzDnDads      , bP.cDnDads      , bP.ppsttzUpDads      , bP.cUpDads      , cRowRel2 , cRowRel3 , cColRelLeftEdge , cColRelLeftCenter , cColRelRightCenter , cColRelRightEdge , 1 ) ;
    woLevelF( tinP , etherP , psttP , bP.ppsttzDnGrandMoms , bP.cDnGrandMoms , bP.ppsttzUpGrandMoms , bP.cUpGrandMoms , cRowRel1 , cRowRel2 , cColRelLeftEdge , cColRelLeftCenter , cColRelRightCenter , cColRelRightEdge , 0 ) ;
        
    ) ; ___( psttP ) ;

        0x2000 //U::CALCULATE THE SIZE NEEDED FOR bP
        ,

        S2(0,scOld_OLDCMDpUSHlEFTwATER)
        S2(0,scOld_OLDCMDpUSHrIGHTwATER)                          +
        S2(0,scOld_OLDCMDpUSHlOWwATER)                            +
        S2(0,scOld_PUSHhIGHwATER)                           +
        S2(0,scOld_POPcOLOR)+

        //OLDlINEtOrATIO(cColRelRightCenter,cRowRel7) +
        OLDmOVE(0,1) +
        //OLDmOVEtOrATIO(cColRelRightCenter,cRowRel1) +

        //OLDlINEtOrATIO(cColRelLeftCenter,cRowRel7) +
        OLDmOVE(0,1) +
        //OLDmOVEtOrATIO(cColRelLeftCenter,cRowRel1) +

        //OLDlINEtOrATIO(cColRelRightEdge,cRowRel6) +
        OLDmOVE(1,0) +
        //OLDmOVEtOrATIO(cColRelLeftEdge,cRowRel6) +

        //OLDlINEtOrATIO(cColRelRightEdge,cRowRel5) +
        OLDmOVE(1,0) +
        //OLDmOVEtOrATIO(cColRelLeftEdge,cRowRel5) +

        //OLDlINEtOrATIO(cColRelRightEdge,cRowRel4) +
        OLDmOVE(1,0) +
        //OLDmOVEtOrATIO(cColRelLeftEdge,cRowRel4) +

        //OLDlINEtOrATIO(cColRelRightEdge,cRowRel3) +
        OLDmOVE(1,0) +
        //OLDmOVEtOrATIO(cColRelLeftEdge,cRowRel3) +

        //OLDlINEtOrATIO(cColRelRightEdge,cRowRel2) +
        OLDmOVE(1,0) +
        //OLDmOVEtOrATIO(cColRelLeftEdge,cRowRel2) +

        //OLDlINEtOrATIO(cColRelLeftEdge,cRowRel1) +
        //OLDlINEtOrATIO(cColRelLeftEdge,cRowRel7) +
        //OLDlINEtOrATIO(cColRelRightEdge,cRowRel7) +
        //OLDlINEtOrATIO(cColRelRightEdge,cRowRel1) +
        //OLDmOVEtOrATIO(cColRelLeftEdge,cRowRel1) +

        S2(0x0000ff,scOld_cPUSHcOLOR)+
        T("")+

    etherP.strMakeF( tinP , LF , psttP , 

    count01T cRowRel7 = mRowRel7 ;
    count01T cRowRel6 = mRowRel6 ;
    count01T cRowRel5 = mRowRel5 ;
    count01T cRowRel4 = mRowRel4 ;
    count01T cRowRel3 = mRowRel3 ;
    count01T cRowRel2 = mRowRel2 ;
    count01T cRowRel1 = mRowRel1 ;

    mRowRel7 += mShift ;
    mRowRel6 += mShift ;
    mRowRel5 += mShift ;
    mRowRel4 += mShift ;
    mRowRel3 += mShift ;
    mRowRel2 += mShift ;
    mRowRel1 += mShift ;
    measureT mShift = (measureT)MAXscOUNT01T * ( 1.0 / 8.0 ) ;

    mRowRel7 *= mShrink ;
    mRowRel6 *= mShrink ;
    mRowRel5 *= mShrink ;
    mRowRel4 *= mShrink ;
    mRowRel3 *= mShrink ;
    mRowRel2 *= mShrink ;
    mRowRel1 *= mShrink ;
    measureT mShrink = 7.0 / 8.0 ;

    measureT mRowRel7 = (measureT)MAXscOUNT01T ;

    measureT mRowRel6 = (measureT)MAXscOUNT01T * ( .6667 + .04 ) ;
    measureT mRowRel5 = (measureT)MAXscOUNT01T / 3.0 * 2.0 ;

    measureT mRowRel4 = (measureT)MAXscOUNT01T * ( .3333 + .04 ) ;
    measureT mRowRel3 = (measureT)MAXscOUNT01T / 3.0 ;

    measureT mRowRel2 = (measureT)MAXscOUNT01T * .04 ;
    measureT mRowRel1 = 0.0 ;

    count01T cColRelRightEdge = mColRelRightEdge ;
    count01T cColRelRightCenter = mColRelRightCenter ;
    count01T cColRelLeftCenter = mColRelLeftCenter ;
    count01T cColRelLeftEdge = mColRelLeftEdge ;

    measureT mColRelRightEdge = (measureT)MAXscOUNT01T ;
    measureT mColRelRightCenter = (measureT)MAXscOUNT01T / 3.0 * 2.0 ;
    measureT mColRelLeftCenter = (measureT)MAXscOUNT01T / 3.0 ;
    measureT mColRelLeftEdge = 0.0 ;
{
voidT strFaceF( tinS& tinP , etherC& etherP , strokeS*& psttP , branchesOldS& bP )

}
    if( bMaleP ) ;

    }
        ) ;

            S2(0,scOld_mmCLIPiD)
            S2(0,scOld_POPoRIGIN) +
            S2(0,scOld_OLDCMDpOPwRAPtRAP) +
            S2(0,scOld_OLDCMDpOPhIGHwATER) +
            S2(0,scOld_OLDCMDpOPlOWwATER) +
            S2(0,scOld_OLDCMDpOPlEFTwATER) +
            S2(0,scOld_OLDCMDpOPrIGHTwATER) +
            T(ppsttzUpP[1]) +
            S2(0,scOld_OLDCMDpUSHrIGHTwATER) +
            S2(0,scOld_OLDCMDpUSHlEFTwATER) +
            S2(0,scOld_OLDCMDpUSHlOWwATER) +
            S2(0,scOld_OLDCMDpUSHhIGHwATER) +
            //OLDmOVE( bMaleP ? CRiNITm : CRiNITf , bMaleP ? CRiNITm : CRiNITf ) +
            S2(flPUSHoRIGIN_WOwO,scOld_cPUSHoRIGIN) +
            OLDmOVE( 1 , 1 ) +
            //OLDmOVEtOrATIO(cColRelRightCenterP,cRowRelMinP) +
    
            OLDcLIPtOpOP +
            OLDmOVE( -1 , -1 ) +
            S2(0,scOld_OLDCMDpUSHwRAPtRAP) +
            //OLDmOVEtOrATIO(cColRelRightEdgeP,cRowRelMaxP) +
    
            S2(0,scOld_PUSHoVERRIDEcOLrOW) +
            OLDmOVE( 1 , 1 ) +
            //OLDmOVEtOrATIO(cColRelRightCenterP,cRowRelMinP) +
            T("") +

        if( cUpP ) etherP.strFuseF( tinP , psttP ,
    {
    if( ppsttzUpP )

    }
        ) ;

            S2(0,scOld_mmCLIPiD)
            S2(0,scOld_POPoRIGIN) +
            S2(0,scOld_OLDCMDpOPwRAPtRAP) +
            S2(0,scOld_OLDCMDpOPhIGHwATER) +
            S2(0,scOld_OLDCMDpOPlOWwATER) +
            S2(0,scOld_OLDCMDpOPlEFTwATER) +
            S2(0,scOld_OLDCMDpOPrIGHTwATER) +
            //OLDmOVE( 0x10 , 0x010 ) +
            ////OLDmOVEtOrATIO(cColRelRightEdgeP,cRowRelMaxP) +
            T(ppsttzDnP[1]) +
            S2(0,scOld_OLDCMDpUSHrIGHTwATER) +
            S2(0,scOld_OLDCMDpUSHlEFTwATER) +
            S2(0,scOld_OLDCMDpUSHlOWwATER) +
            S2(0,scOld_OLDCMDpUSHhIGHwATER) +
            //OLDmOVE( bMaleP ? CRiNITm : CRiNITf , bMaleP ? CRiNITm : CRiNITf ) +
            S2(flPUSHoRIGIN_WOwO,scOld_cPUSHoRIGIN) +
            OLDmOVE( 1 , 1 ) +
            //OLDmOVEtOrATIO(cColRelLeftEdgeP,cRowRelMinP) +
    
            OLDcLIPtOpOP +
            OLDmOVE( -1 , -1 ) +
            S2(0,scOld_OLDCMDpUSHwRAPtRAP) +
            //OLDmOVEtOrATIO(cColRelLeftCenterP,cRowRelMaxP) +
    
            S2(0,scOld_PUSHoVERRIDEcOLrOW) +
            OLDmOVE( 1 , 1 ) +
            //OLDmOVEtOrATIO(cColRelLeftEdgeP,cRowRelMinP) +
            T("") +

        if( cDnP ) etherP.strFuseF( tinP , psttP ,

        ) ;

            S2(0,scOld_mmCLIPiD)
            S2(0,scOld_POPoRIGIN) +
            S2(0,scOld_OLDCMDpOPwRAPtRAP) +
            S2(0,scOld_OLDCMDpOPhIGHwATER) +
            S2(0,scOld_OLDCMDpOPlOWwATER) +
            S2(0,scOld_OLDCMDpOPlEFTwATER) +
            S2(0,scOld_OLDCMDpOPrIGHTwATER) +
            T(ppsttzDnP[0]) +
            S2(0,scOld_OLDCMDpUSHrIGHTwATER) +
            S2(0,scOld_OLDCMDpUSHlEFTwATER) +
            S2(0,scOld_OLDCMDpUSHlOWwATER) +
            S2(0,scOld_OLDCMDpUSHhIGHwATER) +
            //OLDmOVE( bMaleP ? CRiNITm : CRiNITf , bMaleP ? CRiNITm : CRiNITf ) +
            S2(flPUSHoRIGIN_WOwO,scOld_cPUSHoRIGIN) +
            OLDmOVE( 1 , 1 ) +
            //OLDmOVEtOrATIO(cColRelLeftCenterP,cRowRelMinP) +
    
            OLDcLIPtOpOP +
            OLDmOVE( -1 , -1 ) +
            S2(0,scOld_OLDCMDpUSHwRAPtRAP) +
            //OLDmOVEtOrATIO(cColRelRightCenterP,cRowRelMaxP) +
    
            S2(0,scOld_PUSHoVERRIDEcOLrOW) +
            OLDmOVE( 1 , 1 ) +
            //OLDmOVEtOrATIO(cColRelLeftCenterP,cRowRelMinP) +
            T("") +

        etherP.strFuseF( tinP , psttP ,
    {
    if( ppsttzDnP )
{
voidT woLevelF( tinS& tinP , etherC& etherP , strokeS*& psttP , const strokeS** const ppsttzDnP , const countT cDnP , const strokeS** const ppsttzUpP , const countT cUpP , const count01T cRowRelMinP , const count01T cRowRelMaxP , const count01T cColRelLeftEdgeP , const count01T cColRelLeftCenterP , const count01T cColRelRightCenterP , const count01T cColRelRightEdgeP , const boolT bMaleP )


*/
 bMaleP
 c4P
 c3P
 c2P
 c1P
 r2P
 r1P
 cUpP
 ppsttzUpP
 cDnP
 ppsttzDnP
 psttP
 etherP
 tinP
arguments

 0
 rcr7
 rcr5
 rcr3
 rcr1
 rcr2
 rcr1
 bP.cUpGrandMoms
 bP.ppsttzUpGrandMoms
 bP.cDnGrandMoms
 bP.ppsttzDnGrandMoms
 psttP
 etherP
 tinP
arguments example
/*


countT  idMode = IDmODE_HELP ;
countT  idPhase = 2 ;
countT  cIn ;
countT* pczChannel ;

#define IDmODE_HELP 1

#define CRiNITf (0)
#define CRiNITm (0)


// **** SAVE THIS CODE: IT IS A DOODLE FOR KNOWLEDGE TREE SERVER

/*1*/WAKEhIDE( "ifcIDaDAM_NULL" )/*1*/
/**/
*/
this process must be null in production
during development, i can be used to exercise the release
 2010.12.23: this no longer builds, but comment says to save as doodle so it is being obsoleted by c16, which will initially be null
obsoleted by c16
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

