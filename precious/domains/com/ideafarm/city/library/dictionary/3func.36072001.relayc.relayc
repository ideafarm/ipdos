
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        TELL( "relayC: cleaning up" )
    
        THREADmODE1rESTORE
        DEL( pStPop4 ) ;
        DEL( pStPop3 ) ;
        DEL( pStPop2 ) ;
        DEL( pStPop1 ) ;
        DEL( pStPop0 ) ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        TELL( "deleting bang stacks" )
    
        if( pStPop4 ) { cPoof += *pStPop4 ; }
        if( pStPop3 ) { cPoof += *pStPop3 ; }
        if( pStPop2 ) { cPoof += *pStPop2 ; }
        if( pStPop1 ) { cPoof += *pStPop1 ; }
        if( pStPop0 ) { cPoof += *pStPop0 ; }
        TELL( "unregistering my bang stacks and calc poof" )
        ZE( countT , cPoof ) ;
    
        handleUnregisterIF( tinP , idpt ) ; //P: ENDING NODE DEREGISTERS ITSELF AS HANDLE
    
        sgnDone_tmRelayInitiatorF.waitF( tinP ) ;
        sgnDone_tmRelayKillF.waitF( tinP ) ;
        sgnDone_tmRelayPopClientF4.waitF( tinP ) ;
        sgnDone_tmRelayPopClientF3.waitF( tinP ) ;
        sgnDone_tmRelayPopClientF2.waitF( tinP ) ;
        sgnDone_tmRelayPopClientF1.waitF( tinP ) ;
        sgnDone_tmRelayPopClientF0.waitF( tinP ) ;
        sgnDone_tmRelayTeatAcceptorF.waitF( tinP ) ;
    
        }
            }
                ++ s ; tinP.pEtScratch->osSleepF( tinP , TUCK * 0x40 ) ;
    
                if( sgnDone_tmRelayTeatAcceptorF ) break ;

                }
                    SCOOPSdEL
                    POOPR
                {
                else
                }
                    break ;
                    SCOOPSdEL
                {
                if( !POOP )
                sock.connectF( tinP , home.idpTeat , (nicNameC&)home.idpTeat , 1 ) ;
                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                SCOOPSnEW
            {
            while( !sgnDone_tmRelayTeatAcceptorF )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        
            //}
            //    while( !POOP && !home.idpTeat ) { ++ s ; tinP.pEtScratch->osSleepF( tinP , TUCK * 0x40 ) ; }
            //    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //    SCOOPS
            //{
        {
        if( bLaunchedAcceptor )
        bQuit = 1 ; //U::ADDED WITHOUT STUDY
    
        }
            }
                }
                    }
                        DEL( pso ) ;
                        SCOOPS
                        pso->etherF( tinP , *tinP.pEtScratch ) ;
                    {
                    else 
                    if( !ether && pso ) etThread.osThreadF( tinP , countTC() , tmRelayServerCatchBagF , 0 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , (countT)pso , (countT)&sListen , (countT)&stIdptPopClient , (countT)&cLooksForNewPing ) ;
                    TELL( "launching tmRelayServerCatchBagF" )
    
                    //else { CONoUTrAW( "z" ) ; } //U::
                    }
                        break ;
                        DEL( pso ) ;
                        SCOOPS
                        pso->etherF( tinP , *tinP.pEtScratch ) ;
                        //etherC::ifcSayIF( T("gasp!") , flSAY_APPEND | flSAY_LOG ) ;
                        TELL( "quitting" )
                    {
                    else if( bQuit )
                    }
                        continue ;
    
                        if( !etThread ) bLaunchedAcceptor = 1 ;
                        etThread.osThreadF( tinP , countTC() , tmRelayTeatAcceptorF , &sgnDone_tmRelayTeatAcceptorF , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS ) ;
                        etThread.osThreadF( tinP , countTC() , tmRelayInitiatorF    , &sgnDone_tmRelayInitiatorF , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , (countT)&stIdptPopClient , (countT)&cLooksForNewPing , (countT)&bReadyP ) ;
                        etThread.osThreadF( tinP , countTC() , tmRelayKillF         , &sgnDone_tmRelayKillF , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS ) ;
    
                        }
                            etThread.osThreadF( tinP , countTC() , tmRelayPopClientF , &sgnDone_tmRelayPopClientF4 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , IDtYPErELAYpOPcLIENTwORK_RIGHT    ) ;
                            etThread.osThreadF( tinP , countTC() , tmRelayPopClientF , &sgnDone_tmRelayPopClientF3 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , IDtYPErELAYpOPcLIENTwORK_LEFT     ) ;
                            etThread.osThreadF( tinP , countTC() , tmRelayPopClientF , &sgnDone_tmRelayPopClientF2 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , IDtYPErELAYpOPcLIENTwORK_EXPLODE2 ) ;
                            etThread.osThreadF( tinP , countTC() , tmRelayPopClientF , &sgnDone_tmRelayPopClientF1 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , IDtYPErELAYpOPcLIENTwORK_EXPLODE1 ) ;
                            etThread.osThreadF( tinP , countTC() , tmRelayPopClientF , &sgnDone_tmRelayPopClientF0 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , IDtYPErELAYpOPcLIENTwORK_IMPLODE  ) ;
    
                        {
                        if( pStPop0 && pStPop1 && pStPop2 && pStPop3 && pStPop4 )
        
                        TELL( "setting up 2.3" )
                    
                        pStPop4 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        pStPop3 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        pStPop2 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        pStPop1 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        pStPop0 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        TELL( "setting up 2.4" )
                    
                        }
                            if( idpthc && NICnAMElOCAL != ((nicNameC&)(idPortC&)idpthc).pcId[ 0 ] ) stIdptOpen.sinkF( tinP , countTC() , (byteT*)&idpthc , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossip ) ;
                            idPortTimeC idpthc = handleQueryIF( tinP ) ;
                        {
                        stIdptOpen.sinkF( tinP , countTC() , (byteT*)&idpt   , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossip ) ;
                        //P: A NEWBIE CLIENT KNOWS ABOUT ITSELF AND THE HANDLE
            
                        DEL( pso ) ;
                        }
                            }
                                etThread.traceF( tinP , T("could not write sBagOk for woth client") ) ;
                                POOPRqUIET
                            {
                            if( POOP )
                            pso->writeF( tinP , sBagOk ) ;
                            soulC sBagOk( tinP , TAG( TAGiDnULL ) , flSOUL_null , (countT)ifcIDtYPEbAG_SERVERoK ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        bWoth = 0 ;
                        pso->etherF( tinP , *tinP.pEtScratch ) ;
                        etThread.traceF( tinP , T("writing woth bag ifcIDtYPEbAG_SERVERoK") ) ;
                    {
                    if( bWoth ) //WOTH CLIENT MUST NOT BE REFUSED
            
                    }
                        //CONoUT( "client accepted" ) ;
                        //etThread.traceF( tinP , T("accepted [nnPeer,idPortPeer]:    ")+T(nnPeer)+T("    ")+TF2(idPortPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        sListen.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ;
                        ZE( countT , idPortPeer ) ;
                        nicNameC nnPeer ;
                        boolT bRefuse = /*++ idClient == tinP.monitor.idThread && !( bRefused ++ ) ? 1 :*/ 0 ;
                        //static boolT bRefused ;
                    {
                    TELL( "waiting for a client to connect" )
                    ZE( socketC* , pso ) ;
        
                    if( bWoth ) etThread.osThreadF( tinP , countTC() , tmRelayTickleF , 0 , flTHREADlAUNCH_null , 0 , (idPortC&)idpt , (countT)&bWoth ) ;
                {
                while( !POOP && !ether && !bQuit )
                ZE( countT , idClient ) ;
                boolT bWoth = 1 ;
            
                etThread.osTimeNowF( tinP , timeB1 , timeB2 ) ;
                ZE( sCountT , timeB2 ) ;
                ZE( countT  , timeB1 ) ;
            
                TELL( "setting up 2.b" )
                if( !ether ) sListen.listenF( tinP ) ;
                TELL( "setting up 2.c" )
            {
            if( idpt )
            TELL( "setting up 2" )
        {
        signC sgnDone_tmRelayInitiatorF( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayKillF( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayPopClientF4( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayPopClientF3( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayPopClientF2( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayPopClientF1( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayPopClientF0( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayTeatAcceptorF( tinP , TAG( TAGiDnULL ) ) ;
        ZE( boolT , bLaunchedAcceptor ) ;
        ZE( countT , cLooksForNewPing ) ;
        stackC*& pStPop4 = *(stackC**)&_c8ni2P.c1 ;
        stackC*& pStPop3 = *(stackC**)&_c8ni1P.c8 ;
        stackC*& pStPop2 = *(stackC**)&_c8ni1P.c7 ;
        stackC*& pStPop1 = *(stackC**)&_c8ni1P.c6 ;
        stackC*& pStPop0 = *(stackC**)&_c8ni1P.c5 ;
    
        count8S _c8ni3P( (countT)&idSerialLathHeader , (countT)&idPortOrigin , (countT)&swsIdSerialReceived , (countT)&bAltSws , (countT)&cLeverPayload , (countT)&swsWrapRef ) ;
        count8S _c8ni2P( 0 , (countT)&stIdptTemp , (countT)&stIdptOpen , (countT)&stIdptGossip , (countT)&idAdamMediator , (countT)&swsIdptMediator , (countT)&swsIdptMediatorAlt , (countT)&cGossipIn ) ;
        count8S _c8ni1P( (countT)&idpt , (countT)&bQuit , (countT)&stPsoServer , (countT)&swsIdSerialReceived , 0 , 0 , 0 , 0 ) ;
    
        ZE( boolT , bAltSws ) ;
        ZE( countT , idSerialLathHeader ) ;
        ZE( countT , cGossipIn ) ;
        ZE( boolT , bTalk ) ;
    
        //}
        //    }
        //        if( !cTries && !handleQueryIF( tinP ) ) handleRegisterMeIfIF( tinP , idpt ) ; //P: A NEWBIE NODE WILL POLL FOR 4 TOCKS BEFORE REGISTERING ITSELF AS HANDLE
        //
        //        }
        //            if( handleQueryIF( tinP ) ) break ;
        //            ether.osSleepF( tinP , TOCK ) ;
        //        {
        //        while( !ether && cTries && cTries -- )
        //        countT cTries = TUCK / /* 8 */0x40 ;
        //        sleepC s( tinP , TAG( TAGiDnULL ) ) ; //GIVE EXISTING NODES TIME TO ASSUME THE HANDLE ROLE
        //    {
        //{
        //if( !handleQueryIF( tinP ) )
    
        idpt.timeStampIfF( tinP , etThread ) ;
        idpt = idPort ;
        idPortTimeC idpt ;
    
        idPort = socketC::nicNameIF( tinP , etThread ) ;

        etThread.traceF( tinP , T("bind aok [idptHandle:nn,idPort]:    ")+T((nicNameC&)idptHandle)+T("    ")+TF2((countT&)idptHandle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        sListen.etherF( tinP , etThread ) ;

        }
            }
                }
                    idpTry ++ ;
                    etThread.traceF( tinP , T("could not bind to requested port [idPort]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    idPort = idPortC() ;
                    POOPRqUIET
                {
                else
                }
                    break ;
                    etThread.traceF( tinP , T("bind aok to requested port [idPort]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( !POOP )
                idPort = sListen.bindF( tinP , idpTry , nicNameC() , 1 ) ;
            {
            for(;;)
            countT idpTry = ifcIDpORT_RELAY ;

            SCOOPS
        {
        idPortC idPort ;
        socketC sListen( tinP , *tinP.pEtScratch , TAG( TAGiDnULL )/*U:: , 0 , flSOCKETc_TOPsECRET*/ ) ;
    {
    IFsCRATCH

    idPortTimeC idptHandle = handleQueryIF( tinP ) ;

    switchStackC swsWrapRef( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , cLeverPayload , flSTACKc_FIFO|flSTACKc_GIVEsIGNnEWpLATE ) ;
    ZE( countT , cLeverPayload ) ;
    homeS& home = homeS::homeIF() ;
    ZE( boolT , bQuit ) ;
    ranUniC ruZeWo( tinP , 1 , 1 ) ;
    const countT cKidThreadsSave = tinP.cKidThreads ;

    switchStackC swsIdptMediatorAlt(    tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idAdamMediator , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    switchStackC swsIdptMediator(       tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idAdamMediator , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    ZE( countT , idAdamMediator ) ;
    stackC stIdptPopClient(             tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stIdptGossip(                tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ; // { idpt , timeBorn1 , timeBorn2 }, SORTED BY TIME BORN
    stackC stIdptOpen(                  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ; // { idpt , timeBorn1 , timeBorn2 }, SORTED BY TIME BORN
    stackC stIdptTemp(                  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ; // { idpt , timeBorn1 , timeBorn2 }, SORTED BY TIME BORN
    switchStackC swsIdSerialReceivedAlt( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , pbLever , sizeof idPortOrigin ) ;
    switchStackC swsIdSerialReceived(    tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , pbLever , sizeof idPortOrigin ) ;
    const byteT* pbLever = (const byteT*)&idPortOrigin ;
    idPortC idPortOrigin ;
    stackC stPsoServer(                  tinP , etThread , TAG( TAGiDnULL ) ) ;
    etherC& ether = etherC::etPrimeIF() ;
    _IO_
{
/*1*/relayC::relayC( tinS& tinP , etherC& etThread , boolT& bReadyP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

