
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idBook ;

    //DELzOMBIE( pInOutFrame ) ;

    THREADmODE1rESTORE
    THREADmODE3rESTORE

    }
        //if( bDeleteOutParam ) { PUSE( tinP , *(byteT**)ppcpIdAptP ) ; }

        if( processGlobal1I._grabC_pgw ) grabBookNow.ungrabF( tinP ) ;

        }
            tinP.tlsDelF( pbtScratchBuffer ) ;
            tinP.tlsDelF( *(byteT**)&pBk0Doomed ) ;
            DELzOMBIE( pBk0Doomed ) ;

            }
                THREADmODE1rESTORE ;
                writeF( tinP , pbi , cbi ) ; //THIS LINE MIGHT USE CONSTRUCT AND USE A NEW SCRATCH BOOK
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;
            {
            if( cbi )

                                 *ppBk0Scratch = 0 ;
            book0C* pBk0Doomed = *ppBk0Scratch ;
            (*ppBk0Scratch)->readF( tinP , pbi , cbi , offi ) ;
            ZE( countT , offi ) ;
            countT cbi = - 1 ;
            ZE( const byteT* , pbi ) ;

            if( !ppBk0Scratch ) { BLAMMO ; }
        {
        if( pbtScratchBuffer )

        }
            if( F(flagsP) & flBOOKScwRITE_SETrEMAINING ) break ;

            }
                }
                    }
                        }
                            if( flagsSnap == setIfEqualsAM( flags , flagsSnap | flBOOKhEADs_PRIORbOOKnOTcONTINUEDhERE , flagsSnap ) ) break ;
                            flagsT flagsSnap = flags ;
                        {
                        for(;;)
        
                        flagsT& flags = ((bookHeadS&)BOOKnOW).flags ;
                    {
                    else //GIVE OTHERS PERMISSION TO WRITE WOTH BYTE
                    if( !( F(flagsP) & flBOOKScwRITE_SETrEMAINING ) && cb1P ) flagsWrite |= flBOOK0cwRITE_CONTINUEfROMpRIOR ; //GIVE MYSELF PERMISSION TO WRITE WOTH BYTE (ON MY NEXT ITERATION)
                {
                if( !POOP && ( bWroteLath || ( F(flagsP) & flBOOKScwRITE_ALLoRnONE && !bWroteAll ) ) )

                pcRef_postBookNameNoPuse2[ offEltMyHeap ] = 0 ;                                     //THIS FREES THE HEAP ALLOCATION THAT I WAS USING FOR THE NAME
                //if( !( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE ) ) PUSE( tinP , postBookName ) ;
                THREADmODE1rESTORE ;
                //CONoUTrAW( "\r\n+++++++++++ NEWED  BOOK ------------" ) ;

                }
                    pBookUse = &BOOKnOW ;

                    NEWbOOK2sETfLAG

                    tinP.pcUtility[ 0 ] -- ; //U:: TO FIND A BUG
                    THREADmODE3rESTORE
                    }
                        THREADmODE3rESTORE
                        }
                            THREADmODE3rESTORE
                            new( 0 , tinP , PBbOOKbACKnOW , SIZEOF_bookC ) bookC( tinP , TAG( TAGiDnULL ) , postBookName , idStateSpace , flagsCtBook , F(flagsCt) & flBOOKSc_WRITER ? cbBodyNew : 0 , bFill , idMemorySpace ) ;
                            THREADmODE3oFF( flTHREADmODE3_SUPPRESStRACING )
                        {
                        THREADmODE3oN(  flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                    {
                    THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                    tinP.pcUtility[ 0 ] ++ ; //U:: TO FIND A BUG

                    NEWbOOK1bLAMMOiFcT
                {
                if( bBookNowIsDestroyed )

                //CONoUTrAW( "\r\n+++++++++++ NEWING BOOK ++++++++++++" ) ;
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;

                //}
                //    if( postBookName ) thirdC::c_strcpyIF( tinP , postBookName , tName ) ;
                //    PUSE.newF( tinP , LF , *(byteT**)&postBookName , tName.csF( tinP ) + 1 ) ; ___( postBookName ) ;
                //    TN( tName , "" ) ; tName = T(postNameShort)+T(".booksC.1.book.")+tIdBook ;
                //
                //    }
                //        for( countT offi = *PCPiDbOOKnOW ; offi ; offi -- ) tIdBook += tDot+TF3(PCPiDbOOKnOW[offi],flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ;
                //        TN( tDot , "." ) ;
                //        tIdBook = TF3(*PCPiDbOOKnOW,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ;
                //    {
                //    TN( tIdBook , "" ) ;                             //U::ELIMINATE USE OF POOL WHILE grabBookNew IS GRABBED
                //{
                //else
                }
                    thirdC::c_strcpyIF( tinP , postBookName , ostoName ) ;
        
                    }
                        OStEXTCF(  ostoName , PCPiDbOOKnOW[ offi ] , '0' ) ;
                        OStEXTAK( ostoName , "." ) ;
                    {
                    for( countT offi = *PCPiDbOOKnOW ; offi ; offi -- )
                    OStEXTCF(  ostoName , *PCPiDbOOKnOW , '0' ) ;
                    OStEXTAK( ostoName , ".booksC.1.book." ) ;
                    OStEXTA(  ostoName , postNameShort ) ;
                    OStEXT(   ostoName , TUCK << 1 ) ; //JUST TO MAKE SURE THAT BASE OS MAXPATH IS THE LIMITING CAPACITY CONSTRAINT
                {
                //if( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE )
                //20171112@1617: ALWAYS USE OStEXT RATHER THAN POOL, IN ORDER TO AVOID USING POOL WHILE grabBookNow IS GRABBED IN ORDER TO AVOID NONMONOTONIC GRABBING

                }
                    //}
                    //    //if( tinP.pEther ) tinP.pEther->trace F( tinP , T("booksC::writeF [idBook]: ")+TF2(PCPiDbOOKnOW[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    //{
                    //if( PCPiDbOOKnOW[ 0 ] && PCPiDbOOKnOW[ 1 ] >= TUCK ) //U::20141104@0740: TO FIND A BUG (RUNAWAY WHILE PROCESSING all.soil)

                    addF( tinP , PCPiDbOOKnOW , PCPiDbOOKlAG , pcpWo ) ;
                    countT pcpWo[] = { 1 , 1 } ;
                {

                }
                    //CONoUTrAW( "\r\n----------- DELETED  BOOK ------------" ) ;
                    bBookNowIsDestroyed = 1 ;
                    //tinP.pc Utility[ 0 ] -- ; //U:: TO FIND A BUG
                    DELzOMBIEbOOKbACKnOWiF
                    //tinP.pc Utility[ 0 ] ++ ; //U:: TO FIND A BUG
                    pBookUse = 0 ;
                    //CONoUTrAW( "\r\n----------- DELETING BOOK ++++++++++++" ) ;
                {
                else
                }
                    else                              BOOKnOW.purgeF( tinP ) ;
                    if( offBookBackNow < CbOOKsLOTS ) bBookNowIsDestroyed = 1 ;
                {
                if( F(flagsCt) & flBOOKSc_CYCLE )
                ZE( boolT , bBookNowIsDestroyed ) ;
                //if( tinP.pEther ) tinP.pEther->trace F( tinP , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": ")+T(postNameShort)+T(": ")+TF2(offBookBackNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": writeF / incremented") ) ; //U:: TO FIND A BUG
                offBookBackNow ++ ;

                }
                    }
                        //if( !(    (bookHeadS&)**ppBk0Scratch    ).cbBody ) { BLAMMO ; } //U::TO FIND A BUG  20140401
                        ((bookHeadS&)**ppBk0Scratch).flags |= flBOOKhEADs_PRIORbOOKnOTcONTINUEDhERE ;
                        }
                            *ppBk0Scratch = new( 0 , tinP , pbtBook0 , cbtBook0 ) book0C( tinP , pbtScratchBuffer , cbtBuffer ) ;
                        {

                        ;
                                : &tinP.pBk0TraceScratch
                                ? &tinP.pBk0TelemetryAppScratch
                            : bTelemetryApp
                            ? &tinP.pBk0TelemetrySysScratch
                        ppBk0Scratch = bTelemetrySys
                    {
                    else
                    if( !pbtScratchBuffer || !pbtBook0 ) { BLAMMO ; }

                    }
                        TELL( "booksC::writeF / called tlsNewF 2" )
                        pbtBook0  = tinP.tlsNewF( cbtBook0 ) ;
                        TELL( "booksC::writeF / calling tlsNewF 2" )
                    {
                    ZE( byteT* , pbtBook0 ) ;

                    }
                        TELL( "booksC::writeF / called tlsNewF 1" )
                        pbtScratchBuffer = tinP.tlsNewF( cbtBuffer ) ;
                        TELL( "booksC::writeF / calling tlsNewF 1" )
                    {
                    const countT cbtBook0  = sizeof( book0C ) ;

                    const countT cbtBuffer = TOCK ; //20151125@1605: OLD CODE FAILS ; RATHER THAN ANALYZE, JUST THROW A TOCK AT THE PROBLEM
                
                    //;
                    //    : TOCK ; //A:ASSUME: TRACE FROM DEL( p BookOld ) NEW( p BookOld ) IS FEWER THAN TOCK BYTES
                    //    ? sizeof( bookHeadS ) + 2 * ( sizeof( tellS ) + CBtELEMETRYeNVELOPE + sizeof( tellInfoSysNapkinS ) ) + 1       // ADD 1 TO ENSURE THAT THE LATH BYTE OF THE SCRATCH BUFFER IS NOT WRITTEN BY THE TELEMETRY EMITTED WHEN I DELETE AND NEW p BookOld
                    //const countT cbtBuffer = bTelemetrySys || bTelemetryApp
                    //ALLOCATED ROOM FOR 4 NAPKIN TELLS: DEL( p BookOld ) + NEW( p BookOld )
                {
                )
                    ( bTrace     && !tinP.pBk0TraceScratch )
                    ||
                    ( bTelemetryApp && !tinP.pBk0TelemetryAppScratch )
                    ||
                    ( bTelemetrySys && !tinP.pBk0TelemetrySysScratch )
                (
                if

                //IF flBOOKScwRITE_SETrEMAINING || !cb1P THEN I AM DONE WRITING MY DATA BUT MUST SET A FLAG IN THE NEW HEADER TO INDICATE THAT I WAIVE MY RIGHT TO WRITE ITS WOTH BYTE

                }                 
                    cb1P = cb2P ; cb2P = 0 ;
                    pb1P = pb2P ; pb2P = 0 ;
                {
                if( !cb1P && cb2P )

                           cb2P -= cbDone2 ;
                if( pb2P ) pb2P += cbDone2 ;

                           cb1P -= cbDone1 ;
                if( pb1P ) pb1P += cbDone1 ;

                // !cbDone1 || bWroteLath

                }
                    if( offEltMyHeap == cElts ) { BLAMMO ; }
                    }
                        }
                            break ;
                            postBookName = ppostBookNameNoPuse2[ offEltMyHeap ] ;
                        {
                        if( !setIfZeAM( pcRef_postBookNameNoPuse2[ offEltMyHeap ] , 1 ) )
                    {
                    for( offEltMyHeap = 0 ; offEltMyHeap < cElts ; offEltMyHeap ++ )
                    countT cElts = sizeof ppostBookNameNoPuse2 / sizeof ppostBookNameNoPuse2[ 0 ] ;
                {
                ZE( countT   , offEltMyHeap ) ;
                ZE( osTextT* , postBookName ) ;   //U:: BUG: THIS IS NOT REENTRANT.  I NEED TO USE POOL OR SOME OTHER MEMORY ALLOCATION SCHEME FOR THIS NAME SO THAT I AM REENTRANT
                //ALLOCATE postBookNameNoPuse2 (PUSE IS NOT USED TO AVOID NONMONOTONIC GRABBING.  SO I NEED TO HAVE MY OWN LITTLE HEAP)
            {
            else
            else if( F(flagsP) & flBOOKScwRITE_NOsCRATCHING ) { BLAMMO ; }
            else if( pBookUse == tinP.pBk0TraceScratch ) { BLAMMO ; }
            else if( pBookUse == tinP.pBk0TelemetryAppScratch ) { BLAMMO ; }
            else if( pBookUse == tinP.pBk0TelemetrySysScratch ) { BLAMMO ; } //20141206@0700: OBSERVED WITHIN ifcIDaDAM_CLOUD WHILE 3 INSTANCES EXISTED ; 20151026@2013: DITTO WHILE MORE THAN 3 EXISTED BUT ONLY WO WAS ACTIVE AT A TIME ; 20151125@1532 piss (156)
            }
                break ;
                if( ( !( F(flagsP) & flBOOKScwRITE_SETrEMAINING ) && cbDone1 != cb1P ) || cbDone2 != cb2P ) { BLAMMO ; } // cbDoneX MUST EQUAL cbXP; IF I DIDN'T WRITE THE LATH BYTE THEN I MUST HAVE WRITTEN ALL THAT I WANTED TO WRITE
            {
            if( cbDone1 && !bWroteLath ) // SHOULD BE IMPOSSIBLE IF flBOOKScwRITE_SETrEMAINING BECAUSE A flBOOKScwRITE_SETrEMAINING CALL WILL ALWAYS WRITE AT LEAST WO BYTE AND WILL ALWAYS WRITE THE LATH BYTE ; THIS IS BECAUSE ANY PRIOR WRITE THAT WRITES THE LATH BYTE WILL ALWAYS CLOSE THE BOOK AND OPEN THE NEXT BOOK

            boolT bWroteAll  =  !( F(flagsResult) & flBOOK0cwRITErESULT_COULDnOTwRITEaLL ) ;
            boolT bWroteLath = !!( F(flagsResult) & flBOOK0cwRITErESULT_WROTElATHbYTE    ) ;

            //}
            //    }
            //        thirdC::c_memcpyIF( tinP , (byteT*)( *ppcpIdAptP + 2 ) , (byteT*)( PCPiDbOOKnOW + 1 ) , sizeof( countT ) * *PCPiDbOOKnOW ) ;
            //        (*ppcpIdAptP)[ 1 ] = offAt ;
            //        (*ppcpIdAptP)[ 0 ] = 1 + *PCPiDbOOKnOW ;
            //    {
            //    else
            //    if( !cbDone1 ) bDeleteOutParam = 1 ;
            //{
            //if( ppcpIdAptP && *ppcpIdAptP )

            flagsWrite &= ~( F(flBOOK0cwRITE_CONTINUEfROMpRIOR) ) ;

            if( cbDone1 && !idBook ) idBook = PCPiDbOOKnOW[ 1 ] ; // APPS CAN USE THE LOWEST ORDER idBook countT TO IDENTIFY WHICH BOOK A TRANSACTION WAS WRITTEN TO, EVEN WHEN THE FULL IDbOOK VALUE IS LEN > 1, IN ORDER TO SUPPORT CHECKPOINT / RESTART FUNCTIONALITY WITHIN TRANSACTION PROCESSING
            // idBook IS INTENDED TO BE THE ID OF THE WOTH BOOK TO RECEIVE ANY PART OF THE FULL ITEM WRITTEN; FOR CHECKPOINT / RESTART FUNCTIONALITY, TRANSACTION PROCESSING SHOULD USE flBOOKScwRITE_ALLoRnONE

            }
                }
                    c2AppNote.c2 = PCPiDbOOKnOW[ 1 ] ;
                    c2AppNote.c1 = offWrote ;
                    HANDLEaPPnOTEScOUNTcLASS& c2AppNote = *phWroteP ;
                    phWroteP->osF( ifcIDtYPEhANDLE_BOOKS , FINGERnEG_HANDLEbOOKSjOT , 0 , cbDone1 + cbDone2 ) ;
                {
                if( !POOP )

                __( cb2P - cbDone2 ) ;
                if( !( F(flagsP) & flBOOKScwRITE_SETrEMAINING ) ) { __( cb1P - cbDone1 ) ; }
            {
            if( phWroteP && cbDone1 )

            }
                THREADmODE1rESTORE ;
                offAt = pBookUse->writeF( tinP , flagsResult , pb1P , cbDone1 , pb2P , cbDone2 , flagsWrite , phWroteP ? &offWrote : 0 ) ;
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;
            {
            ZE( countT , offAt ) ;
            ZE( countT , offWrote ) ;
            ZE( flagsT , flagsResult ) ;
            countT cbDone2 = cb2P ;
            countT cbDone1 = cb1P ;

            }
                if( POOP ) break ;
                __( *PCPiDbOOKnOW != 1 ) ; // IDbOOK VALUES ARE UNLIMITED.  BUT ONLY LENGTH 1 IDbOOK VALUES CAN BE STORED WITHIN A handleC.  FOR MORE CAPACITY, INCREASE THE SIZE OF handleC::c2AppNote
            {
            if( phWroteP ) // MUST BE CHECKED AGAIN HERE BECAUSE PCPiDbOOKnOW MIGHT HAVE CHANGED SINCE ENTERING ME
        {
        while( cb1P || F(flagsP) & flBOOKScwRITE_SETrEMAINING )
        //ZE( boolT , bDeleteOutParam ) ;
        ZE( book0C** , ppBk0Scratch ) ;

        }
            if( F(flagsP) & flBOOKScwRITE_FLUSHaTpAGE                   ) flagsWrite |= flBOOK0cwRITE_FLUSHaTpAGE                   ;
            if( F(flagsP) & flBOOKScwRITE_FLUSHb4tAIL                   ) flagsWrite |= flBOOK0cwRITE_FLUSHb4tAIL                   ;
            if( F(flagsP) & flBOOKScwRITE_FLUSHbOOKhEADoNcHANGE         ) flagsWrite |= flBOOK0cwRITE_FLUSHbOOKhEADoNcHANGE         ;
        {
        if( pBookUse != tinP.pBk0TelemetrySysScratch && pBookUse != tinP.pBk0TelemetryAppScratch && pBookUse != tinP.pBk0TraceScratch )

        if( F(flagsP) & flBOOKScwRITE_SETrEMAINING                  ) flagsWrite |= flBOOK0cwRITE_SETrEMAINING                  ;
        if( F(flagsP) & flBOOKScwRITE_ALLOWoDDlENGTH                ) flagsWrite |= flBOOK0cwRITE_ALLOWoDDlENGTH                ;
        if( F(flagsP) & flBOOKScwRITE_TAILfINGER                    ) flagsWrite |= flBOOK0cwRITE_TAILfINGER                    ;
        if( F(flagsP) & flBOOKScwRITE_HEADfINGER2                   ) flagsWrite |= flBOOK0cwRITE_HEADfINGER2                   ;
        if( F(flagsP) & flBOOKScwRITE_HEADcBdATA                    ) flagsWrite |= flBOOK0cwRITE_HEADcBdATA                    ;
        if( F(flagsP) & flBOOKScwRITE_HEADiDfORMAT                  ) flagsWrite |= flBOOK0cwRITE_HEADiDfORMAT                  ;
        if( F(flagsP) & flBOOKScwRITE_HEADfINGER1                   ) flagsWrite |= flBOOK0cwRITE_HEADfINGER1                   ;
        if( F(flagsP) & flBOOKScwRITE_ELSEfILLtOeND                 ) flagsWrite |= flBOOK0cwRITE_ELSEfILLtOeND                 ;
        if( F(flagsP) & flBOOKScwRITE_ALLoRnONE                     ) flagsWrite |= flBOOK0cwRITE_ALLoRnONE                     ;
        if( F(flagsP) & flBOOKScwRITE_PURGE                         ) flagsWrite |= flBOOK0cwRITE_PURGE                         ; //WARNING: THIS ONLY PURGES THE CURRENT BOOK; TO PURGE THE BOOK SET, APP CAN DESTROY THIS INSTANCE AND CT AN INSTANCE USING flBOOKSc_PURGEoNcT
        flagsT flagsWrite = flBOOK0cwRITE_null ;

        ZE( byteT* , pbtScratchBuffer ) ; //USED AS BOOLEAN TO INDICATE THAT I AM THE CALL NEST LEVEL THAT MUST POUR AND THEN DESTROY THE SCRATCH BOOK

        //if( !( (bookHeadS&)*pBookUse ).cbBody ) { BLAMMO ; } //U::TO FIND A BUG  20140401

        ;
                    : &BOOKnOW
                    ? tinP.pBk0TraceScratch
                : bTrace && tinP.pBk0TraceScratch
                ? tinP.pBk0TelemetryAppScratch
            : bTelemetryApp && tinP.pBk0TelemetryAppScratch
            ? tinP.pBk0TelemetrySysScratch
        book0C* pBookUse = bTelemetrySys && tinP.pBk0TelemetrySysScratch

        //}
        //    }
        //        grabBookNow.grabF( tinP , TAG( TAGiDnULL ) ) ;
        //        PUSE.newF( tinP , LF , *(byteT**)ppcpIdAptP , sizeof( countT ) * ( 2 + save ) ) ; ___( *ppcpIdAptP ) ;
        //        save = *PCPiDbOOKnOW ;
        //        PUSE( tinP , *(byteT**)ppcpIdAptP ) ;
        //        grabBookNow.ungrabF( tinP ) ;
        //    {
        //    while( *PCPiDbOOKnOW - save )
        //
        //    grabBookNow.grabF( tinP , TAG( TAGiDnULL ) ) ;
        //    PUSE.newF( tinP , LF , *(byteT**)ppcpIdAptP , sizeof( countT ) * ( 2 + save ) ) ; ___( *ppcpIdAptP ) ;
        //    countT save = *PCPiDbOOKnOW ;
        //{
        //else
        //}
            if( processGlobal1I._grabC_pgw ) grabBookNow.grabF( tinP , TAG( TAGiDnULL ) ) ;
        //{
        //if( !ppcpIdAptP || !tinP.pPoolUse || !processGlobal1I._grabC_pgw )
        //20171117@2104: ppcpIdAptP SUPPORT IS COMMENTED OUT BECAUSE IT IS NOT CURRENTLY USED AND ITS CURRENT CODE REQUIRES USE OF PUSE, WHICH CAUSES NONMONOTONIC GRABBING.  BEFORE ENABLING, MUST BE REWRITTEN TO AVOID USING PUSE

        //const boolT bTraceDivert1 = this == &processGlobal3I.bksTraceDivert01 ;
        const boolT bTrace        = this == &processGlobal3I.bksTrace           ;
        const boolT bTelemetryApp = this == &processGlobal3I.bksTelemetryApp    ;
        const boolT bTelemetrySys = this == &processGlobal3I.bksTelemetrySys    ;
    {
    if( cb1P || F(flagsP) & flBOOKScwRITE_SETrEMAINING )
    ZE( countT , idBook ) ;

    //;
    //    : new( 0 , tinP , _pbInOutFrame , sizeof _pbInOutFrame ) inOutFrameC( tinP , LF , IDFILE , BiFCcLASS )
    //    ? 0 
    //inOutFrameC* pInOutFrame = this == &processGlobal3I.bksTrace || this == &processGlobal3I.bksTraceDivert01 || this == &processGlobal3I.bksTraceDivert02 || this == &processGlobal3I.bksTraceDivert03 || this == &processGlobal3I.bksTraceDivert04 || this == &processGlobal3I.bksTraceDivert05 || this == &processGlobal3I.bksTraceDivert06 || this == &processGlobal3I.bksTraceDivert07 || this == &processGlobal3I.bksTraceDivert08
    //byteT _pbInOutFrame[ sizeof( inOutFrameC ) ] ;
    //20191008@0844: DON'T KNOW WHY DONE THIS WAY RATHER THAN JUST USE _IO_

    //if( this == &processGlobal3I.bksTelemetrySys || this == &processGlobal3I.bksTelemetryApp /*|| this == &processGlobal3I.bksTrace || this == &processGlobal3I.bksTraceDivert01*/ || this == &processGlobal3I.bksWord || this == &processGlobal3I.bksWords ) return 0 ;  //U:: TO WORKAROUND A BUG (NONMONOTONIC GRABBING)
    //U::DELETE THE NEXT LINE ONCE I AM TESTED TO VERIFY THAT I DO NOT TRIGGER NONMONOTONIC GRABBING BLAMMO

    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )

    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )     //20200912@1846: ADDED WITHOUT ANALYSIS TO PREVENT RARE EVENT FAILURE THAT I CANNOT LOCATE

    _IO_

    //    ungrab grabBookNow
    //       dt scratch and free tls
    //       pour scratch  (this might ct and use a new scratch book)
    //      if i allocated scratch
    //       ct book
    //       dt book
    //       increment offBookNow
    //       allocate from tls and ct scratch book
    //      if scratch not allocated
    //      adjust parameters by cbDone      
    //     else
    //     else if scratch or no scratching then blammo
    //     if wrote something but did not exhaust book then break
    //     write to pBookUse
    //    while have something to write
    //    set pBookUse to scratch if exists, or to BOOKnOW otherwise
    //    grab grabBookNow
    //   if have something to write
    //   set flag pool alloc from heap
    //  pseudocode

    }
        if( POOP ) return 0 ;
        }
            __( *PCPiDbOOKnOW != 1 ) ; // IDbOOK VALUES ARE UNLIMITED.  BUT ONLY LENGTH 1 IDbOOK VALUES CAN BE STORED WITHIN A handleC.  FOR MORE CAPACITY, INCREASE THE SIZE OF handleC::c2AppNote
            __NZ( !( F(flagsP) & flBOOKScwRITE_ALLoRnONE ) && !( F(flagsP) & flBOOKScwRITE_SETrEMAINING ) ) ;
        {
        if( phWroteP )
        FV( flBOOKScwRITE , flagsP ) ;
        //__( ppcpIdAptP && ( this == &processGlobal3I.bksTelemetrySys || this == &processGlobal3I.bksTelemetryApp || this == &processGlobal3I.bksTrace || this == &processGlobal3I.bksTraceDivert01 || this == &processGlobal3I.bksWord || this == &processGlobal3I.bksWords ) ) ; //CAPTURE OF TELEMETRY OR TRACE IS GUARANTEED TO NEVER INVOLVE USE OF A poolC INSTANCE; SUCH USAGE COULD EMIT TELEMETRY OR TRACE, CAUSING SCRATCH BOOK OVERFLOW
        //__( ppcpIdAptP && *ppcpIdAptP ) ; //20171112@1557: ADDED WITHOUT ANALYSIS WHILE EDITING TO PREALLOCATE TO AVOID USING POOL WHILE grabBookNow IS GRABBED
        if( POOP ) return 0 ;
        __NZ( cbBodyNew < cb1P + cb2P && F(flagsP) & flBOOKScwRITE_ALLoRnONE ) ;
        __NZ( !pb2P && cb2P ) ;
        if( pb2P && !cb2P ) cb2P = thirdC::c_strlenIF( tinP , pb2P ) ;
        if( pb1P && !cb1P ) cb1P = thirdC::c_strlenIF( tinP , pb1P ) ;  //20200920@1713: MOVED THESE 2 LINES EARLIER TO HERE W/O ANALYSIS
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL    

    SCOOP
{
/*1*/countT booksC::writeF( tinS& tinP , const byteT* pb1P , countT cb1P , const byteT* pb2P , countT cb2P , const flagsT flagsP , handleC* const phWroteP /*U::, countT** ppcpIdAptP*/ )/*1*/

countT pcRef_postBookNameNoPuse2[ 0x10 ] ;                  //CS:CODEsYNC: 360fb005 360fb005

;
}
    postBookNameNoPuse2_f ,
    postBookNameNoPuse2_e ,
    postBookNameNoPuse2_d ,
    postBookNameNoPuse2_c ,
    postBookNameNoPuse2_b ,
    postBookNameNoPuse2_a ,
    postBookNameNoPuse2_9 ,
    postBookNameNoPuse2_8 ,
    postBookNameNoPuse2_7 ,
    postBookNameNoPuse2_6 ,
    postBookNameNoPuse2_5 ,
    postBookNameNoPuse2_4 ,
    postBookNameNoPuse2_3 ,
    postBookNameNoPuse2_2 ,
    postBookNameNoPuse2_1 ,
    postBookNameNoPuse2_0 ,
{
osTextT* ppostBookNameNoPuse2[] =                           //CS:CODEsYNC: 360fb005 360fb005

osTextT postBookNameNoPuse2_f[ TUCK ] ;
osTextT postBookNameNoPuse2_e[ TUCK ] ;
osTextT postBookNameNoPuse2_d[ TUCK ] ;
osTextT postBookNameNoPuse2_c[ TUCK ] ;
osTextT postBookNameNoPuse2_b[ TUCK ] ;
osTextT postBookNameNoPuse2_a[ TUCK ] ;
osTextT postBookNameNoPuse2_9[ TUCK ] ;
osTextT postBookNameNoPuse2_8[ TUCK ] ;
osTextT postBookNameNoPuse2_7[ TUCK ] ;
osTextT postBookNameNoPuse2_6[ TUCK ] ;
osTextT postBookNameNoPuse2_5[ TUCK ] ;
osTextT postBookNameNoPuse2_4[ TUCK ] ;
osTextT postBookNameNoPuse2_3[ TUCK ] ;
osTextT postBookNameNoPuse2_2[ TUCK ] ;
osTextT postBookNameNoPuse2_1[ TUCK ] ;
osTextT postBookNameNoPuse2_0[ TUCK ] ;

//I SUPPORT UP TO 01 THREADS SIMULTANEOUSLY 
//20171117@2056: THE FOLLOWING IS A KLUDGE THAT I AM USING TO IMPLEMENT A HEAP SO THAT I CAN ELIMINATE THE USE OF PUSE IN ORDER TO AVOID NONMONOTONIC GRABBING

/**/
*/
  if 0 then i will calculate the null terminated length of pb2P
  if pb2P then should not be 0
  may be 0
 cb2P
  if not 0 then points to second input source
   is normally 0
  may be 0
 pb2P
   if 0 then i will calculate the null terminated length of pb1P
   should not be 0
  if  pb1P then specifies the number of bytes at pb1P
  if !pb1P then specifies the fill value and must be < TUCK
 cb1P
  if 0 then all remaining bytes of book will be set to (byteT)cb1P
  is normally not 0
  can be 0
 pb1P
 tinP
parameters
for caller convenience, i optionally take input from oo sources
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

