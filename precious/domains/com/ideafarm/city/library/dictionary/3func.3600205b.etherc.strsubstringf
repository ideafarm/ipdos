
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        }
            }
                if( idLastP > csttBig ) idLastP = csttBig ;_WQ
                idLastP = idFirstP - 1 + csttCopy ;_WQ
            {
            else
            if( idFirstP > csttBig ) idFirstP = idLastP = 0 ;
            idFirstP = idLastP + 1 ;_WQ
            for( countT offi = 0 ; offi < csttCopy ; offi ++ ) psttP[ CSpREFIX + csttBefore + offi ] = psttBigP[ CSpREFIX + idFirstP - 1 + offi ] ;_WQ
        {
        if( !POOP )

        __Z( psttP ) ;    
        }
            if( psttP ) { SETpREFIX( psttP , csttCopy , csttExtraP ) ; }

            POSTPONEtEST( psttP ) ;_WQ
            third.newF( tinP , LF , psttP , csNew ) ; // CALLER MUST TAG ___( psttP ) ;_WQ
            countT csNew = CSpREFIX + csttCopy + csttExtraP ;_WQ
        {
        else
        }
            }
                psttP[ 2 ].idAdam -= csttCopy ;_WQ
                psttP[ 0 ].idAdam += csttCopy ;_WQ
            {
            if( !POOP )
            __( psttP[ 2 ].idAdam < csttCopy ) ;_WQ
        {
        if( psttP )
        countT csttBefore = psttP ? psttP->idAdam : 0 ;_WQ
    
        countT csttCopy = idLastP - idFirstP + 1 ;_WQ
        __( idFirstP > idLastP ) ;_WQ
        __( idLastP > csttBig ) ;_WQ
        if( !idLastP ) idLastP = csttBig ;_WQ
    {
    else
    if( csttBig < idFirstP ) idFirstP = 0 ;
    countT csttBig = psttBigP->idAdam ;_WQ

    _INoLD_

    }
        if( POOP ) return ;
        __( psttBigP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return ;
        __( idLastP && idFirstP > idLastP ) ;_WQ
        __Z( idFirstP ) ;_WQ
        __Z( psttBigP ) ;_WQ
        if( POOP ) return ;
    {
    IFbEcAREFUL

    //ON RETURNING, idLastP WILL POINT IMPLY AN EQUAL LENGTH STRING, SHORTENED IF NECESSARY TO FIT WITHIN psttBigP
    //ON RETURNING, idFirstP WILL POINT TO THE STROKE AFTER THE ONES FOUND
    SCOOP
{
/*1*/voidT etherC::strSubstringF( tinS& tinP , strokeS*& psttP , countT& idFirstP , countT& idLastP , const strokeS* psttBigP , const countT csttExtraP )/*1*/

/**/
*/
 csttExtraP
 psttBigP
  if not 0 then must not be less than idFirstP
  if 0 then the end of psttBigP is implied
  can be 0
 idLastP
  if there aren't enough strokes in psttBigP, psttP will receive T("") and impotence will not occur
  this is usually set to 1 when drawing the first substring from a string
  must not be ze
 idFirstP
   must have sufficient capacity
  if not 0 then result will be appended
   will be allocated from the pool
  can be 0
 psttP
arguments
  \<A HREF=\"5.1a10104.1.1.0.html\"\>1a10104:  WAKEsHOW( "example.simplest.func.1030066.etherC.strSubstringF" )\</A\>
 simplest
examples
\<A HREF=\"5.1030066.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strSubstringF.0.html\"\>instances\</A\>
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

