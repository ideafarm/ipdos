
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.strokeF( tinP , T("")+S2('\f',sc_cFROMcONTROL) ) ;
ether.loafIF( tinP ) ;
etThread.strokeF( tinP , T("")+S2('\f',sc_cFROMcONTROL)+//SCBA(scbF) ) ;

{ sadamCBFT pf = scbF ; } //VERIFY TYPE

TODO

}
    return 1 ;
    //wP.baton.ungrabF( tinP ) ; //U::
    if( idSnipP && psttSnipP && idsP && c8scratchEventP.c1 && bNoDrawP && flagsP && wP.bDoomed ) ;

    }
        }
            break ;
            }
                }
                    }
                        break ;
                        }
                            }
                                break ;
                            {
                            case ifcIDtYPEtOOL_MOUSEpOSITION     :
                        {
                        switch( idTool )
                    {
                    case ifcIDtYPEaCTION_MOVE :
                    }
                        break ;
                        }
                            }
                                break ;
                            {
                            case ifcIDtYPEtOOL_MOUSEbUTTONrIGHT  :
                            case ifcIDtYPEtOOL_MOUSEbUTTONcENTER :
                            case ifcIDtYPEtOOL_MOUSEbUTTONlEFT   :
                        {
                        switch( idTool )
                    {
                    case ifcIDtYPEaCTION_UP :
                    }
                        break ;
                        }
                            }
                                break ;

                                }
                                    }
                                        }
                                            stInvalidP << pc4 ;

                                            pc4->c4 = R( wP.mIdRow  ) ;
                                            pc4->c3 = R( wP.mIdCol  ) ;
                                            pc4->c2 = R( mIdRowFrom ) ;
                                            pc4->c1 = R( mIdColFrom ) ;
                                        {
                                        if( pc4 )
                                        etherP.newF( tinP , LF , pc4 ) ; ___( pc4 ) ;
                                        ZE( count4S* , pc4 ) ;
                                    {
                    
                                    mRowLathDraw = mIdRowTo ;
                                    mColLathDraw = mIdColTo ;
                                    wP.baton.ungrabF( tinP ) ;
                                    third.winLineF( tinP , wP , mIdColTo , mIdRowTo ) ;
                                    measureT mIdRowTo = idRow ;
                                    measureT mIdColTo = idCol ;
                                    measureT mIdRowFrom = wP.mIdRow ;
                                    measureT mIdColFrom = wP.mIdCol ;
                                    third.winMoveF( tinP , wP ) ;
                                    wP.mIdRow = mRowLathDraw ;
                                    wP.mIdCol = mColLathDraw ;
                                    wP.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                {
                                else
                                }
                                    mRowLathDraw = idRow ;
                                    mColLathDraw = idCol ;
                                {
                                if( !mColLathDraw )
                            {
                            case ifcIDtYPEtOOL_MOUSEbUTTONrIGHT  :
                            case ifcIDtYPEtOOL_MOUSEbUTTONcENTER :
                            case ifcIDtYPEtOOL_MOUSEbUTTONlEFT   :
                        {
                        switch( idTool )
                    {
                    case ifcIDtYPEaCTION_DOWN :
                {
                switch( idAction )

                thirdC& third = etherP ;
                const countT& idRow    = pcNotesP[ 5 ] ;
                const countT& idCol    = pcNotesP[ 4 ] ;
                const countT& idAction = pcNotesP[ 3 ] ;
                const countT& idTool   = pcNotesP[ 2 ] ;
            {
            if( pcNotesP[ 0 ] == 1 && pcNotesP[ 1 ] == 4 )
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            }
                }
                    }
                        }
                            break ;
                            else                                                                                    etherP.etherFireImpersonateMonitorIF( tinP ) ;
                            if( F(thirdC::third_flagsModeProcess1I_IF(tinP)) & flMODEpROCESS1_IGNOREfIREbYoPERATOR ) thirdC::dosBeepIF( tinP , 0x3800 , TUCK * 0x20 ) ;
                        {
                        case ifcIDtYPEtOOL_ESCAPE :
                    {
                    switch( idTool )
                    ZE( boolT , bFreshFace ) ;
                {
                if( idAction == ifcIDtYPEaCTION_DOWN )

                const countT& idAction = pcNotesP[ 3 ] ;
                const countT& idTool = pcNotesP[ 2 ] ;
            {
            if( pcNotesP[ 0 ] == 1 && pcNotesP[ 1 ] == 2 )
        {
        case ifcIDtYPEsTROKEcALLbACK_KEY :
        }
            break ;
            wP.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
            }
                while( bQuit ) { ++ s ; etherP.osSleepF( tinP , TUCK * 0x10 ) ; }
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            wP.baton.ungrabF( tinP ) ;
            bRender = 0 ;
            bQuit = 1 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_DESTROY   :
        }
            break ;
            bRender = 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_RENDERoFF :
        }
            break ;
            bRender = 1 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_RENDERoN :
        }
            break ;
            etherP.osThreadF( tinP , countTC() , tmRenderF , 0 , flTHREADlAUNCH_null , 0 , (countT)&c8scratchSnippetP , (countT)&wP ) ;
            bRender = 1 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_RENDER :
    {
    switch( idTypeCallP )

    measureT& mRowLathDraw = *(measureT*)&c8scratchSnippetP.c8 ;
    measureT& mColLathDraw = *(measureT*)&c8scratchSnippetP.c7 ;
    measureT& mRowMax      = *(measureT*)&c8scratchSnippetP.c6 ;
    measureT& mColMax      = *(measureT*)&c8scratchSnippetP.c5 ;
    measureT& mRowMin      = *(measureT*)&c8scratchSnippetP.c4 ;
    measureT& mColMin      = *(measureT*)&c8scratchSnippetP.c3 ;
    boolT&    bRender      = c8scratchSnippetP.c2 ;
    boolT&    bQuit        = c8scratchSnippetP.c1 ;
    //wP.baton.grabF( tinP , TAG( TAGiDnULL ) ) ; //U::
{
boolT scbF( tinS& tinP , etherC& etherP , windowOldC& wP , stackC& stInvalidP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , count8S& c8scratchEventP , count8S& c8scratchAdamP , count8S& c8scratchSnipP , count8S& c8scratchSnipAdamP , count8S& c8scratchStrokeP )

DONE( tmRenderF )
}
    bQuit = 0 ;
    }
        }
            }
                ++ s ; etThread.osSleepF( tinP , TUCK * 0x10 ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            else
            }
                win.baton.ungrabF( tinP ) ;
                third.winLineF( tinP , win , mIdColTo , mIdRowTo ) ;
                measureT mIdRowTo = mIdRowDraw ;
                measureT mIdColTo = win.mCols ;
                measureT mIdRowFrom = win.mIdRow ;
                measureT mIdColFrom = win.mIdCol ;
                third.winMoveF( tinP , win ) ;
                win.mIdRow = mIdRowDraw ;
                win.mIdCol = 1 ;
                measureT mIdRowDraw = 1 + idRender % (countT)win.mRows ;
                win.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
                thirdC& third = etThread ;
                
                stackC stInvalid( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_count4S ) ;
            {
            if( bRender && !bLame )

            if( !( idRender % (countT)win.mRows ) ) bLame = 1 ;
            ++ idRender ;
            static countT idRender ;
        {
        while( !etThread && !bQuit )
        ZE( boolT , bLame ) ;

        measureT& mRowLathDraw = *(measureT*)&c8scratchSnippetP.c8 ;
        measureT& mColLathDraw = *(measureT*)&c8scratchSnippetP.c7 ;
        measureT& mRowMax      = *(measureT*)&c8scratchSnippetP.c6 ;
        measureT& mColMax      = *(measureT*)&c8scratchSnippetP.c5 ;
        measureT& mRowMin      = *(measureT*)&c8scratchSnippetP.c4 ;
        measureT& mColMin      = *(measureT*)&c8scratchSnippetP.c3 ;
        boolT&    bRender = c8scratchSnippetP.c2 ;
        windowOldC& win = *(windowOldC*)pTaskP->c2 ;
    {
    boolT&    bQuit   = c8scratchSnippetP.c1 ;
    count8S& c8scratchSnippetP = *(count8S*)pTaskP->c1 ;

    etThread.beeClickF( tinP , 0x100 + tinP.monitor.idThread * 0x100 , 0x400 ) ; //U::
{
if( pTaskP && pTaskP->c1 )
TASK( tmRenderF )

//#define R(argP) argP
//#undef R
//U::

/*1*/WAKEhIDE( "doodle.draw.with.mouse" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

