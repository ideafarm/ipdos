
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bCallerMustDelete ;

    _OUT_

    THREADmODE3rESTORE

    grabBookNow.ungrabF( tinP ) ;

    }
        }
            if( cRefWas == -1 ) { BLAMMO ; }

            //}
            //    tinP.pEther->traceF( tinP , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_LOOP | flTRACE_PARAMETERiSoStEXT ) ;
            //
            //    OStEXTAK( ostoSay , " +" ) ;
            //    OStEXTC(  ostoSay , cRefWas , 0 ) ;
            //    OStEXTAK( ostoSay , "    " ) ;
            //    OStEXTC(  ostoSay , pcRef , 0 ) ;
            //    OStEXTAK( ostoSay , "    " ) ;
            //    OStEXTCmIN( ostoSay , this , 8 ) ;
            //    OStEXTAK( ostoSay , "booksC [this,pcRef,cRefWas]:    " ) ;
            //    OStEXT(   ostoSay , TUCK ) ;
            //{
            //if( tinP.pAdamGlobal1->idAdam == ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE1 )
    
            countT cRefWas = incv02AM( *pcRef ) ;
            countT* pcRef = &head.cRef ;
        {
        else
        }
            if( cRefWas == -1 ) { BLAMMO ; }
            countT cRefWas = incv02AM( head.cRef ) ;
        {
        if( !tinP.pEther )
    
        bookHeadS& head = BOOKnOW ;
    {
    if( F(flagsP) & flBOOKScrEAD_INCREMENTrEFERENCEcOUNTiF && !bCallerMustDelete )    //20181210@1318: ADDED "&& !bCallerMustDelete" BECAUSE I AM RETURNING A pbP THAT POINTS TO A poolC DROP RATHER THAN INTO A bookC INSTANCE

    }
        (*tinP.pEther)( tinP , pStkSnip ) ;  //20181210@1316: ADDED WITHOUT ANALYSIS

        }
            PUSE( tinP , pbw ) ;
            *pStkSnip >> pbw ;
            ZE( byteT* , pbw ) ;
        {
        while( *pStkSnip )
    {
    else
    }
        (*tinP.pEther)( tinP , pStkSnip ) ;

        }
            *pbo = 0 ;
            if( pbzSnip && cbzSnip ) { thirdC::c_memcpyIF( tinP , pbo , pbzSnip , cbzSnip ) ; pbo += cbzSnip ; }

            }
                PUSE( tinP , pbw ) ;
                thirdC::c_memcpyIF( tinP , pbo , pbw + sizeof( countT ) , *(countT*)pbw ) ; pbo += *(countT*)pbw ;
                *pStkSnip >> pbw ;
                ZE( byteT* , pbw ) ;
            {
            while( *pStkSnip )
            byteT* pbo = (byteT*)pbP ;
        {
        if( !POOP )

        cbP = cbaAll ; //20131204@1219: ADDED WITHOUT ANALYSIS
        __Z( pbP ) ;
        PUSE.newF( tinP , LF , *(byteT**)&pbP , cbaAll + 1 ) ; ___( pbP ) ;
        __NZ( pbP ) ;

        while( ~hWalk ) ;
        }
            cbaAll += *(countT*)pbw ;
            byteT* pbw = (byteT*)pStkSnip->downF( tinP , hWalk ) ;
        {
        do
        countT cbaAll = cbzSnip ;

        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

        __NZ( F(flagsP) & flBOOKScrEAD_CURRENTbOOKoNLY ) ;
    {
    else if( !bQuit )
    }
        cbP = cbzSnip ;
        pbP = pbzSnip ;
    {
    if( !bCallerMustDelete )
    boolT bCallerMustDelete = !!pStkSnip ;

    }
        }
            }
                else                                                       cbToDo -= cbzSnip ;
                if( !cbzSnip || F(flagsP) & flBOOKScrEAD_CURRENTbOOKoNLY ) cbToDo  = 0       ;

                }
                    pBook->writeF( tinP , flResult , (byteT*)&c2AppNote , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLoRnONE | flBOOK0cwRITE_PURGEiFfULL ) ;
                    countT cb1 = sizeof c2AppNote ;
                    ZE( flagsT , flResult ) ;
                    bookC* pBook = (bookC*)phCursorP->osF( ifcIDtYPEhANDLE_BOOKSrEADcURSOR ) ;
                {
                if( pbzSnip && phCursorP && ~*phCursorP )          //PSEUDOdUPLICATEcODE: 360fb006 360fb006
                //IF READ SUCCEEDED THEN ADVANCE PERSISTENT CURSOR *phCursorP

                BOOKnOW.readF( tinP , pbzSnip , cbzSnip , c2AppNote.c1 ) ;
                cbzSnip = cbToDo ;

                __NZ( cbzSnip ) ;
                __NZ( pbzSnip ) ;
                }
                    cbzSnip = 0 ;
                    pbzSnip = 0 ;

                    }
                        }
                            *pStkSnip << pbw ; pbw = 0 ;
                            thirdC::c_memcpyIF( tinP , pbw + sizeof( countT ) , pbzSnip , cbzSnip ) ;
                            *(countT*)pbw = cbzSnip ;
                        {
                        if( !POOP )

                        __Z( pbw ) ;
                        PUSE.newF( tinP , LF , *(byteT**)&pbw , sizeof( countT ) + cbzSnip ) ; ___( pbw ) ;
                        ZE( byteT* , pbw ) ;
                    {
                    if( !POOP )

                    __Z( pStkSnip ) ;
                    if( !pStkSnip ) (*tinP.pEther)( tinP , pStkSnip , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_byteT ) ; ___( pStkSnip ) ;
                    __Z( cbzSnip ) ;
                {
                if( pbzSnip )
                // MOVE A PRIOR SNIP OUT OF THE WAY
            {
            else
            }
                }
                    pBook->writeF( tinP , flResult , (byteT*)&c2AppNote , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLoRnONE | flBOOK0cwRITE_PURGEiFfULL ) ;
                    countT cb1 = sizeof c2AppNote ;
                    ZE( flagsT , flResult ) ;
                    bookC* pBook = (bookC*)phCursorP->osF( ifcIDtYPEhANDLE_BOOKSrEADcURSOR ) ;
                {
                if( phCursorP && ~*phCursorP )          //PSEUDOdUPLICATEcODE: 360fb006 360fb006

                c2AppNote.c2 = pcpOffIdBookWant[ 2 ] ;
                c2AppNote.c1 = pcpOffIdBookWant[ 1 ] ;
                HANDLEaPPnOTEScOUNTcLASS& c2AppNote = handleP ;
                handleP.osF( ifcIDtYPEhANDLE_BOOKS , FINGERnEG_HANDLEbOOKSjOT ) ;

                handleP.closeIfF() ;

                __Z( pcpOffIdBookWant[ 2 ] ) ; // ONLY LENGTH 1 IDbOOK STRINGS ARE ALLOWED.  FOR MORE CAPACITY, EDIT THIS CODE AND INCREASE THE SIZE OF handleC::c2AppNote
                pcpOffIdBookWant[ 2 ] ++ ;
                pcpOffIdBookWant[ 1 ] = 0 ;     //THE NEXT READ SHOULD BE AT THE BEGINNING OF THE NEXT BOOK
                
                __NZ( head.cbUsed < c2AppNote.c1 ) ;
            {
            if( head.cbUsed == head.cbBody && c2AppNote.c1 >= head.cbUsed - head.cbFill )                                           // (THIS FUNCTIONALITY IS DEFINITELY NEEDED BY tmEatTelemetryF) NO MORE BYTES ARE AVAILABLE IN THE CURRENT BOOK AND THERE NEVER WILL BE BECAUSE THE CURRENT BOOK IS FILLED TO THE BRIM
            //20181107@1054: REMOVED cbToDo == -1 AS ALTERNATIVE CONDITION IN NEXT LINE BECAUSE INCONSISTENT WITH SEMANTIC COMMENT

            }
                if( !cbToDo ) break ;   // NOTHING MORE TO READ SO WE'RE DONE
                cbToDo = head.cbUsed - head.cbFill - c2AppNote.c1 ;
            {
            if( cbToDo == - 1 )                                             // -1 INDICATES THAT CALLER WANTS ME TO RETURN THE REMAINDER OF THE BOOK

            bookHeadS& head = BOOKnOW ;
        {
        if( cbToDo )

        }
            }
                THREADmODE1rESTORE ;

                }
                    NEWbOOK2sETfLAG
                    new( 0 , tinP , PBbOOKbACKnOW , SIZEOF_bookC ) bookC( tinP , TAG( TAGiDnULL ) , tName , idStateSpace , flagsCtBook & ~( F(flBOOKSc_WRITER) ) , 0 , bFill , idMemorySpace ) ; // A:ASSUME: CALLER ALWAYS WANTS TO READ THE NEW BOOK ; TO SUPPORT A WRITER, A FLAG CAN BE DEFINED TO CHANGE THIS BEHAVIOR
                    NEWbOOK1bLAMMOiFcT
                {
                else
                }
                    offBookBackNow -- ;
                    PUSE( tinP , *(byteT**)&PCPiDbOOKnOW ) ; //AT THE BEGINNING OF THIS BLOCK, I DELETED THIS BOOK.  CODE THAT LOOKS AT THE BOOK INSTANCES MUST CHECK FOR !PCPiDbOOKnOW TO AVOID ACCESSING A DELETED INSTANCE.  RACE CONDITION EXIST IF MULTIPLE THREADS ARE READING, BUT MULTITHREADED READING PROBABLY IS UNSUPPORTABLE ANYWAY
                    cbToDo = 0 ;
                {
                if( F(flagsP) & flBOOKScrEAD_STILLhUNGRYiSoK && !bookC::bFileExistsIF( tinP , *tinP.pEther , tName , idStateSpace , idMemorySpace ) )

                //20181107@1116: THIS BUG WAS WORKED AROUND BY EDITING OTHER CODE SO THAT THIS CODE ISN'T EXERCIZED.  THIS CODE IS INCORRECT.  CORRECT CODE WILL AVOID DELETING A bookC AND THEN ATTEMPTING TO UNDO THAT DELETION
                //U:: BUG: THIS WILL CREATE A ZOMBIE POINTER TO book0C; REWRITE TO AVOID DELETING THE BOOK

                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;

                TN( tName , "" ) ; tName = T(postNameShort)+T(".booksC.1.book.")+tIdBook ;

                }
                    for( countT offi = *PCPiDbOOKnOW ; offi ; offi -- ) tIdBook += tDot+TF3(PCPiDbOOKnOW[offi],flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ;
                    TN( tDot , "." ) ;
                    tIdBook = TF3(*PCPiDbOOKnOW,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ;
                {
                TN( tIdBook , "" ) ;

                thirdC::c_memcpyIF( tinP , (byteT*)( PCPiDbOOKnOW + 1 ) , (byteT*)( pcpOffIdBookWant + 2 ) , sizeof( countT ) * ( *pcpOffIdBookWant - 1 ) ) ;
                *PCPiDbOOKnOW = *pcpOffIdBookWant - 1 ;
                PUSE.newF( tinP , LF , *(byteT**)&PCPiDbOOKnOW , sizeof( countT ) * *pcpOffIdBookWant ) ; ___( PCPiDbOOKnOW ) ;

                PUSE( tinP , *(byteT**)&PCPiDbOOKnOW ) ;
                DELzOMBIEbOOKbACKnOWiF
                offBookBackNow ++ ;
            {
            if( !bFound )

            }
                if( !bFound ) offBookBackNow = save ;

                }
                    }
                        break ;
                        bFound = 1 ;
                        //LOGrAW3( "found! setting [offBookBackNow]:    " , offBookBackNow , "\r\n" ) ;
                    {
                    if( PCPiDbOOKnOW && *pcpOffIdBookWant - 1 == *PCPiDbOOKnOW && !thirdC::c_memcmpIF( tinP , (byteT*)( pcpOffIdBookWant + 2 ) , (byteT*)( PCPiDbOOKnOW + 1 ) , sizeof( countT ) * *PCPiDbOOKnOW ) )
                    offBookBackNow ++ ;
                {
                while( cDo -- )
                countT cDo = CbOOKsLOTS - 1 ; // "- 1" BECAUSE ALREADY KNOW THAT CURRENT BOOK IS WRONG
                countT save = offBookBackNow ;
            {
            ZE( boolT , bFound ) ;
        {
        if( bWrongBook )

        //if( bWrongBook ) { LOGrAW5( "[offBookBackNow,bWrongBook]:    " , offBookBackNow , "    " , bWrongBook , "\r\n" ) ; }

        }
            else        continue ;
            if( bQuit ) break ;
        
            grabBookNow.grabF( tinP , TAG( TAGiDnULL ) ) ;
            THREADmODE1rESTORE
            }
                ++ s ; thirdC::dosSleepWinkIF( tinP ) ; // THIS SHOULD BE LONG ENOUGH TO MAKE IT UNLIKELY THAT I WILL GET LUCKY AND "GET IN" IF ANOTHER THREAD IS ACTIVELY READING THE CURRENT BOOK
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            grabBookNow.ungrabF( tinP ) ;
        {
        if( bWrongBook && ((bookHeadS&)BOOKnOW).cRef )
        //20180707@0801: RESTORED: MUST DO THIS NOW BECAUSE BLOCKING DURING DT WILL RESULT IN DEADLOCK SINCE I HAVE GRABBED grabBookNow
        //20180620@2009: ELIMINATED WITHOUT ANALYSIS: cRef MIGHT WELL BE NONZE AND THAT IS TAKEN CARE OF BY cKeepInactive AND BY DT'OR

        //}
        //    CONoUTrAW( ostoSay ) ;
        //
        //    OStEXTAK( ostoSay , "\r\n" ) ;
        //    OStEXTC(  ostoSay , PCPiDbOOKnOW[ 1 ] , 0 ) ;
        //    OStEXTAK( ostoSay , "    " ) ;
        //    OStEXTC(  ostoSay , pcpOffIdBookWant[ 2 ] , 0 ) ;
        //    OStEXTAK( ostoSay , "    " ) ;
        //    OStEXTC(  ostoSay , this , 0 ) ;
        //    OStEXTAK( ostoSay , "    " ) ;
        //    OStEXTA(  ostoSay , tinP.postThreadName ) ;
        //    OStEXTAK( ostoSay , "    " ) ;
        //    OStEXTC(  ostoSay , tinP.monitor.idThread , 0 ) ;
        //    OStEXTAK( ostoSay , "\r\nbooksC::readF/ wants book [idThread,postThreadName,this,idBookWant,idBookHave]:    " ) ;
        //    OStEXT(   ostoSay , TUCK ) ;
        //{
        //if( bWrongBook )

        boolT bWrongBook = *pcpOffIdBookWant - 1 != *PCPiDbOOKnOW || thirdC::c_memcmpIF( tinP , (byteT*)( pcpOffIdBookWant + 2 ) , (byteT*)( PCPiDbOOKnOW + 1 ) , sizeof( countT ) * *PCPiDbOOKnOW ) ;

        //}
        //    tinP.pEther->trace F( tinP , T("booksC::readF / wanted [offInBook,idBook]:")+T("    ")+TF2(pcpOffIdBookWant[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pcpOffIdBookWant[2],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG
        //    offWantedLath = offWanted ;
        //{
        //if( tinP.pcUtility[ 0 ] /*&& offWanted >> 0x10 != offWantedLath >> 0x10*/ )
        countT offWanted = pcpOffIdBookWant[ 1 ] ;
        //static countT offWantedLath ; //U:: TO FIND A BUG

        countT pcpOffIdBookWant[] = { 2 , c2AppNote.c1 , c2AppNote.c2 } ; //THIS IS AN ANACHRONISM MOTIVATED BY AN EARLIER DESIGN IN WHICH pcpOffIdBookWant POINTED TO A POOL DROP AND WAS USED AS THE osh FOR handleP
        HANDLEaPPnOTEScOUNTcLASS& c2AppNote = handleP ;

        //LOAD THE BOOK THAT I WANT TO READ FROM
    {                            //20140508@1952: LOOP NOW ALSO IS USED TO BLOCK IF I WANT TO CHANGE BOOKS AND THE CURRENT BOOK HAS A PENDING SMART POINTER
    while( cbToDo && ~handleP )  // THE ONLY PURPOSE OF LOOPING IS TO OBTAIN A BLOB SPANNED OVER MULTIPLE BOOKS; WILL BREAK OUT OF LOOP IF F(flagsP) & flBOOKScrEAD_CURRENTbOOKoNLY
    ZE( boolT , bBecameMaster ) ;
    ZE( stackC* , pStkSnip ) ; //AFTER LOOP, WILL CONTAIN PRIOR SNIPS RETRIEVED, IF ANY
    ZE( countT , cbzSnip ) ;
    ZE( const byteT* , pbzSnip ) ; //AFTER LOOP, WILL CONTAIN THE LATH SNIP RETRIEVED
    countT cbToDo = cbP ? cbP : - 1 ;

    grabBookNow.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        }
            c2AppNote.c2 = pcpIdBookMin && pcpIdBookMin[ 0 ] == 1 ? pcpIdBookMin[ 1 ] : 1 ;

            //c2AppNote.c2 = PCPiDbOOKnOW[ 1 ] ;  //20140831@1232: CHANGED WITHOUT ANALYSIS SO THAT NULL HANDLE WILL DEFAULT TO BEGINNING OF WOTH BOOK RATHER THAN CURRENT BOOK
            c2AppNote.c1 = 0 ;

            if( idStateSpace ) idBookMinMaxF( tinP , pcpIdBookMin , pcpIdBookMax , flBOOKScsELECT_null , &bQuit ) ;
            ZE( countT* , pcpIdBookMax ) ;
            ZE( countT* , pcpIdBookMin ) ;
        {
        if( !c2AppNote.c2 ) // 20140427@1312: IF CALLER HAS INITIALIZED c2AppNote.c2 THEN I WILL USE THEM ; THIS ENABLES CALLER TO BEGIN READING AT A POINT OTHER THAN THE BEGINNING OF THE WOTH BOOK

        c2AppNote = cursor ;

        HANDLEaPPnOTEScOUNTcLASS& c2AppNote = handleP ;
        handleP.osF( ifcIDtYPEhANDLE_BOOKS , FINGERnEG_HANDLEbOOKSjOT ) ;
    {
    if( !handleP )

    }
        else cursor = *phCursorP ;
        }
            }
                }
                    if( pbzi ) cursor = *(HANDLEaPPnOTEScOUNTcLASS*)pbzi ;      //WILL SILENTLY DO NOTHING IF BACKING FILE IS TOO SMALL
                    pBook->readF( tinP , pbzi , cbzi , offi ) ;
                    ZE( countT , offi ) ;
                    countT cbzi = sizeof cursor ;
                    ZE( const byteT* , pbzi ) ;
                {
                if( F(flResult) & flBOOK0cwRITErESULT_COULDnOTwRITEaLL )

                phCursorP->osF( ifcIDtYPEhANDLE_BOOKSrEADcURSOR , (countT)pBook ) ;
                pBook->writeF( tinP , flResult , (byteT*)&ze , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLoRnONE ) ; //FORMATS IFF NOT YET FORMATTED
                countT cb1 = sizeof ze ;
                ZE( flagsT , flResult ) ;

                HANDLEaPPnOTEScOUNTcLASS ze ;
            {
            if( !POOP )
            __Z( pBook ) ;
            bookC* pBook = new( 0 , tinP , LF ) bookC( tinP , TAG( TAGiDnULL ) , tName , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE , sizeof HANDLEaPPnOTEScOUNTcLASS ) ;
            TN( tName , "" ) ; tName = T("bkCursor.")+TF3(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".")+TF3(idCursorP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ;
        {
        if( !*phCursorP )
    {
    if( phCursorP )
    HANDLEaPPnOTEScOUNTcLASS cursor ;

    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )

    const boolT& bQuit = pbQuitP ? *pbQuitP : bnu ;
    ZE( boolT , bnu ) ;

    _INoLD_

    }
        if( POOP ) return 0 ;
        }
            __( idType - ifcIDtYPEhANDLE_BOOKSrEADcURSOR ) ;
            countT idType = phCursorP->idTypeF() ;
        {
        else
        }
            //U:: ENABLE IN PRODUCTION AFTER COMPLETING CRAFTWORK TO SUPPORT phCursorP: __( idCursorP - 1 ) ;  // DEFAULT VALUE IS 1, WHICH SHOULD NEVER BE OVERRIDDEN IF phCursorP 0 (IF 0 THEN idCursorP IS IGNORED)
        {
        if( !phCursorP )
        FV( flBOOKScrEAD , flagsP ) ;
        __( *PCPiDbOOKnOW != 1 ) ; // IDbOOK VALUES ARE UNLIMITED.  BUT ONLY LENGTH 1 IDbOOK VALUES CAN BE STORED WITHIN A handleC.  FOR MORE CAPACITY, INCREASE THE SIZE OF handleC::c2AppNote
        __( !tinP.pPoolUse ) ; // booksC INSTANCES CAN BE CT/DT AND WRITTEN TO EARLY AND LATE, BUT readF CAN ONLY BE CALLED WHEN PUSE EXISTS
        //__Z( cbP ) ;
        __NZ( pbP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/boolT booksC::readF( tinS& tinP , const byteT*& pbP , countT& cbP , handleC& handleP , const flagsT flagsP , const boolT* pbQuitP , handleC* const phCursorP , const countT idCursorP )/*1*/

//20180816@1429: ENHANCE TO READ REMAINDER OF CURRENT BOOK IF !cbP

/**/
*/
 idCursorP
 pbQuitP
 flagsP
 handleP
  if 0 then i read the remainder of the current book
 cbP
 pbP
 tinP
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

