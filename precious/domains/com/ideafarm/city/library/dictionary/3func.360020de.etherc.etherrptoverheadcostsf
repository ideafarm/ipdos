
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
#endif

    for( countT ids = 2 ; ids <= cSteps ; ids ++ ) pcP[ ids ] /= CtRIES ;

    }
        }
            delF( tinP , pcTagTime ) ;

            for( countT ids = 2 ; ids <= cSteps ; ids ++ ) pcP[ ids ] += pcTagTime[ ids ] - pcTagTime[ ids - 1 ] ;

            }
                _T 
                }
                    _T 
                    }
                        _T 
                        _T third.dosWriteStdOutIF( tinP , DDNAME ) ;
                        _T third.dosWriteStdOutIF( tinP , "\r\n-" ) ;
                    {
                    _T if( F(third.flagsWatch) & flWATCH_SAY )
                    //}
                    //    _T 
                    //    _T third.pcFunctionExits[ idFile ] ++ ;
                    //    _T ((thirdC&)third).osTimeAddF( tinP , third.pcFunctionTime1[ idFile ] , third.pcFunctionTime2[ idFile ] , time1 , time2 ) ;
                    //    _T ((thirdC&)third).osTimeSubtractF( tinP , time1 , time2 , timeIn1 , timeIn2 ) ;
                    //    _T ((thirdC&)third).osTimeNowF( tinP , time1 , time2 ) ;
                    //{
                    //_T if( F(third.flagsWatch) & flWATCH_TIME && !POOP && third.bFunctionCountersReady )
                    _T ZE( sCountT , time2 ) ;
                    _T ZE(  countT , time1 ) ;
                {
                _T if( F(third.flagsWatch) )
                }
                    _T 
                    //}
                    //    _T 
                    //    _T third.osTimeNowF( tinP , timeIn1 , timeIn2 ) ;
                    //    _T third.pcFunctionEntries[ idFile ] ++ ;
                    //{
                    //_T if( F(third.flagsWatch) & flWATCH_TIME && !POOP && third.bFunctionCountersReady )
                    }
                        _T 
                        _T third.dosWriteStdOutIF( tinP , DDNAME ) ;
                        _T third.dosWriteStdOutIF( tinP , "\r\n+" ) ;
                    {
                    _T if( F(third.flagsWatch) & flWATCH_SAY )
                {
                _T if( third.flagsWatch )
                _T ZE( sCountT , timeIn2 ) ;
                _T ZE(  countT , timeIn1 ) ;
                _T static countT idFile = processGlobal8I.source.idFileF( tinP , DDNAME ) ;
            {

            memSetF( tinP , (byteT*)pcTagTime , sizeof( countT ) * ( 1 + CAPACITY + 1 ) ) ;
            newF( tinP , LF , pcTagTime , 1 + CAPACITY + 1 ) ; ___( pcTagTime ) ; // ASSUME: LESS THAN "CAPACITY" CALLS TO _T IN THIS FUNCTION DEFINITION
            ZE( countT* , pcTagTime ) ;
            cSteps = 0 ;
        {
        while( cTries -- )
        countT cTries = CtRIES ;
    {
    ZE( countT , cSteps ) ;
    // TAKE SOME SAMPLE RUNS THROUGH THE STEPS

    memSetF( tinP , (byteT*)pcP , sizeof( countT ) * ( 1 + CAPACITY + 1 ) ) ;
    newF( tinP , LF , pcP , 1 + CAPACITY + 1 ) ; ___( pcP ) ; // ASSUME: LESS THAN "CAPACITY" CALLS TO _T IN THIS FUNCTION DEFINITION
    _IO_

    }
        if( POOP ) return ;
        __NZ( pcP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

#if defined( NEVERdEFINED )

    if( tinP.fingerprint && pcP ) ;
    BLAMMO ; //U::REDESIGN AND REWRITE THIS SUBSYSTEM
    SCOOP
{
/*1*/voidT etherC::etherRptOverheadCostsF( tinS& tinP , countT*& pcP )/*1*/

#define CtRIES 0x10
#define CAPACITY 0x80
#define _T pcTagTime[ ++ cSteps ] = thirdC::osClockIF( tinP ) ;
//#define _T pcTagTime[ ++ cSteps ] = third.osTimeTicksSinceBootIF() ;
// "_T" IS FOR "TAG" AS IN "TAG BASE IN A BASEBALL GAME"

/**/
*/
   use etherC::delF
  the caller must d elete pcP
    the cost of copying a return value to the stack for the thread (rare)
    the cost of calling "__( condition )" to validate each parameter
    the cost of evaluating (countT)third, which is done twice (only once if no parameter is validated)
    the cost of copying argument values to the stack for the thread
   there are other overhead costs associated with an etherC member function
   OUT is the standard exit overhead of an etherC member function
   _IO_ is the standard entry overhead of an etherC member function
  each countT value is the cost of one step in IN ct and then dt
   if n is the number of steps, then pcP[ n+1 ] will be ze
   pcP[ n ] will be the cost of the n-th step
   pcP[ 1 ] will be the cost of the first step
   pcP[ 0 ] will always be 0
  after evaluation, will point to a 1-indexed null terminated string of countT values
  must be 0
 pcP
 tinP
arguments
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.10300fd.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$etherRptOverheadCostsF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

