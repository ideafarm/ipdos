
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            }
                }
                    etThread.delF( tinP , postw ) ;
                    st_psttP << psttv ; psttv = 0 ;
                    strokeS* psttv = psttOldC( tinP , etThread , T(postw) ) ; ___( psttv ) ;
                    if( postw ) postw[ cbLabel ] = 0 ;
                    etThread.memCopyF( tinP , postw , pbLabel , cbLabel ) ;
                    etThread.newF( tinP , LF , postw , cbLabel + 1 ) ; ___( postw ) ;
                    ZE( osTextT* , postw ) ;
                {
                else
                if( !cbLabel ) break ;
                const osTextT* pbLabel =  pbP ; pbP += cbLabel ;
            {
            if( !POOP )

            __( pbe < pbP + cbLabel ) ;
            countT         cbLabel = *pbP ; pbP += 1 ;
        {
        else
        }
            break ;
            __1
            //TELLsYSc1( ifcIDtYPEtELLsYS_ERRORlABELiStOOlONG )
        {
        else if( *pbP & 0xc0 )
        }
            break ;
            nameF( tinP , etThread , st_psttP , pbr , pbe - pbr ) ;

            if( POOP ) break ;
            __( pbe <= pbr ) ;

            pbP += 2 ;
            const byteT* pbr = (byteT*)this + ( SWAB2( *(count01T*)pbP ) & ~0xc000 ) ;

            if( POOP ) break ;
            __( pbe < pbP + sizeof( count01T ) ) ;

            // USE THE SPECIFIED OFFSET TO OBTAIN THE VALUE OF THIS LABEL FROM ELSEWHERE IN THE MESSAGE
        {
        if( ( *pbP & 0xc0 ) == 0xc0 ) // IF pbP POINTS TO AN OFFSET RATHER THAN TO A LABEL LITERAL
    {
    for(;;)
    const byteT* const pbe = pbP + cbP ;

    _IO_

    }
        if( etThread ) return ;
        __Z( cbP ) ;
        __( pbP < (byteT*)this + sizeof( dnsMsgHeaderS ) ) ;
        __Z( pbP ) ;
        __( st_psttP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_strokeS ) ;
        if( etThread ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT dnsMsgHeaderS::nameF( tinS& tinP , etherC& etThread , stackC& st_psttP , const byteT*& pbP , const countT cbP )/*1*/

/**/
*/
 cbP
   only partially enforced
  must be within the same dns record that begins with me
  must point to the beginning of the wo'th label for a name
  must not be 0
 pbP
  must be of type ifcSTACKtYPE_PTR_strokeS
   this is not enforced, because i might be called recursively
  must be empty
 st_psttP
 etThread
 tinP
arguments
i also set pbP to the end of the data that i used
i fill st_psttP with the "labels" that comprise the name at pbP
\<A HREF=\"5.1630006.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$nameF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

