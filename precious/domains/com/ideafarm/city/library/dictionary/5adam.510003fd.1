
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    etThread.delF( tinP , pcIdName ) ;
    }
        cDone ++ ;

        }
            }
                }
                    break ;
                    __1
                    __( idCmd ) ;
                {
                default :
                }
                    break ;

                    }
                        }
                            lake.readCloseF( tinP , handle ) ;

                            if( offTarget + cbWrite <= cbo ) ppso[ off ]->readF( tinP , pbo + offTarget , cbWrite ) ;

                            ppso[ off ]->readF( tinP , (byteT*)&cbWrite , sizeof cbWrite ) ;
                            ZE( countT , cbWrite ) ;

                            ppso[ off ]->readF( tinP , (byteT*)&offTarget , sizeof offTarget ) ;
                            ZE( countT , offTarget ) ;
                        {
                        if( pbo )
                        lake.readF( tinP , pbo , cbo , handle , pcIdName , cSkip ) ;
                        ZE( countT , cSkip ) ;
                        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FISH ) ;
                        ZE( countT , cbo ) ;
                        ZE( byteT* , pbo ) ;
                    {
                    if( *pcIdName )

                    pcIdName[ ccIdName ] = 0 ;
                    ppso[ off ]->readF( tinP , (byteT*)pcIdName  , ccIdName * sizeof( countT ) ) ;
                    __( ccIdName > CCiDnAMEmAX ) ;
                    ppso[ off ]->readF( tinP , (byteT*)&ccIdName , sizeof ccIdName ) ;
                    ZE( countT , ccIdName ) ;
                {
                case idCMDlAKEsERVER_WRITE :
            {
            switch( idCmd )

            ppso[ off ]->readF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;
            ZE( countT , idCmd ) ;
        {
        else
        if( etThread ) { DEL( ppso[ off ] ) ; }

        sIn.acceptF( tinP , ppso[ off ] , idPortPeer , nnPeer , countTC() ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        DEL( ppso[ off ] ) ;

        }
            etThread.strokeF( tinP , T(post2) ) ;
            const osTextT post2[] = { 'a' + cDone % 26 , 0 } ;
        {
        off = cDone % CsLOTpSO ;
    {
    while( !etThread )
    ZE( countT , cDone ) ;
    ZE( countT , off ) ;

    lakeC lake( tinP , etThread ) ;

    etThread.newF( tinP , LF , pcIdName , CCiDnAMEmAX + 1 ) ; ___( pcIdName ) ;
    ZE( countT* , pcIdName ) ;

    etThread.memSetF( tinP , (byteT*)ppso , sizeof( ppso ) ) ;
    socketC* ppso[ CsLOTpSO ] ;

    sIn.listenF( tinP ) ;
    sIn.bindF( tinP , ifcPORToLD1lAKE ) ;
    socketC sIn( tinP , etThread , TAG( TAGiDnULL ) ) ;

    etThread.strokeF( tinP , T("IdeaFarm " "(tm) City Lake Server\r\ni give remote nodes access to the local lake\r\n\r\n") ) ;
{
else
}
    etThread.strokeF( tinP , T("Another ff30104 appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tinP , TAG( TAGiDnULL ) , T("ff30104") ) ;

TODO

#define CCiDnAMEmAX 0x10
#define CsLOTpSO 0x4

/*1*/WAKEhIDE( "city.lake.server" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

