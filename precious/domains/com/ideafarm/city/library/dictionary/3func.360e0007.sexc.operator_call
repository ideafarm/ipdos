
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            pEtRock->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
            OStEXTA(  ostoSay , pzMetaHead->postName ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , pbDataEnd , '0' ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , pbSlot , 0 ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , pbData , 0 ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , pzMetaHead->expSlots , 0 ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , pzMetaHead->expCbSlot , 0 ) ;
            OStEXTAK( ostoSay , "sexC::operator (): out of range [expCbSlot,expSlots,pbData,pbSlot,pbDataEnd]:    " ) ;
            OStEXT(   ostoSay , TUCK << 2 ) ;
        {
        if( pEtRock && pzMetaHead )
        etherC* pEtRock = &etherC::etRockIF( tinP ) ;

        _IO_
    {
    else
    }
        }
            }
                pEtRock->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
                OStEXTA(  ostoSay , pzMetaHead->postName ) ;
                OStEXTAK( ostoSay , "    " ) ;
                OStEXTC(  ostoSay , pbDataEnd , '0' ) ;
                OStEXTAK( ostoSay , "    " ) ;
                OStEXTC(  ostoSay , pbSlot , 0 ) ;
                OStEXTAK( ostoSay , "    " ) ;
                OStEXTC(  ostoSay , pbData , 0 ) ;
                OStEXTAK( ostoSay , "    " ) ;
                OStEXTC(  ostoSay , pzMetaHead->expSlots , 0 ) ;
                OStEXTAK( ostoSay , "    " ) ;
                OStEXTC(  ostoSay , pzMetaHead->expCbSlot , 0 ) ;
                OStEXTAK( ostoSay , "sexC::operator (): success! [expCbSlot,expSlots,pbData,pbSlot,pbDataEnd]:    " ) ;
                OStEXT(   ostoSay , TUCK << 2 ) ;
            {
            if( pEtRock && pzMetaHead )
            etherC* pEtRock = &etherC::etRockIF( tinP ) ;

            _IO_
        {
        if( F(tinP.flagsThreadMode3) & flTHREADmODE3_POOLdELtRYhARDERaNDtRACE )

        idLathNewDel = ifcIDsEXclATHnEWdEL_DEL ; // INTENTIONAL RACE

        tinP.cPoolDropDt ++ ;

        if( !btrAM( pbzMetaBitsOwned , offSlot ) ) { BLAMMO ; } //BLAMMO IS USED RATHER THAN __() TO AVOID NEEDING TO CALL TINSL, FOR MAX SPEED ; 20210111@2031: THIS COMMENT IS OBSOLETE SINCE I NOW HAVE tinPPPPPPPPPPPPPPPPPPPPPPPPP

        if( F(flagsCt) & fliSEXc_MAPPEDtOdISK ) thirdC::c_memsetIF( pbv , 1 << pzMetaHead->expCbSlot , 0 ) ; //TO SHRINK SIZE OF COMPRESSED DISK IMAGE; SANS tinP USED FOR MAX SPEED

        if( offSlot < pzMetaHead->cSlotsAvoidLo ) { BLAMMO ; }

        }
            thirdC::c_memsetIF( (byteT*)pDoomed , sizeof( dropNoteS ) , 0xdd ) ; //U:: TO FIND A BUG

            pDoomed->idThreadDel = tinP.monitor.idThread ;
            //thirdC::c_memsetIF( (byteT*)pDoomed , sizeof( dropNoteS ) , 0 ) ; //SANS tinP USED FOR MAX SPEED; INTENTIONALLY COMMENTED OUT SO THAT SLOTS WHICH ARE NOT CONTINUALLY REUSED CAN BE VISIBLE (SUCH CODE IS CANDIDATE FOR MIGRATION FROM poolC TO jotC)

            inc02AM( pDoomed->idDelLath ) ;

            if( !pDoomed->idLineTagged || !pDoomed->idiFileTagged ) { BLAMMO ; }
            idiFileTaggedCopy = pDoomed->idiFileTagged ;
            idLineTaggedCopy = pDoomed->idLineTagged ;

            dropNoteS* pDoomed = pzMetaNote + offSlot ;
        {
        if( pzMetaNote )
        ZE( countT , idiFileTaggedCopy ) ;
        ZE( countT , idLineTaggedCopy ) ;

        pbP = 0 ;

        }
            BLAMMOiD( 0xaabbccdd ) ;
            //tinP.pc Utility[ 0xf ] = pbSlot - pbv ;
        {
        if( pbSlot != pbv )
        byteT* pbv     = pbData + offSlot * cbGross ;
        countT offSlot = ( pbSlot - pbData ) / cbGross ;

        countT cbGross = CBsEXdROPhEADER + ( 1 << pzMetaHead->expCbSlot ) ;
        _IO_
    {
    if( pbData <= pbSlot && pbSlot < pbDataEnd )
    if( F(flagsCt) & fliSEXc_READoNLY ) { BLAMMO ; }

    const byteT* pbSlot = !pbP ? 0 : pbP - CBsEXdROPhEADER ;

    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
    _IO_
    SCOOP
{
/*1*/voidT sexC::operator ()( tinS& tinP , byteT*& pbP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

