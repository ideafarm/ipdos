
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        BLAMMO ;

        etRock.traceF( tinP , T("napkinC::napkinC: traced  pool tallies; now calling BLAMMO") ) ;
        etRock.tracePoolTalliesF( tinP ) ;
        etRock.traceF( tinP , T("napkinC::napkinC: tracing pool tallies") ) ;
        etRock.traceF( tinP , T("napkinC::napkinC: could not allocate pbNapkin [idLineCtP,idiFileCtP,cbP,postP]: ")+TF2(idLineCtP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(idiFileCtP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(postP) ) ;

        etherC& etRock = etherC::etRockIF( tinP ) ;
    {
    if( POOP || !pbNapkin )

    }
        TELLc3LIFI( ifcIDtYPEtELL_NAPKINaTTACH , (byteT*)&ti , sizeof ti , idLineCt , idiFileCt )
        ti.idiFileCt = idiFileCt ;
        ti.idLineCt  = idLineCt ;
        ti.cbData    = ((napkinHeaderS*)pbNapkin)->cbData ;
        ti.pbData    = pbNapkin + sizeof( napkinHeaderS ) ;    // IF flNAPKINc_DOnOTcOMMIT THEN MONITOR WILL DISCOVER THE HARD WAY THAT IT CANNOT READ THIS MEMORY
        ti.costName  = thirdC::c_strlenIF( tinP , ti.postName ) ;
        thirdC::c_strncpyIF( tinP , ti.postName , postName , sizeof ti.postName ) ;
        ti.osPid     = tinP.osPid ;
        tellInfoNapkinS ti ;
    {
    if( pbNapkin && F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED && this != &processGlobal3I.napHome ) //ASSUME: napHome IS CT WOTH
    
    }
        else if( *this != sizeof( countT ) * ( 4 + CCwORD ) ) { BLAMMO ; }
        }
            formattingIsDoneF( tinP ) ;
            //pch[ 4 ]                                      // BEGINNING OF BUFFER AREA (USED AS CIRCULAR BUFFER)
            pch[ 3 ] = CCwORD ;                             // CsLOTS (NUMBER OF WORDS CAPACITY)
            //pch[ 2 ]                                      // NUMBER OF WORDS WRITTEN (MIGHT WRAP)
            //pch[ 1 ]                                      // idThreadOwner (WILL BE SET BY THE CLAIMANT THREAD)
            putNegAM( pch[ 0 ] , FINGERnEG_NAPwORD ) ;      // FINGERPRINT
            thirdC::c_memsetIF( tinP , (byteT*)pch , *this ) ;
            //LOGrAW5( "formatting data area of word napkin that contains " , *this , " bytes (memory space " , rootAdamGlobal1I.idMemorySpace , ")\r\n" )
        {
        else if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
        if( !pch ) { BLAMMO ; }
        countT* pch = (countT*)(byteT*)*this ;
    {
    else if( bWord )
    }
        if( bNew ) processGlobal7I._socketC_napIpMapHome.formattingIsDoneF( tinP ) ;

        }
            }
                //LOGrAW( ostoLog ) ;
                //
                //OStEXTAK( ostoLog , " will be mapped to ports selected at run time rather than specified in code\r\n" ) ;
                //OStEXTC( ostoLog , etherC::ifc_idHomeIdisk_IF() , 0 ) ;
                //OStEXTAK( ostoLog , "/napkinC: home " ) ;
                //OStEXTC( ostoLog , tinP.pAdamGlobal1->idAdam , 0 ) ;
                //OStEXT( ostoLog , TUCK << 2 ) ;

                pMap->nnHome = nnHome ;
                thirdC::c_strncpyIF( tinP , pMap->postMxName     , postzMx     , sizeof pMap->postMxName     ) ;
                thirdC::c_strncpyIF( tinP , pMap->postDomainName , postzDomain , sizeof pMap->postDomainName ) ;
            {
            else
            }
                //LOGrAW5( "" , tinP.pAdamGlobal1->idAdam , "/napkinC: no mapping for home  " , etherC::ifc_idHomeIdisk_IF() , "\r\n" ) ;
                pMap->flagsHome |= flIPmAPhOMEs_NOmAPPING ;
            {
            if( !nnHome )

            }
                }
                    }
                        off += thirdC::c_strlenIF( tinP , posti + off ) + 1 ;
    
                        else      nnHome = thirdC::c_atoiIF( tinP , posti + off ) ; //U::SUPPORT IPv6
                        if( ppo ) *ppo = posti + off ;
    
                        else if( !postzMx     ) ppo = &postzMx     ;
                             if( !postzDomain ) ppo = &postzDomain ;
                        ZE( osTextT** , ppo ) ;
    
                        if( !posti[ off ] ) continue ;
                    {
                    for( countT off = 0 ; off < costi ; off ++ )
    
                    }}
                        if( thirdC::c_strchrIF( tinP , TbLACK , posti[ off ] ) ) posti[ off ] = 0 ;
                    {
                    {for( countT off = 0 ; off < costi ; off ++ )
                {
                if( costi )
    
                }
                    }
                        costi = 0 ;
                        POOPR ;
                    {
                    if( POOP )
                    THREADmODE1rESTORE
                    thirdC::dosReadIF( tinP , posti , costi , ostoName ) ;
                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                    POOPIE
                {
                countT  costi = sizeof( posti ) ;
    
                OStEXTAK( ostoName , ".setting.keyValue.ipmap" ) ;
                OStEXTC(  ostoName , etherC::ifc_idHomeIdisk_IF() , 0 ) ;
                OStEXTAK( ostoName , "c" ":\\ideafarm.home." ) ;
                OStEXT(   ostoName , TUCK << 2 ) ;
            {
            nicNameC nnHome ;
            ZE( osTextT* , postzMx ) ;
            ZE( osTextT* , postzDomain ) ;
            osTextT posti[ TUCK ] ;
        {
        if( pMap && !pMap->nnHome && !( F(pMap->flagsHome) & flIPmAPhOMEs_NOmAPPING ) )

        }
            if( offm < CiPmAPhOME ) pMap = pMapArray + offm ;

            }
                }
                    if( !setIfZeAM( pMapArray[ offm ].idHome , etherC::ifc_idHomeIdisk_IF() ) ) break ;
                {
                for( offm = 0 ; offm < CiPmAPhOME ; offm ++ )
            {
            if( offm == CiPmAPhOME )

            }
                if( pMapArray[ offm ].idHome == etherC::ifc_idHomeIdisk_IF() ) break ;
            {
            for( offm = 0 ; offm < CiPmAPhOME ; offm ++ )
            ZE( countT , offm ) ;
    
            ipMapHomeS* const pMapArray = (ipMapHomeS*)(byteT*)processGlobal7I._socketC_napIpMapHome ;
        {
        else
        }
            }
                }
                    break ;
                    pMap = pMapArray + offm ;
                {
                if( !setIfZeAM( pMapArray[ offm ].idHome , etherC::ifc_idHomeIdisk_IF() ) )
            {
            for( countT offm = 0 ; offm < CiPmAPhOME ; offm ++ )
        
            ipMapHomeS* const pMapArray = (ipMapHomeS*)(byteT*)processGlobal7I._socketC_napIpMapHome ;
        {
        if( bNew )
        ZE( ipMapHomeS* , pMap ) ;
                
        }
            while( cToDo -- ) new( 0 , tinP , (byteT*)( pCursor ++ ) , sizeof( ipMapHomeS ) ) ipMapHomeS( tinP ) ;
            countT cToDo = CiPmAPhOME ;
            ipMapHomeS* pCursor = (ipMapHomeS*)(byteT*)*this ;
            bNew = 1 ;
        {
        if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
        ZE( boolT , bNew ) ;
    {
    else if( this == &processGlobal7I._socketC_napIpMapHome )
    }
        }
            formattingIsDoneF( tinP ) ;
            new( 0 , tinP , (byteT*)*this , sizeof( grabotC ) ) grabotC( tinP , idLineCt , idiFileCt , pbBitsCt , flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES | flGRABITc_SHARElAYER , 0 , ifcIDgRABlAYER_8POOL5nEW ) ;
            thirdC::c_memsetIF( tinP , (byteT*)*this , (countT)*this ) ;
        {
        if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
    {
    else if( this == &processGlobal7I._sexC_napGlobalRegistry )
    }
        }
            formattingIsDoneF( tinP ) ;
            thirdC::c_memsetIF( tinP , (byteT*)*this , (countT)*this ) ;
        {
        if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
    {
    else if( this == &processGlobal4I._marketC_napGoodRegistry )
    }

        ph->grabSuperRandom.flags &= ~( F(flGRABc_DISABLED) ) ;
        ph->grabTimeUnique.flags  &= ~( F(flGRABc_DISABLED) ) ;
        homeS* ph = (homeS*)(byteT*)processGlobal3I.napHome ;

        }
            formattingIsDoneF( tinP ) ;
            for( countT ogw = 0 ; ogw < processGlobal1I._grabC_cgw ; ogw ++ ) new( 0 , tinP , (byteT*)( processGlobal1I._grabC_pgw + ogw ) , sizeof( grabWantS ) ) grabWantS( tinP ) ;
            thirdC::c_memsetIF( tinP , (byteT*)processGlobal1I._grabC_pgw , *this ) ;
        {
        if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
    
        processGlobal3I.bksWords.grabBookNow.formatF(         tinP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER                      , TAG( TAGiDnULL ) , ifcIDgRABlAYER_9BOOKSc ) ; // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
        processGlobal3I.bksWord.grabBookNow.formatF(          tinP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER                      , TAG( TAGiDnULL ) , ifcIDgRABlAYER_9BOOKSc ) ; // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
        processGlobal3I.bksTraceDivert08.grabBookNow.formatF( tinP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER                      , TAG( TAGiDnULL ) , ifcIDgRABlAYER_9BOOKSc ) ; // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
        processGlobal3I.bksTraceDivert07.grabBookNow.formatF( tinP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER                      , TAG( TAGiDnULL ) , ifcIDgRABlAYER_9BOOKSc ) ; // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
        processGlobal3I.bksTraceDivert06.grabBookNow.formatF( tinP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER                      , TAG( TAGiDnULL ) , ifcIDgRABlAYER_9BOOKSc ) ; // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
        processGlobal3I.bksTraceDivert05.grabBookNow.formatF( tinP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER                      , TAG( TAGiDnULL ) , ifcIDgRABlAYER_9BOOKSc ) ; // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
        processGlobal3I.bksTraceDivert04.grabBookNow.formatF( tinP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER                      , TAG( TAGiDnULL ) , ifcIDgRABlAYER_9BOOKSc ) ; // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
        processGlobal3I.bksTraceDivert03.grabBookNow.formatF( tinP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER                      , TAG( TAGiDnULL ) , ifcIDgRABlAYER_9BOOKSc ) ; // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
        processGlobal3I.bksTraceDivert02.grabBookNow.formatF( tinP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER                      , TAG( TAGiDnULL ) , ifcIDgRABlAYER_9BOOKSc ) ; // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
        processGlobal3I.bksTraceDivert01.grabBookNow.formatF( tinP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER                      , TAG( TAGiDnULL ) , ifcIDgRABlAYER_9BOOKSc ) ; // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
        processGlobal3I.bksTrace.grabBookNow.formatF(         tinP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER | flGRABc_SHARElAYER , TAG( TAGiDnULL ) , ifcIDgRABlAYER_9BOOKSc ) ; // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
        processGlobal3I.bksTelemetry.grabBookNow.formatF(     tinP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER | flGRABc_SHARElAYER , TAG( TAGiDnULL ) , ifcIDgRABlAYER_9BOOKSc ) ; //20170820@1239: MOVED OUT OF IF BLOCK WITHOUT ANALYSIS (IF AND ELSE DIFFERED IN THAT IF SPECIFIED LAYER WHILE ELSE DID NOT)
        //CS:CODEsYNC: 360fb003 3603e003

        //20200610@2149: "not jealous" MIGHT NO LONGER BE NEEDED ON SOME OF THE FOLLOWING, NOW THAT heapC::grabMe HAS BEEN MADE A SNEAKY LOVER

        //20200520@1322: bksTrace.grabBookNow: ADDED flGRABc_NOTjEALOUS BECAUSE OBSERVED A THREAD HOLDING grabBookNow WHILE IN booksC::writeF AND THEN ATTEMPTING TO GRAB *pSwsRecycle WHILE CALLING GETfROMrECYCLER5 WITHIN TASKdRIVENsERVER

        // 20161110@1730: bksTrace MADE "SNEAKY" IN ORDER TO AVOID FAILURE DURING inOutFrameC TRACING
        // bksWord AND bksWords MUST THEREFORE BE WELL BEHAVED
        // bksWord AND bksWords ALSO ARE "SNEAKY" (DO NOT TRIGGER JEALOUSY).  THIS IS SO THAT WORD TRACING CAN BE SPRINKLED EVERYWHERE TO DEBUG AND TUNE, WITHOUT WORRYING ABOUT JEALOUS REACTIONS
        // bksTelemetry MUST BE SNEAKY SO THAT APPLICATION CODE NEED NOT WORRY ABOUT TRIGGERING THE EMISSION OF TELEMETRY
        // SNEAKY LOVERS:

        if( setIfZeAM( *(countT*)&processGlobal1I._grabC_pgw , (countT)(byteT*)*this ) ) { BLAMMO ; }
        if( processGlobal1I._grabC_cgw * sizeof( grabWantS ) - cbP ) { BLAMMO ; }
    {
    else if( this == &processGlobal3I._grabC_napGrabWant )
    }
        processGlobal1I.flCt |= flCTdTg_napSlabI ;

        else if( *this != sizeof( slabS ) ) { BLAMMO ; }
        }
            formattingIsDoneF( tinP ) ;
            new( 0 , tinP , (byteT*)*this , sizeof( slabS ) ) slabS ;
        {
        else if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
        if( !ps ) { CONoUTrAW( "napkinC::napkinC/napSlab/ps is null\r\n" ) ; BLAMMO ; }
        slabS* ps = (slabS*)(byteT*)*this ;
    {
    else if( this == &processGlobal3I.napSlab )
    }
        //CONoUTrAW( ostol ) ;
        //OStEXTAK( ostol , "\r\n" )
        //OStEXTC( ostol , rootAdamGlobal1I.idMemorySpace , 0 )
        //OStEXTAK( ostol , " idMemorySpace: " )
        //OStEXT( ostol , 0x80 )

        processGlobal1I.flCt |= flCTdTg_napHomeI ;

        }
            }
                new( 0 , tinP , (byteT*)&processGlobal4I.bUniverse , sizeof processGlobal4I.bUniverse ) batonC( tinP , TAG( TAGiDnULL ) , "bUniverse" , ifcIDgRABlAYER_aGRABuNIVERSEc | flBATONc_NOTjEALOUS , flBATONc_DOnOTsERIALIZEnAPKIN ) ;
                DELzOMBIE( pbu ) ;
                batonC* pbu = &processGlobal4I.bUniverse ;
            {
            if( !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT ) )

            new( 0 , tinP , (byteT*)&processGlobal3I.grabUniverse , sizeof processGlobal3I.grabUniverse ) grabUniverseC( tinP , ifcIDgRABlAYER_aGRABuNIVERSEc ) ;
            DELzOMBIE( pgu ) ;
            grabUniverseC* pgu = &processGlobal3I.grabUniverse ;
        {
        if( bMemorySpaceChanged )

        //CONoUTrAW5( "napkinC::napkinC/napHome/[idCell,idMemorySpace]: " , rootAdamGlobal1I.idCell , " " , rootAdamGlobal1I.idMemorySpace , "\r\n" ) ;

        }
            }
                break ;
                //conGF( "memory space changed\r\n" ) ;
                bMemorySpaceChanged = 1 ;
                *(countT*)&tinP.pAdamGlobal1->idMemorySpace = ifcIDmEMORYsPACE_WATCH ;
            {
            case ifcIDaDAM_PREPARElISTS : //THIS LINE FACILITATES DEBUGGING AND HAS NO EFFECT IN PRODUCTION
            case ifcIDaDAM_WATCHiDLEcPU :
            case ifcIDaDAM_WATCH :
            }
                break ;
                //conGF( "memory space changed\r\n" ) ;
                bMemorySpaceChanged = 1 ;
                *(countT*)&tinP.pAdamGlobal1->idMemorySpace = ifcIDmEMORYsPACE_MEMBRANE ; //ifcIDmEMORYsPACE_MEMBRANE IS WRITTEN BY KERNEL AND READ BY ifcIDaDAM_MEMBRANEgLASS; NO OTHER PROCESS MAY ACCESS THE MEMBRANE SPACE
            {
            case ifcIDaDAM_MEMBRANEgLASS :
            case 0x4010fff : //U::REMOVE IN PRODUCTION
            }
                break ;
                //conGF( "memory space changed\r\n" ) ;
                bMemorySpaceChanged = 1 ;
                *(countT*)&tinP.pAdamGlobal1->idMemorySpace = ifcIDmEMORYsPACE_KERNEL ; //ifcIDmEMORYsPACE_KERNEL IS RESERVED FOR THE EXCLUSIVE USE OF THE DRIVER/MONITOR
            {
            case ifcIDaDAM_KERNEL2MONITOR :
            case ifcIDaDAM_KERNEL1DRIVER :
            }
                break ;
                //conGF( "memory space changed\r\n" ) ;
                bMemorySpaceChanged = 1 ;
                *(countT*)&tinP.pAdamGlobal1->idMemorySpace = ifcIDmEMORYsPACE_CLOAK ; //ifcIDmEMORYsPACE_CLOAK IS RESERVED FOR THE EXCLUSIVE USE OF ifcIDaDAM_CLOAK (ANTI-MALWARE SYSTEM INTEGRITY CHECKER)
            {
            case ifcIDaDAM_CLOAK :
        {
        switch( processGlobal1I.idAdamRoot )
        ZE( boolT , bMemorySpaceChanged ) ;

        //conGF( "\r\n" ) ;
        //conGF( processGlobal1I.idAdamRoot ) ;
        //conGF( "napkinC [idAdamRoot]: " ) ;

        //}
        //    thirdC::osSelectProcessorsIF( tinP , idType ) ;
        //    ;
        //            : ifcIDtYPEtHREAD_SHOWpONY
        //            ? ifcIDtYPEtHREAD_KERNEL
        //        : rootAdamGlobal1I.idCell < 3
        //        ? ifcIDtYPEtHREAD_WORKhORSE
        //    countT idType = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS || etherC::ifc_idHomeIdisk_IF() < 0x100
        //{
        //20170213@1454: COMMENTED OUT WITHOUT ANALYSIS TO PERHAPS FIX UNEXPECTED PROCESSOR AFFINITY FOR KERNEL1_MONITOR ADAM

        *(countT*)&rootAdamGlobal1I.idCell = 1 + incv02AM( ph->idCellLath ) ;
    
        else if( *this != sizeof( homeS ) ) { BLAMMO ; }
        }
            formattingIsDoneF( tinP ) ;
            new( 0 , tinP , (byteT*)*this , sizeof( homeS ) ) homeS( tinP ) ;
        {
        else if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
        if( !ph ) { CONoUTrAW( "napkinC::napkinC/napHome/ph is null\r\n" ) ; BLAMMO ; }
        homeS* ph = (homeS*)(byteT*)*this ;
    {
    if( this == &processGlobal3I.napHome )

    }
        }
            thirdC::dosPriorityIF( tinP , idDesireCtSave ) ;
            tinP.cYield = 0 ;
    
            THREADmODE3oFF( flTHREADmODE3_SUPPRESStRACING )

            }
                }
                    ++ s ; thirdC::dosSleepWinkIF( tinP ) ;
                {
                while( getNegAM( ((napkinHeaderS*)pbNapkin)->bFormatted ) != FINGERnEG_NAPKINiSfORMATTED )
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            else
            if( !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT ) ) pzbUniverseUse->ungrabF( tinP ) ;

            }
                inc02AM( ((napkinHeaderS*)pbNapkin)->cRef ) ;

                if( (sCountT)((napkinHeaderS*)pbNapkin)->cRef < 0 ) { BLAMMO ; } //IT MIGHT BE 0, BUT IT SURE AS HELL BETTER NOT BE NEGATIVE!

                //if( !((napkinHeaderS*)pbNapkin)->cRef       ) { BLAMMO ; }
                //CANNOT TEST FOR THIS BECAUSE RACE; ANOTHER THREAD MIGHT HAVE JUST DEC BUT NOT YET CLOSED HANDLE: 
            {
            if( !( F(flagsCt) & flNAPKINc_DOnOTcOMMIT ) )
        {
        else
        }
            }
                THREADmODE3oFF( flTHREADmODE3_SUPPRESStRACING )
                if( !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT ) ) pzbUniverseUse->ungrabF( tinP ) ;           //U::BUG: napGuts IS FULLY CT WITHOUT EVER UNGRABBING THIS
            {
            else
            }
                ((napkinHeaderS*)pbNapkin)->bFormatted = 0   ;
                ((napkinHeaderS*)pbNapkin)->cRef       = 1   ;
                ((napkinHeaderS*)pbNapkin)->cbData     = cbP ;
            {
            if( !( F(flagsCt) & flNAPKINc_DOnOTcOMMIT ) )
        {
        if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
        //CS:CODEsYNC: 3603e003 3603e007

        bDataAreaFormatted = 0 ;
    {
    else
    }
        thirdC::dosPriorityIF( tinP , idDesireCtSave ) ;
        tinP.cYield = 0 ;

        THREADmODE3oFF( flTHREADmODE3_SUPPRESStRACING )
        if( !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT ) ) pzbUniverseUse->ungrabF( tinP ) ;

        bDataAreaFormatted = 0 ;
    {
    else if( !pbNapkin )
    if( POOP ) BLAMMO
    
    }
        if( bNoQuit ) { __Z( pbNapkin ) ; }
    
        }
            BLAMMO
            //DOES NOT WORK:LOGrAW3( "napkinC::napkinC: blammo [cbP]: " , cbP , "\r\n" ) ;
        {
        if( POOP )

        }
            BLAMMO ; // I DO THIS TO FORCE THE FUNCTIONS THAT I CALL TO DELIVER A SENSIBLE RESULT
        {
        if( bFail && pbNapkin )
    
        }
            THREADmODE1rESTORE ;
            bFail = !!POOP ;
            }
                }
                    else break ;
                    }
                        //BLAMMO ; //U:: TO FIND A BUG 20171201@1438

                        thirdC::dosSleepRWinkIF( tinP ) ;

                        tinP.pEther->tracePoolTalliesF( tinP ) ;

                        tinP.pEther->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;

                        OStEXTC(  ostoSay , cTriesP , 0 ) ;
                        OStEXTAK( ostoSay , "    " ) ;
                        OStEXTC(  ostoSay , cbData , 0 ) ;
                        OStEXTAK( ostoSay , "napkinC::napkinC / tracing pool tallies and then napping for a wink [cbData,cTries]:    " ) ;
                        OStEXT(   ostoSay , TUCK << 2 ) ;

                        THREADmODE3oFF( flTHREADmODE3_SUPPRESStRACING )
                        if( !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT ) ) pzbUniverseUse->ungrabF( tinP ) ;

                        POOPR
                        ++ s ;
                    {
                    )
                        )
                            )
                                -- cTriesP
                                &&
                                cTriesP
                            (
                            ||
                            )
                                !thirdC::thPrimeIF( tinP )
                                &&
                                thirdC::thPrimeExistsIF( tinP )                      // thPrimeExistsIF( tinP ) IS CHECKED BECAUSE IT WILL BE 0 WHEN I AM CALLED TO CONSTRUCT poolOldRoot AND poolOld (AFTER poolC IS EDITED TO USE napkinC)
                                &&
                                bNoQuitEarly
                            (
                            ||
                            bNoQuit
                        (
                        &&
                        POOP
                    (
                    if

                    }
                        if( cNote ) pbNapkin = (byteT*)cNote + cbaHeader - sizeof( napkinHeaderS ) ;
                        countT cNote = hNapkin.cNoteF() ;
                    {
                    if( !POOP )

                    }
                        BLAMMO ;
                    {
                    if( POOP && ~hNapkin )

                    thirdC::dosOpenSharedMemIF( tinP , hNapkin , (flagsT&)flagsSharedMemory , postName , phFileP , cbP ? cbaHeader + cbP : 0 , idHowP , idMemorySpaceP , flagsOpen | flOPENsHAREDmEMORY_DOnOTsERIALIZE ) ;

                    if( !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT ) ) pzbUniverseUse->grabF( tinP , TAG( TAGiDnULL ) ) ;
                    THREADmODE3oN( flTHREADmODE3_SUPPRESStRACING )

                    //CONoUTrAW( ostoSay ) ;
                    ////processGlobal3S::_processGlobal3I_IF().bksTrace.writeF( tinP , ostoSay , thirdC::c_strlenIF( tinP , ostoSay ) , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                    //OStEXTC(  ostoSay , cbP+cbaHeader , 0 ) ;
                    //OStEXTAK( ostoSay , "    " ) ;
                    //OStEXTC(  ostoSay , cbaHeader , 0 ) ;
                    //OStEXTAK( ostoSay , "    " ) ;
                    //OStEXTC(  ostoSay , cbP , 0 ) ;
                    //OStEXTAK( ostoSay , "\r\nnapkinC::napkinC [cbData,cbHeader,cbAlloc]:    " ) ;
                    //OStEXT(   ostoSay , TUCK << 2 ) ;
                {
                for(;;)
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            POOPIE
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;
        {
        ZE( boolT , bFail ) ;
        boolT bNoQuitEarly = !cTriesP ;
        boolT bNoQuit = cTriesP == - 1 ;
    {

    thirdC::c_strncpyIF( tinP , postName , ostoNapkinName , sizeof postName ) ;

    ;
        : sizeof( napkinHeaderS )
        ? 1 << thirdC::os_expCbPage_IF( tinP )
    const countT cbaHeader = F(flagsCt) & flNAPKINc_PAGEaLIGNdATA

    tinP.cYield = 0 ;
    thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;

    }
        if( !POOP ) pzbUniverseUse = pbUniverseOverride ;
        __Z( pbUniverseOverride ) ;
        pbUniverseOverride = new( 0 , tinP , pbz_bUniverseOverride , sizeof pbz_bUniverseOverride ) batonC( tinP , TAG( TAGiDnULL ) , "bUniverse" , ifcIDgRABlAYER_aGRABuNIVERSEc , flBATONc_DOnOTsERIALIZEnAPKIN | flBATONc_NOTjEALOUS , 0 , 0 , idMemorySpaceP ) ;
    {
    )
        )
            F(flagsCt) & flNAPKINc_USEgRABuNIVERSEoVERRIDE
            ||
            ( idMemorySpaceP && idMemorySpaceP != tinP.pAdamGlobal1->idMemorySpace )
        (
        &&
        !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT )
    (
    if

    //}
    //    //LOGrAW( "\"\r\n" ) ;
    //    //LOGrAW( ostoNapkinName ) ;
    //{
    //if( thirdC::c_strstrIF( ostoNapkinName , "sexC/data/" ) )
        
    }
        //CONoUTrAW( "\r\n" )
        //CONoUTrAW( ostoNapkinName )
        
        //LOGrAW( "\r\n" )
        //LOGrAW( ostoNapkinName )
        
        OStEXTC( ostoNapkinName , ++ idLath , 0 ) ;
        OStEXTAK( ostoNapkinName , "." ) ;
        OStEXTC( ostoNapkinName , tinP.osPid , 0 ) ;
        OStEXTAK( ostoNapkinName , "." ) ;
        OStEXTC( ostoNapkinName , processGlobal1I.idAdamRoot , 0 ) ;
        
        static countT idLath ;
    {
    if( bWord )

    const boolT bWord = &processGlobal6I.napWord1 <= this && this <= &processGlobal6I.napWord2 ; //CODEsYNC: 15e0003 0a00001

    //}
    //    }
    //        //U::THINK ABOUT HOW BEST TO ALLOW MONITOR TO KISS GRABBERS WHO REGISTERED THEMSELVES IN OTHER SPACES
    //        idMemorySpaceP = ifcIDmEMORYsPACE_APPLICATION ;
    //    {
    //    if( idMemorySpaceP == ifcIDmEMORYsPACE_KERNEL )
    //{
    //if( this == &processGlobal3I._grabC_napGrabWant )

    //if( !idMemorySpaceP ) idMemorySpaceP = tinP.pAdamGlobal1->idMemorySpace ;
    //20200417@1855: KEEP idMemorySpaceP NULL SO THAT CALLER DOES NOT HAVE TO SET flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE

    //}
    //    cbP += sizeof( countT ) ;
    //
    //    if( !cbP ) cbP = CBdROPmEANdEFAULT ;
    //
    //    }
    //        }
    //            }
    //                }
    //                    if( off ) cbP <<= 4 ;
    //
    //                    else break ;
    //                    else if( post9[ off ] >= 'a' && post9[ off ] <= 'f' ) cbP += 0xa + post9[ off ] - 'a' ;
    //                         if( post9[ off ] >= '0' && post9[ off ] <= '9' ) cbP +=       post9[ off ] - '0' ;
    //                {
    //                for( sCountT off = cbToRead - 1 ; off >= 0 ; off -- )
    //            {
    //            if( cbToRead == 8 )
    //            thirdC::fileReadIF( tinP , post9 , cbToRead , ostoFileName ) ;
    //            thirdC::c_memsetIF( tinP , post9 , sizeof post9 ) ;
    //            osTextT post9[ 0x9 ] ;
    //            if( cbToRead > 8 ) cbToRead = 8 ;
    //        {
    //        if( !bFail )
    //
    //        }
    //            bFail = !!POOP ;
    //            tinP.flagsThreadMode1 = fSave ;
    //            cbToRead = thirdC::fileReadIF( tinP , 0 , cbRead , ostoFileName ) ;
    //            tinP.flagsThreadMode1 |= flTHREADmODE1_QUIETiMPOTENCE ;
    //            flagsT fSave = tinP.flagsThreadMode1 ;
    //            ZE( countT , cbRead ) ;
    //            POOPIE
    //        {
    //        ZE( countT , cbToRead ) ;
    //        ZE( boolT , bFail ) ;
    //    {
    //{
    //if( !cbP && !thirdC::c_strcmpIF( tinP , postP , "root" ) )
    //
    //OStEXTAK( ostoFileName , ".setting.keyValue.cbPoolRoot" ) ;
    //OStEXTC( ostoFileName , etherC::ifc_idHomeIdisk_IF() , 0 ) ;
    //OStEXTAK( ostoFileName , "c" ":\\ideafarm.home." ) ;
    //OStEXT( ostoFileName , TUCK << 2 )
    //U::CONJ: OBSOLETED BY REWRITE OF poolC

    if( F(flagsCt) & flNAPKINc_DOnOTcOMMIT     ) *(flagsT*)&flagsOpen |= flOPENsHAREDmEMORY_DOnOTcOMMIT     ;
    if( F(flagsCt) & flNAPKINc_LOCK            ) *(flagsT*)&flagsOpen |= flOPENsHAREDmEMORY_LOCK            ;
    if( F(flagsCt) & flNAPKINc_ALLmEMORYsPACES ) *(flagsT*)&flagsOpen |= flOPENsHAREDmEMORY_ALLmEMORYsPACES ;
    if( F(flagsCt) & flNAPKINc_ALLhOMES        ) *(flagsT*)&flagsOpen |= flOPENsHAREDmEMORY_ALLhOMES        ;
    if( F(flagsCt) & flNAPKINc_ALLuSERS        ) *(flagsT*)&flagsOpen |= flOPENsHAREDmEMORY_ALLuSERS        ;

    if( F(flagsCt) & flNAPKINc_PAGEaLIGNdATA ) { BLAMMO ; } //U::BUG: 20170121@1439: SOME CODE DOES NOT SUPPORT THIS BECAUSE DATA IS ASSUMED TO IMMEDIATELY FOLLOW THE HEADER

    ;
        : flOPENsHAREDmEMORY_null
        ? flOPENsHAREDmEMORY_READoNLY
    const flagsT flagsOpen = F(flagsCt) & flNAPKINc_READoNLY

    OStEXTA(  ostoNapkinName , postP ) ;
    OStEXTAK( ostoNapkinName , "//napkinC/" ) ;
    OStEXT(   ostoNapkinName , COSTnAPKINnAMEmAX )

    }
        if( POOP ) BLAMMO ;
        __( idMemorySpaceP && !( F(tinP.flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tinP ) >= ifcIDpHASEaDAM_PROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tinP ) < ifcIDpHASEaDAM_EPILOGaDAMmAINa1 ) ;
        __( F(tinP.flagsThreadMode3) & flTHREADmODE3_SUPPRESStRACING ) ;  // I USE THIS FLAG IN A WAY THAT DOES NOT SUPPORT RECURSION (I AND formattingIsDoneF RESET THE FLAG RATHER THAN USE RESTORE)
        if( POOP ) BLAMMO ; //U:: TO FIND A BUG
        FV(flNAPKINc,flagsCt)
        if( POOP ) BLAMMO ; //U:: TO FIND A BUG
        __( phFileP && F(flagsCt) & flNAPKINc_DOnOTcOMMIT ) ;
        if( POOP ) BLAMMO ; //U:: TO FIND A BUG
        __Z( idHowP ) ;
        if( POOP ) BLAMMO ; //U:: TO FIND A BUG
        __Z( postP ) ;
        if( POOP ) BLAMMO ;
    {
    IFbEcAREFUL

    //if( tinP.pc Utility[ 0 ] ) thirdC::third_pcDebugI_IF( tinP ) ; //U:: SHOULD BE COMMENTED OUT IN PRODUCTION; TO FACILITATE DEBUGGING USING WDW

    else            thirdC::c_memsetIF( tinP , (byteT*)pbBitsCt , sizeof pbBitsCt ) ;
    if( pbBitsCtP ) thirdC::c_memcpyIF( tinP , (byteT*)pbBitsCt , (byteT*)pbBitsCtP , sizeof pbBitsCt ) ;

    _IO_ // EARLY SO THAT napkinC BEHAVIOR CANNOT BE AFFECTED BY FOREIGN IMPOTENCE
    SCOOP
{
phFile( phFileP )
flagsState( F(flagsP) & flNAPKINc_DOnOTcOMMIT ? flNAPKINcsTATE_NOTyETcOMMITTED : flNAPKINcsTATE_null ) ,
idDesireCtSave( thirdC::dosPriorityIF( tinP ) ) ,
osTidCt( tinP.osTid ) ,
pzbUniverseUse( &processGlobal4I.bUniverse ) ,
pbUniverseOverride( 0 ) ,
bDataAreaFormatted( 1 ) , // SO IMPOTENCE TEST IN DESTRUCTOR WILL NOT TRIGGER IMPOTENCE
flagsSharedMemory( 0 ) ,
cbData( cbP ) ,
pbNapkin( 0 ) ,
hNapkin( tinP , idLineCtP , idiFileCtP , (byteT*)bitsC( tinP , CbITSlIFI , 0 , (countT)(0+1) ) , ifcIDtYPEhANDLE_SHAREDmEMORY ) ,
flagsCt( flagsP ) ,
idiFileCt( idiFileCtP ) ,
idLineCt( idLineCtP ) ,
/*1*/napkinC::napkinC( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postP , const handleC* const phFileP , countT cbP , const countT idHowP , const flagsT flagsP , countT cTriesP , countT idMemorySpaceP )/*1*/ :

/**/
*/
  normal apps never specify a value other than -1, 0, or 1
  > 0: the number of times that i should try before quitting
  0: no quit early: will not quit unless etPrimeIF() is impotent (the adam has been fired)
  - 1: no quit (even when the adam has been fired)
 cTriesP
 flagsP
  can be 0
 cbP
 idHowP
 postP
 ecP
   TAG creates a bitsC instance that is dt as soon as i return, resulting in a non lifo d elete on the tls, which is illegal (enforced)
   i create a tls item that is not dt until i am dt
  if idMemorySpaceP and idMemorySpaceP is not the default memory space then TAG() cannot be used
 pbBitsCtP
 idiFileCtP
 idLineCtP
 tinP
arguments
warning: application code must verify that "operator byteT*()" returns a nonze value, unless cTriesP == -1 is specified
the calling code -must- call formattingIsDoneF after constructing me to indicate that it has finished formatting the data area
\<A HREF=\"5.15e0003.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

