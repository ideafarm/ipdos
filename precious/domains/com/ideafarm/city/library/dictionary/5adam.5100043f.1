
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

//==============================================================================================================================================================
//==== BELOW THIS LINE: DAYTIME WORK ===========================================================================================================================
//==============================================================================================================================================================

REST

etThread.ifcDrivenServerF( tinP , i1 , i2 ) ;
serverInfo2S i2( 0x1f40 , flSOCKETc_null , TF2(thirdC::third_idAdamRootI_IF( tinP ),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , 0 , (countT)&c8p , 0 , - 1 , 1 , sizeof( stateS ) , translateStateF ) ;
serverInfo1S i1( &pbdVarying , b_pbdVarying , bHandedOff , sgnIdPortReplaced , tmcF , countTC() , ether ) ;
etThread.ifcChatF( tinP , (countT)&c8p , DDNUMB , jobFillCourseF ) ;
//U:etThread.osThreadF(  tinP , countTC() , tmLogF  , 0 , flTHREADlAUNCH_null , 0 , (countT)&c8p ) ;

c8p.c5 = (countT)&tinP.cKidThreads ;
c8p.c4 = (countT)&stPhrasesLog ;
c8p.c3 = (countT)&stPhrases ;
c8p.c2 = (countT)&b_pbdVarying ;
c8p.c1 = (countT)&pbdVarying ;
count8S c8p ;

stackC stPhrasesLog( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
stackC stPhrases(    tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
ZE( boolT , bHandedOff ) ;
batonC b_pbdVarying( tinP , TAG( TAGiDnULL ) ) ;
ZE( byteT* , pbdVarying ) ;
signC sgnIdPortReplaced( tinP , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmLogF )

}
    }
        ether.osSleepF( tinP , TOCK ) ;
        }
            etThread.delF( tinP , psttp ) ;
            //etThread.ifcSayF( tinP , psttp , flSAY_APPEND | flSAY_LOG ) ;
            stPhrasesLog >> psttp ;
            ZE( strokeS* , psttp ) ;
        {
        while( stPhrasesLog )
    {
    while( !etThread && ( !ether || cKidThreads > 1 ) )

    countT&      cKidThreads   =      *(countT*)c8p.c5 ;
    stackC&      stPhrasesLog  =      *(stackC*)c8p.c4 ;
    stackC&      stPhrases     =      *(stackC*)c8p.c3 ;
    batonC&      b_pbdVarying  =      *(batonC*)c8p.c2 ;
    byteT*&      pbdVarying    =      *(byteT**)c8p.c1 ;
    count8S&     c8p           = *(count8S*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmLogF )

DONEdRIVENsERVER( tmcF )
}
    while( !bQuit ) bQuit = woRequestF( tinP , etThread , *tinP.zEtScratch , *pso , stPhrases , stPhrasesLog ) ;
    ZE( boolT , bQuit ) ;

    b_pbdVarying.ungrabF( tinP ) ;
    }
        TN( t_cHamburgers , "" ) ; t_cHamburgers = TF3(++state.cHamburgers,0,8) ;
        TN( t_idMe        , "" ) ; t_idMe        = TF3(state.idMe,0,8) ;
        stateS& state = *(stateS*)pbdVarying ;
    {
    if( pbdVarying )
    b_pbdVarying.grabF( tinP , TAG( TAGiDnULL ) ) ;

    countT&      cKidThreads   =      *(countT*)c8p.c5 ;
    stackC&      stPhrasesLog  =      *(stackC*)c8p.c4 ;
    stackC&      stPhrases     =      *(stackC*)c8p.c3 ;
    batonC&      b_pbdVarying  =      *(batonC*)c8p.c2 ;
    byteT*&      pbdVarying    =      *(byteT**)c8p.c1 ;
    count8S&     c8p           =     *(count8S*)cArg ;
{
if( cArg )
TASKdRIVENsERVER( tmcF )

}
    return 1 ;
    stPhrasesP.ungrabF( tinP ) ;

    }
        sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_9) ) ;
        }
            tinP.zEtScratch->delF( tinP , postBody ) ;
            }
                sClientP.writeF( tinP , postBody , costBody ) ;
                sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_4C) ) ;
                else               sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postBody) ) ;
                if( bEncodedBody ) sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , tEncoded    ) ;
                sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_4B) ) ;
            {
            if( postBody && costBody )
        {
        if( !*tinP.zEtScratch )
        sClientP.writeF( tinP , "\r\n" , 2 ) ;
        }
            tinP.zEtScratch->delF( tinP , postl ) ;
            sClientP.writeF( tinP , "\r\n" , 2 ) ;
            sClientP.writeF( tinP , postl , costl ) ;
            sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postl)+tCRLF ) ;
            tinP.zEtScratch->delF( tinP , psttl ) ;
            countT costl = tinP.zEtScratch->strMakeF( tinP , postl , psttl ) ; ___( postl ) ;
            ZE( osTextT* , postl ) ;
            stHeaderLines >> psttl ;
            ZE( strokeS* , psttl ) ;
        {
        while( stHeaderLines )
        sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_4A) ) ;
        // WRITE REPLY TO CLIENT

        sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_3C) ) ;
        }
            else               sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postBody) ) ;
            if( bEncodedBody ) sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , tEncoded    ) ;
            if( postBody ) postBody[ costBody ] = 0 ;
            sServer.readF( tinP , postBody , costBody ) ;
            tinP.zEtScratch->newF( tinP , LF , postBody , costBody + 1 ) ; ___( postBody ) ;
            sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_3B) ) ;
        {
        if( costBody )
        { ZE( strokeS* , psttHost ) ; bEncodedBody = 0 ; readHeaderLinesF( tinP , etThread , *tinP.zEtScratch , sServer , stPhrasesP , stPhrasesLogP , stHeaderLines , costBody , bEncodedBody , countTC() , psttHost , 1 ) ; tinP.zEtScratch->delF( tinP , psttHost ) ; }
        sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_3A) ) ;
        ZE( countT , costBody ) ;
        ZE( osTextT* , postBody ) ;
        // READ REPLY FROM SERVER

        tinP.zEtScratch->delF( tinP , psttBody ) ;
        sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_2C) ) ;
        }
            tinP.zEtScratch->delF( tinP , postBody ) ;
            sServer.writeF( tinP , postBody , costBody ) ;
            else               sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , psttBody ) ;
            if( bEncodedBody ) sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , tEncoded    ) ;
            countT costBody = tinP.zEtScratch->strMakeF( tinP , postBody , psttBody ) ; ___( postBody ) ;
            ZE( osTextT* , postBody ) ;
            sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_2B) ) ;
        {
        if( psttBody && psttBody->idAdam )
        sServer.writeF( tinP , "\r\n" , 2 ) ;
        }
            tinP.zEtScratch->delF( tinP , postl ) ;
            sServer.writeF( tinP , "\r\n" , 2 ) ;
            sServer.writeF( tinP , postl , costl ) ;
            sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postl)+tCRLF ) ;
            tinP.zEtScratch->delF( tinP , psttl ) ;
            countT costl = tinP.zEtScratch->strMakeF( tinP , postl , psttl ) ; ___( postl ) ;
            ZE( osTextT* , postl ) ;
            stHeaderLines >> psttl ;
            ZE( strokeS* , psttl ) ;
        {
        while( stHeaderLines )
        sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_2A) ) ;
        tinP.zEtScratch->delF( tinP , psttHost ) ;
        sServer.connectF( tinP , idPort ? idPort : 0x50 , socketC::nicNameIF( tinP , *tinP.zEtScratch , psttHost ) ) ;
        socketC sServer( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) ) ;
        // WRITE REQUEST TO SERVER
    {
    if( !*tinP.zEtScratch && stHeaderLines ) // DO NOT KNOW WHY THIS HAPPENS WITH IE5.5: CONJ: WHEN I AM RUN ON IFC21, I AM SO SLOW THAT IE5.5 ABANDONS THE REQUEST

    sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T("psttHost: \"")+T(psttHost)+T("\"\r\n") ) ;

    }
        sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_1C) ) ;
        }
            }
                else               sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , psttBody ) ;
                if( bEncodedBody ) sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , tEncoded ) ;
                tinP.zEtScratch->delF( tinP , postBody ) ;
                tinP.zEtScratch->strMakeF( tinP , psttBody , T(postBody) ) ; ___( psttBody ) ;
                if( postBody ) postBody[ costBody ] = 0 ;
            {
            if( !*tinP.zEtScratch )
            sClientP.readF( tinP , postBody , costBody ) ;
            tinP.zEtScratch->newF( tinP , LF , postBody , costBody + 1 ) ; ___( postBody ) ;
            ZE( osTextT* , postBody ) ;
            sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_1B) ) ;
        {
        if( !*tinP.zEtScratch && costBody )

        readHeaderLinesF( tinP , etThread , *tinP.zEtScratch , sClientP , stPhrasesP , stPhrasesLogP , stHeaderLines , costBody , bEncodedBody , idPort , psttHost ) ;
        bEncodedBody = 0 ;
        sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_1A) ) ;
        ZE( countT , costBody ) ;
    {
    ZE( countT , idPort ) ;
    stackC stHeaderLines( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    ZE( boolT , bEncodedBody ) ;
    ZE( strokeS* , psttBody ) ;
    ZE( strokeS* , psttHost ) ;
    // READ REQUEST FROM CLIENT
    sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_0) ) ;
    TN( tEncoded , "[encoded]\r\n" ) ;
    TN( tCRLF , "\r\n" ) ;

    stPhrasesP.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
boolT woRequestF( tinS& tinP , etherC& etThread , socketC& sClientP , stackC& stPhrasesP , stackC& stPhrasesLogP )
*/
/*

}
    tinP.zEtScratch->delF( tinP , psttPVersion ) ;
    tinP.zEtScratch->delF( tinP , psttProtocol ) ;
    tinP.zEtScratch->delF( tinP , psttPort ) ;
    tinP.zEtScratch->delF( tinP , psttUrl ) ;
    tinP.zEtScratch->delF( tinP , psttAction ) ;

    }
        tinP.zEtScratch->delF( tinP , psttl ) ;
        }
            break ;
            tinP.zEtScratch->delF( tinP , psttl ) ;
        {
        else
        }
            }
                tinP.zEtScratch->delF( tinP , psttValue ) ;
                tinP.zEtScratch->delF( tinP , psttKey ) ;
                }
                    bEncodedBodyP = 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tImage , psttValue ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf = 1 ;
                    tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttValue ) ; ___( psttValue ) ;
                {
                else if( !tinP.zEtScratch->strCompareF( tinP , psttKey , tContentType   ) )
                     if( !tinP.zEtScratch->strCompareF( tinP , psttKey , tContentLength ) ) costBodyP = tinP.zEtScratch->strDigitsToSCountF( tinP , psttValue , 0xa , 1 ) ;
                tinP.zEtScratch->strSubstringF( tinP , psttValue , idf , idl , psttl ) ; ___( psttValue ) ;
                ZE( countT , idl ) ;
                tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttKey ) ; ___( psttKey ) ;
                tinP.zEtScratch->strSubstringF( tinP , psttKey , idf , sttq , tColonWhite , psttl , 1 ) ; ___( psttKey ) ;
                countT idf = 1 ;
                ZE( strokeS* , psttValue ) ;
                ZE( strokeS* , psttKey ) ;
            {
            else
            }
                sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T("psttHostP:    \"")+T(psttHostP)+tEQCRLF ) ;
                sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T("psttPVersion: \"")+T(psttPVersion)+tEQCRLF ) ;
                sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T("psttProtocol: \"")+T(psttProtocol)+tEQCRLF ) ;
                sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T("psttPort:     \"")+T(psttPort)+tEQCRLF ) ;
                sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T("psttUrl:      \"")+T(psttUrl)+tEQCRLF ) ;
                sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T("psttAction:   \"")+T(psttAction)+tEQCRLF ) ;


                tinP.zEtScratch->delF( tinP , psttw ) ;
                tinP.zEtScratch->strSubstringF( tinP , psttPVersion , idf , sttq , tSlash , psttw ) ; ___( psttPVersion ) ;
                tinP.zEtScratch->strSubstringF( tinP , psttProtocol , idf , sttq , tSlash , psttw ) ; ___( psttProtocol ) ;
                idf = 1 ; //sttq = ze ;
                tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttw ) ; ___( psttw ) ;
                tinP.zEtScratch->strSubstringF( tinP , psttw , idf , sttq , tBlank , psttl , 1 ) ; ___( psttw ) ;
                ZE( strokeS* , psttw ) ;

                }
                    }
                        tinP.zEtScratch->strSubstringF( tinP , psttHostP , idf2 , sttq2 , tSlash , psttUrl ) ; ___( psttHostP ) ;
                        //sttq2 = ze ;
                        idf2 = 1 ;
                    {
                    else
                    if( 1 == tinP.zEtScratch->strIdF( tinP , idf2 , sttq2 , tHttpColonSS , psttUrl ) ) { tinP.zEtScratch->strSubstringF( tinP , psttHostP , idf2 , sttq2 , tSlash , psttUrl ) ; ___( psttHostP ) ; }
                    strokeS sttq2( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf2 = 1 ;
                {
                else
                }
                    tinP.zEtScratch->delF( tinP , psttd ) ;
                    idPortP = tinP.zEtScratch->strDigitsToSCountF( tinP , psttPort , 0xa , 1 ) ;
                    tinP.zEtScratch->strSubstringF( tinP , psttPort  , idf2 , sttq2 , tColon , psttd ) ; ___( psttPort ) ;
                    tinP.zEtScratch->strSubstringF( tinP , psttHostP , idf2 , sttq2 , tColon , psttd ) ; ___( psttHostP ) ;
                    strokeS sttq2( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf2 = 1 ;
                    psttUrl = 0 ;
                    strokeS* psttd = psttUrl ;
                {
                if( !tinP.zEtScratch->strCompareF( tinP , psttAction , tConnect ) && tinP.zEtScratch->strIdF( tinP , tColon , psttUrl ) ) //U: DOES NOT CORRECTLY HANDLE CASE WHERE URL CONTAINS A COLON (E.G. "http://foo.com:123")
                tinP.zEtScratch->strSubstringF( tinP , psttUrl , idf , sttq , tBlank , psttl , 1 ) ; ___( psttUrl ) ;

                tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttAction ) ; ___( psttAction ) ;
                tinP.zEtScratch->strSubstringF( tinP , psttAction , idf , sttq , tBlank , psttl , 1 ) ; ___( psttAction ) ;

                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                countT idf = 1 ;

                TN( tConnect     , "connect" ) ;
                TN( tEQCRLF      , "\"\r\n"  ) ;
                TN( tHttpColonSS , "http://" ) ;
                TN( tColon       , ":"       ) ;
                TN( tSlash       , "/"       ) ;
                TN( tBlank       , " "       ) ;
            {
            if( !bReplyP && !psttAction )
            sayF( tinP , etThread , stPhrasesP , stPhrasesLogP , T(psttl)+tCRLF ) ;

            stP << psttOldC( tinP , *tinP.zEtScratch , psttl ) ;
        {
        if( !*tinP.zEtScratch && psttl && psttl->idAdam )
        sInP.readWoLineF( tinP , psttl , 0x200 ) ; ___( psttl ) ;
        ZE( strokeS* , psttl ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    {
    while( !*tinP.zEtScratch )

    ZE( strokeS* , psttPVersion ) ;
    ZE( strokeS* , psttProtocol ) ;
    ZE( strokeS* , psttPort ) ;
    ZE( strokeS* , psttUrl ) ;
    ZE( strokeS* , psttAction ) ;

    TN( tImage         , "image/" ) ;
    TN( tContentType   , "content-type" ) ;
    TN( tContentLength , "content-length" ) ;
    TN( tColonWhite , ": " ) ;
    TN( tCRLF , "\r\n" ) ;
{
voidT readHeaderLinesF( tinS& tinP , etherC& etThread , socketC& sInP , stackC& stPhrasesP , stackC& stPhrasesLogP , stackC& stP , countT& costBodyP , boolT& bEncodedBodyP , countT& idPortP , strokeS*& psttHostP , const boolT bReplyP = 0 )

}
    stPhrasesLogP << psttOldC( tinP , etThread , tPhrase ) ;
    stPhrasesP    << psttOldC( tinP , etThread , tPhrase ) ;
    TN( tPhrase , psttP ) ;
{
voidT sayF( tinS& tinP , etherC& etThread , stackC& stPhrasesP , stackC& stPhrasesLogP , const strokeS* const psttP )

#define postSEPARATOR_9  "\r\n---< E N D >----< E N D >----< E N D >----< E N D >----< E N D >----< E N D >----< E N D >----< E N D >----< E N D >----< E N D >---\r\n\r\n"
#define postSEPARATOR_4C     "---- 4 4 4 4 :   END ---------------------------------------------------------------------------------------------------------------\r\n\r\n"
#define postSEPARATOR_4B     "---- 4 4 4 4 :   BODY OUT TO CLIENT ------------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_4A "\r\n---- 4 4 4 4 :   HEADERS OUT TO CLIENT ---------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_3C     "---- 3 3 3 3 :   END ---------------------------------------------------------------------------------------------------------------\r\n\r\n"
#define postSEPARATOR_3B     "---- 3 3 3 3 :   BODY IN FROM SERVER -----------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_3A "\r\n---- 3 3 3 3 :   HEADERS IN FROM SERVER --------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_2C     "---- 2 2 2 2 :   END ---------------------------------------------------------------------------------------------------------------\r\n\r\n"
#define postSEPARATOR_2B     "---- 2 2 2 2 :   BODY OUT TO SERVER ------------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_2A "\r\n---- 2 2 2 2 :   HEADERS OUT TO SERVER ---------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_1C     "---- 1 1 1 1 :   END ---------------------------------------------------------------------------------------------------------------\r\n\r\n"
#define postSEPARATOR_1B     "---- 1 1 1 1 :   BODY IN FROM CLIENT -----------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_1A "\r\n---- 1 1 1 1 :   HEADERS IN FROM CLIENT --------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_0  "\r\n-< B E G I N >< B E G I N >< B E G I N >< B E G I N >< B E G I N >< B E G I N >< B E G I N >< B E G I N >< B E G I N >< B E G I N >-\r\n\r\n"


//==============================================================================================================================================================
//==== ABOVE THIS LINE: DAYTIME WORK ===========================================================================================================================
//==============================================================================================================================================================


//==============================================================================================================================================================
//==== BELOW THIS LINE: MOONLIGHT WORK =========================================================================================================================
//==============================================================================================================================================================

}
    if( ether && *tinP.zEtScratch && cArgP && c8argP.c1 && sDataP && sNotesTextP && sNotesDataP && idChatSessionP ) ;

    }
        }
            break ;

            etThread.delF( tinP , psttBody ) ;
            etThread.delF( tinP , psttFrom ) ;
            }
                etThread.delF( tinP , postBody ) ;
                etThread.delF( tinP , psttu ) ;
                etThread.boxPutUniqueF( tinP , psttu , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(DDNUMB)+T("/in/in") , postBody , costBody ) ;
                ZE( strokeS* , psttu ) ;

                countT costBody = etThread.strMakeF( tinP , postBody , psttBody ) ; ___( postBody ) ;
                ZE( osTextT* , postBody ) ;
            {

            sOrderP >> psttBody ; ___( psttBody ) ;
            ZE( strokeS* , psttBody ) ;

            __( idAdamTo - DDNUMB ) ;
            __Z(  idAdamTo ) ;
            sOrderP >> idAdamTo ;
            ZE( countT , idAdamTo ) ;

            __(  psttFrom && !psttFrom->idAdam ) ;
            __Z( psttFrom ) ;
            sOrderP >> psttFrom ; ___( psttFrom ) ;
            ZE( strokeS* , psttFrom ) ;

            __( idJobType - ifcIDcMDjOBoRDER_MAIL ) ;
            sOrderP >> idJobType ;
            ZE( countT , idJobType ) ;
        {
        case 1 :
    {
    switch( idCourseP )

    __( idAdamP - DDNUMB ) ;
{
voidT jobFillCourseF( tinS& tinP , etherC& ether , etherC& etThread , soulC& sDataP , soulC& sNotesTextP , soulC& sNotesDataP , const countT idCourseP , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

//==============================================================================================================================================================
//==== ABOVE THIS LINE: MOONLIGHT WORK =========================================================================================================================
//==============================================================================================================================================================


//==============================================================================================================================================================
//==== BELOW THIS LINE: PROCESS STATE CODE =====================================================================================================================
//==============================================================================================================================================================

TRANSLATEsTATEdRIVENsERVER_END
    state.idMe ++ ;
TRANSLATEsTATEdRIVENsERVER_MIDDLE
    case 1 : { state.idMe        = stateOther.idMe        ; }
    case 2 : { state.cHamburgers = stateOther.cHamburgers ; }
TRANSLATEsTATEdRIVENsERVER_BEGIN( stateS , 2 )

;
}
    countT cHamburgers ;
    countT idMe ;
    countT idVersion ;
{
struct stateS

//==============================================================================================================================================================
//==== ABOVE THIS LINE: PROCESS STATE CODE =====================================================================================================================
//==============================================================================================================================================================

/*1*/WAKEhIDE( "ifc.port.04f1.wiretap" )/*1*/
/**/
*/
  as of this writing, the only way to fire me is to hire me again or to reboot
 to stop recording, fire me
 as you use your browser, i will collect data
 press enter to make the wo'th request
 hire me on the tap host
 type in the url (but do not press enter) of the wo'th request that you want me to collect data for
 set your browser's proxy setting to point to the tap host and to use port 8000_9
 browser host: the host on which you will use your browser
 tap host: the host on which i am hired
instructions
i relay port 05 connections and collect data from the data stream
obsoletes c240104
\<A HREF=\"5.2440104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

