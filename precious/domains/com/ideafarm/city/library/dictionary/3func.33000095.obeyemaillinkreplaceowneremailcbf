
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        ) ;

            +T("</SPAN>\r\n")
            +T(     psttKVReportP)
            )

                "<P>\r\n"
                "Not done.\r\n"
            
            T(

        meP.pushSnipF( tinP , stBodyP ,
    {
    else
    }
        ) ;

            +T("</SPAN>\r\n")
            +T(     psttKVReportP)
            )

                "<P>\r\n"
                "Not done.  Another account is owned by the proposed email address.\r\n"
            
            T(

        meP.pushSnipF( tinP , stBodyP ,
    {
    else if( bAlreadyExists )
    }
        ) ;

            +T("</SPAN>\r\n")
            +T(     psttKVReportP)
            )

                "<P>\r\n"
                "Done.\r\n"
            
            T(

        meP.pushSnipF( tinP , stBodyP ,
    {
    if( bDone )

    }
        }
            }
                }
                    }
                        }
                            }
                                }
                                    etThread.delF( tinP , posti ) ;
                                    }
                                        bDone = 1 ;
                                        }
                                            while( ~hFind1 ) ;
                                            }
                                                DEL( pInfo1 ) ;
                                                }
                                                    while( ~hFind2 ) ;
                                                    }
                                                        DEL( pInfo2 ) ;
                                                        }
                                                            }
                                                                etThread.delF( tinP , posti ) ;
                                                                }
                                                                    tinP.pEtScratch->boxPutF( tinP , pInfo2->psttIfoName , tNew , tNew.csF( tinP ) ) ;
                                                                    etThread.delF( tinP , psttw ) ;
                                                                    TN( tNew , "" ) ; tNew = T(psttw) ;
                                                                    etThread.strReplaceF( tinP , psttw , T(posti) , tEmailLoggedIn , tEmailTicket , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttw ) ;
                                                                    ZE( strokeS* , psttw ) ;
                                                                {
                                                                else if( posti && *posti )
                                                                if( POOP ) { POOPR ; }
                                                                tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , pInfo2->psttIfoName , 1 ) ; ___( posti ) ;
                                                                ZE( countT , costi ) ;
                                                                ZE( osTextT* , posti ) ;
                                                            {
                                                            IFmATCHwILD( etThread , pat , fn )
                                                            fileNameC fn( tinP , etThread , pInfo2->psttIfoName ) ;
                                                            patternC pat( tinP , etThread , T("txt.*") , ifcIDtYPEpATTERN_FOREIGNwILDCARDmICROSOFT ) ;
                                                        {
                                                        if( pInfo2 && !( F(pInfo2->flags) & flFILEaTTR_DIRECTORY ) )
                                                        tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo2 , hFind2 , tDirSubaccount+T("*") ) ; ___( pInfo2 ) ;
                                                        ZE( infoFileS* , pInfo2 ) ;
                                                    {
                                                    do
                                                    handleC hFind2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                                    TN( tDirSubaccount , "" ) ; tDirSubaccount = T(pInfo1->psttIfoName) ;
                                                {
                                                if( pInfo1 && F(pInfo1->flags) & flFILEaTTR_DIRECTORY && !( F(pInfo1->flags) & flFILEaTTR_DOTdIRECTORY ) )
                                                tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo1 , hFind1 , tDirSubaccounts+T("*") ) ; ___( pInfo1 ) ;
                                                ZE( infoFileS* , pInfo1 ) ;
                                            {
                                            do
                                            handleC hFind1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                            TN( tDirSubaccounts , "" ) ; tDirSubaccounts += tDirAccount+T("/subaccounts/") ;
                                        {
                                        etThread.boxPutF( tinP , tFile , tEmailTicket , tEmailTicket.csF( tinP ) ) ;
                                    {
                                    else if( posti && !etThread.strCompareF( tinP , T(posti) , tEmailLoggedIn ) )
                                    if( POOP ) { POOPR ; }
                                    tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , tFile , 1 ) ; ___( posti ) ;
                                    ZE( countT , costi ) ;
                                    ZE( osTextT* , posti ) ;
                                    TN( tFile , "" ) ; tFile = tDirAccount+tShortFileOwner ;
            
                                    TN( tDirAccount , "" ) ; tDirAccount = tIpdosAccounts+TF4(idAccountLoggedIn,flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_NObIGITvALUES,0,36)+T("/") ;
                                {
                                if( !bAlreadyExists )

                                }
                                    }
                                        if( !bAlreadyExists ) { etThread.diskFindFileOrDirF( tinP , psttDirAccount , hFind , tLike ) ; ___( psttDirAccount ) ; }
                                        etThread.delF( tinP , psttDirAccount ) ;
                        
                                        }
                                            etThread.delF( tinP , posti ) ;
                                            else if( posti && costi && !etThread.strCompareF( tinP , tEmailTicket , T(posti) ) ) bAlreadyExists = 1 ;
                                            if( POOP ) { POOPR ; }
                                            tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , T(psttDirAccount)+tShortFileOwner ) ; ___( posti ) ;
                                            ZE( countT , costi ) ;
                                            ZE( osTextT* , posti ) ;
                                        {
                                        else
                                        if( !bDir || bDots ) etThread.delF( tinP , psttDirAccount ) ;
                        
                                        }
                                            etThread.delF( tinP , psttw ) ;
                                            ;
                                                !etThread.strCompareF( tinP , psttw , T(".") )
                                                !etThread.strCompareF( tinP , psttw , T("..") ) ||
                                            bDots = 
                        
                                            etThread.strWordF( tinP , psttw , psttDirAccount , sttq , S1C('/') , - 1 - bDir ) ; ___( psttw ) ;
                                            ZE( strokeS* , psttw ) ;
                                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        
                                            bDir = psttDirAccount && psttDirAccount[ CSpREFIX - 1 + psttDirAccount->idAdam ].idAdam == '/' ;
                                        {
                                        ZE( boolT , bDir ) ;
                                        ZE( boolT , bDots ) ;
                                    {
                                    while( !etThread && psttDirAccount && !bAlreadyExists )
                        
                                    etThread.diskFindFileOrDirF( tinP , psttDirAccount , hFind , tLike ) ; ___( psttDirAccount ) ;
                                    ZE( strokeS* , psttDirAccount ) ;
                                    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                    TN( tLike , "" ) ; tLike = tIpdosAccounts+T("*") ;
                                {
                                TN( tShortFileOwner , "txt.email.owner.txt" ) ;
                                TN( tIpdosAccounts , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/accounts/" ) ;
                                //SEARCH FOR AN EXISTING ACCOUNT OWNED BY tEmailTicket; THIS NEEDS TO BE DONE WITHOUT BLOWING MEMORY WITH A LARGE LIST

                                }
                                    etThread.delF( tinP , psttEmailTicket ) ;
                                    tEmailTicket = T(psttEmailTicket) ;
                                    sIn >> psttEmailTicket ; ___( psttEmailTicket ) ;
                                    ZE( strokeS* , psttEmailTicket ) ;
                                {
                            {
                            if( idAccountTicket && idAccountTicket == idAccountLoggedIn )
                            sIn >> idAccountTicket ;
                            ZE( countT , idAccountTicket ) ;
                        {
                        if( idType == ifcIDtYPEtICKET_REPLACEaCCOUNToWNEReMAIL )
                        sIn >> idType ;
                        ZE( countT , idType ) ;
                    {
                    if( idFormat == 1 )
                    sIn >> idFormat ;
                    ZE( countT , idFormat ) ;
                {
                if( finger == FINGERnEG_TICKET )
                sIn >> finger ;
                ZE( countT , finger ) ;

                tinP.pEtScratch->boxGetShadowF( tinP , sIn , tFileNew ) ;
                soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
            {
            else
            if( POOP ) { POOPR ; }
            tinP.pEtScratch->diskMoveFileOrDirF( tinP , tFileNew , tDirOld+tShort ) ;
            TN( tFileNew , "" ) ; tFileNew = tDirNew+tShort ;
            TN( tShort  , "soul.ticket." ) ; tShort += T(zsttIdTicket)+T(".soul") ;

            if( POOP ) { POOPR ; }
            tinP.pEtScratch->diskMakeDirIfNeededF( tinP , tDirNew ) ;
            TN( tDirNew , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets.used/" ) ;
            TN( tDirOld , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets/" ) ;

            if( zsttIdTicket ) { etThread.strTrimF( tinP , zsttIdTicket , 0 , T(TbLACKnEWlINE) ) ; ___( zsttIdTicket ) ; }
            strokeS*& zsttIdTicket = *(strokeS**)&(countT&)swKVP ;
            psttLeverKVP = tKey ;
        {
        if( swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKey ) )
        TN( tKey , "idticket" ) ;
        SCOOPS
    {
    IFsCRATCH
    TN( tEmailTicket , "" ) ;
    ZE( boolT , bAlreadyExists ) ;
    ZE( boolT , bDone ) ;

    }
        etThread.delF( tinP , psttEmailLoggedIn ) ;
        tEmailLoggedIn = T(psttEmailLoggedIn) ;
        idAccountLoggedIn = session.getIdAccountF( tinP ) ;
        session.getEmailF( tinP , psttEmailLoggedIn ) ; ___( psttEmailLoggedIn ) ;
        sessionC& session = sessionsP( tinP , nnPeerP ) ;
        ZE( strokeS* , psttEmailLoggedIn ) ;
    {
    ZE( countT , idAccountLoggedIn ) ;
    TN( tEmailLoggedIn , "" ) ;
{
/*1*/voidT obeyEmailLinkReplaceOwnerEmailCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttUrlP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

