
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    delF( tinP , psttd1 ) ;

    }
        idClassP = strDigitsToSCountF( tinP , psttd1 ) ;
    {
    if( psttP )

    }
        }
            delF( tinP , psttP ) ;
            ___( psttP ) ;
        {
        if( psttP && !idFirstP && psttBigP->idAdam - ( idfs - 1 ) - psttP->idAdam - 4 > psttd1->idAdam )
        POSTPONEtEST( psttP ) ;
        strSubstringF( tinP , psttP , idFirstP , sttQuoteP , T("/*")+T(psttd1)+T("*/") , psttBigP , csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;
        const countT idfs = idFirstP ;
    {
    if( psttd1 && idFirstP )

    // psttd1 NOW CONTAINS THE DELIMITER, AND idFirstP POINTS TO THE STROKE FOLLOWING ITS FIRST OCCURANCE
    }
        }
            if( !cDigits || off < cDigits ) delF( tinP , psttd1 ) ;
            }
                break ;
                if( ( psttd1[ CSpREFIX + off ] >= '0' && psttd1[ CSpREFIX + off ] <= '9' ) || ( psttd1[ CSpREFIX + off ] >= 'a' && psttd1[ CSpREFIX + off ] <= 'f' ) ) continue ;
            {
            for( ; off < cDigits ; off ++ )
            ZE( countT , off ) ;
            countT cDigits = psttd1->idAdam ;
        {
        if( psttd1 )

        if( !idFirstP ) delF( tinP , psttd1 ) ;
        if( idFirstP ) { strSubstringF( tinP , psttd1 , idFirstP , sttQuoteP , T("*/") ,psttBigP ) ; ___( psttd1 ) ; }
        delF( tinP , psttd1 ) ;
        strSubstringF( tinP , psttd1 , idFirstP , sttQuoteP , T("/*") ,psttBigP ) ; ___( psttd1 ) ;
    {
    while( idFirstP && !psttd1 )
    ZE( strokeS* , psttd1 ) ;

    _INoLD_

    }
        if( POOP ) return ;
        __Z( psttBigP ) ;
        __Z( idFirstP ) ;
        __( idClassP ) ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/**//*1*/voidT etherC::strSubstringDelimitedF( tinS& tinP , strokeS*& psttP , countT& idClassP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* const psttBigP , const countT csttExtraP )/*1*/
*/
 csttExtraP
   each occurance of "/" "*" must be followed by "*" "/"
  must contain valid C++ code
  must not be 0
 psttBigP 
   example: strokeS psttq ;
   a virgin object is an object that has been constructed using its default , no argument, constructor
  this should normally be set to a virgin strokeS object the first time that a substring is extracted from psttBigP
 sttQuoteP
  must not be 0
 idFirstP
  must be 0
 idClassP
  must be 0
 psttP
arguments
delimiters can be of any length, but should be limited to 8 or fewer hex digits so that the value can be returned correctly
psttP will contain the text that was between those delimiters
idFirstP will be set to the position following the second delimiter of the first matched pair of delimiters
delimiters are of the form "/ *nnn* /" (ignore those spaces) where any number of hex digits [0-9,a-f] can be specified
extracts the first delimited substring
  \<A HREF=\"5.1b10104.1.1.0.html\"\>1b10104:  WAKEsHOW( "example.simplest.func.10300bf.etherC.strSubstringDelimitedF" )\</A\>
 simplest
examples
\<A HREF=\"5.10300bf.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strSubstringDelimitedF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

