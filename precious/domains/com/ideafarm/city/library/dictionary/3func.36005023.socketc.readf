
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
    
        tinP.pAdamGlobal3->_socketC_.grab.ungrabF( tinP ) ;
        pOdometer->cbWrite += tinP.odoSockCbWrite - _odoSockCbWriteOpen ;
        pOdometer->cbRead  += tinP.odoSockCbRead  - _odoSockCbReadOpen  ;
        pOdometer = (sockOdometerS*)&(countT&)*tinP.pAdamGlobal3->_socketC_.pSwOdometer ;
        tinP.pAdamGlobal3->_socketC_.nnLever = nnPeer ;
        tinP.pAdamGlobal3->_socketC_.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        bRead.ungrabF( tinP ) ;
    
        if( idleTimeAllowedRead ) FRESHtIMEaTOMIC( *pEther , timeLathRead.time1 , timeLathRead.time2 )
    
        }
            }
                pEther->delF( tinP , pbIn2 ) ;
                pEther->delF( tinP , pbAll ) ;
                }
                    soulP.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbAll , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                    if( cbIn2 ) pEther->memCopyF( tinP , pbAll + sizeof( countT ) , pbIn2 , cbIn2 ) ;
                    *(countT*)pbAll = length ;
                {
                if( pbAll )
                pEther->newF( tinP , LF , pbAll , sizeof( countT ) + length ) ; ___( pbAll ) ;
                ZE( byteT* , pbAll ) ;
    
                }
                    pEther->delF( tinP , pcCode2 ) ;
                    }
                        }        
                            __( cbIn2 - length ) ;
                            dad( tinP , pbIn2 , cbIn2 , pcCode2 , length ) ; ___( pbIn2 ) ;
                        {
                        if( !*pEther )
                        readF( tinP , (byteT*)pcCode2 , sizeof( count01T ) * length , flSOCKETcrEAD_null , time1P , time2P ) ;
                    {
                    if( pcCode2 )
                    pEther->newF( tinP , LF , pcCode2 , length ) ; ___( pcCode2 ) ;
                    ZE( count01T* , pcCode2 ) ;
                {
                if( length )
                ZE( countT , cbIn2 ) ;
                ZE( byteT* , pbIn2 ) ;
    
                }    
                    }
                        pEther->delF( tinP , pbIn1 ) ;
                        if( pbIn1 ) length = *(countT*)pbIn1 ;
                        __( cbIn1 - sizeof length ) ;
                        dad( tinP , pbIn1 , cbIn1 , pcCode1 , sizeof( countT ) ) ; ___( pbIn1 ) ;
                        ZE( countT , cbIn1 ) ;
                        ZE( byteT* , pbIn1 ) ;
                    {
                    if( !*pEther )
            
                    readF( tinP , (byteT*)( pcCode1 + 1 ) , sizeof pcCode1 - sizeof pcCode1[ 0 ] , flSOCKETcrEAD_null , time1P , time2P ) ;
                    count01T pcCode1[ sizeof( countT ) ] = { woth } ;
                {
                ZE( countT , length ) ;
            {
            else
            }
                }
                    pEther->delF( tinP , pcCodeE ) ;
                    }
                        }
                            pEther->delF( tinP , pbIn1 ) ;
                            soulP.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbIn1 , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ; //WILL NOT BE DONE IF PEER JUST SENT A PIN REFERENCE
                            __Z( cbIn1 ) ;
                            __Z( pbIn1 ) ;
                            dad( tinP , pbIn1 , cbIn1 , pcCodeE , ccCodeE ) ; ___( pbIn1 ) ;
                            ZE( countT , cbIn1 ) ;
                            ZE( byteT* , pbIn1 ) ;
                        {
                        if( !*pEther )
            
                        readF( tinP , (byteT*)( pcCodeE + 3 ) , sizeof( count01T ) * pcCodeEp[ 2 ] , flSOCKETcrEAD_null , time1P , time2P ) ;
                        pcCodeE[ 2 ] = pcCodeEp[ 2 ] ;
                        pcCodeE[ 1 ] = pcCodeEp[ 1 ] ;
                        pcCodeE[ 0 ] = pcCodeEp[ 0 ] ;
                    {
                    if( pcCodeE )
                    pEther->newF( tinP , LF , pcCodeE , ccCodeE ) ; ___( pcCodeE ) ;
                    countT ccCodeE = 3 + pcCodeEp[ 2 ] ;
                    ZE( count01T* , pcCodeE ) ;
                {
                if( pcCodeEp[ 2 ] )
                readF( tinP , (byteT*)( pcCodeEp + 1 ) , sizeof pcCodeEp - sizeof pcCodeEp[ 0 ] , flSOCKETcrEAD_null , time1P , time2P ) ;
                count01T pcCodeEp[ 3 ] = { woth } ; //"Ep": "ESCAPE SEQUENCE PREFIX: NULL IDcMD CCaRG"
            {
            if( !woth ) //THIS SOUL'S ENCODING IS AN ESCAPE SEQUENCE
            readF( tinP , (byteT*)&woth , sizeof woth , flSOCKETcrEAD_null , time1P , time2P ) ;
            ZE( count01T , woth ) ;
        {
        else if( !*pEther )
        }
            THREADmODE1rESTORE

            else                                               pEther->sockReadF( tinP , soulP , handle , time1P , time2P ) ;
            if( F(flagsMode) & flSOCKETcmODE_CRYPTfOREIGNsSL ) /*U::pEther->openSsl_readF( tinP ,  , handle )*/ ;

            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        {
        if( F(flags) & flSOCKETc_NOsECRECY )
    
        }
            }
                }
                    }
                        break ;
                        __1
                        __( idCmd ) ;
                    {
                    default :
                    }
                        break ;
    
                        (*pEther)( tinP , psFinger ) ;
                        }
                            __( finger - FINGERnEG_SOCKETsECREThANDSHAKE ) ;
                            *psFinger >> finger ;
                            ZE( countT , finger ) ;
                            readF( tinP , *psFinger ) ;
                        {
                        if( psFinger )
                        (*pEther)( tinP , psFinger , TAG( TAGiDnULL ) ) ;
                        ZE( soulC* , psFinger ) ;
    
                        }
                            }
                                pEther->delF( tinP , pcCode ) ;
                                }
                                    }
                                        __NZ( pbIn1 ) ;
                                        dad( tinP , pbIn1 , cbIn1 , pcCode , ccCode ) ; ___( pbIn1 ) ;
                                        ZE( countT , cbIn1 ) ;
                                        ZE( byteT* , pbIn1 ) ;
                                    {
                                    if( !*pEther )
                
                                    readF( tinP , (byteT*)pcCode , ccCode * sizeof( count01T ) ) ; //CANNOT USE soulC BECAUSE PIN HAS ALREADY BEEN APPLIED TO PEER AND I DO NOT WANT TO FIDDLE WITH MY flags MEMBER BECAUSE I AM NOT SERIALIZED WRT writeF
                                {
                                if( pcCode )
                                pEther->newF( tinP , LF , pcCode , ccCode ) ; ___( pcCode ) ;
                                ZE( count01T* , pcCode ) ;
                            {
                            else
                            if( !ccCode ) __1
    
                            readF( tinP , (byteT*)&ccCode , sizeof ccCode ) ;
                            ZE( countT , ccCode ) ;
                        {
                    {
                    case ifcIDcMDsOCKETtOPsECRET_3APPLYtHISpINrEFERENCE :
                    }
                        break ;
    
                        }
                            }
                                }
                                    //CONoUTrAW( TF1(tinP.monitor.idThread)+T(".- ")+T(tinP.postThreadName)+T("\r\n") ) ;
                                    pEther->delF( tinP , pbKey ) ;
                            
                                    }
                                        (*pEther)( tinP , psSecret ) ;
                                        (*pEther)( tinP , psTo ) ;
                                        }
                                            }
                                                pEther->cioPutSecretF( tinP , etherC::etPrimeIF( tinP ) , *psSecret , *psTo , count8S( ifcIDaDAM_KERNEL3BANG , ifcIDcHANNELfUNCTION_SECREThANDsHAKEkEY ) ) ;
                                                CONoUTrAW( "whispering\r\n" ) ;
                                            {
                                            //if( !incv02AM( cIn ) && idHomeDisk == 2 ) //U::TO FIND A BUG
                                            //static countT cIn ;
        
                                            //pEther->beeClickF( tinP , 1760 * 3 ) ;
                                            //CONoUTrAW( TF1(tinP.monitor.idThread)+T(".")+T(tinP.postThreadName)+T(": whispering\r\n")+T(pczKeyTopSecret)+T("\r\n") ) ; //U::
                                            psSecret->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_byteTptr , pbKey , cbKey ) ;
                                            *psSecret << pczKeyTopSecret ;
                                            idptRelayTopSecretPeer >> *psTo ;
                                        {
                                        if( psSecret && psTo )
                                        (*pEther)( tinP , psTo , TAG( TAGiDnULL ) ) ;
                                        ZE( soulC* , psTo ) ;
                                        (*pEther)( tinP , psSecret , TAG( TAGiDnULL ) ) ;
                                        ZE( soulC* , psSecret ) ;
                                    {
                                    else
                                    if( !pbKey || !cbKey ) __1
                            
                                    if( POOP ) break ;
                                    pEther->boxGetShadowF( tinP , pbKey , cbKey , tLong , 1 ) ; ___( pbKey ) ;
                                    ZE( countT , cbKey ) ;
                                    ZE( byteT* , pbKey ) ;
                            
                                    TN( tLong , "" ) ; tLong = T("///desk/" POSTfOLDERsECURITYkEYdEPOSITORY)+(idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/")+tShort ;
                                    countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;
                                    textC tShort( tinP , TAG( TAGiDnULL ) , flTEXTc_null , (countT*)pczKeyTopSecret , flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE , 8 , 0 , tDot ) ;
                                    TN( tDot , "." ) ;
                
                                    timeLathTopSecretPinSend.time2 = timeN2 ;
                                    timeLathTopSecretPinSend.time1 = timeN1 ;
                                    //CONoUTrAW( TT(timeD1,timeD2)+T("\r\n")+TF1(tinP.monitor.idThread)+T(".+ ")+T(tinP.postThreadName)+T("\r\n") ) ;
                                    //CONoUTrAW( "request not ignored 2\r\n" ) ;
                                {
                                if( timeD2 || timeD1 > TOCK * 0x40 ) //THIS TEST ELIMINATES REDUNDANT JOB ORDERS TO SECRET SERVICE
            
                                pEther->osTimeSubtractF( tinP , timeD1 , timeD2 , timeLathTopSecretPinSend.time1 , timeLathTopSecretPinSend.time2 ) ;
                                sCountT timeD2 = timeN2 ;
                                countT timeD1 = timeN1 ;
                                //CONoUTrAW( "request not ignored 1\r\n" ) ;
                            {
                            if( timeD2 || timeD1 > TOCK * 0x40 ) //U::TICK
                            //THE NEXT LINE SUPPRESSES TOP SECRECY FOR INFANT CONNECTIONS, TO REDUCE THE LOAD ON THE SECRET SERVERS
        
                            pEther->osTimeSubtractF( tinP , timeD1 , timeD2 , timeWothTopSecretPinRequestReceived.time1 , timeWothTopSecretPinRequestReceived.time2 ) ;
                            sCountT timeD2 = timeN2 ;
                            countT timeD1 = timeN1 ;
                        {
                        else
                        }
                            timeWothTopSecretPinRequestReceived.time2 = timeN2 ;
                            timeWothTopSecretPinRequestReceived.time1 = timeN1 ;
                            //CONoUTrAW( "woth request received\r\n" ) ;
                        {
                        if( !timeWothTopSecretPinRequestReceived.time1 && !timeWothTopSecretPinRequestReceived.time2 )
    
                        pEther->osTimeNowF( tinP , timeN1 , timeN2 ) ;
                        ZE( sCountT , timeN2 ) ;
                        ZE( countT , timeN1 ) ;
                    {
                    case ifcIDcMDsOCKETtOPsECRET_2SENDpINiMAGEsECRETLY :
                    }
                        break ;
    
                        (*pEther)( tinP , pSoul ) ;
                        }
                            idptRelayTopSecretPeer << *pSoul ;
                            *pSoul >> pczKeyTopSecretPeer ; ___( pczKeyTopSecretPeer ) ;
                            readF( tinP , *pSoul ) ;
                        {
                        if( pSoul )
                        (*pEther)( tinP , pSoul , TAG( TAGiDnULL ) ) ;
                        ZE( soulC* , pSoul ) ;
                    {
                    case ifcIDcMDsOCKETtOPsECRET_1MYpINnAMEiS :
                    }
                        break ;
                        bPayload = 1 ;
                    {
                    case ifcIDcMDsOCKETtOPsECRET_PAYLOAD :
                {
                switch( idCmd )
                readF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;
        
                ZE( countT , idCmd ) ;
            {
            while( !*pEther && !bPayload )
            ZE( boolT , bPayload ) ;
        {
        if( F(flags) & flSOCKETc_TOPsECRET )
    
        bRead.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        const countT _odoSockCbWriteOpen = tinP.odoSockCbWrite ;
        const countT _odoSockCbReadOpen  = tinP.odoSockCbRead  ;
    
        _IO_
    
        }
            }
                return ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )

            __( !(const byteT*)soulP ) ;

            }
                return ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL    
        SCOOPP
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/voidT socketC::readF( tinS& tinP , soulC& soulP , const countT time1P , const sCountT time2P )/*1*/

/**/
*/
\<A HREF=\"5.1070026.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$readF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

