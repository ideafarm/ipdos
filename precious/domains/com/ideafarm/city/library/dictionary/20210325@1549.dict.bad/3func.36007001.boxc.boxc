
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        __1
        if( !( F(ether.flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) ) ether.etherPutLogF( tinP , psttAll ) ;
    {    
    else
    }
        }
            //THE FILE WILL BE OPENED BY THE FIRST ACCESSOR METHOD
        {
        else if( !psttType->idAdam )
        }
            ether.delF( tinP , psttNapkin ) ;
            __Z( pbNapkin ) ;
            pbNapkin = (byteT*)pv + sizeof(countT) ;
            pv = (voidT*)handle.cNoteF() ;
            ether.memOpenSharedF( tinP , handle , countTC() , psttNapkin ) ;
            ZE( voidT* , pv ) ;

            __( idf ) ;
            ether.strSubstringF( tinP , psttNapkin , idf , sttq , S1C('/') , psttName ) ; ___( psttNapkin ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNapkin ) ;
        {
        else if( !ether.strCompareF( tinP , psttType , T("napkin") ) )
        }
            ether.delF( tinP , psttNapkin ) ;
            __Z( pbNapkin ) ;
            }
                pbNapkin = (byteT*)pv + sizeof cbNapkin ;
                *(countT*)pv = cbNapkin ;
            {
            if( pv )
            pv = (voidT*)handle.cNoteF() ;
            ether.memOpenSharedF( tinP , handle , countTC() , psttNapkin , 0 , sizeof cbNapkin + cbNapkin , ifcOPENsHAREDmEMORYhOW_nCeF ) ; //U::BUG: SHOULD SPEC cTries=1
            ZE( voidT* , pv ) ;

            if( !cbNapkin ) cbNapkin = 0x100000 ;
            }
                ether.delF( tinP , psttc1b ) ;
                cbNapkin = ether.strDigitsToSCountF( tinP , psttc1b ) ;
            {
            if( psttc1b )
            ZE( countT , cbNapkin ) ;
            __( idf ) ;
            if( idf ) { ether.strSubstringF( tinP , psttc1b , idf , sttq , S1C('/') , psttName ) ; ___( psttc1b ) ; }
            ether.strSubstringF( tinP , psttNapkin , idf , sttq , S1C('/') , psttName ) ; ___( psttNapkin ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttc1b ) ;
            ZE( strokeS* , psttNapkin ) ;
        {
        else if( !ether.strCompareF( tinP , psttType , T("napkin.make") ) )
        }
            if( !ether && pHoseProcessError ) pHoseProcessError->openNewClientF( tinP ) ;
            pHoseProcessError = new( 0 , tinP , LF ) boxC( tinP , ether , T("/tap/process.error/")+T(psttName) ) ; ___( pHoseProcessError ) ;
        {
        else if( !ether.strCompareF( tinP , psttType , T("process.error") ) )
        }
            if( !ether && pHoseProcessOut ) pHoseProcessOut->openNewClientF( tinP ) ;
            pHoseProcessOut = new( 0 , tinP , LF ) boxC( tinP , ether , T("/tap/process.out/")+T(psttName) ) ; ___( pHoseProcessOut ) ;
        {
        else if( !ether.strCompareF( tinP , psttType , T("process.out") ) )
        }
            //U:
        {
        else if( !ether.strCompareF( tinP , psttType , T("process.in") ) )
        }
            ether.delF( tinP , psttw ) ;
            ether.osProcessF( tinP , countTC() , pid , ether.strDigitsToSCountF( tinP , psttw ) ) ;
            handleC hProcess( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_PROCESS ) ;
            handleC hThread( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_THREAD ) ;
            ether.strSubstringF( tinP , psttw , idf , idl , psttName ) ; ___( psttw ) ;
            ZE( countT , idl ) ;
            ether.delF( tinP , psttw ) ;
            ether.strSubstringF( tinP , psttw , idf , sttq , S1C('/') , psttName ) ; ___( psttw ) ; // UNIQUE STRING USED BY THIS PROCESS INSTANCE
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttw ) ;

            ether.fileWriteF( tinP , h2 , (byteT*)&cb , sizeof cb ) ; //U:NT (HANDLE 2 IS HARDCODED)
            ether.fileWriteF( tinP , h1 , (byteT*)&cb , sizeof cb ) ; //U:NT (HANDLE 1 IS HARDCODED)
            countT cb = - 1 ;
            h2.osF( ifcIDtYPEhANDLE_FILE , 2 ) ;
            h1.osF( ifcIDtYPEhANDLE_FILE , 1 ) ;
            handleC h2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            handleC h1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;

            if( !ether && pHoseProcessError ) pHoseProcessError->isErrorF( tinP ) ;
            pHoseProcessError = new( 0 , tinP , LF ) boxC( tinP , ether , T("/hose/process.error/")+T(psttName) , ifcOPENaCCESS_WR , ifcOPENhOW_nCeO , 0 ) ; ___( pHoseProcessError ) ;

            if( !ether && pHoseProcessOut ) pHoseProcessOut->isOutF( tinP ) ;
            pHoseProcessOut = new( 0 , tinP , LF ) boxC( tinP , ether , T("/hose/process.out/")+T(psttName) , ifcOPENaCCESS_WR , ifcOPENhOW_nCeO , 0 ) ; ___( pHoseProcessOut ) ;

            //U:if( !ether && pHoseProcessIn ) pHoseProcessIn->isInF( tinP ) ;
            //U:pHoseProcessIn = new( 0 , tinP , LF ) boxC( tinP , ether , T("/hose/process.in/")+T(psttName) , ifcOPENaCCESS_WR , ifcOPENhOW_nCeO , 0 ) ; ___( pHoseProcessIn ) ;

            }
                hAliasError = hError ;
                hAliasOut = hOut ;
                hAliasIn = hIn ;
                hError.osF( ifcIDtYPEhANDLE_FILE , 2 ) ;
                hOut.osF(   ifcIDtYPEhANDLE_FILE , 1 ) ;
                hIn.osF(    ifcIDtYPEhANDLE_FILE , 0 ) ;
                handleC hError( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                handleC hOut(   tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                handleC hIn(    tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            {
        {
        else if( !ether.strCompareF( tinP , psttType , T("process") ) )
        }
            #endif
                pSgnTapReady->giveF( tinP ) ;
                ether.delF( tinP , psttRM ) ;
                ether.delF( tinP , psttOldCM ) ;
                ether.fileOpenF( tinP , hHoseReply   , fnu2 , psttRM , idAccess , idShare , flOPENdETAILS_FAIL | flOPENdETAILS_WRITEnOW | flOPENdETAILS_TEMPORARY , idOpenHow , 0 , 0 , cOpenTries ) ;
                fnu2 = 0 ;
                ether.fileOpenF( tinP , hHoseCommand , fnu2 , psttOldCM , idAccess , idShare , flOPENdETAILS_FAIL | flOPENdETAILS_WRITEnOW | flOPENdETAILS_TEMPORARY , idOpenHow , 0 , 0 , cOpenTries ) ;
                countT fnu2 = 0 ;
                ether.diskMakeDirIfNeededF( tinP , psttRM ) ;
                ether.diskMakeDirIfNeededF( tinP , psttOldCM ) ;
                ether.delF( tinP , psttR ) ;
                ether.delF( tinP , psttOldC ) ;
                ether.diskMapFileNameF( tinP , psttRM , psttR ) ; ___( psttRM ) ;
                ether.diskMapFileNameF( tinP , psttOldCM , psttOldC ) ; ___( psttOldCM ) ;
                ether.strFuseF( tinP , psttR , psttName ) ; ___( psttR ) ;
                ether.strFuseF( tinP , psttOldC , psttName ) ; ___( psttOldC ) ;
                ether.strMakeF( tinP , LF , psttR , T("///ideafarm/ephemeral/domains/com/ideafarm/tmp/hose/r.") ) ; ___( psttR ) ;
                ether.strMakeF( tinP , LF , psttOldC , T("///ideafarm/ephemeral/domains/com/ideafarm/tmp/hose/c.") ) ; ___( psttOldC ) ;
                ZE( strokeS* , psttRM ) ;
                ZE( strokeS* , psttOldCM ) ;
                ZE( strokeS* , psttR ) ;
                ZE( strokeS* , psttOldC ) ;
                pBatTap->grabF( tinP , TAG( TAGiDnULL ) ) ;
            #elif defined( __NT__ )
                ether.delF( tinP , pstt ) ;
                ether.fileHoseCreateF( tinP , handle , pstt ) ;
                // THE FOLLOWING CALL IS SUPPORTED BY OS2 AND NT BUT -NOT- BY WIN 95
                ether.strFuseF( tinP , pstt , psttName ) ; ___( pstt ) ;
                ether.strMakeF( tinP , LF , pstt , T("/hose/") , psttName ? psttName->idAdam : 0 ) ; ___( pstt ) ;
                ZE( strokeS* , pstt ) ;
            #ifdef __OS2__
            fTap = 1 ;
        {
        else if( !ether.strCompareF( tinP , psttType , T("tap") ) )
        }
            #endif
                ether.delF( tinP , psttRM ) ;
                ether.delF( tinP , psttOldCM ) ;
                ether.fileOpenF( tinP , hHoseReply   , fnu2 , psttRM , idAccess , idShare , flOPENdETAILS_FAIL | flOPENdETAILS_WRITEnOW | flOPENdETAILS_TEMPORARY , idOpenHow , 0 , 0 , cOpenTries ) ;
                fnu2 = 0 ;
                ether.fileOpenF( tinP , hHoseCommand , fnu2 , psttOldCM , idAccess , idShare , flOPENdETAILS_FAIL | flOPENdETAILS_WRITEnOW | flOPENdETAILS_TEMPORARY , idOpenHow , 0 , 0 , cOpenTries ) ;
                countT fnu2 = 0 ;
                ether.diskMakeDirIfNeededF( tinP , psttRM ) ;
                ether.diskMakeDirIfNeededF( tinP , psttOldCM ) ;
                ether.delF( tinP , psttR ) ;
                ether.delF( tinP , psttOldC ) ;
                ether.diskMapFileNameF( tinP , psttRM , psttR ) ; ___( psttRM ) ;
                ether.diskMapFileNameF( tinP , psttOldCM , psttOldC ) ; ___( psttOldCM ) ;
                ether.strFuseF( tinP , psttR , psttName ) ; ___( psttR ) ;
                ether.strFuseF( tinP , psttOldC , psttName ) ; ___( psttOldC ) ;
                ether.strMakeF( tinP , LF , psttR , T("///ideafarm/ephemeral/domains/com/ideafarm/tmp/hose/r.") ) ; ___( psttR ) ;
                ether.strMakeF( tinP , LF , psttOldC , T("///ideafarm/ephemeral/domains/com/ideafarm/tmp/hose/c.") ) ; ___( psttOldC ) ;
                ZE( strokeS* , psttRM ) ;
                ZE( strokeS* , psttOldCM ) ;
                ZE( strokeS* , psttR ) ;
                ZE( strokeS* , psttOldC ) ;
                pSgnTapReady->waitF( tinP ) ;
                pBatHose->grabF( tinP , TAG( TAGiDnULL ) ) ;
            #elif defined( __NT__ )
                ether.fileOpenF( tinP , handle , fnu , psttAll , idAccess , idShare , flOPENdETAILS_FAIL | flOPENdETAILS_LOCsEQ , idOpenHow , 0 , 0 , cOpenTries ) ;
                flagsT fnu = 0 ;
            #ifdef __OS2__
        {
        if( !ether.strCompareF( tinP , psttType , T("hose") ) )
    {
    else if( !psttHost->idAdam )
    }
    {
    else if( !ether.strCompareF( tinP , psttType , T("fyle") ) )
    }
        }
            }
                verifyReplyF( tinP , 211 ) ;
                { textC txt = T("group ")+T(psttName)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }
            {
            if( psttName->idAdam )

            verifyReplyF( tinP , 200 ) ; //U: VERIFY THAT STRING CONTAINS "(posting ok)"
            pSControl->connectF( tinP , /*port 119*/idPort , hidIfo , cOpenTries ) ;
            }
                __1
                ether.strokeF( tinP , T("Could not get nicName for \"")+T(psttHost)+T("\"\r\n") ) ;
            {
            if( !hidIfo )
            nicNameC hidIfo = socketC::nicNameIF( tinP , ether , psttHost->idAdam ? psttHost : 0 ) ;
        {
        if( !POOP )

        __Z( pSControl ) ;
        pSControl = new( 0 , tinP , LF ) socketC( tinP , ether , TAG( TAGiDnULL ) ) ; ___( pSControl ) ;
    {
    else if( psttHost->idAdam && !ether.strCompareF( tinP , psttType , T("news") ) )
    }
        }
            verifyReplyF( tinP ) ;
            { textC txt = T("pass ") + T(psttPass) + T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }

            verifyReplyF( tinP ) ;
            { textC txt = T("user ") + T(psttUser) + T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }

            verifyReplyF( tinP ) ;
            pSControl->connectF( tinP , /*port 110*/idPort , hidIfo , cOpenTries ) ;
            nicNameC hidIfo = socketC::nicNameIF( tinP , ether , psttHost->idAdam ? psttHost : 0 ) ;
        {
        if( !POOP )

        __Z( pSControl ) ;
        pSControl = new( 0 , tinP , LF ) socketC( tinP , ether , TAG( TAGiDnULL ) ) ; ___( pSControl ) ;
    {
    else if( psttHost->idAdam && !ether.strCompareF( tinP , psttType , T("pop") ) )
    }
        }
            while( bNoQuitEarly || ( cDo && -- cDo ) ) ;
            }
                }
                    }
                        ++ s ; ether.osSleepF( tinP ) ; //U::20190903@2353: CALLING THIS WHEN ether IS IMPOTENT
                        ether.traceF( tinP , T("boxC::boxC / http / after trying all ip addresses, napping for a wink [cNicName]: ")+TF2(cNicName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( bNoQuitEarly || cDo > 1 )

                    //ether.traceF( tinP , tSay ) ;
                    //else           tSay = T("boxC::boxC / http / could not obtain a dns list [psttHost]: ")+T(psttHost) ;
                    //if( cNicName ) tSay = T("boxC::boxC / http / no hosts responded [cNicName]: ")+TF2(cNicName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
                    //TN( tSay , "" ) ;
                {
                if( !pSControl )

                if( bConnected ) break ;

                }
                    tinP.pEtScratch->delF( tinP , pNicName ) ;

                    }
                        }
                            }
                                DEL( pSControl ) ;
                                POOPRqUIET
                            {
                            else
                            }
                                break ;
                                bConnected = 1 ;
                                pSControl->etherF( tinP , ether ) ;
                                //ether.traceF( tinP , T("boxC::boxC / http / connected [nn]: ")+T(pNicName[offi]) ) ;
                            {
                            if( !POOP )

                            //ether.traceF( tinP , T("boxC::boxC / [idpMe,nnMe]:    ")+TF2(idpMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(nnMe) ) ;

                            if( !POOP ) pSControl->myNameF( tinP , idpMe , nnMe ) ;
                            nicNameC nnMe ;
                            ZE( countT , idpMe ) ;

                            if( !POOP ) pSControl->connectF( tinP , idPort , pNicName[ offi ] , 1 ) ;

                            __Z( pSControl ) ;

                            pSControl = new( 0 , tinP , LF ) socketC( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , 0 , bHttps ? flSOCKETc_CRYPTfOREIGNsSL : flSOCKETc_null , 0 , countTC( timeAllowed1 ) , countTC( timeAllowed1 ) , countTC( timeAllowed1 ) ) ; ___( pSControl ) ;
                        {
                        for( countT offi = 0 ; offi < cNicName ; offi ++ )
                    {
                    else
                    if( POOP ) { POOPRqUIET ; }

                    __Z( cNicName ) ;
                    __Z( pNicName ) ;
                    socketC::nicNameIF( tinP , *tinP.pEtScratch , pNicName , cNicName , psttHost->idAdam ? psttHost : 0 ) ; ___( pNicName ) ;
                    ZE( nicNameC* , pNicName ) ;
                    SCOOPS
                {
                IFsCRATCH
                ZE( countT , cNicName ) ;
                ZE( boolT , bConnected ) ;
            {
            do
            countT cDo = cOpenTries ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;

            boolT bNoQuitEarly = !cOpenTries ;
        {
        if( !POOP )

        const boolT bHttps = !ether.strCompareF( tinP , psttType , T("https") ) ;
    {
    else if( !ether.strCompareF( tinP , psttType , T("http") ) ||  !ether.strCompareF( tinP , psttType , T("https") ) )
    }
    {
    else if( !ether.strCompareF( tinP , psttType , T("smtp") ) )
    }
        }
            verifyReplyF( tinP , 200 ) ;
                pSControl->writeF( tinP , (osTextT*)T("type i\r\n") ) ;

            verifyReplyF( tinP , 230 ) ;
            { textC txt = T("pass ") + T(psttPass) + T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }

            verifyReplyF( tinP , 331 ) ;
            { textC txt = T("user ") + T(psttUser) + T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }

            verifyReplyF( tinP , 220 ) ;
            pSControl->connectF( tinP , /*port ifcPORToLD1fTP*/idPort , hidIfo , cOpenTries ) ;
            nicNameC hidIfo = socketC::nicNameIF( tinP , ether , psttHost->idAdam ? psttHost : 0 ) ;
        {
        if( !POOP )

        __Z( pSControl ) ;
        pSControl = new( 0 , tinP , LF ) socketC( tinP , ether , TAG( TAGiDnULL ) ) ; ___( pSControl ) ;
    {
    else if( !ether.strCompareF( tinP , psttType , T("ftp") ) )
    }

        }
            pSControl->writeF( tinP , (byteT*)&idOs , sizeof idOs ) ;

            #endif
                countT idOs = 2 ;
            #elif defined( __NT__ )
                countT idOs = 1 ;
            #if defined( __OS2__ )

            pSControl->connectF( tinP , /*ifcPORToLD1dISPATCHER*/idPort , ether.sockNicNameF( tinP , psttHost->idAdam ? psttHost : 0 ) , cOpenTries ) ;
        {
        if( !POOP )

        __Z( pSControl ) ;
        pSControl = new( 0 , tinP , LF ) socketC( tinP , ether , TAG( TAGiDnULL ) ) ; ___( pSControl ) ;
    {
    else if( !ether.strCompareF( tinP , psttHost , T(WWWiDEAFARMcOM) ) &&  !ether.strCompareF( tinP , psttType , T("dispatcher") ) )
    }

        if( !POOP ) pSControl->connectF( tinP , /*ifcPORToLD1tIMEaUTHORITY*/idPort , ether.sockNicNameF( tinP , psttHost->idAdam ? psttHost : 0 ) , cOpenTries ) ;

        __Z( pSControl ) ;
        pSControl = new( 0 , tinP , LF ) socketC( tinP , ether , TAG( TAGiDnULL ) ) ; ___( pSControl ) ;
    {
    else if( !ether.strCompareF( tinP , psttHost , T(WWWiDEAFARMcOM) ) &&  !ether.strCompareF( tinP , psttType , T("time") ) )
    }

        if( !POOP ) pSControl->connectF( tinP , /*ifcPORToLD1bOXsUCKER*/idPort , ether.sockNicNameF( tinP , psttHost->idAdam ? psttHost : 0 ) , cOpenTries ) ;

        __Z( pSControl ) ;
        pSControl = new( 0 , tinP , LF ) socketC( tinP , ether , TAG( TAGiDnULL ) ) ; ___( pSControl ) ;
    {
    else if( !ether.strCompareF( tinP , psttType , T("box.sucker") ) )
    }
        }
            }
                }
                    if( !POOP ) pSControl->connectF( tinP , /*ifcPORToLD1bOXsERVER*/idPort , ether.sockNicNameF( tinP , psttHost->idAdam ? psttHost : 0 ) , cOpenTries ) ;
                    __Z( pSControl ) ;
                    pSControl = new( 0 , tinP , LF ) socketC( tinP , ether , TAG( TAGiDnULL ) ) ; ___( pSControl ) ;
                    DEL( pSControl ) ;
                    ether = 0 ;
                {
                if( POOP )
                pSControl->connectF( tinP , /*pidBoxServer*/idPort , hidBoxServer , cOpenTries ) ;
            {
            if( !POOP )

            __Z( pSControl ) ;
            pSControl = new( 0 , tinP , LF ) socketC( tinP , ether , TAG( TAGiDnULL ) ) ; ___( pSControl ) ;
        {
        if( !POOP )

        #endif
        }
            pidBoxServer = ifcPORToLD1bOXsERVER ;
            hidBoxServer = ether.sockNicNameF( tinP , psttHost->idAdam ? psttHost : 0 ) ;
            //U: 19971122.1715: DISABLE USE OF DEPUTY HERE CAUSE DOESN'T WORK AND DON'T KNOW WHY (I AM "COLD" ON THIS CODE NOW. DEFER THIS TILL I BECOME FAMILIAR WITH IT AGAIN.)

            }
                ether.delF( tinP , pbin ) ;
                }
                    pidBoxServer = ifcPORToLD1bOXsERVERdEPUTY ;
                    hidBoxServer = *(sCountT*)pbin ;
                {
                if( !ether && pbin && cbin == 2 * sizeof( countT ) )
                ether.boxGetShadowF( tinP , pbin , cbin , T(psttHost)+T("///dispatcher") ) ; ___( pbin ) ;
                ZE( countT , cbin ) ;
                ZE( byteT* , pbin ) ;
            {
            if( 1 == ether.strIdF( tinP , idf , sttq , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/7use/") , psttName ) )
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        #if defined( NEVERdEFINED )
        //U: ENABLE AS PART OF ENABLING DISPATCHER FUNCTION (TO USE DEPUTY BOX SERVERS)
        //countT pidBoxServer = ifcPORToLD1bOXsERVER ;
        countT hidBoxServer = ether.sockNicNameF( tinP , psttHost->idAdam ? psttHost : 0 ) ;
    {
    else if( !ether.strCompareF( tinP , psttType , T("box.server.deputy") ) )
    }
        }
            if( !POOP ) pSControl->connectF( tinP , /*ifcPORToLD1bOXsERVER*/idPort , ether.sockNicNameF( tinP , psttHost->idAdam ? psttHost : 0 ) , cOpenTries ) ;

            __Z( pSControl ) ;
            pSControl = new( 0 , tinP , LF ) socketC( tinP , ether , TAG( TAGiDnULL ) ) ; ___( pSControl ) ;
        {
        if( !POOP )
    {
    if( !ether.strCompareF( tinP , psttType , T("box.server") ) || !ether.strCompareF( tinP , psttType , T("box.server.adam") ) )
    // OPEN THE BACKING FILE

    }
        pSgnTapFinished  = new( 0 , tinP , LF ) signC( tinP , TAG( TAGiDnULL ) , T("sgnTapFinished" ) ) ; ___( pSgnTapFinished  ) ;
        pSgnTapReady     = new( 0 , tinP , LF ) signC( tinP , TAG( TAGiDnULL ) , T("sgnTapReady"    ) ) ; ___( pSgnTapReady     ) ;
        pSgnHoseFinished = new( 0 , tinP , LF ) signC( tinP , TAG( TAGiDnULL ) , T("sgnHoseFinished") ) ; ___( pSgnHoseFinished ) ;

        pBatHPR  = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) , T("bhpr"     ) ) ; ___( pBatHPR  ) ;
        pBatHPC  = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) , T("bhpc"     ) ) ; ___( pBatHPC  ) ;
        pBatTap  = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) , T("batonTap" ) ) ; ___( pBatTap  ) ;
        pBatHose = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) , T("batonHose") ) ; ___( pBatHose ) ;
    {
    if( psttType && ( !ether.strCompareF( tinP , psttType , T("hose") ) || !ether.strCompareF( tinP , psttType , T("tap") ) ) )

    if( POOP ) return ;
    __Z( psttName ) ;
    __Z( psttType ) ;
    __Z( psttHost ) ;
    if( POOP ) return ;

    if( !idShare  ) idShare  = ifcOPENsHARE_WR ;
    if( !idOpenHow   ) idOpenHow   = ifcOPENhOW_nFeO ;
    if( !idAccess ) idAccess = ifcOPENaCCESS_R ;
    countT idShare  = idShareP ;
    countT idOpenHow   = idOpenHowP ;
    countT idAccess = idAccessP ;

    else      { ether.strMakeF( tinP , LF , psttName , T("") ) ; ___( psttName ) ; }
    if( idf ) { ether.strSubstringF( tinP , psttName , idf , idLathI , psttAll ) ; ___( psttName ) ; }

    }
        if( psttPass && !psttPass->idAdam ) { ether.strFuseF( tinP , psttPass , tInfo ) ; ___( psttPass ) ; }
        if( psttUser && !psttUser->idAdam ) { ether.strFuseF( tinP , psttUser , tAnon ) ; ___( psttUser ) ; }
        ether.strSubstringF( tinP , psttPass , idf , sttq , S1C('/') , psttAll , tInfo.csF( tinP ) ) ; ___( psttPass ) ;
        ether.strSubstringF( tinP , psttUser , idf , sttq , S1C('/') , psttAll , tAnon.csF( tinP ) ) ; ___( psttUser ) ;
        TN( tInfo , ifcEMAIL_WEBsITEcONTACT ) ;
        TN( tAnon , "anonymous" ) ;
        }
            __1
            if( !( F(ether.flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) ) ether.etherPutLogF( tinP , psttAll ) ;
        {
        if( !idf )
    {
    )
        )
            !ether.strCompareF( tinP , psttType , T("pop") )
            !ether.strCompareF( tinP , psttType , T("ftp") ) ||
        (
        psttHost->idAdam && 
        psttHost &&
    ( 
    if

    }
        else if( !ether.strCompareF( tinP , psttType , T("dispatcher"       ) ) ) idPort = ifcPORToLD1dISPATCHER    ;
        else if( !ether.strCompareF( tinP , psttType , T("time"             ) ) ) idPort = ifcPORToLD1tIMEaUTHORITY ;
        else if( !ether.strCompareF( tinP , psttType , T("box.sucker"       ) ) ) idPort = ifcPORToLD1bOXsUCKER     ;
        else if( !ether.strCompareF( tinP , psttType , T("box.server.adam"  ) ) ) idPort = ifcPORToLD1bOXsERVERaDAM ;
        else if( !ether.strCompareF( tinP , psttType , T("box.server.deputy") ) ) idPort = ifcPORToLD1bOXsERVER     ;
        else if( !ether.strCompareF( tinP , psttType , T("box.server"       ) ) ) idPort = ifcPORToLD1bOXsERVER     ;
        else if( !ether.strCompareF( tinP , psttType , T("news"             ) ) ) idPort = 119 ;
        else if( !ether.strCompareF( tinP , psttType , T("pop"              ) ) ) idPort = 110 ;
        else if( !ether.strCompareF( tinP , psttType , T("https"            ) ) ) idPort = 443 ;
        else if( !ether.strCompareF( tinP , psttType , T("http"             ) ) ) idPort =  80 ;
        else if( !ether.strCompareF( tinP , psttType , T("smtp"             ) ) ) idPort =  25 ;
             if( !ether.strCompareF( tinP , psttType , T("ftp"              ) ) ) idPort = ifcPORToLD1fTP ;
    {
    if( !idPort && psttType && (countT)*psttType )

    }
        ether.strMakeF( tinP , LF , psttType , T("fyle") ) ; ___( psttType ) ;
        ether.strMakeF( tinP , LF , psttHost , T("") ) ; ___( psttHost ) ;
        ether.delF( tinP , psttType ) ;
        ether.delF( tinP , psttHost ) ;
    {
    if( !ether.strCompareF( tinP , psttHost , T("fyles") ) )

    ether.strSubstringF( tinP , psttType , idf , sttq , S1C('/') , psttAll ) ; ___( psttType ) ;

    }
        __1
        if( !( F(ether.flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) ) ether.etherPutLogF( tinP , psttAll ) ;
    {
    if( !idf )
    }
        ether.delF( tinP , psttPort ) ;
        if( psttPort && (countT)*psttPort ) idPort = ether.strDigitsToSCountF( tinP , psttPort ) ;
        ether.strSubstringF( tinP , psttPort , idf , sttq , S1C('/') , psttAll ) ; ___( psttPort ) ;
        ZE( strokeS* , psttPort ) ;
    {

    }
        __1
        if( !( F(ether.flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) ) ether.etherPutLogF( tinP , psttAll ) ;
    {
    if( !idf )

    ether.strSubstringF( tinP , psttHost , idf , sttq , S1C('/') , psttAll ) ; ___( psttHost ) ;
    ether.strMakeF( tinP , LF , psttAll , psttP ) ; ___( psttAll ) ;

    ZE( countT , idLathI ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    countT idf = 1 ;
    _IO_

    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
timeAllowed2( timeAllowed2P )
timeAllowed1( timeAllowed1P ) ,
flagsOpenDetails( flagsOpenDetailsP ) ,
cOpenTries( cOpenTriesP ) ,
pBatHPR( 0 ) ,
pBatHPC( 0 ) ,
pBatTap( 0 ) ,
pBatHose( 0 ) ,
pSgnTapFinished( 0 ) ,
pSgnTapReady( 0 ) ,
pSgnHoseFinished( 0 ) ,
pSControl( 0 ) ,
psttName( 0 ) ,
psttPass( 0 ) ,
psttUser( 0 ) ,
psttType( 0 ) ,
idPort( 0 ) ,
psttHost( 0 ) ,
psttAll( 0 ) ,
pid( 0 ) ,
pHoseProcessError( 0 ) ,
pHoseProcessOut( 0 ) ,
pHoseProcessIn( 0 ) ,
pbNapkin( 0 ) ,
hHoseReply( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_PIPE ) ,
hHoseCommand( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_PIPE ) ,
hAliasError( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ,
hAliasOut( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ,
hAliasIn( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ,
handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) , //U::CONJ: FOR SOME BOX TYPES THIS HANDLE TYPE IS WRONG
fTap( 0 ) ,
poop( etherP ) ,
ether( etherP ) ,
/*1*/boxC::boxC( tinS& tinP , etherC& etherP , const strokeS* const psttP , const countT idAccessP , const countT idOpenHowP , const countT idShareP , const countT cOpenTriesP , countT timeAllowed1P , const sCountT timeAllowed2P , const flagsT flagsOpenDetailsP )/*1*/ :

/**/
*/
  if not 0 then will try cOpenTriesP times
  if 0 then will retry forever
 cOpenTriesP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010016.ifcOPENsHARE!||
 idShareP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010014.ifcOPENhOW!||
 idOpenHowP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010015.ifcOPENaCCESS!||
 idAccessP
 psttP
 etherP
arguments
  name must be of the form "n.n.n.n. ..." where each "n" is a countT value
 fyles///name: specifies a fyle in the (distributed) IdeaFarm " "(tm) City fyles subsystem
  if idShare is ze, ifcOPENsHARE_WR is implied
  if idOpenHowP is ze, ifcOPENhOW_nFeO is implied
  if idAccessP is ze, ifcOPENaCCESS_R is implied
   users might be given the ability to prevent usage of boxes of this form
   this form might become illegal
   this will work, but usage of this form is discouraged
  psttP example: T("///c" "/my.directory/my.file.name")
  subdirectories will be created as needed
  psttP example: T("///ideafarm/ephemeral/domains/my.domain/my.directory/my.file.name")
  psttP example: T("///ideafarm/ephemeral/domains/my.domain/my.file.name")
 ///name: specifies a local file
 //napkin: specifies a napkin created by another box in this or another local process
 //napkin.make: specifies a napkin to be created now
 //tap/name: specifies the server end of a hose
 //hose/name: specifies the client end of a hose
 www.ideafarm.com//time: specifies the reference time at city center
 host//news: specifies a news server
 host//http: specifies an http server
  host is optional and should usually be omitted
 host//smtp: specifies an smtp server (not a file)
  if password is ze length, "info@" "ideafarm.com" is implied
  if user is ze length, "anonymous" is implied
 host//pop/user/password/name: specifies a file on a host with a pop server
  if password is ze length, "info@" "ideafarm.com" is implied
  if user is ze length, "anonymous" is implied
 host//ftp/user/password/name: specifies a file on a host with an ftp server
there are several kinds of boxes
 "getting" gets all bytes that are in the box
 "putting" fills a presumably empty box
the contents of a box are handled as a unit, normally
constructs a box that can store bytes
  \<A HREF=\"5.4120104.1.1.0.html\"\>4120104:  WAKEsHOW( "example.simplest.func.1090001.boxC.boxC" )\</A\>
 simplest
examples
\<A HREF=\"5.1090001.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

