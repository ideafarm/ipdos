
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                    
REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    etThread.delF( tinP , postRpt ) ;
    etThread.boxPutF( tinP , T("///ideafarm/ephemeral/reports/rpt.inOutFrameC.time.ttt") , postRpt , costRpt ) ;

    etThread.delF( tinP , psttRpt ) ;
    countT costRpt = etThread.strMakeF( tinP , LF , postRpt , psttRpt ) ; ___( postRpt ) ;
    ZE( osTextT* , postRpt ) ;

    }
        etThread.delF( tinP , psttl ) ;
        etThread.strFuseF( tinP , psttRpt , psttl ) ;
        stRpt >> psttl ;
        ZE( strokeS* , psttl ) ;
    {
    while( stRpt )
    etThread.strMakeF( tinP , LF , psttRpt , tRptPrefix , csttRptBody ) ; ___( psttRpt ) ;
    TN( tRptPrefix , "{\r\n    IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System\r\n\r\n    inOutFrameC Telemetry Report: Time\r\n\r\n    To generate telemetry for this report, set flTHREADmODE4_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY.\r\n}\r\n" ) ;
    ZE( strokeS* , psttRpt ) ;    

    }
        }
            }
                stRpt.sinkF( tinP , countTC() , psttl ) ;
                csttRptBody += psttl->idAdam ;
                etThread.strMakeF( tinP , LF , psttl , tSay ) ; ___( psttl ) ;
                ZE( strokeS* , psttl ) ;

                ;

                    +tcr
                    +tb4+TF3(pczFL[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF2(pczFL[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postTitle)
                    +tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T(" %")
                    +tDot+TF3(((countT*)&cTimeNet)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)
                    TF3(((countT*)&cTimeNet)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)

                TN( tSay , "" ) ; tSay =

                countT perTuck = (countT)( TUCK * cTimeNet / cTimeNetGrandTotal ) ;

                }
                    if( postTitle ) postTitle += sizeof( countT ) ;
                    if( idFile ) postTitle = mapFileTitle( idFile ) ;
                    countT idFile = source.idFileRankF( tinP , pczFL[ 0 ] ) ;
                {
                if( pczFL[ 0 ] )
                ZE( const osTextT* , postTitle ) ;
            {
            else
            }
                if( cTimeNetGrandTotal < was ) { BLAMMO ; }
                cTimeNetGrandTotal += cTimeNet ;
                count04T was = cTimeNetGrandTotal ;
            {
            if( idPass == 1 )

            count04T& cTimeNet = *(count04T*)&(countT&)swTime ;

            pczFL = (countT*)swTime.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swTime.cFlavorsF( tinP ) ;
    {
    for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
    ZE( count04T , cTimeNetGrandTotal ) ;
    ZE( countT , csttRptBody ) ;

    stackC stRpt( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKrEVERSE , ifcSTACKtYPE_PTR_strokeS ) ;

    etThread.traceF( tinP , T("net wall time consumption") ) ;
{

}
    etThread.delF( tinP , postRpt ) ;
    etThread.boxPutF( tinP , T("///ideafarm/ephemeral/reports/rpt.inOutFrameC.cpu.ttt") , postRpt , costRpt ) ;

    etThread.delF( tinP , psttRpt ) ;
    countT costRpt = etThread.strMakeF( tinP , LF , postRpt , psttRpt ) ; ___( postRpt ) ;
    ZE( osTextT* , postRpt ) ;

    }
        etThread.delF( tinP , psttl ) ;
        etThread.strFuseF( tinP , psttRpt , psttl ) ;
        stRpt >> psttl ;
        ZE( strokeS* , psttl ) ;
    {
    while( stRpt )
    etThread.strMakeF( tinP , LF , psttRpt , tRptPrefix , csttRptBody ) ; ___( psttRpt ) ;
    TN( tRptPrefix , "{\r\n    IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System\r\n\r\n    inOutFrameC Telemetry Report: Cpu\r\n\r\n    To generate telemetry for this report, set flTHREADmODE4_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY.\r\n}\r\n" ) ;
    ZE( strokeS* , psttRpt ) ;

    }
        }
            }
                stRpt.sinkF( tinP , countTC() , psttl ) ;
                csttRptBody += psttl->idAdam ;
                etThread.strMakeF( tinP , LF , psttl , tSay ) ; ___( psttl ) ;
                ZE( strokeS* , psttl ) ;

                ;

                    +tcr
                    +tb4+TF3(pczFL[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF2(pczFL[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postTitle)
                    +tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T(" %")
                    +tDot+TF3(((countT*)&cCpuNet)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)
                    TF3(((countT*)&cCpuNet)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)

                TN( tSay , "" ) ; tSay =

                countT perTuck = (countT)( TUCK * cCpuNet / cCpuNetGrandTotal ) ;

                }
                    if( postTitle ) postTitle += sizeof( countT ) ;
                    if( idFile ) postTitle = mapFileTitle( idFile ) ;
                    countT idFile = source.idFileRankF( tinP , pczFL[ 0 ] ) ;
                {
                if( pczFL[ 0 ] )
                ZE( const osTextT* , postTitle ) ;
            {
            else
            }
                if( cCpuNetGrandTotal < was ) { BLAMMO ; }
                cCpuNetGrandTotal += cCpuNet ;
                count04T was = cCpuNetGrandTotal ;
            {
            if( idPass == 1 )

            count04T& cCpuNet = *(count04T*)&(countT&)swCpu ;

            pczFL = (countT*)swCpu.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swCpu.cFlavorsF( tinP ) ;
    {
    for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
    ZE( count04T , cCpuNetGrandTotal ) ;
    ZE( countT , csttRptBody ) ;

    stackC stRpt( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKrEVERSE , ifcSTACKtYPE_PTR_strokeS ) ;

    etThread.traceF( tinP , T("net cpu consumption") ) ;
{

}
    etThread.delF( tinP , postRpt ) ;
    etThread.boxPutF( tinP , T("///ideafarm/ephemeral/reports/rpt.inOutFrameC.tally.ttt") , postRpt , costRpt ) ;

    etThread.delF( tinP , psttRpt ) ;
    countT costRpt = etThread.strMakeF( tinP , LF , postRpt , psttRpt ) ; ___( postRpt ) ;
    ZE( osTextT* , postRpt ) ;

    }
        etThread.delF( tinP , psttl ) ;
        etThread.strFuseF( tinP , psttRpt , psttl ) ;
        stRpt >> psttl ;
        ZE( strokeS* , psttl ) ;
    {
    while( stRpt )
    etThread.strMakeF( tinP , LF , psttRpt , tRptPrefix , csttRptBody ) ; ___( psttRpt ) ;
    TN( tRptPrefix , "{\r\n    IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System\r\n\r\n    inOutFrameC Telemetry Report: Tallies\r\n\r\n    To generate telemetry for this report, set flTHREADmODE4_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY.\r\n}\r\n" ) ;
    ZE( strokeS* , psttRpt ) ;    

    }
        }
            stRpt.sinkF( tinP , countTC() , psttl ) ;
            csttRptBody += psttl->idAdam ;
            etThread.strMakeF( tinP , LF , psttl , TF3((countT)swTally,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,8)+tb4+TF3(pczFL[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF2(pczFL[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postTitle)+tcr ) ; ___( psttl ) ;
            ZE( strokeS* , psttl ) ;

            }
                if( postTitle ) postTitle += sizeof( countT ) ;
                if( idFile ) postTitle = mapFileTitle( idFile ) ;
                countT idFile = source.idFileRankF( tinP , pczFL[ 0 ] ) ;
            {
            if( pczFL[ 0 ] )
            ZE( const osTextT* , postTitle ) ;

            pczFL = (countT*)swTally.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swTally.cFlavorsF( tinP ) ;
    {
    ZE( countT , csttRptBody ) ;

    stackC stRpt( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKrEVERSE , ifcSTACKtYPE_PTR_strokeS ) ;

    etThread.traceF( tinP , T("tallies") ) ;
{

sourceC& source = sourceC::sourceIF() ;
mapCTC& mapFileTitle = processGlobal3S::_processGlobal3I_IF().mapFileTitle ;

etThread.traceF( tinP , tSayWorkPerWatch , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , tSayBookPer , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , tSayBook    , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , tSayCtDt    , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , tSayDt      , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , tSayInNet   , flTRACE_NOpREFIX ) ;
//MEANINGLESS: etThread.traceF( tinP , tSayInGross , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , tSayCt      , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , T("cBook            :    ")+TF2(cBook,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , T("cArrayPacketsMax :    ")+TF2(cArrayPacketsMax ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_NOpREFIX ) ;

;
    +tDot+TF3(((countT*)&cCpuCyclesWorkPerWatch)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesWorkPerWatch)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayWorkPerWatch , "cCpuCyclesWorkPerWatch: " ) ; tSayWorkPerWatch +=

;
    +tDot+TF3(((countT*)&cCpuCyclesBookPer)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesBookPer)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayBookPer      , "cCpuCyclesBookPer     : " ) ; tSayBookPer +=

;
    +tDot+TF3(((countT*)&cCpuCyclesBook)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesBook)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayBook         , "cCpuCyclesBook        : " ) ; tSayBook +=

;
    +tDot+TF3(((countT*)&cCpuCyclesCtDt)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesCtDt)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayCtDt         , "cCpuCyclesCtDt        : " ) ; tSayCtDt +=

;
    +tDot+TF3(((countT*)&cCpuCyclesDt)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesDt)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayDt           , "cCpuCyclesDt          : " ) ; tSayDt +=

;
    +tDot+TF3(((countT*)&cCpuCyclesInNet)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesInNet)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayInNet        , "cCpuCyclesInNet       : " ) ; tSayInNet +=

;
    +tDot+TF3(((countT*)&cCpuCyclesInGross)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesInGross)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayInGross      , "cCpuCyclesInGross     : " ) ; tSayInGross +=

;
    +tDot+TF3(((countT*)&cCpuCyclesCt)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesCt)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayCt           , "cCpuCyclesCt          : " ) ; tSayCt +=

count04T cCpuCyclesWorkPerWatch = !cCpuCyclesWatch ? 0 : cCpuCyclesInNet / cCpuCyclesWatch ;
count04T cCpuCyclesWatch = cCpuCyclesCtDt + cCpuCyclesBook ;
count04T cCpuCyclesCtDt = cCpuCyclesCt + cCpuCyclesDt ;

count04T cCpuCyclesBookPer = !cBook ? 0 : cCpuCyclesBook / cBook ;

}
    //etThread.traceF( tinP , T("tmEatTelemetrySysF / 6") ) ;
    }
        //CONoUTrAW( "." ) ;
        ++ s ; etThread.osSleepF( tinP , TOCK >> 2 ) ;
        TELL( "napping for a quarter tock" )

        if( bQuitEating ) break ;
        }
            bBookHead = !bBookHead ;
    
            }
                else          pbi = 0 ;
                if( bDelete ) PUSE( tinP , *(byteT**)&pbi ) ;
                TELL( "maybe deleting hamburger" )
    
                }
                    // /*if( idCycle == TUCK << 0 )*/ bQuitEating = 1 ;
    
                    cbi = sizeof( telemetryBookHeadS ) ;
    
                    }
                        }
                            }
                                break ;

                                }
                                    }
                                        *(count04T*)&(countT&)swTime += note.dTimeInNet      ;
                                        *(count04T*)&(countT&)swCpu  += note.dCpuCyclesInNet ;
                                        swTally ++ ;

                                        pczLever[ 1 ] = note.idLineInOut ;
                                        pczLever[ 0 ] = note.idiFileInOut ;

                                        if( cCpuCyclesDt < was ) { BLAMMO ; }
                                        cCpuCyclesDt += note.dCpuCyclesDt ;
                                        was = cCpuCyclesDt ;

                                        if( cCpuCyclesInNet < was ) { BLAMMO ; }
                                        cCpuCyclesInNet += note.dCpuCyclesInNet ;
                                        was = cCpuCyclesInNet ;

                                        if( cCpuCyclesInGross < was ) { BLAMMO ; }
                                        cCpuCyclesInGross += note.dCpuCyclesIn ;
                                        was = cCpuCyclesInGross ;

                                        if( cCpuCyclesCt < was ) { BLAMMO ; }
                                        cCpuCyclesCt += note.dCpuCyclesCt ;
                                        /*static*/ count04T was ; was = cCpuCyclesCt ;

#endif
#if defined( NEVERdEFINED )

#endif

                                        etThread.traceF( tinP , tSay , flTRACE_NOpREFIX ) ;

                                        ;

                                            +tDot+TF3(((countT*)&note.dCpuCyclesDt)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb4 +TF3(((countT*)&note.dCpuCyclesDt)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tDot+TF3(((countT*)&note.dCpuCyclesInNet)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb4 +TF3(((countT*)&note.dCpuCyclesInNet)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tDot+TF3(((countT*)&note.dCpuCyclesIn)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb4 +TF3(((countT*)&note.dCpuCyclesIn)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tDot+TF3(((countT*)&note.dCpuCyclesCt)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb4 +TF3(((countT*)&note.dCpuCyclesCt)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb8 +T("Ct In InNet Dt:")

                                            +tDot+TF3(((countT*)&note.cCpuCycles4)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb4 +TF3(((countT*)&note.cCpuCycles4)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tDot+TF3(((countT*)&note.cCpuCycles3)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb4 +TF3(((countT*)&note.cCpuCycles3)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tDot+TF3(((countT*)&note.cCpuCycles2)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb4 +TF3(((countT*)&note.cCpuCycles2)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tDot+TF3(((countT*)&note.cCpuCycles1)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb4 +TF3(((countT*)&note.cCpuCycles1)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb8 +T("1 2 3 4:")

                                            +tDot+TF3(((countT*)&note.cTime4)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb4 +TF3(((countT*)&note.cTime4)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tDot+TF3(((countT*)&note.cTime3)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb4 +TF3(((countT*)&note.cTime3)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tDot+TF3(((countT*)&note.cTime2)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb4 +TF3(((countT*)&note.cTime2)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tDot+TF3(((countT*)&note.cTime1)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                            +tb4 +TF3(((countT*)&note.cTime1)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)

                                            +tb4+TF3(told.idiFileTalking,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF2(told.idLineTalking,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                            +tb4+TF3(note.cDadLevels,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)
                                            +tb4+TF3(told.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)
                                            +TF3(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)

                                        TN( tSay , "" ) ; tSay = tn

#if defined( NEVERdEFINED )

                                        tellInfoAppInOutFrameS& note = pPackets[ offi ] ;
                                    {
                                    for( countT offi = 0 ; offi < cPackets ; offi ++ )
                                {
                                if( told.cbNote == cbExpected )

                                ;
                                    :                               sizeof( tellInfoAppInOutFrameS )
                                    ? sizeof( countT ) + cPackets * sizeof( tellInfoAppInOutFrameS )
                                /*static*/ countT cbExpected = bArray

                                ;
                                    : (tellInfoAppInOutFrameS*)  pbNote
                                    ? (tellInfoAppInOutFrameS*)( pbNote + sizeof( countT ) )
                                /*static*/ tellInfoAppInOutFrameS* pPackets = bArray

                                //etThread.traceF( tinP , T(bArray?"INoUTaRRAY    ":"INoUT    ")+(bArray?TF2(cPackets,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED):T("")) ) ;

                                if( bArray && cArrayPacketsMax < cPackets ) cArrayPacketsMax = cPackets ;

                                }
                                    countT foo = 2 ;
                                {
                                if( !cPackets )         //U:: TO FIND A BUG

                                ;
                                    : 1
                                    ? *(countT*)pbNote
                                /*static*/ countT cPackets = bArray

                                //CONoUTrAW( bArray ? "A" : "." ) ;
                                /*static*/ boolT bArray = told.idType == ifcIDtYPEtELLaPP_INoUTaRRAY ;

                                TELL( "INoUT" )
                            {
                            case ifcIDtYPEtELLaPP_INoUTaRRAY :
                            case ifcIDtYPEtELLaPP_INoUT :
                            }
                                break ;

                                }
                                    etThread.traceF( tinP , T("INoUTtINdT") ) ;

                                    if( cCpuCyclesBook < was ) { BLAMMO ; }
                                    cCpuCyclesBook += note.cCpuCyclesWriteInOutTelemetry ;
                                    count04T was = cCpuCyclesBook ;
                                    cBook += note.cTells ;

                                    //etThread.traceF( tinP , tSay , flTRACE_NOpREFIX ) ;
                                    //
                                    //;
                                    //
                                    //    +tDot+TF3(((countT*)&note.cCpuCyclesWriteInOutTelemetry)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                    //    +tb4 +TF3(((countT*)&note.cCpuCyclesWriteInOutTelemetry)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                    //
                                    //    +tb4+TF3(note.idThreadReporting,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)
                                    //    +tb4+TF3(told.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)
                                    //    +tb4+TF3(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)
                                    //
                                    //TN( tSay , "" ) ; tSay = T(" [idCycle,idThread,cCpuCyclesWriteInOutTelemetry]:    ")

                                    tellInfoAppInOutFrameTinDtS& note = *(tellInfoAppInOutFrameTinDtS*)pbNote ;
                                {
                                if( told.cbNote == sizeof( tellInfoAppInOutFrameTinDtS ) )
                                TELL( "INoUTtINdT" )
                            {
                            case ifcIDtYPEtELLaPP_INoUTtINdT :
                        {
                        switch( told.idType )

                        //}
                        //    etThread.traceF( tinP , T("telemetry [idType]:    ")+(postSay?T(postSay):TF2(told.idType,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)) ) ;
                        //    const osTextT* postSay = ps3.mapSay( told.idType ) ;
                        //    processGlobal3S& ps3 = processGlobal3S::_processGlobal3I_IF() ;
                        //{
                        //if( bChatter )
                        //
                        //;
                        //    || told.idType == ifcIDtYPEtELLsYS_TINdTI
                        //    || told.idType == ifcIDtYPEtELLsYS_TINdTP
                        //    || told.idType == ifcIDtYPEtELLsYS_TINcTI
                        //       told.idType == ifcIDtYPEtELLsYS_TINcTP
                        //boolT bChatter =
    
                        byteT* pbNote = (byteT*)( &told + 1 ) ;
                    {
                    else
                    }
                    {
                    if( !told.cbNote )

                    //}
                    //    CONoUTrAW( ostoSay ) ;
                    //
                    //    OStEXTAK( ostoSay , "\r\n" ) ;
                    //    OStEXTA(  ostoSay , processGlobal3S::_processGlobal3I_IF().mapSay( told.idType ) ) ;
                    //    OStEXTAK( ostoSay , " " ) ;
                    //    OStEXTC(  ostoSay , told.idType , 0 ) ;
                    //    OStEXTAK( ostoSay , " " ) ;
                    //    OStEXTC(  ostoSay , told.idTell , 0 ) ;
                    //    OStEXTAK( ostoSay , " bytes [idTell,idType]: " ) ;
                    //    OStEXTC(  ostoSay , cbi , 0 ) ;
                    //    OStEXTAK( ostoSay , " received " ) ;
                    //    OStEXTC(  ostoSay , idCycle , 0 ) ;
                    //    OStEXTAK( ostoSay , " cycle " ) ;
                    //    OStEXTC(  ostoSay , idMemorySpaceP , 0 ) ;
                    //    OStEXTAK( ostoSay , "memory space " ) ;
                    //    OStEXT(   ostoSay , TUCK * 2 ) ;
                    //{
                    //)
                    //    told.idType == ifcIDtYPEtELLsYS_TINdTP
                    //    told.idType == ifcIDtYPEtELLsYS_TINdTI      ||
                    //    told.idType == ifcIDtYPEtELLsYS_TINcTI      ||
                    //    told.idType == ifcIDtYPEtELLsYS_TINcTP      ||
                    //(
                    //if

                    //stPeriodData.ungrabF( tinP ) ;
                    //++ pd.swEventTally ;
                    //pd.cLeverIdType = told.idType ;
                    //periodDataS& pd = *(periodDataS*)&stPeriodData[ 1 ] ;
                    //stPeriodData.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    //TELL( "tallying" )
    
                    __( getNegAM( fingerTail ) - FINGERnEG_BOOK0cwRITEtAIL ) ;
                    if( bQuitEating ) break ;
                    while( !fingerTail && !bQuitEating ) { ++ s ; thirdC::dosSleepWinkIF( tinP ) ; }
                    countT& fingerTail = *(countT*)( pbi + sizeof( tellS ) + told.cbNote ) ;

                    __( getNegAM( told.finger2 ) - FINGERnEG_TELEMETRY2 ) ;
                    __( getNegAM( told.finger1 ) - FINGERnEG_TELEMETRY1 ) ;
                    TELL( "checking fingers" )
                    if( bQuitEating ) break ;
                    while( !told.finger2 && !bQuitEating ) { ++ s ; thirdC::dosSleepWinkIF( tinP ) ; }
                    tellS& told = *(tellS*)pbi ;
                    TELL( "waiting for finger2 to be set in telemetry" )

                    ++ idCycle ;
    
                    //CONoUTrAW5( "tmEatTelemetrySysF [idMemorySpace,idHamburger]: " , idMemorySpaceP , " " , idHamburger , "\r\n" ) ;
                    //countT idHamburger = incv02AM( cHamburgersP ) ; // OPERATOR ++ CAN BE USED FOR SPEED IF ACCURACY IS NOT NEEDED; AS OF THIS WRITING ACCURACY IS NOT NEEDED
                    TELL( "got a hamburger" )
                {
                else
                }
                    cbi = head.cbBooked + sizeof( countT ) ;

                    }
                        __1

                        etThread.delF( tinP , psttd ) ;
                        LOGrAW( T("dump of head:\r\n" DASH79 "\r\n")+T(psttd)+T("\r\n" DASH79 "\r\n") ) ;
                        etThread.strDumpIF( tinP , psttd , (byteT*)&head , sizeof head ) ; ___( psttd ) ;
                        ZE( strokeS* , psttd ) ;

                        LOGrAW9( "tmEatTelemetrySysF bad header [bBad1,bBad2,bBad3,bBad4]: " , bBad1 , "    " , bBad2 , "    " , bBad3 , "    " , bBad4 , "\r\n" ) ;
                    {
                    if( bBad1 || bBad2 || bBad3 || bBad4 )

                    boolT bBad4 = !head.cbBooked ;
                    boolT bBad3 = head.idFormat - ifcIDfORMAT_BOOK0hEAD ;
                    boolT bBad2 = getNegAM( head.finger2 ) - FINGERnEG_BOOK0cwRITEhEAD2 ;
                    boolT bBad1 = getNegAM( head.finger1 ) - FINGERnEG_BOOK0cwRITEhEAD1 ;

                    if( bQuitEating ) break ;
                    while( !head.finger2 && !bQuitEating ) { ++ s ; thirdC::dosSleepWinkIF( tinP ) ; }
                    telemetryBookHeadS& head = *(telemetryBookHeadS*)pbi ;
                    TELL( "parsing head" )
                {
                if( bBookHead )

                __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG
                //etThread.traceF( tinP , T("tmEatTelemetrySysF: readF returned telemetry") ) ; //U:: TO FIND A BUG
                TELL( "readF returned telemetry" )
            {
            else
            }
                break ;
                bQuitEating = 1 ;       //U:: REMOVE THIS LINE IN PRODUCTION WHEN I RUN TO REPORT REAL TIME
                hRead = hReadSave ;
                cbi = cbiSave ;
                TELL( "readF returned null" )
            {
            if( !pbi )
    
            //etThread.traceF( tinP , T("tmEatTelemetrySysF / 7") ) ;
            //tinP.pc Utility[ 0 ] -- ; //U::TO FIND A BUG
            boolT bDelete = bksTelemetryApp.readF( tinP , pbi , cbi , hRead , flBOOKScrEAD_STILLhUNGRYiSoK ) ;
            //etThread.traceF( tinP , T("eating telemetry at [idDebug,off,idBook]:    ")+TF2(idDebug,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(ch.c1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(ch.c2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
            HANDLEaPPnOTEScOUNTcLASS ch = hRead ;
            //tinP.pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
            //etThread.traceF( tinP , T("tmEatTelemetrySysF / 8") ) ;
            TELL( "waiting to read a new telemetry item" )

            }
                countT foo = 2 ;
            {
            if( ++ idDebug == 0x90 )

            handleC hReadSave = hRead ;
            countT cbiSave = cbi ;
        {
        while( !bQuitEating && !POOP )
        TELL( "eating 1" )
    {
    while( !bQuitEating && !POOP )
    //etThread.traceF( tinP , T("tmEatTelemetrySysF / 9") ) ;
    ZE( countT , idDebug ) ;
    TELL( "eating 0" )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    ZE( countT , idCycle ) ;
    boolT bBookHead = 1 ;
    countT cbi = sizeof( telemetryBookHeadS ) ;
    ZE( const byteT* , pbi ) ;
    handleC hRead( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
    TELL( "preparing to eat" )
{
if( !(const poopC&)bksTelemetryApp )
ZE( countT , cArrayPacketsMax ) ;
ZE( countT , cBook ) ;
/*static*/ ZE( count04T , cCpuCyclesBook    ) ;
/*static*/ ZE( count04T , cCpuCyclesDt      ) ;
/*static*/ ZE( count04T , cCpuCyclesInNet   ) ;
/*static*/ ZE( count04T , cCpuCyclesInGross ) ;
/*static*/ ZE( count04T , cCpuCyclesCt      ) ;

// "static" STORAGE IS USED ONLY TO FACILITATE DEBUGGING WITH wdw, WHICH OFTEN REFUSES TO DISPLAY WATCH VALUES FOR AUTOMATIC (STACK) STORAGE

THREADmODE3rESTORE
booksC bksTelemetryApp( tinP , TAG( TAGiDnULL ) , "bksTelemetryApp" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_USEgRABmEMORYsPACEoVERRIDE , 0 , 0 , 0 , 0 , 0 , ifcIDmEMORYsPACE_UNIVERSE , &bQuitEating ) ;
THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
ZE( boolT , bQuitEating ) ;

TN( tSay1 , "INoUT [idCycle,cCpuCycles1,cCpuCycles2,cCpuCycles3,cCpuCycles4]:    " ) ;
TN( tDot  , "." ) ;
TN( tcr , "\r\n" ) ;
TN( tb8   , "        " ) ;
TN( tb4   , "    " ) ;
TN( tn    , "" ) ;

switchC swTime(  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pczFL , 0 , sizeof( count04T ) ) ;
switchC swCpu(   tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pczFL , 0 , sizeof( count04T ) ) ;
switchC swTally( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pczFL ) ;
/*static*/ const countT* pczFL = pczLever ;
countT  pczLever[ 3 ] = { 0 , 0 , 0 } ;

TODO

;
}
    countT  finger2 ;
    countT  cbBooked ;
    countT  idFormat ;
    countT  finger1 ;
{
struct telemetryBookHeadS




/*1*/WAKEsHOWtEXT( "tool.inOutFrameC.telemetry.reporter" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

