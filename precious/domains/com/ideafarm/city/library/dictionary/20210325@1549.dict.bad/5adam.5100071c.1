
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

while( ~hFindDir && !ether && !POOP ) ;
}
    DEL( pInfoDir ) ;

    }
        }
            flushTimeGroupF( tinP , etThread , stSortKeyShortRoot ,tPathDirTo+tShortDir , tPathDirFrom+tShortDir ) ;
            etThread.traceF( tinP , T("flushing time group: ")+tTimeGroupLath ) ;
            while( ~hFindFile && !ether && !POOP ) ;
            }
                DEL( pInfoFile ) ;

                }
                    }
                        }
                            // }
                            //     //boolT bOk = CreateSymbolicLink( tOsNameTo , tOsNameFrom , 0 ) ;
                            // 
                            //     }
                            //         etThread.traceF( tinP , T("        to: ")+tOsNameTo   ) ;
                            //         etThread.traceF( tinP , T("      from: ")+tOsNameFrom ) ;
                            //         etThread.traceF( tinP , T("name: ")+tName  ) ;
                            //     {
                            //     if( bSay ) 
                            // {
                            // else
                            // }
                            //     etThread.traceF( tinP , T("destination file exists [tIfNameTo]: ")+tIfNameTo ) ;
                            // {
                            // if( etThread.diskFileExistsF( tinP , tIfNameTo ) )
                            // 
                            // TN( tOsNameTo   , "" ) ; tOsNameTo   = T( osFileNameC( tinP , etThread , tIfNameTo ) ) ;
                            // TN( tIfNameTo   , "" ) ; tIfNameTo   = tPathDirTo+tShortDir+TF3(++idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+tDot+tName ;
                            // TN( tOsNameFrom , "" ) ; tOsNameFrom = T( osFileNameC( tinP , etThread , tIfoName                                                                                                                     ) ) ;
                            // etThread.diskMakeDirIfNeededF( tinP , tPathDirTo+tShortDir ) ;
                            // 
                            // //etThread.diskMoveFileOrDirF( tinP , tPathDirFrom+tShortDir+TF3(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+tDot+tName , tIfoName ) ;

                            }
                                stSortKeyShortRoot.sinkF( tinP , countTC() , pstt1KeyRoot , flSTACKsINK_null , 0 , 1 ) ;
                                etThread.strFuseSeparateF( tinP , pstt1KeyRoot , tShortRoot ) ;
                                etThread.strFuseSeparateF( tinP , pstt1KeyRoot , tName      , 0 , 0 , 0 , 0 , CSpREFIX + tShortRoot.csF( tinP ) ) ; ___( pstt1KeyRoot ) ;
                                ZE( strokeS* , pstt1KeyRoot ) ;

                                //etThread.traceF( tinP , tb8+tName+tb8+tShortRoot ) ;

                                etThread.delF( tinP , psttTimeGroup ) ;
                                }
                                    flushTimeGroupF( tinP , etThread , stSortKeyShortRoot ,tPathDirTo+tShortDir ,tPathDirFrom+tShortDir ) ;

                                    tTimeGroupLath = T(psttTimeGroup) ;
                                    etThread.traceF( tinP , T("flushing time group: ")+tTimeGroupLath ) ;
                                {
                                if( etThread.strCompareF( tinP , tTimeGroupLath , psttTimeGroup ) )

                                etThread.strSubstringF( tinP , psttTimeGroup , idf , idl , tShortRoot ) ; ___( psttTimeGroup ) ;
                                ZE( strokeS* , psttTimeGroup ) ;
                                countT idl = 0x28 ;
                                countT idf = 1 ;

                                // !ideafarm.8.2.00000000.00000001.20100908@1008.20100909@0645.001.
                                // 123456789abcdef0123456789abcdef0123456789abc
                                // 0              1               2 
                            {
                            if( tShortRoot.csF( tinP ) && tName.csF( tinP ) )

                            }
                                }
                                    etThread.delF( tinP , postName ) ;
                                    tName = T(postName) ;
                                    etThread.boxGetShadowF( tinP , postName , costName , tFileMetaNameLong ) ; ___( postName ) ;
                                    ZE( countT   , costName ) ;
                                    ZE( osTextT* , postName ) ;
                                {
                                else
                                if( !etThread.diskFileExistsF( tinP , tFileMetaNameLong ) ) etThread.traceF( tinP , T("error / file does not exist: ")+tFileMetaNameLong ) ;

                                TN( tFileMetaNameLong , "" ) ; tFileMetaNameLong = tPathDirFrom+tShortDir+tShortRoot+tMetaDotCurrentName ;
                            {
                            TN( tName , "" ) ;

                            }
                                etThread.delF( tinP , psttShortRoot ) ;
                                tShortRoot = T(psttShortRoot) ;
                                etThread.strSubstringF( tinP , psttShortRoot , idf , idHit , tShortFile ) ; ___( psttShortRoot ) ;
                                countT idf = 1 ;
                                ZE( strokeS* , psttShortRoot ) ;
                            {
                            TN( tShortRoot , "" ) ;
                        {
                        if( idHit )
                        countT idHit = etThread.strIdF( tinP , tDotDataDot , tShortFile ) ;

                        boolT bSay = 1 /* !( ++ idFile % TUCK ) || idFile == 1 */ ;
                    {
                    if( !bDir )

                    }
                        etThread.delF( tinP , psttShortFile ) ;
                        tShortFile = T(psttShortFile) ;
                        etThread.delF( tinP , psttnu ) ;
                        etThread.strBisectF( tinP , psttnu , psttShortFile , pInfoFile->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShortFile ) ;
                        ZE( strokeS* , psttShortFile ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShortFile , "" ) ;

                    const boolT bDir = pInfoFile->psttIfoName[ CSpREFIX - 1 + pInfoFile->psttIfoName->idAdam ].idAdam == '/' ;
                    TN( tIfoName , pInfoFile->psttIfoName ) ;
                {
                else
                }
                    break ;
                    DEL( pInfoFile ) ;
                {
                if( !pInfoFile || !pInfoFile->psttIfoName )

                etThread.diskFindFileOrDirOldF( tinP , pInfoFile , hFindFile , tPathDirFrom+tShortDir+tLikeFile ) ; ___( pInfoFile ) ;
                ZE( infoFileS* , pInfoFile ) ;
            {
            do
            handleC hFindFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            stackC stSortKeyShortRoot( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
            ZE( countT , idFile ) ;
            TN( tTimeGroupLath , "" ) ;

            etThread.traceF( tinP , tShortDir ) ;
        {
        if( bDir && etThread.strCompareF( tinP , tDotSlash , tShortDir ) && etThread.strCompareF( tinP , tDotDotSlash , tShortDir ) )

        }
            etThread.delF( tinP , psttShortDir ) ;
            tShortDir = T(psttShortDir) ;
            etThread.delF( tinP , psttnu ) ;
            etThread.strBisectF( tinP , psttnu , psttShortDir , pInfoDir->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShortDir ) ;
            ZE( strokeS* , psttShortDir ) ;
            ZE( strokeS* , psttnu ) ;
        {
        TN( tShortDir , "" ) ;

        const boolT bDir = pInfoDir->psttIfoName[ CSpREFIX - 1 + pInfoDir->psttIfoName->idAdam ].idAdam == '/' ;
        TN( tIfoName , pInfoDir->psttIfoName ) ;
    {
    else
    }
        break ;
        DEL( pInfoDir ) ;
    {
    if( !pInfoDir || !pInfoDir->psttIfoName )

    etThread.diskFindFileOrDirOldF( tinP , pInfoDir , hFindDir , tPathDirFrom+tLikeDir ) ; ___( pInfoDir ) ;
    ZE( infoFileS* , pInfoDir ) ;
{
do
handleC hFindDir( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

TN( tDot , "." ) ;
TN( tDotDotSlash , "../" ) ;
TN( tDotSlash , "./" ) ;
TN( tb8 , "        " ) ;
TN( tb , " " ) ;
TN( tMetaDotStar , "meta.*" ) ;
TN( tMetaDotCurrentName , "meta.currentname" ) ;
TN( tDotDataDot , ".data." ) ;
TN( tSlash , "/" ) ;
TN( tLikeFile , "!ideafarm.8.2.00000000.00000001.*.data.*" ) ;
TN( tLikeDir , "*" ) ;
TN( tPathDirTo , "///d/archive.sorted/" ) ;
TN( tPathDirFrom      , "///d/archive/" ) ;

TODO

}
    }
        etherP.delF( tinP , pstt1KeyRoot ) ;

        }
            while( ~hFindFile && !POOP ) ;
            }
                DEL( pInfoFile ) ;

                }
                    }
                        etherP.delF( tinP , psttShortNew ) ;
                        etherP.diskMoveFileOrDirF( tinP , tFolderTo+T(psttShortNew) , tFolderFrom+tShortFile ) ;

                        //etherP.traceF( tinP , T("moving from: ")+tShortFile ) ;
                        //etherP.traceF( tinP , T("moving to  : ")+T(psttShortNew)   ) ;
                        //etherP.traceF( tinP , T("        ")+tShortFile ) ;

                        //etherP.traceF( tinP , T("[psttShortNew]: ")+T(psttShortNew) ) ;
            
                        }
                            }
                                psttShortNew[ CSpREFIX - 1 + 0x2b ] = psttzNewDigits[ CSpREFIX - 1 + 3 ] ;
                                psttShortNew[ CSpREFIX - 1 + 0x2a ] = psttzNewDigits[ CSpREFIX - 1 + 2 ] ;
                                psttShortNew[ CSpREFIX - 1 + 0x29 ] = psttzNewDigits[ CSpREFIX - 1 + 1 ] ;
                            {
                            if( psttzNewDigits )
                            strokeS* psttzNewDigits = tIdFile ;
                        {
            
                        // !ideafarm.8.2.00000000.00000001.20100908@1008.20100909@0645.001.
                        // 123456789abcdef0123456789abcdef0123456789abc
                        // 0              1               2 
            
                        etherP.strMakeF( tinP , LF , psttShortNew , tShortFile ) ; ___( psttShortNew ) ;
                        ZE( strokeS* , psttShortNew ) ;

                        }
                            etherP.delF( tinP , psttShortFile ) ;
                            tShortFile = T(psttShortFile) ;
                            etherP.delF( tinP , psttnu ) ;
                            etherP.strBisectF( tinP , psttnu , psttShortFile , pInfoFile->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShortFile ) ;
                            ZE( strokeS* , psttShortFile ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShortFile , "" ) ;
                    {
                    if( !bDir )

                    const boolT bDir = pInfoFile->psttIfoName[ CSpREFIX - 1 + pInfoFile->psttIfoName->idAdam ].idAdam == '/' ;
                    TN( tIfoName , pInfoFile->psttIfoName ) ;
                {
                else
                }
                    break ;
                    DEL( pInfoFile ) ;
                {
                if( !pInfoFile || !pInfoFile->psttIfoName )

                etherP.diskFindFileOrDirOldF( tinP , pInfoFile , hFindFile , tFolderFrom+tLikeFile ) ; ___( pInfoFile ) ;
                ZE( infoFileS* , pInfoFile ) ;
            {
            do
            handleC hFindFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

            TN( tLikeFile , "" ) ; tLikeFile = T(psttzRoot)+T("*") ;
        {
        )
            psttzRoot[ CSpREFIX - 1 + 0x2c ].idAdam == '.'
            &&
            psttzRoot[ CSpREFIX - 1 + 0x28 ].idAdam == '.'
            &&
            psttzRoot[ CSpREFIX - 1 + 0x23 ].idAdam == '@'
            &&
            psttzRoot[ CSpREFIX - 1 + 0x1a ].idAdam == '.'
            &&
            psttzRoot[ CSpREFIX - 1 + 0x15 ].idAdam == '@'
            &&
            psttzRoot[ CSpREFIX - 1 + 0x0c ].idAdam == '.'
            &&
            psttzRoot[ CSpREFIX - 1 + 0x0a ].idAdam == '.'
            &&
            psttzRoot[ CSpREFIX - 1 + 0x01 ].idAdam == '!'
            &&
            psttzRoot
        (
        if

        }
            else if( !psttzRoot ) psttzRoot = psttc1 ;
                 if( !psttzKey  ) psttzKey  = psttc1 ;

            //etherP.traceF( tinP , T("    ")+T(psttc1) ) ;
        {
        FORsTRINGSiN1( pstt1KeyRoot )
        ZE( strokeS* , psttzRoot ) ;
        ZE( strokeS* , psttzKey ) ;
        //etherP.traceF( tinP , T("[idDataFileInGroupLathP]: ")+tIdFile ) ;
        textC tIdFile( tinP , TAG( TAGiDnULL ) , flTEXTc_null , ++idFile , flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObASE , 3 , 0xa ) ;

        stSortKeyShortRootP >> pstt1KeyRoot ;
        ZE( strokeS* , pstt1KeyRoot ) ;
    {
    while( stSortKeyShortRootP )
    TN( tSlash , "/" ) ;
    ZE( countT , idFile ) ;

    TN( tFolderFrom , psttFolderFromP ) ;
    TN( tFolderTo   , psttFolderToP   ) ;
{
voidT flushTimeGroupF( tinS& tinP , etherC& etherP , stackC& stSortKeyShortRootP , const strokeS* const psttFolderToP , const strokeS* const psttFolderFromP )


/*1*/WAKEsHOWtEXT( "tool.archive.sort.by.name.within.timestamp" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

