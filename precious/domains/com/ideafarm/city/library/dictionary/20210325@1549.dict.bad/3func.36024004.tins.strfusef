
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( &tinP == this ) flagsThreadMode1 = flagsThreadMode1Save ;

    }
        }
            }
                idns ++ ;
                bOut = 0 ;
            {
            if( bOut )

            ) ; ___( psttP ) ;

                tc                                                                                              //g
                (bb?T(""):(postFileStep?t4b+tq+T(postFileStep)+tq:T("")))+                                      //f
                T((sCountT)pLFstep[((ids&OFFsLOTtINsTEPmAX)<<1)+1]<0?"":" ")+                                   //e
                TF3(pLFstep[((ids&OFFsLOTtINsTEPmAX)<<1)+1],flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+             //e
                t9b+                                                                                            //k
                TF3(idns,0,3)+                                                                                  //d
                TP("",1+idns)+                                                                                  //c
                TF4(pLFstep[(ids&OFFsLOTtINsTEPmAX)<<1]&~fliSTEP_FLAGmASK,flFORMAT_FOREIGN|flFORMAT_UNSIGNED,0xc,0xa)+ //b
                tStepSuff+                                                                                      //a
                TF3(ids,0,8)+                                                                                   //Z
                (ids==monitor.idStep||ids==idsMin?tStep:tStep2)+                                                        //Y
                ti+                                                                                             //g

            ether.strFuseF( tinP , psttP ,

            }
                }
                    if( idns == - 1 ) idns = 0 ;
                    idns -- ;
                {
                else
                if( pLFstep[ ( ids & OFFsLOTtINsTEPmAX ) << 1 ] & fliSTEP_NESToUT ) bOut = 1 ;
            {
            if( pLFstep[ ( ids & OFFsLOTtINsTEPmAX ) << 1 ] & fliSTEP_NESTcHANGE )
            const osTextT* postFileStep = processGlobal7I.source.postFileTitleF( tinP , processGlobal7I.source.idFileRankF( tinP , pLFstep[ ( ( ids & OFFsLOTtINsTEPmAX ) << 1 ) + 1 ] ) ) ;
        {
        for( countT ids = monitor.idStep ; ids >= idsMin ; ids -- )
        ZE( boolT , bOut ) ;
        idns = monitor.cInNest ;
        if( !( F(flags1) & flTINrPT1_pLFstepAll ) && monitor.idStep - idsMin > 0xf ) idsMin = monitor.idStep - 0xf ;
    {
    if( ( F(flags1) & flTINrPT1_pLFstepAll ) | ( F(flags1) & flTINrPT1_pLFstepLast01 ) )

    }
        }
            ) ; ___( psttP ) ;

                tc                                                                                              //h
                (bb?T(""):(postFileNest?t4b+tq+T(postFileNest)+tq:T("")))+                                      //O
                T((sCountT)monitor.pLFnest[((idn&OFFsLOTtINnESTmAX)<<1)+1]<0?"":" ")+                                   //N
                TF3(monitor.pLFnest[((idn&OFFsLOTtINnESTmAX)<<1)+1],flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+             //N
                TF3(pIdInNest[idn&OFFsLOTtINnESTmAX],flFORMAT_UNSIGNED,9)+                                  //i
                TF3(idn,0,3)+                                                                                   //M
                TP("",1+idn)+                                                                                   //L
                TF4(monitor.pLFnest[(idn&OFFsLOTtINnESTmAX)<<1],flFORMAT_FOREIGN|flFORMAT_UNSIGNED,0xc,0xa)+            //K
                (idn==monitor.cInNest||idn==idnMin?tCalledBy:tCalledBy2)+                                                 //J
                ti+                                                                                             //h

            ether.strFuseF( tinP , psttP ,

            const osTextT* postFileNest = processGlobal7I.source.postFileTitleF( tinP , processGlobal7I.source.idFileRankF( tinP , monitor.pLFnest[ ( ( idn & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ) ) ;
        {
        for( countT idn = monitor.cInNest ; idn >= idnMin ; idn -- )
    {
    if( F(flags1) & flTINrPT1_pLFnest )

    }
        ) ; ___( psttP ) ;

            tc                                                                                                  //X
            (bb?T(""):(postFileLast?t4b+tq+T(postFileLast)+tq:T("")))+                                          //I
            T((sCountT)pLFstep[((monitor.idStep&OFFsLOTtINsTEPmAX)<<1)+1]<0?"":" ")+                                    //C
            TF3(pLFstep[((monitor.idStep&OFFsLOTtINsTEPmAX)<<1)+1],flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+              //C
            t9b+                                                                                                //l
            TF3(monitor.cInNest,0,3)+                                                                                     //H
            TP("",1+monitor.cInNest)+                                                                                     //G
            TF4(pLFstep[(monitor.idStep&OFFsLOTtINsTEPmAX)<<1]&~fliSTEP_FLAGmASK,flFORMAT_FOREIGN|flFORMAT_UNSIGNED,0xc,0xa)+ //F
            T(ppostTitle[0xb])+                                                                                 //A
            ti+                                                                                                 //X

        ether.strFuseF( tinP , psttP ,
    {
    if( F(flags1) & flTINrPT1_pLFstepLast )

    }
        if( F(flags1) & flTINrPT1_idWhat1               ) { ether.strFuseF( tinP , psttP , ti+T(ppostTitle[0xa])+TP(processGlobal3I.mapWhat(monitor.idWhat1),csttWhereMax)                                                       +tc ) ; ___( psttP ) ; } //A //E
        if( F(flags2) & flTINrPT2_postTellIf            ) { ether.strFuseF( tinP , psttP , ti+T(ppostTitle[0x11])+tq+T(postTellIf)+tq                                                                            +tc ) ; ___( psttP ) ; } //A //m
        if( F(flags2) & flTINrPT2_postTell              ) { ether.strFuseF( tinP , psttP , ti+T(ppostTitle[0x10])+tq+T(postTell)+tq                                                                              +tc ) ; ___( psttP ) ; } //A //m
        if( F(flags1) & flTINrPT1_postThreadName        ) { ether.strFuseF( tinP , psttP , ti+T(ppostTitle[  1])+tq+T(postThreadName)+tq                                                                         +tc ) ; ___( psttP ) ; } //A //B
        if( F(flags1) & flTINrPT1_idThread              ) { ether.strFuseF( tinP , psttP , ti+T(ppostTitle[  2])+TF3(monitor.idThread,0,8)                                                                               +tc ) ; ___( psttP ) ; } //A //C
        if( F(flags1) & flTINrPT1_idProcessOld             ) { ether.strFuseF( tinP , psttP , ti+T(ppostTitle[0xd])+TF3(monitor.idProcessOld,0,8)                                                                              +tc ) ; ___( psttP ) ; } //A //C
        if( F(flags1) & flTINrPT1_osTid                 ) { ether.strFuseF( tinP , psttP , ti+T(ppostTitle[  3])+TF3(osTid,0,8)                                                                                  +tc ) ; ___( psttP ) ; } //A //C
        if( F(flags1) & flTINrPT1_osPid                 ) { ether.strFuseF( tinP , psttP , ti+T(ppostTitle[  4])+TF3(osPid,0,8)                                                                                  +tc ) ; ___( psttP ) ; } //A //C

        }
            ) ; ___( psttP ) ;
    
                tc                                                                                                  //X
                TF4(idLineCt&0xfff,flFORMAT_FOREIGN|flFORMAT_UNSIGNED,0,0xa)+                                       //F
                t1b+                                                                                                //V
                (bb?T(""):TF2(idiFileCt,flFORMAT_UNSIGNED))+                                                        //W
                T(ppostTitle[0xc])+                                                                                 //A
                ti+                                                                                                 //X
    
            ether.strFuseF( tinP , psttP ,
        {
        if( F(flags1) & flTINrPT1_idLineCt )

        if( F(flags1) & flTINrPT1_idStep                ) { ether.strFuseF( tinP , psttP , ti+T(ppostTitle[0xe])+TF3(monitor.idStep,0,8)                                                                                 +tc ) ; ___( psttP ) ; } //A //C
        if( F(flags2) & flTINrPT2_idDirty               ) { ether.strFuseF( tinP , psttP , ti+T(ppostTitle[0xf])+TF3(monitor.idDirty,0,8)                                                                                +tc ) ; ___( psttP ) ; } //A //C
    {
    else
    }
        if( bc ) { ether.strFuseF( tinP , psttP , tc ) ; ___( psttP ) ; } //B
        if( F(flags1) & flTINrPT1_idWhat1               ) { bc = 1 ; ether.strFuseF( tinP , psttP , ti+TP(processGlobal3I.mapWhat(monitor.idWhat1),csttWhereMax)                                                       +t1b ) ; ___( psttP ) ; } //A //E
        if( F(flags1) & flTINrPT1_postThreadName        ) { bc = 1 ; ether.strFuseF( tinP , psttP , ti+T(postThreadName)                                                                               +t1b ) ; ___( psttP ) ; } //A //B
        if( F(flags1) & flTINrPT1_idThread              ) { bc = 1 ; ether.strFuseF( tinP , psttP , ti+TF1(monitor.idThread)                                                                                   +t1b ) ; ___( psttP ) ; } //A //C
        if( F(flags1) & flTINrPT1_idProcessOld             ) { bc = 1 ; ether.strFuseF( tinP , psttP , ti+TF1(monitor.idProcessOld)                                                                                  +t1b ) ; ___( psttP ) ; } //A //C
        if( F(flags1) & flTINrPT1_osTid                 ) { bc = 1 ; ether.strFuseF( tinP , psttP , ti+TF1(osTid)                                                                                      +t1b ) ; ___( psttP ) ; } //A //C
        if( F(flags1) & flTINrPT1_osPid                 ) { bc = 1 ; ether.strFuseF( tinP , psttP , ti+TF1(osPid)                                                                                      +t1b ) ; ___( psttP ) ; } //A //C
        ZE( boolT , bc ) ;
    {
    if( bb )
    //if( !bb ) { ether.strFuseF( tinP , psttP , ti+T(ppostTitle[0])+tc ) ; ___( psttP ) ; } //A

    ether.strFuseF( tinP , psttP , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ csttn + csttExtraP ) ; ___( psttP ) ;

    //U: TF3 -> TF1 and TP->T AFTER VERIFY THAT LENGTH CALCULATION IS CORRECT

    }
        csttn += csttnb ;
        csttn += csttna ;
        }
            }
                idns ++ ;
                bOut = 0 ;
            {
            if( bOut )

            csttn += tc.csF( tinP ) + cIndentP ; //g
            if( postFileStep ) csttnb += t4b.csF( tinP ) + 2 * tq.csF( tinP ) + ether.strBodyLengthF( tinP , postFileStep ) ; //f
            csttn += 8 ; //e
            csttn += 3 ; //d
            csttna += 1 + idns ; //c
            csttn += 9 ; //k
            csttn += 0xc ; //b
            csttn += tStepSuff.csF( tinP ) ; //a
            csttn += 8 ; //Z
            csttn += tStep.csF( tinP ) ; //Y

            }
                }
                    if( idns == - 1 ) idns = 0 ;
                    idns -- ;
                {
                else
                if( pLFstep[ ( ids & OFFsLOTtINsTEPmAX ) << 1 ] & fliSTEP_NESToUT ) bOut = 1 ;
            {
            if( pLFstep[ ( ids & OFFsLOTtINsTEPmAX ) << 1 ] & fliSTEP_NESTcHANGE )
            const osTextT* postFileStep = processGlobal7I.source.postFileTitleF( tinP , processGlobal7I.source.idFileRankF( tinP , pLFstep[ ( ( ids & OFFsLOTtINsTEPmAX ) << 1 ) + 1 ] ) ) ;
        {
        for( countT ids = monitor.idStep ; ids >= idsMin ; ids -- )
        ZE( boolT , bOut ) ;

        csttn += csttn9 ;
        csttn += csttn8 ;
        csttn += csttn7 ;
        csttn += csttn6 ;
        csttn += csttn5 ;
        }
            csttn += cIndentP + tc.csF( tinP ) ;                                                                //h
            if( postFileNest ) csttn6 += t4b.csF( tinP ) + 2 * tq.csF( tinP ) + ether.strBodyLengthF( tinP , postFileNest ) ; //O
            csttn += 8 ;                                                                                        //N
            csttn += 9 ;                                                                                        //i
            csttn += 3 ;                                                                                        //M
            csttn5 += 1 + idn ;                                                                                 //L
            csttn += 0xc ;                                                                                      //K
            csttn +=  tCalledBy.csF( tinP ) ;                                                                   //J

            const osTextT* postFileNest = processGlobal7I.source.postFileTitleF( tinP , processGlobal7I.source.idFileRankF( tinP , monitor.pLFnest[ ( ( idn & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ) ) ;
        {
        for( countT idn = monitor.cInNest ; idn >= idnMin ; idn -- )

        csttn += cIndentP + csttWhereMax ;                                                                      //E
        csttn += csttn4 ;
        if( postFileLast ) csttn4 = t4b.csF( tinP ) + 2 * tq.csF( tinP ) + ether.strBodyLengthF( tinP , postFileLast ) ; //I

        csttn += 2 * ( cIndentP + tc.csF( tinP ) ) ;                                                            //X
        csttn += t1b.csF( tinP ) ;                                                                              //V
        csttn += csttn3 ;
        csttn += 9 ;                                                                                            //g
        csttn3 = 1 + monitor.cInNest ;                                                                                    //G
        csttn += 1 * 3 ;                                                                                        //H
        csttn += 1 * 0x10 + cIndentP ;                                                                          //D //U:A POSITIVE VALUE ONLY REQUIRES 0xc STROKES
        csttn += 2 * 0xc ;                                                                                      //F
        csttn += 0xa * 0xd + 0xc * cIndentP ;                                                                   //C
        csttn += csttn2 ;
        csttn += cIndentP + ether.strBodyLengthF( tinP , postTell       ) + 2 * tq.csF( tinP ) ;                //m
        csttn += cIndentP + ether.strBodyLengthF( tinP , postTellIf     ) + 2 * tq.csF( tinP ) ;                //m
        csttn2 = 0xc ;                                                                                          //W
        csttn += cIndentP + ether.strBodyLengthF( tinP , postThreadName ) + 2 * tq.csF( tinP ) ;                //B

        csttn += csttn1 ;
        for( countT off = 0 ; off < sizeof ppostTitle / sizeof *ppostTitle ; off ++ ) csttn1 += ether.strBodyLengthF( tinP , ppostTitle[ off ] ) + tc.csF( tinP ) ; //A
    {
    ZE( countT , csttnb ) ;
    ZE( countT , csttna ) ;
    ZE( countT , csttn9 ) ;
    ZE( countT , csttn8 ) ;
    ZE( countT , csttn7 ) ;
    ZE( countT , csttn6 ) ;
    ZE( countT , csttn5 ) ;
    ZE( countT , csttn4 ) ;
    ZE( countT , csttn3 ) ;
    ZE( countT , csttn2 ) ;
    ZE( countT , csttn1 ) ; // THESE ARE USED SO THAT THE CAUSE OF A HUGE csttn VALUE CAN BE TRACKED

    countT csttWhereMax = processGlobal3I.mapWhat.costMaxF() ;
    ZE( countT , csttn ) ;
    countT idns = monitor.cInNest ;
    countT idsMin = monitor.idStep > OFFsLOTtINsTEPmAX ? monitor.idStep - OFFsLOTtINsTEPmAX : 1 ;
    const countT idnMin =  monitor.cInNest > OFFsLOTtINnESTmAX ?  monitor.cInNest - OFFsLOTtINnESTmAX : 1 ;

    const osTextT* postFileLast = processGlobal7I.source.postFileTitleF( tinP , processGlobal7I.source.idFileRankF( tinP , pLFstep[ ( ( monitor.idStep & OFFsLOTtINsTEPmAX ) << 1 ) + 1 ] ) ) ;

    TN( tStepSuff  , "     | "               ) ;
    TN( tStep2     , "|  | "                ) ; // ""
    TN( tStep      , "step "                ) ; // CODE ASSUMES THAT THESE 2 ARE THE SAME LENGTH
    TN( tCalledBy2 , "|       |         | " ) ; // ""
    TN( tCalledBy  , "called by         | " ) ; // CODE ASSUMES THAT THESE 2 ARE THE SAME LENGTH
    TN( tc , "\r\n" ) ;
    TN( tq , "\"" ) ;
    TN( t9b , "         " ) ;
    TN( t4b , "    " ) ;
    TN( t3b , "   " ) ;
    TN( t2b , "  " ) ;
    TN( t1b , " " ) ;

    } ;
        "postTellIf        | " ,                        //11
        "postTell          | " ,                        //01
        "idDirty           | " ,                        //f
        "idStep            | " ,                        //e
        "idProcessOldI         | " ,                        //d
        "constructed       | " ,                        //c
        "last              | " ,                        //b
        "idWhat           | " ,                        //a
        "mStepsPerTuck     | " ,                        //8
        "cNewSteps         | " ,                        //7
        "idMonitorTock     | " ,                        //6
        "idMonitor         | " ,                        //5
        "osPid             | " ,                        //4
        "osTid             | " ,                        //3
        "idThread          | " ,                        //2
        "postThreadName    | " ,                        //1
        "tinS"              ,                            //0 //NO LONGER USE THIS, AND REMOVED LEADING BLANK IN REMAINING ELEMENTS OF THIS ARRAY
    {
    static osTextT* ppostTitle[] =

    const boolT bb = idFormatP != flTINrPTfORMAT_NORMAL ; // "bb" "BE BRIEF"
    if( !idFormatP ) idFormatP = flTINrPTfORMAT_NORMAL ;
    const flagsT flags2 = ( F(flagsInclude2P) ? flagsInclude2P : FaLLsET( flagsInclude2P ) ) & ~( F(flagsExclude2P) ) ;
    const flagsT flags1 = ( F(flagsInclude1P) ? flagsInclude1P : FaLLsET( flagsInclude1P ) ) & ~( F(flagsExclude1P) ) ;

    }
        flagsThreadMode1 &= ~( F(flTHREADmODE1_UPDATEtIN) ) ;
        flagsThreadMode1Save = flagsThreadMode1 ;
    {
    if( &tinP == this )
    ZE( flagsT , flagsThreadMode1Save ) ;

    while( cToDo -- ) ti += T(" ") ;
    countT cToDo = cIndentP ;
    TN( ti , "" ) ;

    _IO_

    }
        if( POOP ) return ; // IF DO ANY TESTING THEN MUST DISABLE UPDATING EARLIER (BEFORE HERE)
        __( &tinP == this ) ;
        FV( flTINrPT2 , flagsExclude2P ) ;
        FV( flTINrPT2 , flagsInclude2P ) ;
        FV( flTINrPT1 , flagsExclude1P ) ;
        FV( flTINrPT1 , flagsInclude1P ) ;
        if( POOP ) return ; // IF DO ANY TESTING THEN MUST DISABLE UPDATING EARLIER (BEFORE HERE)
    {
    IFbEcAREFUL
    scoopC scoop( tinP , LF , ether ) ;
{
/*1*/voidT tinS::strFuseF( tinS& tinP , etherC& ether , strokeS*& psttP , const countT csttExtraP , const flagsT flagsInclude1P , const flagsT flagsInclude2P , const flagsT flagsExclude1P , const flagsT flagsExclude2P , countT idFormatP , const countT cIndentP )/*1*/

/**/
*/
  each line of the report will be indented this many strokes
  can be 0
 cIndentP
 idFormatP
  is used to "turn off" some of the flags specified by (or implied by a null value of) flagsIncludeP
  can be 0
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010167.flTINrPT2!||
 flagsExclude2P
  is used to "turn off" some of the flags specified by (or implied by a null value of) flagsIncludeP
  can be 0
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001014e.flTINrPT1!||
 flagsExclude1P
  if 0 then the value - 1 (all flags) is implied
  can be 0
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010167.flTINrPT2!||
 flagsInclude2P
  if 0 then the value - 1 (all flags) is implied
  can be 0
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001014e.flTINrPT1!||
 flagsInclude1P
  if tinP is *this then i will disable *this so that it is not updated while i report on it
  can be *this
 tinP
arguments
it is illegal to refer to this symbol in the definition of an adam
  \<A HREF=\"5.7740104.1.1.0.html\"\>7740104:  WAKEsHOW( "example.simplest.func.12f0007.tinS.strFuseF" )\</A\>
 simplest
examples
\<A HREF=\"5.12f0007.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strFuseF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

