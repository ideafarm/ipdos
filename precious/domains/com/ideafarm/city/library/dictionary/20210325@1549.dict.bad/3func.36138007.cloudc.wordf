
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    bHandle.ungrabF( tinP ) ;

    }
        scrP.tMaybePublicUrl2 = scrP.tMaybeInternalUrl2 = T("") ;
        scrP.flags &= ~( F(flCLOUDoPENsCRATCH_CLOUDfILES) ) ;

        }
            //etRock.traceF( tinP , T("wordF / cloud files!  setting [tRackspacePublicUrl,tRackspaceInternalUrl]: ")+rP.tRackspacePublicUrl+T(" ")+rP.tRackspaceInternalUrl ) ;
            ether.delF( tinP , psttCleaned2 ) ;
            ether.delF( tinP , psttCleaned1 ) ;
            rP.tRackspaceInternalUrl = T(psttCleaned2) ;
            rP.tRackspacePublicUrl   = T(psttCleaned1) ;

            ether.strTrimF( tinP , psttCleaned2 , 0 , 0 , T("\"") ) ; ___( psttCleaned2 ) ;
            ether.strTrimF( tinP , psttCleaned1 , 0 , 0 , T("\"") ) ; ___( psttCleaned1 ) ;

            ether.strReplaceF( tinP , psttCleaned2 , scrP.tMaybeInternalUrl2 , tOld , tNew , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttCleaned2 ) ;
            ether.strReplaceF( tinP , psttCleaned1 , scrP.tMaybePublicUrl2   , tOld , tNew , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttCleaned1 ) ;
            ZE( strokeS* , psttCleaned2 ) ;
            ZE( strokeS* , psttCleaned1 ) ;
            TN( tNew , "/" ) ;
            TN( tOld , "\\/" ) ;
        {
        else
        }
            //etRock.traceF( tinP , T("wordF / the word is not for cloud files ") ) ;
        {
        if( !F(scrP.flags) & flCLOUDoPENsCRATCH_CLOUDfILES )
    {
    else if( !ether.strCompareF( tinP , tPath , tPathServiceCatalog ) )
    }
        scrP.tMaybePublicUrl1 = scrP.tMaybeInternalUrl1 = T("") ;
        scrP.flags &= ~( F(flCLOUDoPENsCRATCH_MYrEGION) ) ;

        }
            //etRock.traceF( tinP , T("wordF / my region!  setting [tMaybePublicUrl2,tMaybeInternalUrl2]: ")+scrP.tMaybePublicUrl2+T(" ")+scrP.tMaybeInternalUrl2 ) ;
            scrP.tMaybeInternalUrl2 = scrP.tMaybeInternalUrl1 ;
            scrP.tMaybePublicUrl2   = scrP.tMaybePublicUrl1   ;
        {
        else
        }
            //etRock.traceF( tinP , T("wordF / the word is for another region ") ) ;
        {
        if( !F(scrP.flags) & flCLOUDoPENsCRATCH_MYrEGION )
    {
    if( !ether.strCompareF( tinP , tPath , tPathEndpoints ) )

    TN( tPathServiceCatalog , "\"access\"/\"serviceCatalog\"/" ) ;
    TN( tPathEndpoints      , "\"access\"/\"serviceCatalog\"/\"endpoints\"/" ) ;

    //etRock.traceF( tinP , T("wordF [tPath]: ")+tPath ) ;
    }
        }
            while( ~hWalk ) ;
            do tPath += T((strokeS*)stPathP.upF(tinP,hWalk))+T("/") ;
        {
        if( stPathP )
        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    TN( tPath , "" ) ;
    //CS:CODEsYNC: DUPLICATE CODE: 36138009 36138007

    }
        }
            //}
            //    ether.traceF( tinP , T("[ids,idLevel]: ")+TF2(ids,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idLevel,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            //{
            //if( idLevelLag != idLevel )

            }
                }
                    }
                        ;
                            : 0
                            ? ids + 1
                        idPairWoth = ids + 1 < idWordLath

                        ether.delF( tinP , psttPair ) ;
                        pairF( tinP , scrP , stPathP , psttPair ) ;
                        ether.strTrimF( tinP , psttPair ) ; ___( psttPair ) ;
                        ether.strSubstringF( tinP , psttPair , idPairWoth , idPairLath , psttP ) ; ___( psttPair ) ;
                        ZE( strokeS* , psttPair ) ;

                        countT idPairLath = ids - 1 ;
                    {
                    if( !idLevel || ( idLevel == 1 && ostc == ',' ) )
                {
                case ',' :

                case '}' : { -- idLevel ; } // INTENTIONAL FALLTHROUGH

                case '{' : { ++ idLevel ; break ; }

                case ']' : { -- idLevel ; break ; }

                case '[' : { ++ idLevel ; break ; }
            {
            switch( ostc )

            if( bIgnore ) continue ;

            }
                //}
                //    ether.delF( tinP , psttIgnored ) ;
                //    ether.traceF( tinP , T("ignored: ")+T(psttIgnored) ) ;
                //    ether.strSubstringF( tinP , psttIgnored , idf , idl , psttP ) ; ___( psttIgnored ) ;
                //    ZE( strokeS* , psttIgnored ) ;
                //
                //    countT idl = ids ;
                //    countT idf = idsIgnoreWoth ;
                //{
                //else
                //if( bIgnore ) idsIgnoreWoth = ids ;

                bIgnore = !bIgnore ;
            {
            if( ostc == '"' )

            countT ostc = psttP[ CSpREFIX - 1 + ids ].idAdam ;
            idLevelLag = idLevel ;
        {
        for( countT ids = idWordWoth ; ids <= idWordLath ; ids ++ )
        ZE( countT , idsIgnoreWoth ) ;
        ZE( boolT , bIgnore ) ;
        countT idPairWoth = idWordWoth + 1 ;
        ZE( countT , idLevelLag ) ;
        ZE( countT , idLevel ) ;

        const countT idWordLath = psttP->idAdam ;
        const countT idWordWoth = 1 ;
    {
    if( !POOP && psttP->idAdam > 2 )

    __NZ( psttP[ CSpREFIX ].idAdam != '{' || psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != '}' ) ;
    //VERIFY THAT psttP BEGINS WITH '{' AND ENDS WITH '}'

    //
    // value := [ word , word , ... ]
    //
    // value := word
    // 
    // pair := key : value
    //
    // word := { pair , pair , ... }
    //
    // INPUT IS EXACTLY WO word
    // INPUT FORMAT SPECIFICATION
    // 
    // RECIPE
    cloudInfoS& rP = *(cloudInfoS*)hCloud.osF( ifcIDtYPEhANDLE_CLOUD ) ;
    bHandle.grabF( tinP , TAG( TAGiDnULL ) ) ;

    //etRock.traceF( tinP , T("wordF [psttP]: ")+T(psttP) ) ;
    etherC& etRock = etherC::etRockIF( tinP ) ;

    _IO_

    }
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    SCOOP
{
/*1*/voidT cloudC::wordF( tinS& tinP , cloudOpenScratchS& scrP , stackC& stPathP , const strokeS* const psttP )/*1*/

/**/
*/
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

