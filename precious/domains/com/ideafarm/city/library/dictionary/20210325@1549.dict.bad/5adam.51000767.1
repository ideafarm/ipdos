
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

swFlock.ungrabF( tinP ) ;
swFlock.freeAllF( tinP ) ;

}
    DEL( pFlock ) ;

    }
        }
            }
                else                        break ;
                if( info3.NextEntryOffset ) pbInfo3 += info3.NextEntryOffset ;

                //etThread.traceF( tinP , T("    [name]:    ")+T(postName) ) ;
                if( bOk ) ;

                unicodeToAnsiF( postName , sizeof postName , (byteT*)info3.FileName , info3.FileNameLength >> 1 ) ;

                thirdC::c_memsetIF( tinP , postName , sizeof postName ) ;
                osTextT postName[ TUCK << 1 ] ;

                FILE_FULL_DIR_INFO& info3 = *(FILE_FULL_DIR_INFO*)pbInfo3 ;
            {
            for(;;)
        {
        else
        }
            if( rc ) ;
            countT rc = GetLastError() ;
        {
        if( !bOk )

        bOk = GetFileInformationByHandleEx( (HANDLE)hFile.osF( ifcIDtYPEhANDLE_FILE ) , (FILE_INFO_BY_HANDLE_CLASS)FileFullDirectoryInfo_updated , pbBuffer , sizeof pbBuffer ) ;
    {

    byteT* pbInfo3 = pbBuffer ;

    }
        //etThread.traceF( tinP , T("[name]:    ")+T(postName) ) ;
        if( bOk ) ;

        unicodeToAnsiF( postName , sizeof postName , (byteT*)info2.FileName , info2.FileNameLength >> 1 ) ;

        thirdC::c_memsetIF( tinP , postName , sizeof postName ) ;
        osTextT postName[ TUCK << 1 ] ;
    {
    else
    }
        if( rc ) ;
        countT rc = GetLastError() ;
    {
    if( !bOk )
    bOk = GetFileInformationByHandleEx( (HANDLE)hFile.osF( ifcIDtYPEhANDLE_FILE ) , FileNameInfo , pbBuffer , sizeof pbBuffer ) ;
    FILE_NAME_INFO& info2 = *(FILE_NAME_INFO*)pbBuffer ;
    byteT pbBuffer[ TOCK ] ;

    }
        //etThread.traceF( tinP , T("uncloaking [volume,idiFile]:    ")+TF3((countT)info.dwVolumeSerialNumber,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF3((countT)info.nFileIndexLow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+TF3((countT)info.nFileIndexHigh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
    {
    if( bOk )
    boolT bOk = GetFileInformationByHandle( (HANDLE)hFile.osF( ifcIDtYPEhANDLE_FILE ) , &info ) ;
    BY_HANDLE_FILE_INFORMATION info ;
    handleC& hFile = *pFlock ;

    fileC*& pFlock   = *(fileC**)&(countT&)swFlock ;
    psttzLeverFolder = (strokeS*)swFlock.leverF( tinP , idf ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
countT cFlavors = swFlock.cFlavorsF( tinP ) ;
swFlock.grabF( tinP , TAG( TAGiDnULL ) ) ;
TN( tb4    , "    " ) ;

//etThread.traceF( tinP , T("unlocking") ) ;
ether.loafIF( tinP ) ;

ether.ifcHireF( tinP , T("ifcIDaDAM_CLOAK") , ifcIDaDAM_KERNEL2MONITOR , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

//U::etThread.osThreadF( TaRG1( tmWatchHandlesF ) ) ;

etThread.osThreadF( TaRG1( tmServerF ) , (countT)&psttzLeverFolder , (countT)&swFlock ) ;

//etThread.traceF( tinP , T("folder:    ")+tFolder ) ;
//}
//    etThread.delF( tinP , psttFolder ) ;
//    tFolder = T(psttFolder) ;
//    ZE( strokeS* , psttFolder ) ; etThread.querySettingF( tinP , psttFolder , T("!ipdos.cloak.folder")  ) ; ___( psttFolder ) ;
//{
//TN( tFolder , "" ) ;

}
    etThread.delF( tinP , psttf ) ;

    }
        }
            }
                DEL( pFlock ) ;
            {
            if( cDo )

            }
                }
                    swFlock.ungrabF( tinP ) ;
                    else          { swFlock = (countT)pFlock ; pFlock = 0 ; }
                    if( swFlock ) DEL( pFlock )                                   //SHOULD BE IMPOSSIBLE
                    psttzLeverFolder = psttf ;
                    swFlock.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    //etThread.traceF( tinP , T("folder locked:    ")+T(psttf) ) ;
                {
                if( !cDo )
            {
            else
            }
                DEL( pFlock ) ;
                etThread.traceF( tinP , T("error: could not lock folder:    ")+T(psttf) ) ;
                POOPRqUIET
            {
            if( POOP )

            fileC* pFlock = new( 0 , tinP , LF ) fileC( tinP , psttf , ifcOPENaCCESS_R , 0 , flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_BUMPkEY | flOPENdETAILS_DOnOTmAKEdIRiFnEEDED , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 ) ; ___( pFlock ) ;
        {
        while( cDo -- )  //THIS IS TO VERIFY THAT I CAN DESTROY AND RECREATE THE FILE LOCK
        countT cDo = 2 ;

        SCOOPS
    {
    IFsCRATCH
    //CS:CODEsYNCH 51000767 51000767

    stFolderToCloak >> psttf ;
    ZE( strokeS* , psttf ) ;
{
while( stFolderToCloak )

switchC swFlock( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzLeverFolder ) ;
ZE( strokeS* , psttzLeverFolder ) ;

}
    }
        }
            }
                psttf = 0 ; // psttf HAS BEEN SUNK, SO THIS COPY IS A ZOMBIE

                }
                    etThread.traceF( tinP , T("error: could not walk:    ")+T(psttf) ) ;
                    POOPR
                {
                if( POOP )

                tinP.pEtScratch->diskWalkF( tinP , cDirs , cFiles , psttf , ether , flDISKwALK_DIRECTORIESoNLY , sinkFolderToCloakCBF , pcArg , 0 , 0 ) ;
                ZE( countT , cFiles ) ;
                ZE( countT , cDirs ) ;

                SCOOPS
            {
            IFsCRATCH
        {
        else
        if( !ids ) etThread.delF( tinP , psttf ) ;

        stFolderToCloak.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        ZE( countT , ids ) ;

        stFoldersToWalk >> psttf ;
        ZE( strokeS* , psttf ) ;
    {
    while( stFoldersToWalk )

    countT pcArg[] = { (countT)tinP.pEtScratch , (countT)&stFolderToCloak , (countT)&stFolderExclude , (countT)&stFoldersExclude } ;

    }
        //else       psttf = 0 ;
        //if( !ids ) etThread.delF( tinP , psttf ) ;
        //stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //ids = 0 ;
        //etThread.strMakeF( tinP , LF , psttf , tHome+T("tmp/") ) ; ___( psttf ) ;

        else       psttf = 0 ;
        if( !ids ) etThread.delF( tinP , psttf ) ;
        stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        ids = 0 ;
        etThread.strMakeF( tinP , LF , psttf , tHome+T("controls/") ) ; ___( psttf ) ;

        //else       psttf = 0 ;
        //if( !ids ) etThread.delF( tinP , psttf ) ;
        //stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //ids = 0 ;
        //etThread.strMakeF( tinP , LF , psttf , tHome+T("precious/domains/com/ideafarm/city/workshop/handle/") ) ; ___( psttf ) ;

        //else       psttf = 0 ;
        //if( !ids ) etThread.delF( tinP , psttf ) ;
        //stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //ids = 0 ;
        //etThread.strMakeF( tinP , LF , psttf , tHome+T("ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/") ) ; ___( psttf ) ;

        //else       psttf = 0 ;
        //if( !ids ) etThread.delF( tinP , psttf ) ;
        //stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //ids = 0 ;
        //etThread.strMakeF( tinP , LF , psttf , tHome+T("ephemeral/domains/com/ideafarm/city/park/exedll/1/master/") ) ; ___( psttf ) ;

        else       psttf = 0 ;
        if( !ids ) etThread.delF( tinP , psttf ) ;
        stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        ids = 0 ;
        etThread.strMakeF( tinP , LF , psttf , tHome+T("IdeaFarm (tm)/") ) ; ___( psttf ) ;

        // SINK EXCLUSIONS

        else       psttf = 0 ;
        if( !ids ) etThread.delF( tinP , psttf ) ;
        stFoldersToWalk.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //U::etThread.strMakeF( tinP , LF , psttf , tHome ) ; ___( psttf ) ;
        etThread.strMakeF( tinP , LF , psttf , /*U:: tHome */ T("///d/tmp/locked.test/") ) ; ___( psttf ) ;
        ZE( countT , ids ) ;

        // SINK FOLDERS TO WALK

        ZE( strokeS* , psttf ) ;
        
        //etThread.traceF( tinP , T("home:  ")+tHome ) ;
        }
            etThread.delF( tinP , psttNU ) ;
            etThread.delF( tinP , psttHome ) ;
            tHome  = T(psttHome) ;
            etThread.strBisectF( tinP , psttHome , psttNU , tName , tSlash , 5 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttHome ) ; ___( psttNU ) ;
            ZE( strokeS* , psttNU ) ;
            ZE( strokeS* , psttHome ) ;
        
            //etThread.traceF( tinP , T("if name:  ")+tName ) ;
            }
                break ;
                tName = T(ifName) ;
                etThread.delF( tinP , psttLower ) ;
                ifFileNameC ifName( tinP , etThread , T(psttLower) ) ;
                etThread.strConvertToLowerCaseF( tinP , psttLower , psttc1 ) ; ___( psttLower ) ;    // D:\iDeAfArM.home.1\ephemeral\domains\com\ideafarm\city\park\exedll\1\hover\ideafarm.00000180.ipdos-we
                ZE( strokeS* , psttLower ) ;
                //etThread.traceF( tinP , T("parameter:  ")+T(psttc1) ) ;
            {
            FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )
            TN( tName , "" ) ;
            TN( tSlash , "/" ) ;
        {
        TN( tHome , "" ) ;
    {
    stackC stFoldersExclude( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;        // PLURAL:        THE EXACT MATCH FOLDER AND ALL CONTAINED SUBFOLDERS
    stackC stFolderExclude(  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;        // SINGULAR: ONLY THE EXACT MATCH FOLDER
    stackC stFoldersToWalk(  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
{
stackC stFolderToCloak(      tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

TODO

DONE( tmServerF )
}
    }
        }
            SCOOPSdEL
            }
                }
                    else                { DEL( pso ) ; }
                    if( !ether && pso ) etThread.osThreadF( TaRG1( tmcCloakServerF ) , (countT)pso , (countT)&psttzLeverFolderP , (countT)&swFlockP ) ;

                    //etRock.traceF( tinP , T("cloak: called  acceptF for sListen") ) ;
                    sListen.acceptF( tinP , pso , idPortPeer , nnPeer , countTC() ) ;
                    //etRock.traceF( tinP , T("cloak: calling acceptF for sListen") ) ;
                    ZE( countT , idPortPeer ) ;
                    nicNameC nnPeer ;
                    ZE( socketC* , pso ) ;
                {
                while( !POOP && !etThread && !ether )
                sListen.listenF( tinP ) ;
            {
            else
            }
                etRock.traceF( tinP , T("cloak: could not bind to a port") ) ;
                POOPR
            {
            if( POOP )

            //LOGrAW3( "home.idPortKernelMonitor: " , home.idPortKernelMonitor , "\r\n" ) ;
            //etRock.traceF( tinP , T("cloak: sListen bound to port ")+TF2(home.portCloak,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
            home.portCloak = sListen.bindF( tinP ) ;
            homeS& home = homeS::homeIF() ;
            socketC sListen( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_NOsECRECY ) ;
            SCOOPSnEW
        {
        IFsCRATCH
        //etThread.traceF( tinP , T("listening for clients") ) ;
    {
    while( !ether )

    switchC&  swFlockP          =  *(switchC*)pTaskP->c2 ;
    strokeS*& psttzLeverFolderP = *(strokeS**)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmServerF )

DONE( tmWatchHandlesF )
}
    }
        ether.osSleepF( tinP , TOCK >> 1 ) ;

        }
            //etThread.traceF( tinP , T("hired handle.exe [value,idDeathType]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            etThread.osProcessF( tinP , osTid , osPid , value , idDeathType , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/handle/handle64.exe") , 0 , flPROCESShIRE_null , &hfOut , &hfError , 0 ) ;
            //G:etThread.osProcessF( tinP , osTid , osPid , value , idDeathType , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/bench.baseless/bench.exe") , 0 , flPROCESShIRE_null , &hfOut , &hfError , 0 ) ;
            //etThread.traceF( tinP , T("hiring handle.exe") ) ;
            ZE( countT , idDeathType ) ;
            ZE( countT , value ) ;
            ZE( countT , osPid ) ;
            ZE( countT , osTid ) ;
            TN( tb4 , "    " ) ;

            const handleC& hfError = fError ;
            fileC fError( tinP , (strokeS*)tError , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

            const handleC& hfOut = fOut ;
            fileC fOut( tinP , (strokeS*)tOut , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

            TN( tError  , "" ) ; tError  = T("///d/tmp/handle.error.")+tSuffix ;
            TN( tOut    , "" ) ; tOut    = T("///d/tmp/handle.out.")+tSuffix ;
            TN( tSuffix , "" ) ; tSuffix = TF3(++idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(".ttt") ;
        {
    {
    while( !ether && !POOP )
    ZE( countT , idCycle ) ;
{
if( pTaskP )
TASK( tmWatchHandlesF )

DONE( tmcCloakServerF )
}
    }
        DEL( psoP ) ;

        }
            }
                break ;

                }
                    DEL( psOut ) ;
                    }
                        psoP->writeF( tinP , *psOut ) ;
                        psOut = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psOut ) ;
                        DEL( psOut ) ;
                        psoP->writeF( tinP , *psOut ) ;
            
                        }
                            }
                                break ;

                                }
                                    swFlockP.ungrabF( tinP ) ;
                                    }
                                        //U::reportFilesF( tinP , etThread , psOut , psoP , pFlock , psttzLeverFolderP , flagsWant ) ;

                                        fileC*& pFlock   = *(fileC**)&(countT&)swFlockP ;
                                        psttzLeverFolderP = (strokeS*)swFlockP.leverF( tinP , idf ) ;
                                    {
                                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                    countT cFlavors = swFlockP.cFlavorsF( tinP ) ;
                                    swFlockP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                                    *psOut << (countT)ifcIDrEPLYcLOAK_ALLlOCKEDfOLDERScONTENTS ;
                                    *psOut << (countT)1 ;
                                    *psOut << (countT)FINGERnEG_CLOAKrEPLY ;
                                {
                                else
                                if( POOP ) etThread.traceF( tinP , T("error: invalid value received [flagsWant]:    ")+TF2(flagsWant,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                //FV(flFILEiNFO,flagsWant) ;
                                sIn >> flagsWant ;
                                ZE( flagsT , flagsWant ) ;
                            {
                            case ifcIDcMDcLOAK_QUERYaLLlOCKEDfOLDERScONTENTS :
                            }
                                break ;

                                }
                                    swFlockP.ungrabF( tinP ) ;
                                    }
                                        //U::reportFilesF( tinP , etThread , psOut , psoP , pFlock , psttFolder , flagsWant ) ;

                                        *psOut << (countT)ifcIDrEPLYcLOAK_FOLDERcONTENTS ;
                                        *psOut << (countT)1 ;
                                        *psOut << (countT)FINGERnEG_CLOAKrEPLY ;

                                        fileC*& pFlock   = *(fileC**)&(countT&)swFlockP ;
                                        psttzLeverFolderP = psttFolder ;
                                    {
                                    else
                                    if( !swFlockP.idSlotOfLeverF( tinP , (countT)psttFolder ) ) etThread.traceF( tinP , T("flavor not found [psttFolder]:    ")+T(psttFolder) ) ;
                                    swFlockP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                {
                                else
                                if( POOP ) etThread.traceF( tinP , T("error: invalid value received [flagsWant]:    ")+TF2(flagsWant,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                //FV(flFILEiNFO,flagsWant) ;
                                sIn >> flagsWant ;
                                ZE( flagsT , flagsWant ) ;

                                sIn >> psttFolder ;
                                ZE( strokeS* , psttFolder ) ;
                            {
                            case ifcIDcMDcLOAK_QUERYfOLDERcONTENTS :
                        {
                        switch( idCmd )
                        sIn >> idCmd ;
                        ZE( countT , idCmd ) ;

                        __( idFormat - 1 ) ;
                        sIn >> idFormat ;
                        ZE( countT , idFormat ) ;

                        __( finger - FINGERnEG_CLOAKcOMMAND ) ;
                        sIn >> finger ;
                        ZE( countT , finger ) ;
                    {
                    else
                    if( POOP ) { POOPR DEL( psoP ) ; }
            
                    psoP->readF( tinP , sIn ) ;

                    soulC* psOut = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psOut ) ;
                    soulC sIn(  tinP , TAG( TAGiDnULL ) ) ;
                {
                while( !POOP && !etThread && !ether && psoP )
            {
            case ifcIDtYPEcLOAKcONNECTION_SOULFUL :
            }
                break ;

                }
                    }
                        swFlockP.ungrabF( tinP ) ;
                        }
                            reportFilesSimpleF( tinP , etThread , psoP , pFlock , fnLike.pathF() , fnLike ) ;

                            fileC*& pFlock    = *(fileC**)&(countT&)swFlockP ;
                            psttzLeverFolderP = tLike ;
                        {
                        else
                        if( !swFlockP.idSlotOfLeverF( tinP , (countT)psttzLike ) ) etThread.traceF( tinP , T("flavor not found [psttFolder]:    ")+T(psttzLike) ) ;
                        swFlockP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                        strokeS* psttzLike = tLike ;
                        TN( tLike , fnLike.pathF() ) ;

                        patternC pat( tinP , etThread , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                        fileNameC fnLike( tinP , etThread , T(iffn) ) ;

                        ifFileNameC iffn( tinP , etThread , postLike ) ;

                        postLike[ costLike ] = 0 ;
                        psoP->readF( tinP , postLike , costLike ) ;
                    {
                    if( postLike )
                    
                    etThread.newF( tinP , LF , postLike , costLike + 1 ) ; ___( postLike ) ;
                    ZE( osTextT* , postLike ) ;
                {
                else
                if( POOP ) etThread.traceF( tinP , T("error: invalid request prefix") ) ;

                __( costLike > TUCK << 2 ) ;     // DEFENSIVE
                psoP->readF( tinP , (byteT*)&costLike , sizeof costLike ) ;
                ZE( countT , costLike ) ;

                __( idFormat - 1 ) ;
                psoP->readF( tinP , (byteT*)&idFormat , sizeof idFormat ) ;
                ZE( countT , idFormat ) ;

                __( finger - FINGERnEG_CLOAKsIMPLEcONNECTION ) ;
                psoP->readF( tinP , (byteT*)&finger , sizeof finger ) ;
                ZE( countT , finger ) ;
            {
            case ifcIDtYPEcLOAKcONNECTION_SIMPLE :
        {
        switch( idTypeConnection )
        psoP->readF( tinP , (byteT*)&idTypeConnection , sizeof idTypeConnection ) ;
        ZE( countT , idTypeConnection ) ;
    
        psoP->etherF( tinP , *tinP.pEtScratch ) ;
        SCOOPS
    {
    IFsCRATCH

    switchC&  swFlockP          =  *(switchC*)pTaskP->c3 ;
    strokeS*& psttzLeverFolderP = *(strokeS**)pTaskP->c2 ;
    socketC*  psoP              =   (socketC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TELL( "setting up" )
TASK( tmcCloakServerF )

}
    }
        replaceCloakF( tinP , etherP , pFlockP , psttFolderP ) ;

        }
            etherP.delF( tinP , pbBuffer ) ;
            while( !POOP && !bDone ) ;
            }
                }
                    }
                        }
                            psOutP = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psOutP ) ;
                            DEL( psOutP ) ;
                            psoP->writeF( tinP , *psOutP ) ;
                        {
                        if( *psOutP >= TUCK )   // THIS IS TO AVOID CAPACITY CONSTRAINT AND TO ALLOW CLIENT TO BEGIN PROCESSING THE FILE LIST

                        else                        break ;
                        if( info3.NextEntryOffset ) pbInfo3 += info3.NextEntryOffset ;

                        }
                            if( F(flagsP) & flFILEiNFO_CBnAME ) ;
                            if( F(flagsP) & flFILEiNFO_CBeXTENDEDaTTRIBUTES ) ;
                            if( F(flagsP) & flFILEiNFO_ATTRIBUTES ) ;
                            if( F(flagsP) & flFILEiNFO_CBaLLOCATED ) ;
                            if( F(flagsP) & flFILEiNFO_OFFSETeNDoFfILE ) ;
                            if( F(flagsP) & flFILEiNFO_TIMEcHANGED ) ;
                            if( F(flagsP) & flFILEiNFO_TIMEwRITTEN ) ;
                            if( F(flagsP) & flFILEiNFO_TIMEaCCESSED ) ;
                            if( F(flagsP) & flFILEiNFO_TIMEcREATED ) ;
                            if( F(flagsP) & flFILEiNFO_IDsERIAL ) ;

                            if( F(flagsP) & flFILEiNFO_NAME ) *psOutP << (strokeS*)T(postName) ;
                        {
                        if( thirdC::c_strcmpIF( tinP , postName , "." ) && thirdC::c_strcmpIF( tinP , postName , ".." ) )

                        //etherP.traceF( tinP , T("    [name]:    ")+T(postName) ) ;

                        unicodeToAnsiF( postName , sizeof postName , (byteT*)info3.FileName , info3.FileNameLength >> 1 ) ;

                        thirdC::c_memsetIF( tinP , postName , sizeof postName ) ;
                        osTextT postName[ TUCK << 1 ] ;

                        FILE_FULL_DIR_INFO& info3 = *(FILE_FULL_DIR_INFO*)pbInfo3 ;
                    {
                    for(;;)
                {
                else
                }
                    }
                        }
                            break ;
                            bDone = 1 ;
                        {
                        case ERROR_NO_MORE_FILES :
                        }
                            break ;
                            thirdC::c_memsetIF( tinP , pbBuffer , cbBuffer ) ;
                            etherP.newF( tinP , LF , pbBuffer , cbBuffer ) ; ___( pbBuffer ) ;
                            cbBuffer <<= 1 ;
                            etherP.delF( tinP , pbBuffer ) ;
                        {
                        case ERROR_BAD_LENGTH :
                        case ERROR_MORE_DATA :
                    {
                    switch( rc )
                    //etherP.traceF( tinP , T("GetFileInformationByHandleEx [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT rc = GetLastError() ;
                {
                if( !bOk )
                boolT bOk = GetFileInformationByHandleEx( (HANDLE)hFile.osF( ifcIDtYPEhANDLE_FILE ) , (FILE_INFO_BY_HANDLE_CLASS)FileFullDirectoryInfo_updated , pbBuffer , cbBuffer ) ;
                byteT* pbInfo3 = pbBuffer ;
            {
            do
            ZE( boolT , bDone ) ;

            //etherP.traceF( tinP , T("[sizeof FILE_FULL_DIR_INFO]:    ")+TF2( sizeof FILE_FULL_DIR_INFO , flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED ) ) ;

            thirdC::c_memsetIF( tinP , pbBuffer , cbBuffer ) ;
            etherP.newF( tinP , LF , pbBuffer , cbBuffer ) ; ___( pbBuffer ) ;
            countT cbBuffer = TUCK << 1 ;
            ZE( byteT* , pbBuffer ) ;

            handleC& hFile = *pFlockP ;
        {
    {
    if( F(flagsP) )

    //*psOutP << psttFolderP ;

    __1
    //U:: THIS NEEDS TO BE EDITED TO DO WHAT SIMPLE DOES: QUEUE ALL FILE INFORMATION AND RECLOAK BEFORE BEGINNING TO SEND INFO TO CLIENT

    }
        if( POOP ) return ;
        //FV(flFILEiNFO,flagsP) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
voidT reportFilesF( tinS& tinP , etherC& etherP , soulC*& psOutP , socketC*& psoP , fileC*& pFlockP , const strokeS* const psttFolderP , const flagsT flagsP )

}
    psoP->writeF( tinP , (byteT*)&costo , sizeof costo ) ;
    ZE( countT , costo ) ;

    DEL( pPat ) ;
    }
        etherP.delF( tinP , pbIn ) ;

        }
            else                        break ;
            if( info3.NextEntryOffset ) pbCursor += info3.NextEntryOffset ;

            }
                }
                    etherP.traceF( tinP , T("reportFilesSimpleF / sending [posto]:    ")+T(posto) ) ;
                    psoP->writeF( tinP , posto , costo ) ;
                    psoP->writeF( tinP , (byteT*)&costo , sizeof costo ) ;
                    countT   costo = tShort.csF( tinP ) ;
                    osTextT* posto = tShort ;
                {
                if( bOk )

                }
                    else                                 bOk = 0 ;
                    IFpATTERN( etherP , *pPat , tShort ) {}
                {
                if( pPat )
                boolT bOk = 1 ;
                TN( tShort , postName ) ;

                if( pPat ) etherP.traceF( tinP , T("reportFilesSimpleF [postName]:    \"")+T(postName)+T("\"") ) ;

                boolT bDir = info3.FileAttributes & FILE_ATTRIBUTE_DIRECTORY ;
            {
            if( thirdC::c_strcmpIF( tinP , postName , "." ) && thirdC::c_strcmpIF( tinP , postName , ".." ) )

            unicodeToAnsiF( postName , sizeof postName , (byteT*)info3.FileName , info3.FileNameLength >> 1 ) ;
            thirdC::c_memsetIF( tinP , postName , sizeof postName ) ;
            osTextT postName[ TUCK << 1 ] ;

            FILE_FULL_DIR_INFO& info3 = *(FILE_FULL_DIR_INFO*)pbCursor ;
        {
        for(;;)
        byteT* pbCursor = pbIn ;

        stBlobIn >> pbIn ;
        ZE( byteT* , pbIn ) ;
    {
    while( stBlobIn )
    patternC* pPat = !psttPatternP || !psttPatternP->idAdam ? 0 : new( 0 , tinP , LF ) patternC( tinP , etherP , psttPatternP , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; ___( pPat ) ;

    etherP.traceF( tinP , T("reportFilesSimpleF / replaced  cloak [psttFolderP]:    \"")+T(psttFolderP)+T("\"") ) ;

    replaceCloakF( tinP , etherP , pFlockP , psttFolderP ) ;

    etherP.traceF( tinP , T("reportFilesSimpleF / replacing cloak [psttFolderP]:    \"")+T(psttFolderP)+T("\"") ) ;

    }
        etherP.delF( tinP , pbBuffer ) ;
        while( !POOP && !bDone ) ;
        }
            }
                stBlobIn << pbUsed ;

                thirdC::c_memcpyIF( tinP , pbUsed , pbBuffer , cbUsed ) ;
                etherP.newF( tinP , LF , pbUsed , cbUsed ) ; ___( pbUsed ) ;
                ZE( byteT* , pbUsed ) ;

                }
                    }
                        break ;
                        cbUsed += 2 * unicodeLengthF( (unTextT*)info3.FileName ) ;                  // WE DONT SUBTRACT 2 BECAUSE WE CODE DEFENSIVELY (NULL LENGTH NAME) AND THE EXTRA BYTE WONT HURT ANYTHING
                        cbUsed += sizeof( FILE_FULL_DIR_INFO ) ;                                    // 2 EXTRA BYTES BECAUSE CONTAINS WOTH CHAR OF NAME
                    {
                    else
                    }
                        pbCursor += info3.NextEntryOffset ;
                        cbUsed += info3.NextEntryOffset ;
                    {
                    if( info3.NextEntryOffset )

                    FILE_FULL_DIR_INFO& info3 = *(FILE_FULL_DIR_INFO*)pbCursor ;
                {
                for(;;)
                ZE( countT , cbUsed ) ;
            {
            else
            }
                }
                    }
                        break ;
                        bDone = 1 ;
                    {
                    case ERROR_NO_MORE_FILES :
                    }
                        break ;
                        thirdC::c_memsetIF( tinP , pbBuffer , cbBuffer ) ;
                        etherP.newF( tinP , LF , pbBuffer , cbBuffer ) ; ___( pbBuffer ) ;
                        cbBuffer <<= 1 ;
                        etherP.delF( tinP , pbBuffer ) ;
                    {
                    case ERROR_BAD_LENGTH :
                    case ERROR_MORE_DATA :
                {
                switch( rc )
                countT rc = GetLastError() ;
            {
            if( !bOk )
            boolT bOk = GetFileInformationByHandleEx( (HANDLE)hFile.osF( ifcIDtYPEhANDLE_FILE ) , (FILE_INFO_BY_HANDLE_CLASS)FileFullDirectoryInfo_updated , pbBuffer , cbBuffer ) ;
            byteT* pbCursor = pbBuffer ;
        {
        do
        ZE( boolT , bDone ) ;

        thirdC::c_memsetIF( tinP , pbBuffer , cbBuffer ) ;
        etherP.newF( tinP , LF , pbBuffer , cbBuffer ) ; ___( pbBuffer ) ;
        countT cbBuffer = TOCK ; // PRODUCTION
        ZE( byteT* , pbBuffer ) ;

        handleC& hFile = *pFlockP ;
    {
    stackC stBlobIn( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_byteT ) ;

    etherP.traceF( tinP , T("reportFilesSimpleF [psttFolderP]:    \"")+T(psttFolderP)+T("\"") ) ;

    // QUEUE FILE INFORMATION FOR DISPENSING LATER, AFTER RELOCK psttFolderP: THIS IS NECESSARY BECAUSE CLIENT MIGHT USE FILE INFORMATION RECEIVED TO OPEN FILES, WHICH WOULD PREVENT ME FROM RELOCKING

    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
voidT reportFilesSimpleF( tinS& tinP , etherC& etherP , socketC*& psoP , fileC*& pFlockP , const strokeS* const psttFolderP , const strokeS* const psttPatternP )

}
    THREADmODE1rESTORE
    }
        }
            //etherP.traceF( tinP , T("folder relocked:    ")+T(psttFolderP) ) ;
        {
        else
        }
            //U:: SHUTDOWN THE COMPUTER BY FORCE HERE (SECURITY HOLE)

            DEL( pFlockP ) ;
            etherP.traceF( tinP , T("error: could not relock folder so am shutting this computer down (U::not really):    ")+T(psttFolderP) ) ;
            POOPRqUIET
        {
        if( POOP )

        pFlockP = new( 0 , tinP , LF ) fileC( tinP , psttFolderP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_BUMPkEY | flOPENdETAILS_DOnOTmAKEdIRiFnEEDED , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 ) ; ___( pFlockP ) ;

        SCOOPS
    {
    IFsCRATCH
    //CS:CODEsYNCH 51000767 51000767

    DEL( pFlockP ) ; //THIS IS NEEDED BECAUSE WINDOWS IS SUCH A PIECE OF SHIT: THERE IS NO OTHER WAY TO RESET THE HANDLE SO THAT THE NEXT QUERY DOES NOT RECEIVE "ERROR_NO_MORE_FILES"

    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

    //U:: ALT: IF I CANNOT REOPEN THE FILE, SHUT DOWN THE COMPUTER IMMEDIATELY (DECISION: DO THIS)
    //U:: ALT: SUPPORT THIS COMMAND ONLY ONCE PER PERIOD AND LAUNCH A THREAD TO WAIT A RANDOM AMOUNT OF TIME BEFORE CLOSING AND IMMEDIATELY REOPENING THIS FILE
    //U:: SECURITY HOLE: A MALICIOUS CLIENT CAN EXPLOIT THIS BY EMITTING THIS COMMAND AND THEN STARTING A CYCLING RACE TO TRY TO OPEN THE HANDLE ITSELF, PREVENTING ME FROM OPENING IT
{
voidT replaceCloakF( tinS& tinP , etherC& etherP , fileC*& pFlockP , const strokeS* const psttFolderP )

}
    return 0 ;

    }
        }
            else       psttf = 0 ;
            if( !ids ) etherP.delF( tinP , psttf ) ;
            stFolderToCloakP.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
            ZE( countT , ids ) ;
        {
        if( psttf )

        }
            }
                etherP.delF( tinP , psttf ) ;
                etherP.traceF( tinP , T("excluding folder but not its tree:    ")+T(psttf) ) ;
            {
            if( ids )
            stFolderExcludeP.sinkF( tinP , ids , psttf , flSTACKsINK_QUERY ) ;
            ZE( countT , ids ) ;
        {
        if( psttf && stFolderExcludeP )

        }
            while( !etherP && !stFoldersExcludeP.third && ~hWalk ) ;
            }
                }
                    break ;
                    etherP.delF( tinP , psttf ) ;
                    etherP.traceF( tinP , T("excluding folder and its tree:    ")+T(psttf) ) ;
                {
                if( 1 == etherP.strIdF( tinP , psttzf , psttf ) )

                strokeS* psttzf = (strokeS*)stFoldersExcludeP.downF( tinP , hWalk ) ;
            {
            do
            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , csttNeeded ) ;
        {
        if( stFoldersExcludeP )

        etherP.strMakeF( tinP , LF , psttf , tName ) ; ___( psttf ) ;
        ZE( strokeS* , psttf ) ;

        //etherP.traceF( tinP , tName ) ;

        TN( tName , ifName ) ;
        ifFileNameC ifName( tinP , etherP , postNameP ) ;

        stackC& stFoldersExcludeP = *(stackC*)pcArgP[ 3 ] ;
        stackC& stFolderExcludeP  = *(stackC*)pcArgP[ 2 ] ;
        stackC& stFolderToCloakP  = *(stackC*)pcArgP[ 1 ] ;
        etherC& etherP            = *(etherC*)pcArgP[ 0 ] ;

        _IO_
    {
    if( postNameP )
    _IO_
{
boolT sinkFolderToCloakCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

}
    return 0 ;

    *pbOutP = 0 ;
    }
        pbInP ++ ;
        *( pbOutP ++ ) = *( pbInP ++ ) ;
    {
    while( cInP -- )

    if( cbOutP <= cInP ) return 1 ;
{
boolT unicodeToAnsiF( byteT* pbOutP , const countT cbOutP , const byteT* pbInP , countT cInP )
//U::MOVE TO BASE

}
    return cunt ;
    for( countT offi = 0 ; puntP[ offi ] ; offi ++ ) cunt ++ ;
    ZE( countT , cunt ) ;
{
countT unicodeLengthF( const unTextT* puntP )
//U::MOVE TO BASE


} FILE_FULL_DIR_INFO, *PFILE_FULL_DIR_INFO;
  WCHAR         FileName[1];
  ULONG         EaSize;
  ULONG         FileNameLength;
  ULONG         FileAttributes;
  LARGE_INTEGER AllocationSize;
  LARGE_INTEGER EndOfFile;
  LARGE_INTEGER ChangeTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER CreationTime;
  ULONG         FileIndex;
  ULONG         NextEntryOffset;
typedef struct _FILE_FULL_DIR_INFO {
//CONJ: WATCOM'S NT HEADERS ARE OLD



} FILE_INFO_BY_HANDLE_CLASS_updated, *PFILE_INFO_BY_HANDLE_CLASS_updated;
  MaximumFileInfoByHandleClas_updateds
  FileNormalizedNameInfo_updated,
  FileCaseSensitiveInfo_updated,
  FileRenameInfoEx_updated,
  FileDispositionInfoEx_updated,
  FileIdExtdDirectoryRestartInfo_updated,
  FileIdExtdDirectoryInfo_updated,
  FileIdInfo_updated,
  FileAlignmentInfo_updated,
  FileStorageInfo_updated,
  FileFullDirectoryRestartInfo_updated,
  FileFullDirectoryInfo_updated,
  FileRemoteProtocolInfo_updated,
  FileIoPriorityHintInfo_updated,
  FileIdBothDirectoryRestartInfo_updated,
  FileIdBothDirectoryInfo_updated,
  FileAttributeTagInfo_updated,
  FileCompressionInfo_updated,
  FileStreamInfo_updated,
  FileEndOfFileInfo_updated,
  FileAllocationInfo_updated,
  FileDispositionInfo_updated,
  FileRenameInfo_updated,
  FileNameInfo_updated,
  FileStandardInfo_updated,
  FileBasicInfo_updated,
typedef enum _FILE_INFO_BY_HANDLE_CLASS_updated {


/*1*/WAKEhIDE( "ifcIDaDAM_CLOAK" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

