
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    etThread.delF( tinP , pbd ) ;
    byteT* pbd = (byteT*)cpbd ;
    stStringsOfBytesToDelete >> cpbd ;
    ZE( countT , cpbd ) ;
{
while( stStringsOfBytesToDelete )

}
    DEL( ptbld ) ;
    tableC* ptbld = (tableC*)cptbld ;
    stTablesToDelete >> cptbld ;
    ZE( countT , cptbld ) ;
{
while( stTablesToDelete )

}
    DEL( pstd ) ;
    stackC* pstd = (stackC*)cpstd ;
    stStacksToDelete >> cpstd ;
    ZE( countT , cpstd ) ;
{
while( stStacksToDelete )

reportF( tinP , etThread , bLever , lever , swNickname , swExtEmail ) ;

loadDataF( tinP , etThread , stStringsOfBytesToDelete , stTablesToDelete , stStacksToDelete , tNickname , tExtEmail , bLever , lever , swNickname , swExtEmail ) ;
TN( tExtEmail   , "///ideafarm/ephemeral/domains/com/ideafarm/city/data/base/be30104.extEmail"   ) ;
TN( tNickname   , "///ideafarm/ephemeral/domains/com/ideafarm/city/data/base/be30104.nickname"   ) ;

stackC stStacksToDelete( tinP , etThread , TAG( TAGiDnULL ) ) ;
stackC stTablesToDelete( tinP , etThread , TAG( TAGiDnULL ) ) ;
stackC stStringsOfBytesToDelete( tinP , etThread , TAG( TAGiDnULL ) ) ;

switchC      swExtEmail( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever ) ;
switchC      swNickname( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever ) ;
batonC       bLever( tinP , TAG( TAGiDnULL ) ) ;
ZE( countT , lever ) ;

TODO

}
    bLeverP.ungrabF( tinP ) ;

    }
        !tbl ;

        }
            }
                tbl.newObjectF( tinP , psttn ) ;
                tbl.newObjectF( tinP , leverP ) ;
                tbl.newEventF( tinP ) ;
            {
            if( psttn )
            strokeS* psttn = (strokeS*)(countT)swExtEmailP ;
            leverP = swExtEmailP.leverF( tinP , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )

        tbl.newColF( tinP ) ;
        tbl.newColF( tinP ) ;
        tableC tbl( tinP , etThread ) ;

        const countT cLevers = swExtEmailP.cFlavorsF( tinP ) ;
    {

    }
        !tbl ;

        }
            }
                tbl.newObjectF( tinP , psttn ) ;
                tbl.newObjectF( tinP , leverP ) ;
                tbl.newEventF( tinP ) ;
            {
            if( psttn )
            strokeS* psttn = (strokeS*)(countT)swNicknameP ;
            leverP = swNicknameP.leverF( tinP , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )

        tbl.newColF( tinP ) ;
        tbl.newColF( tinP ) ;
        tableC tbl( tinP , etThread ) ;

        const countT cLevers = swNicknameP.cFlavorsF( tinP ) ;
    {

    bLeverP.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT reportF( tinS& tinP , etherC& etThread , batonC& bLeverP , countT& leverP , switchC& swNicknameP , switchC& swExtEmailP )

}
    bLeverP.ungrabF( tinP ) ;

    }
        }
            swExtEmailP = (countT)tbl._CT1_07F( idr , 2 ) ;
            leverP   =            tbl._CT1_04F( idr , 1 ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tinP ) ;

        tbl.readF( tinP , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttExtEmailP ) ;
        tableC tbl( tinP , etThread ) ;
    {
    if( etThread.diskFileExistsF( tinP , psttExtEmailP ) )

    }
        }
            swNicknameP = (countT)tbl._CT1_07F( idr , 2 ) ;
            leverP   =            tbl._CT1_04F( idr , 1 ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tinP ) ;

        tbl.readF( tinP , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttNicknameP ) ;
        tableC tbl( tinP , etThread ) ;
    {
    if( etThread.diskFileExistsF( tinP , psttNicknameP ) )

    bLeverP.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT loadDataF( tinS& tinP , etherC& etThread , stackC& stStringsOfBytesToDeleteP , stackC& stTablesToDeleteP , stackC& stStacksToDeleteP , const strokeS* const psttNicknameP , const strokeS* const psttExtEmailP , batonC& bLeverP , countT& leverP , switchC& swNicknameP  , switchC& swExtEmailP )

/*1*/WAKEhIDE( "listCitizens" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

