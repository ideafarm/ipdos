
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

THREADmODE1rESTORE
}
    ether.loafIF( tinP ) ;

    }
        //}
        //    ++ s ; ether.osSleepF( tinP , TOCK * 0x10 ) ;
        //    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        //{

        etThread.delF( tinP , psttd ) ;
        etThread.strokeF( tinP , psttd ) ;
        strFaceF( tinP , etThread , psttd , bs ) ; ___( psttd ) ;
        ZE( strokeS* , psttd ) ;

        tree.nearbyF( tinP , bs ) ;
        branchesOldS bs ;
    {
    //for( tinP.lever ForAdamToUse = 1 ; !ether && tinP.lever ForAdamToUse <= 2 ; tinP.lever ForAdamToUse ++ )
    
    tree.downF( tinP ) ;
    
    tree.leftF( tinP ) ;
    tree.upF( tinP ) ;
    ~tree = tw222 ;
    
    tree.newKidF( tinP , T("223C") ) ;
    tree.newKidF( tinP , T("223B") ) ;
    tree.newKidF( tinP , T("223A") ) ;
    ~tree = tw223 ;
    
    tree.newKidF( tinP , T("222C") ) ;
    tree.newKidF( tinP , T("222B") ) ;
    tree.newKidF( tinP , T("222A") ) ;
    ~tree = tw222 ;
    
    tree.newKidF( tinP , T("221C") ) ;
    tree.newKidF( tinP , T("221B") ) ;
    tree.newKidF( tinP , T("221A") ) ;
    ~tree = tw221 ;
    
    tree.leftF( tinP ) ;
    tree.upF( tinP ) ;
    ~tree = tw22 ;
    
    tree.newKidF( tinP , T("23C") ) ;
    tree.newKidF( tinP , T("23B") ) ;
    tree.newKidF( tinP , T("23A") ) ;
    ~tree = tw23 ;
    
    tree.newKidF( tinP , T("22C") ) ;
    tree.newKidF( tinP , T("22B") ) ;
    tree.newKidF( tinP , T("22A") ) ;
    ~tree = tw22 ;
    
    tree.newKidF( tinP , T("21C") ) ;
    tree.newKidF( tinP , T("21B") ) ;
    tree.newKidF( tinP , T("21A") ) ;
    ~tree = tw21 ;
    
    tree.leftF( tinP ) ;
    tree.upF( tinP ) ;
    tree.kissF( tinP ) ;
    ~tree = tw2 ;
    
    tree.newKidF( tinP , T("3C") ) ;
    tree.newKidF( tinP , T("3B") ) ;
    tree.newKidF( tinP , T("3A") ) ;
    ~tree = tw3 ;
    
    tree.newKidF( tinP , T("2C") ) ;
    tree.newKidF( tinP , T("2B") ) ;
    tree.newKidF( tinP , T("2A") ) ;
    ~tree = tw2 ;
    
    tree.newKidF( tinP , T("1C") ) ;
    tree.newKidF( tinP , T("1B") ) ;
    tree.newKidF( tinP , T("1A") ) ;
    ~tree = tw1 ;

    TN( tw223 , "223" ) ;
    TN( tw222 , "222" ) ;
    TN( tw221 , "221" ) ;
    TN( tw23 , "23" ) ;
    TN( tw22 , "22" ) ;
    TN( tw21 , "21" ) ;
    TN( tw3 , "3" ) ;
    TN( tw2 , "2" ) ;
    TN( tw1 , "1" ) ;

    pTree = &tree ;
    treeOldC tree( tinP , TAG( TAGiDnULL ) ) ;
{
THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
//etThread.strokeF( tinP , T("")+OLDmOVEtO(IDcOLiNIT(*pw),IDrOWiNIT(*pw)) ) ;

{ sadamCBFT pf = scbF ; } //VERIFY TYPE

TODO

}
    WINDOWrEFERENCEeND( pw )

    etherP.strFuseF( tinP , psttP , T("")+//SCBA(scbF) ) ;

    woLevelF( tinP , etherP , psttP , bP.ppsttzDnKids      , bP.cDnKids      , bP.ppsttzUpKids      , bP.cUpKids      , rcr6 , rcr7 , rcr1 , rcr3 , rcr5 , rcr7 , 1 ) ;
    woLevelF( tinP , etherP , psttP , bP.ppsttzDnWives     , bP.cDnWives     , bP.ppsttzUpWives     , bP.cUpWives     , rcr5 , rcr6 , rcr1 , rcr3 , rcr5 , rcr7 , 0 ) ;
    woLevelF( tinP , etherP , psttP , bP.ppsttzDnBros      , bP.cDnBros      , bP.ppsttzUpBros      , bP.cUpBros      , rcr4 , rcr5 , rcr1 , rcr3 , rcr5 , rcr7 , 1 ) ;
    woLevelF( tinP , etherP , psttP , bP.ppsttzDnMoms      , bP.cDnMoms      , bP.ppsttzUpMoms      , bP.cUpMoms      , rcr3 , rcr4 , rcr1 , rcr3 , rcr5 , rcr7 , 0 ) ;
    woLevelF( tinP , etherP , psttP , bP.ppsttzDnDads      , bP.cDnDads      , bP.ppsttzUpDads      , bP.cUpDads      , rcr2 , rcr3 , rcr1 , rcr3 , rcr5 , rcr7 , 1 ) ;
    woLevelF( tinP , etherP , psttP , bP.ppsttzDnGrandMoms , bP.cDnGrandMoms , bP.ppsttzUpGrandMoms , bP.cUpGrandMoms , rcr1 , rcr2 , rcr1 , rcr3 , rcr5 , rcr7 , 0 ) ;
        
    ) ; ___( psttP ) ;

        0x2000 //U::CALCULATE THE SIZE NEEDED FOR bP
        ,

        S2(0,scOld_OLDCMDpUSHlEFTwATER)
        S2(0,scOld_OLDCMDpUSHrIGHTwATER)                          +
        S2(0,scOld_OLDCMDpUSHlOWwATER)                            +
        S2(0,scOld_PUSHhIGHwATER)                           +

        // //OLDlINEtOrATIO(rcr7,rcr2) +
        // //OLDmOVEtOrATIO(rcr1,rcr2) +
        // 
        // //OLDlINEtOrATIO(rcr7,rcr6) +
        // //OLDmOVEtOrATIO(rcr1,rcr6) +
        // 
        // //OLDlINEtOrATIO(rcr7,rcr5) +
        // //OLDmOVEtOrATIO(rcr1,rcr5) +
        // 
        // //OLDlINEtOrATIO(rcr7,rcr4) +
        // //OLDmOVEtOrATIO(rcr1,rcr4) +
        // 
        // //OLDlINEtOrATIO(rcr7,rcr3) +
        // //OLDmOVEtOrATIO(rcr1,rcr3) +
        // 
        // //OLDlINEtOrATIO(rcr7,rcr2) +
        // //OLDmOVEtOrATIO(rcr1,rcr2) +
        // 
        // //OLDlINEtOrATIO(rcr5,rcr7) +
        // //OLDmOVEtOrATIO(rcr5,rcr1) +
        // 
        // //OLDlINEtOrATIO(rcr3,rcr7) +
        // //OLDmOVEtOrATIO(rcr3,rcr1) +
        // 
        // //OLDlINEtOrATIO(rcr1,rcr1) +
        // //OLDlINEtOrATIO(rcr1,rcr7) +
        // //OLDlINEtOrATIO(rcr7,rcr7) +
        // //OLDlINEtOrATIO(rcr7,rcr1) +
        // //OLDmOVEtOrATIO(rcr1,rcr1) +
        //THIS STUFF DOES NOT WORK

        T("")+S2('\f',sc_cFROMcONTROL)                            +

    etherP.strMakeF( tinP , LF , psttP , 

    count01T rcr7 = (measureT)MAXscOUNT01T ;

    count01T rcr6 = (measureT)MAXscOUNT01T * ( .6667 + .04 ) ;
    count01T rcr5 = (measureT)MAXscOUNT01T / 3 * 2 ;

    count01T rcr4 = (measureT)MAXscOUNT01T * ( .3333 + .04 ) ;
    count01T rcr3 = (measureT)MAXscOUNT01T / 3 ;

    count01T rcr2 = (measureT)MAXscOUNT01T * .04 ;
    count01T rcr1 = 0 ;

    WINDOWrEFERENCEbEGIN( tinP , pw )
    windowOldC*& pw = thirdC::pWinRootIF() ;
{
voidT strFaceF( tinS& tinP , etherC& etherP , strokeS*& psttP , branchesOldS& bP )

}
    return 1 ;
    if( psttSnipP && idsP && bNoDrawP && flagsP && wP.bDoomed && stInvalidP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;

    }
        }
            break ;
            }
                }
                    }
                        break ;
                        }
                            case ifcIDtYPEtOOL_MOUSEbUTTONlEFT : { etherP.beeClickF( tinP , 0x1000 ) ; break ; }
                        {
                        switch( idTool )
                    {
                    case ifcIDtYPEaCTION_DOWN :
                {
                switch( idAction )

                const countT& idRow    = pcNotesP[ 5 ] ;
                const countT& idCol    = pcNotesP[ 4 ] ;
                const countT& idAction = pcNotesP[ 3 ] ;
                const countT& idTool   = pcNotesP[ 2 ] ;
            {
            if( pcNotesP[ 0 ] == 1 && pcNotesP[ 1 ] == 4 )
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            }
                //else etherP.beeClickF( tinP , 0x100 ) ;
                }
                    }
                        etherP.delF( tinP , psttd ) ;
                        etherP.strokeF( tinP , psttd ) ;
                        strFaceF( tinP , etherP , psttd , bs ) ; ___( psttd ) ;
                        ZE( strokeS* , psttd ) ;

                        pTree->nearbyF( tinP , bs ) ;
                        branchesOldS bs ;
                    {
                    if( bFreshFace )

                    }
                        }
                            break ;
                            }
                                bFreshFace = 1 ;
                                pTree->outF( tinP ) ;
                            {
                            if( pTree->outF( tinP , 1 ) )
                        {
                        case ifcIDtYPEtOOL_PAGEuPnUM :
                        case ifcIDtYPEtOOL_PAGEuP :
                        }
                            break ;
                            }
                                bFreshFace = 1 ;
                                pTree->inF( tinP ) ;
                            {
                            if( pTree->inF( tinP , 1 ) )
                        {
                        case ifcIDtYPEtOOL_PAGEdOWNnUM :
                        case ifcIDtYPEtOOL_PAGEdOWN :
                        }
                            break ;
                            }
                                bFreshFace = 1 ;
                                pTree->downF( tinP ) ;
                                pTree->rightF( tinP ) ;
                                pTree->upF( tinP ) ;
                            {
                            if( pTree->upF( tinP , 1 ) )
                        {
                        case ifcIDtYPEtOOL_RIGHTnUM :
                        case ifcIDtYPEtOOL_RIGHT :
                        }
                            break ;
                            }
                                bFreshFace = 1 ;
                                pTree->downF( tinP ) ;
                                pTree->leftF( tinP ) ;
                                pTree->upF( tinP ) ;
                            {
                            if( pTree->upF( tinP , 1 ) )
                        {
                        case ifcIDtYPEtOOL_LEFTnUM :
                        case ifcIDtYPEtOOL_LEFT :
                        }
                            break ;
                            }
                                bFreshFace = 1 ;
                                pTree->downF( tinP ) ;
                            {
                            if( pTree->downF( tinP , 1 ) )
                        {
                        case ifcIDtYPEtOOL_DOWNnUM :
                        case ifcIDtYPEtOOL_DOWN :
                        }
                            break ;
                            }
                                bFreshFace = 1 ;
                                pTree->upF( tinP ) ;
                            {
                            if( pTree->upF( tinP , 1 , 1 ) )
                        {
                        case ifcIDtYPEtOOL_UPnUM :
                        case ifcIDtYPEtOOL_UP :
                        }
                            break ;
                            else                                                                                    etherP.etherFireImpersonateMonitorIF( tinP ) ;
                            if( F(thirdC::third_flagsModeProcess1I_IF( tinP )) & flMODEpROCESS1_IGNOREfIREbYoPERATOR ) thirdC::dosBeepIF( tinP , 0x3800 , TUCK * 0x20 ) ;
                        {
                        case ifcIDtYPEtOOL_ESCAPE :
                    {
                    switch( idKey )
                    ZE( boolT , bFreshFace ) ;
                {
                if( idAction == ifcIDtYPEaCTION_DOWN )

                const countT& idAction = pcNotesP[ 3 ] ;
                const countT& idKey = pcNotesP[ 2 ] ;
            {
            if( pcNotesP[ 0 ] == 1 && pcNotesP[ 1 ] == 2 )
        {
        case ifcIDtYPEsTROKEcALLbACK_KEYBOARD :
        }
            break ;
        {
        case ifcIDtYPEsTROKEcALLbACK_DESTROY   :
        }
            break ;
        {
        case ifcIDtYPEsTROKEcALLbACK_RENDERoFF :
        }
            break ;
        {
        case ifcIDtYPEsTROKEcALLbACK_RENDERoN :
        }
            break ;
        {
        case ifcIDtYPEsTROKEcALLbACK_RENDER :
    {
    switch( idTypeCallP )

    scratchSnipP.c8scratch.c8 = idSnipP ; //U::
    measureT& mRowMax = *(measureT*)&scratchSnipP.c8scratch.c6 ;
    measureT& mColMax = *(measureT*)&scratchSnipP.c8scratch.c5 ;
    measureT& mRowMin = *(measureT*)&scratchSnipP.c8scratch.c4 ;
    measureT& mColMin = *(measureT*)&scratchSnipP.c8scratch.c3 ;
    boolT&    bRender = scratchSnipP.c8scratch.c2 ;
    boolT&    bQuit   = scratchSnipP.c8scratch.c1 ;
{
boolT scbF( tinS& tinP , etherC& etherP , windowOldC& wP , stackC& stInvalidP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )

voidT strFaceF( tinS& tinP , etherC& etherP , strokeS*& psttP , branchesOldS& bP ) ;

treeOldC* pTree ;

}
    }
        ) ;

            S2(0,scOld_mmCLIPiD)
            T(ppsttzUpP[1])                                                                             +
            OLDmOVE( bMaleP ? CRiNITm : CRiNITf , bMaleP ? CRiNITm : CRiNITf )                             +
            //OLDmOVEtOrATIO(c3P,r1P)                                                                        +
    
            OLDcLIPtOpOP                                                                                   +
            OLDmOVE( -1 , -1 )                                                                             +
            //OLDmOVEtOrATIO(c4P,r2P)                                                                        +
    
            S2(0,scOld_PUSHoVERRIDEcOLrOW)                                            +
            OLDmOVE( 1 , 1 )                                                                               +
            //OLDmOVEtOrATIO(c3P,r1P)                                                                        +
            T("")                                                                                       +

        if( cUpP ) etherP.strFuseF( tinP , psttP ,
    {
    if( ppsttzUpP )

    }
        ) ;

            S2(0,scOld_mmCLIPiD)
            T(ppsttzDnP[1])                                                                             +
            OLDmOVE( bMaleP ? CRiNITm : CRiNITf , bMaleP ? CRiNITm : CRiNITf )                             +
            //OLDmOVEtOrATIO(c1P,r1P)                                                                        +
    
            OLDcLIPtOpOP                                                                                   +
            OLDmOVE( -1 , -1 )                                                                             +
            //OLDmOVEtOrATIO(c2P,r2P)                                                                        +
    
            S2(0,scOld_PUSHoVERRIDEcOLrOW)                                            +
            OLDmOVE( 1 , 1 )                                                                               +
            //OLDmOVEtOrATIO(c1P,r1P)                                                                        +
            T("")                                                                                       +

        if( cDnP ) etherP.strFuseF( tinP , psttP ,

        ) ;

            S2(0,scOld_mmCLIPiD)
            T(ppsttzDnP[0])                                                                             +
            OLDmOVE( bMaleP ? CRiNITm : CRiNITf , bMaleP ? CRiNITm : CRiNITf )                             +
            //OLDmOVEtOrATIO(c2P,r1P)                                                                        +
    
            OLDcLIPtOpOP                                                                                   +
            OLDmOVE( -1 , -1 )                                                                             +
            //OLDmOVEtOrATIO(c3P,r2P)                                                                        +
    
            S2(0,scOld_PUSHoVERRIDEcOLrOW)                                            +
            OLDmOVE( 1 , 1 )                                                                               +
            //OLDmOVEtOrATIO(c2P,r1P)                                                                        +
            T("")                                                                                       +

        etherP.strFuseF( tinP , psttP ,
    {
    if( ppsttzDnP )
{
voidT woLevelF( tinS& tinP , etherC& etherP , strokeS*& psttP , const strokeS** const ppsttzDnP , const countT cDnP , const strokeS** const ppsttzUpP , const countT cUpP , const count01T r1P , const count01T r2P , const count01T c1P , const count01T c2P , const count01T c3P , const count01T c4P , const boolT bMaleP )

#define CRiNITf (0x2)
#define CRiNITm (0x4)

/*1*/WAKEhIDE( "doodle.hollywood.squares" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

