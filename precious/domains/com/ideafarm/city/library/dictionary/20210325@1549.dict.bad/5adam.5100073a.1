
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tinP , T("ok") ) ;

THREADmODE2rESTORE
}
    }
        ++ s ; etThread.osSleepF( tinP , TOCK ) ;
    {
    while( ws.cWorkers )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    //etThread.traceF( tinP , T("waiting for worker") ) ;

    }
        //etThread.traceF( tinP , T("napped") ) ;
        ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        //etThread.traceF( tinP , T("napping") ) ;

        //etThread.ifcHireF( tinP , T("ifcIDaDAM_ACCESSeVENTS2bOOKtOGETHER") , ifcIDaDAM_ACCESSeVENTS4rEPORT , 0 , flHIRE_WAIT | flHIRE_DISPLAYaUTO , 0 , 0 , 1 ) ;
        //etThread.traceF( tinP , T("hiring reporter and waiting") ) ;

        if( bQuit ) break ;

        THREADmODE1rESTORE
        }
            }
                }
                    }
                        ++ s ; etThread.osSleepF( tinP , TOCK >> 3 ) ;
                    {
                    while( ws.st_pPageEvent > ( TUCK >> 2 ) )
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( ws.st_pPageEvent > ( TUCK << 3 ) )

                //if( ws.idIn == TUCK ) bQuit2 = 1 ;

                bPrefix = !bPrefix ;

                else          pbi = 0 ;
                if( bDelete ) PUSE( tinP , *(byteT**)&pbi ) ;

                ;
                    : sizeof( countT )
                    ? *(countT*)pbi
                cbi = bPrefix

                //if( bPrefix && !( ++ ws.idIn % TUCK ) ) etThread.traceF( tinP , T("[ws.idIn]:    ")+TF2(ws.idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                }
                    ws.st_pPageEvent << *(countT*)&pPageEvent ;
                    __( (countT)*pPageEvent - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;
                    {
                    if( !(const byteT*)*pPageEvent )

                    THREADmODE3rESTORE
                    //tinP.pc Utility[ 0 ] -- ; //U:: TO FIND A BUG
                    bksAccessEvents.readF( tinP , *pPageEvent , hRead , flBOOKScrEAD_null ) ;
                    //tinP.pc Utility[ 0 ] ++ ; //U:: TO FIND A BUG
                    pPageEvent = new( 0 , tinP , LF ) pageC( tinP , bksAccessEvents , cbi ) ; ___( pPageEvent ) ;
                    THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                    ZE( pageC* , pPageEvent ) ;
                {
                else
                }
                    __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;
                    {
                    if( !pbi )
                    //tinP.pc Utility[ 0 ] -- ; //U:: TO FIND A BUG
                    bDelete = bksAccessEvents.readF( tinP , pbi , cbi , hRead ) ;
                    //tinP.pc Utility[ 0 ] ++ ; //U:: TO FIND A BUG
                {
                if( bPrefix )
                ZE( boolT , bDelete ) ;

                HANDLEaPPnOTEScOUNTcLASS ch = hRead ;

                handleC hReadSave = hRead ;
                countT cbiSave = cbi ;
            {
            while( !bQuit && !bQuit2 && !POOP )
            boolT bPrefix = 1 ;
            countT cbi = sizeof( countT ) ;
            ZE( const byteT* , pbi ) ;

            // *****************************************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
            // ********                    *************************************************************************************************************************************************************************************************************************
            // ********  EAT BOOK ENTRIES  *************************************************************************************************************************************************************************************************************************
            // ********                    *************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
        {
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    {
    while( !bQuit && !bQuit2 && !POOP )
    ZE( boolT , bQuit2 ) ;
    handleC hRead( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;

    #endif
    //etThread.traceF( tinP , T("napped  to let workers wake up") ) ;
    }
        ++ s ; etThread.osSleepF( tinP , TOCK << 4 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    //etThread.traceF( tinP , T("napping to let workers wake up") ) ;
    #if defined( NEVERdEFINED )

    }
        etThread.osThreadF( tinP , countTC() , tmWorkerF , 0 , flTHREADlAUNCH_null , TOCK , (countT)&ws , (countT)&bksAccessEvents ) ;
        inc02AM( ws.cWorkers ) ;
    {
    while( cDo -- )
    countT cDo = 0x10 ;

    workS ws( tinP , etThread ) ;
{
THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

booksC bksAccessEvents( tinP , TAG( TAGiDnULL ) , "bksAccessEvents.1.raw" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_null , 0 , 1 , 0 , 0 , 0 , 0 , &bQuit ) ;
const boolT& bQuit = *(const boolT*)&(const countT&)ether ;


// EVERY JOT INSTANCE CONTAINS HASH PREFIXED STRINGS TO KEEP CODE SIMPLE EVEN THOUGH THE HASH IS NOT USEFUL FOR THE STRINGS IN jhsOther

//U:: REDUCE SIZE OF SOME OF THESE jotC INSTANCES


//U::ether.ifcHireF( tinP , T("ifcIDaDAM_ACCESSeVENTS2bOOKtOGETHER") , ifcIDaDAM_CLOUD , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; // flHIRE_DISPLAYaUTO CAN BE COMMENTED OUT TO AVOID WDW FOR ROOT CLOUD INSTANCE WHICH IS USUALLY NOT INTERESTING

TODO

DONE( tmWorkerF )
}
    dec02AM( wsP.cWorkers ) ;
    }
        }
            THREADmODE1rESTORE
            THREADmODE2rESTORE
            }
                wsP.st_pPageEvent.ungrabF( tinP ) ;
                }
                    wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    }
                        THREADmODE3rESTORE
                        DEL( pPageEvent ) ;
                        THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )

                        etThread.delF( tinP , psttBrowser ) ;
                        etThread.delF( tinP , psttProtocol ) ;
                        etThread.delF( tinP , psttQuery ) ;
                        etThread.delF( tinP , psttUri ) ;
                        etThread.delF( tinP , psttContainer ) ;
                        etThread.delF( tinP , psttLogBucket ) ;
                        etThread.delF( tinP , psttMethod ) ;

                        }
                            }
                                }
                                    listC::fieldIF( tinP , pOut , hRecordEvent , pczfBrowser   , _1_pushC( pidj[ 6 ] ) + _1_modeMixinDoNotIndexC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ; { puseC pu( wsP.puseAT ) ; DELlIST( fieldEditParamOutC , pOut ) ; } // DO NOT INDEX
                                    listC::fieldIF( tinP , pOut , hRecordEvent , pczfCbRequest , _1_pushC( cbRequest ) + _1_modeMixinDoNotIndexC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ; { puseC pu( wsP.puseAT ) ; DELlIST( fieldEditParamOutC , pOut ) ; }
                                    listC::fieldIF( tinP , pOut , hRecordEvent , pczfCode      , _1_pushC( code      ) + _1_modeMixinDoNotIndexC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ; { puseC pu( wsP.puseAT ) ; DELlIST( fieldEditParamOutC , pOut ) ; }
                                    listC::fieldIF( tinP , pOut , hRecordEvent , pczfProtocol  , _1_pushC( pidj[ 5 ] ) + _1_modeMixinDoNotIndexC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ; { puseC pu( wsP.puseAT ) ; DELlIST( fieldEditParamOutC , pOut ) ; }
                                    listC::fieldIF( tinP , pOut , hRecordEvent , pczfQuery     , _1_pushC( pidj[ 4 ] ) + _1_modeMixinDoNotIndexC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ; { puseC pu( wsP.puseAT ) ; DELlIST( fieldEditParamOutC , pOut ) ; }
                                    listC::fieldIF( tinP , pOut , hRecordEvent , pczfUri       , _1_pushC( pidj[ 3 ] ) + _1_modeMixinDoNotIndexC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ; { puseC pu( wsP.puseAT ) ; DELlIST( fieldEditParamOutC , pOut ) ; } // DO NOT INDEX
                                    listC::fieldIF( tinP , pOut , hRecordEvent , pczfContainer , _1_pushC( pidj[ 2 ] ) + _1_modeMixinDoNotIndexC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ; { puseC pu( wsP.puseAT ) ; DELlIST( fieldEditParamOutC , pOut ) ; }
                                    listC::fieldIF( tinP , pOut , hRecordEvent , pczfLogBucket , _1_pushC( pidj[ 1 ] ) + _1_modeMixinDoNotIndexC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ; { puseC pu( wsP.puseAT ) ; DELlIST( fieldEditParamOutC , pOut ) ; }
                                    listC::fieldIF( tinP , pOut , hRecordEvent , pczfMethod    , _1_pushC( pidj[ 0 ] ) + _1_modeMixinDoNotIndexC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ; { puseC pu( wsP.puseAT ) ; DELlIST( fieldEditParamOutC , pOut ) ; }

                                    listC::openIF( tinP , hRecordEvent    , hIdJotUri       , pczRecordEvent    , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ;
                                    listC::openIF( tinP , hIdJotUri       , hHashUri        , pczIdJotUri       , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ;
                                    listC::openIF( tinP , hHashUri        , hIdJotContainer , pczHashUri        , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ;
                                    listC::openIF( tinP , hIdJotContainer , hContainers     , pczIdJotContainer , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ;
                                    listC::openIF( tinP , hContainers     , pczContainers                       , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ;

                                    puseC pu3( wsP.puseEvents ) ;
                                {

                                grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;

                                if( !( idOutMine % TUCK ) ) etThread.traceF( tinP , T("[idOut]:    ")+TF2(idOutMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                countT idOutMine = 1 + incv02AM( wsP.idOut ) ;

                                handleC hRecordEvent(    tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                                handleC hIdJotUri(       tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                                handleC hHashUri(        tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                                handleC hIdJotContainer( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                                handleC hContainers(     tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                                _IO_
                            {

                            // *****************************************************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            // ********                                                     ****************************************************************************************************************************************************************************************
                            // ********  OPEN EVENT RECORD ; STORE idJotContainer idJotUri  ****************************************************************************************************************************************************************************************
                            // ********                                                     ****************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************

                            }
                                ) ;
                                    2 + ccn , count2S( LISTnAME_RECORD )
                                    ,
                                        : (const countT*)count4S( ((const countT*)nnHe)[ 0 ]                                                                                        , timeW1 , (countT)timeW2 )
                                        ? (const countT*)count7S( ((const countT*)nnHe)[ 0 ] , ((const countT*)nnHe)[ 1 ] , ((const countT*)nnHe)[ 2 ] , ((const countT*)nnHe)[ 3 ] , timeW1 , (countT)timeW2 )
                                    ccn > 1
                                    tinP , pcznu , 0 ,
                                (
                                etherC::strStretchIF
                                countT* pcznu = pczRecordEvent ;

                                if( ccn > 1 ) ccn = 4 ;
                                if( !ccn || ccn > 4 ) { BLAMMO ; }
                                countT ccn = nnHe.ccF() ;
                                _IO_
                            {

                            { countT* pcznu = pczIdJotUri ; etherC::strStretchIF( tinP , pcznu , 0 , pidj[ 3 ] ) ; }

                            // *****************************************************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            // ********                        *********************************************************************************************************************************************************************************************************************
                            // ********  CONSTRUCT LIST NAMES  *********************************************************************************************************************************************************************************************************************
                            // ********                        *********************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************

                            }
                                if( !pidj[ offi ] ) { BLAMMO ; }

                                ppjhs[ offi ]->ungrabF( tinP ) ;
                                //if( offi == 3 ) etThread.traceF( tinP , T("serialized processing ---- for offi==3 [hash]:    ")+TF2(ph[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                }
                                    etThread.traceF( tinP , T("stored  [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[ offi ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                    DELlIST( fieldEditParamOutC , pOut ) ;
                                    }
                                        listC::fieldIF( tinP , pOut , hHashUri  , pczfIdJotUri , _1_pushC( pidj[ offi ] ) + _1_modeMixinDoNotIndexC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ;

                                        listC::openIF( tinP , hHashUri        , hIdJotContainer , pczHashUri        , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ;
                                        listC::openIF( tinP , hIdJotContainer , hContainers     , pczIdJotContainer , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ;
                                        listC::openIF( tinP , hContainers     , pczContainers                       , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ;

                                        puseC pu1( wsP.puseEvents ) ;

                                        grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;

                                        handleC hHashUri(        tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                                        handleC hIdJotContainer( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                                        handleC hContainers(     tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

                                        //etThread.delF( tinP , pczSquished ) ;
                                        //etThread.traceF( tinP , T("listing new uri [idJotNewUri,pczHashUri]:   ")+TF2(pidj[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pczSquished,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        //etThread.strSquishIF( tinP , pczSquished , pczHashUri ) ; ___( pczSquished ) ;
                                        //ZE( countT* , pczSquished ) ;
                                    {
                                    else if( offi == 3 )
                                    }
                                        DELlIST( fieldEditParamOutC , pOut ) ;
                                        }
                                            listC::fieldIF( tinP , pOut , hContainers  , pczfIdJotContainer , _1_pushC( pidj[ offi ] ) + _1_modeMixinDoNotIndexC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ;
                                            listC::openIF( tinP , hContainers , pczContainers , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ;
                                            puseC pu1( wsP.puseEvents ) ;
                                        {

                                        grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;

                                        handleC hContainers( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

                                        //etThread.delF( tinP , pczSquished ) ;
                                        //etThread.traceF( tinP , T("listing new container [idJotNewContainer,pczContainers]:   ")+TF2(pidj[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pczSquished,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        //etThread.strSquishIF( tinP , pczSquished , pczContainers ) ; ___( pczSquished ) ;
                                        //ZE( countT* , pczSquished ) ;
                                    {
                                    if( offi == 2 )
                                    pidj[ offi ] = (countT)pbEncoded ;
                                    etThread.strEncodeF( tinP , pbEncoded , psttzv , 0 , sizeof( countT ) , (const byteT*)&ph[ offi ] ) ; ___( pbEncoded ) ;
                                    ZEJ( byteT* , pbEncoded , *ppjhs[ offi ] ) ;
                                    //etThread.traceF( tinP , T("storing [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[ offi ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                    _IO_
                                {
                                if( !pidj[ offi ] )

                                }
                                    }
                                        break ;
                                        }
                                            }
                                                etThread.delF( tinP , psttHe ) ;
                                                }
                                                    //etThread.traceF( tinP , T("found   [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                                    pidj[ offi ] = ppjhs[ offi ]->idLathReadF() ;
                                                {
                                                if( !etThread.strCompareF( tinP , psttzv , psttHe ) )
                                                //etThread.traceF( tinP , T("comparing [offi,psttzv,psttHe]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv)+tb4+T(psttHe) ) ;
                                                etThread.strDecodeF( tinP , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                                                ZE( strokeS* , psttHe ) ;
                                            {
                                            else if( *(countT*)pbEncodedHe == ph[ offi ] )
                                            if( !pbEncodedHe || !cbEncodedHe ) break ;

                                            countT       cbEncodedHe = pageHe ;
                                            const byteT* pbEncodedHe = pageHe ;

                                            pageC pageHe = *ppjhs[ offi ] ;
                                            //CS:PSEUDOdUPLICATE this this
                                        {
                                        while( !pidj[ offi ] )
                                        ppjhs[ offi ]->resetLathReadF() ;
                                        _IO_
                                    {
                                    default :   // SEARCH JOT SEQUENTIALLY
                                    }
                                        break ;

                                        stIdJotUri.purgeF( tinP ) ;
                                        }
                                            }
                                                etThread.delF( tinP , psttHe ) ;
                                                }
                                                    break ;
                                                    etThread.delF( tinP , psttHe ) ;
                                                    //etThread.traceF( tinP , T("found! [offi,idJot,psttzv,psttHe]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv)+tb4+T(psttHe) ) ;
                                                    pidj[ offi ] = idJot ;
                                                {
                                                if( !etThread.strCompareF( tinP , psttzv , psttHe ) )
                                                //etThread.traceF( tinP , T("comparing [offi,psttzv,psttHe]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv)+tb4+T(psttHe) ) ;
                                                etThread.strDecodeF( tinP , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                                                ZE( strokeS* , psttHe ) ;

                                                }
                                                    continue ;
                                                    etThread.traceF( tinP , T("error: unexpected hash [offi,idJot,actualHash,expectedHash]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(*(countT*)pbEncodedHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ph[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( *(countT*)pbEncodedHe != ph[ offi ] )
                                            {
                                            if( pbEncodedHe && cbEncodedHe )

                                            countT       cbEncodedHe = pageHe ;
                                            const byteT* pbEncodedHe = pageHe ;

                                            pageC pageHe = jotUse[ idJot ] ;
                                            //CS:PSEUDOdUPLICATE this this

                                            jotC& jotUse = *ppjhs[ offi ] ;

                                            stIdJotUri >> idJot ;
                                            ZE( countT , idJot ) ;
                                            _IO_
                                        {
                                        while( stIdJotUri )

                                        DELlIST( fieldEditParamOutC , pOut ) ;
                                        }
                                            }
                                                pCursor = pCursor->pNext ;
                                                }
                                                    stIdJotUri << idJotUri ;
                                                    //etThread.traceF( tinP , T("retrieved [idJotUri]:   ")+TF2(idJotUri,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    countT idJotUri = *(const countT*)pCursor->vspCount ;
                                                {
                                                if( (const countT*)pCursor->vspCount )
                                            {
                                            while( pCursor )
                                            fieldEditParamOutC* pCursor = pOut ;
                                            _IO_
                                        {

                                        }
                                            //}
                                            //    etThread.delF( tinP , pczSquished ) ;
                                            //    etThread.traceF( tinP , T("querying container [pczHashUri]:   ")+TF2(pczSquished,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //        
                                            //    etThread.strSquishIF( tinP , pczSquished , pczHashUri ) ; ___( pczSquished ) ;
                                            //    ZE( countT* , pczSquished ) ;
                                            //{
                                            //if( bSay )

                                            }
                                                }
                                                    }
                                                        }
                                                            listC::fieldIF( tinP , pOut , hHashUri , pczfIdJotUri , _1_queryC() + _1_modeAllC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ;
                                                            //bSay ++ ;
                                                        {
                                                        if( ~hHashUri )
                                                        listC::openIF( tinP , hHashUri , hIdJotContainer , pczHashUri , flLISToPEN_IFeXISTS , ifcIDgRABlAYER_7BASEmISC3 ) ;
                                                    {
                                                    if( ~hIdJotContainer )
                                                    listC::openIF( tinP , hIdJotContainer , hContainers , pczIdJotContainer , flLISToPEN_IFeXISTS , ifcIDgRABlAYER_7BASEmISC3 ) ;
                                                {
                                                if( ~hContainers )

                                                listC::openIF( tinP , hContainers , pczContainers , flLISToPEN_IFeXISTS , ifcIDgRABlAYER_7BASEmISC3 ) ;

                                                puseC pu2( wsP.puseEvents ) ;
                                                grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
                                            {
                                            //ZE( boolT , bSay ) ;

                                            handleC hHashUri(        tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                                            handleC hIdJotContainer( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                                            handleC hContainers(     tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

                                            _IO_
                                        {

                                        { countT* pcznu = pczHashUri        ; etherC::strStretchIF( tinP , pcznu , 0 , hashUri   ) ; }
                                        { countT* pcznu = pczIdJotContainer ; etherC::strStretchIF( tinP , pcznu , 0 , pidj[ 2 ] ) ; }
                                    {                                           //  LISTnAME_STRETCHbEGINcOUNTsTRZ   |-------- idJotContainer OR hashUri ----------------------------------------------------|   LISTnAME_STRETCHeND
                                    case 3 :    // LOOK UP idJotUri
                                    }
                                        break ;

                                        stIdJotContainer.purgeF( tinP ) ;
                                        }
                                            }
                                                etThread.delF( tinP , psttHe ) ;
                                                }
                                                    break ;
                                                    etThread.delF( tinP , psttHe ) ;
                                                    pidj[ offi ] = idJot ;
                                                {
                                                if( !etThread.strCompareF( tinP , psttzv , psttHe ) )
                                                etThread.strDecodeF( tinP , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                                                ZE( strokeS* , psttHe ) ;

                                                }
                                                    continue ;
                                                    etThread.traceF( tinP , T("error: unexpected hash [offi,idJot,actualHash,expectedHash]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(*(countT*)pbEncodedHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ph[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( *(countT*)pbEncodedHe != ph[ offi ] )
                                            {
                                            if( pbEncodedHe && cbEncodedHe )

                                            countT       cbEncodedHe = pageHe ;
                                            const byteT* pbEncodedHe = pageHe ;

                                            pageC pageHe = jotUse[ idJot ] ;
                                            //CS:PSEUDOdUPLICATE this this

                                            jotC& jotUse = *ppjhs[ offi ] ;

                                            stIdJotContainer >> idJot ;
                                            ZE( countT , idJot ) ;
                                            _IO_
                                        {
                                        while( stIdJotContainer )

                                        DELlIST( fieldEditParamOutC , pOut ) ;
                                        }
                                            }
                                                pCursor = pCursor->pNext ;
                                                }
                                                    stIdJotContainer << idJotContainer ;
                                                    //etThread.traceF( tinP , T("retrieved [idJotContainer]:   ")+TF2(idJotContainer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    countT idJotContainer = *(const countT*)pCursor->vspCount ;
                                                {
                                                if( (const countT*)pCursor->vspCount )
                                            {
                                            while( pCursor )
                                            fieldEditParamOutC* pCursor = pOut ;
                                            _IO_
                                        {

                                        }
                                            //}
                                            //    etThread.delF( tinP , pczSquished ) ;
                                            //    etThread.traceF( tinP , T("querying container [pczContainers]:   ")+TF2(pczSquished,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //
                                            //    etThread.strSquishIF( tinP , pczSquished , pczContainers ) ; ___( pczSquished ) ;
                                            //    ZE( countT* , pczSquished ) ;
                                            //{
                                            //if( bSay )

                                            }
                                                }
                                                    listC::fieldIF( tinP , pOut , hContainers , pczfIdJotContainer , _1_queryC() + _1_modeAllC() , LF , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC3 ) ; ___( pOut ) ;
                                                    //bSay ++ ;
                                                {
                                                if( ~hContainers )

                                                listC::openIF( tinP , hContainers , pczContainers , flLISToPEN_IFeXISTS , ifcIDgRABlAYER_7BASEmISC3 ) ;
                                                puseC pu1( wsP.puseEvents ) ;
                                                grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
                                                handleC hContainers( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                                            {
                                            //ZE( boolT , bSay ) ;

                                            _IO_
                                        {
                                    {
                                    case 2 :    // LOOK UP idJotContainer
                                {
                                switch( offi )

                                //}
                                    //}
                                    //    countT foo = 2 ;
                                    //{
                                    //if( idIn == 2 )

                                    //etThread.traceF( tinP , T("off==3 [idIn,uri]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(ppsttzValue[offi]) ) ;

                                    //countT idIn = 1 + incv02AM( idInLath ) ;
                                    //static countT idInLath ;
                                //{
                                //if( offi == 3 )
                                //U:: TO FIND A BUG

                                //if( offi == 3 ) etThread.traceF( tinP , T("serialized processing ++++ for offi==3 [hash]:    ")+TF2(ph[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                ppjhs[ offi ]->grabF( tinP , TAG( TAGiDnULL ) ) ;

                                if( offi != 2 && offi != 3 ) ph[ offi ] = hashF( (byteT*)psttzv , sizeof( strokeS ) * ( CSpREFIX + psttzv->idAdam ) , 0 ) ;          // I ALREADY HAVE HASH FOR OFFSETS 2 3

                                strokeS* psttzv = ppsttzValue[ offi ] ;
                                _IO_
                            {
                            for( countT offi = 0 ; offi < sizeof ppsttzValue / sizeof ppsttzValue[ 0 ] ; offi ++ )
                            ZE( fieldEditParamOutC* , pOut ) ;
                    
                            countT   ph[]          = { 0             , 0             , hashContainer , hashUri     , 0             , 0             , 0               } ; // "ph":"pHash"                                    CS:CODEsYNC: this this this this
                            countT   pidj[]        = { 0             , 0             , 0             , 0           , 0             , 0             , 0               } ; // "pidj":"pIdJot"                                 CS:CODEsYNC: this this this this
                            strokeS* ppsttzValue[] = { psttMethod    , psttLogBucket , psttContainer , psttUri     , psttQuery     , psttProtocol  , psttBrowser     } ; // STROKE STRING                                   CS:CODEsYNC: this this this this
                            jotC*    ppjhs[]       = { &wsP.jhsOther , &wsP.jhsOther , &wsP.jhsOther , &wsP.jhsUri , &wsP.jhsQuery , &wsP.jhsOther , &wsP.jhsBrowser } ; // "ppjhs":"ppJotHashStrings"                        CS:CODEsYNC: this this this this
                            // CONTAINER (OFFSET 2) MUST HAVE LOWER OFFSET THAN URI (OFFSET 3) IN THESE ARRAYS SO THAT I HAVE idJotContainer WHEN I NEED TO LOOK UP idJotUri

                            } ;
                                LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , 0                                                     // LISTnAME_STRETCHeND , LISTnAME_RECORD
                                LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER ,         // 6: NN1
                                LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER ,         // 5: NN2
                                LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER ,         // 4: NN3
                                LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER ,         // 3: NN4
                                LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER ,         // 2: TIME1
                                LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER ,         // 1: TIME2
                                LISTnAME_PLACEhOLDER ,                                                                              // LISTnAME_STRETCHbEGINcOUNTsTRZ
                            {
                            countT pczRecordEvent[] =

                            countT pczIdJotUri[]       = { LISTnAME_PLACEhOLDER           , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , 0 } ;

                            countT pczHashUri[]        = { LISTnAME_PLACEhOLDER           , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , 0 } ;

                            countT pczIdJotContainer[] = { LISTnAME_PLACEhOLDER           , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , 0 } ;

                                                       //  LISTnAME_STRETCHbEGINcOUNTsTRZ   |-------- idJotContainer OR hashUri ----------------------------------------------------|   LISTnAME_STRETCHeND

                            { countT* pcznu = pczContainers ; etherC::strStretchIF( tinP , pcznu , pczPrefix , hashContainer ) ; }

                            } ;
                                LISTnAME_PLACEhOLDER , 0                                                                            // LISTnAME_STRETCHeND
                                LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER ,         // HASHcONTAINER
                                LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER , LISTnAME_PLACEhOLDER ,         // LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION , "listAccessEeventsByContainerUri" , LISTnAME_STRETCHbEGINcOUNTsTRZ
                            {
                            countT pczContainers[] =                                                                          // PLURAL BECAUSE MULTIPLE CONTAINERS MIGHT HAVE THIS HASH

                            // *****************************************************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            // ********                             ****************************************************************************************************************************************************************************************************************
                            // ********  GET IDjOT VALUES , HASHES  ****************************************************************************************************************************************************************************************************************
                            // ********                             ****************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************

                            const countT hashUri       = hashF( (byteT*)psttUri       , sizeof( strokeS ) * ( CSpREFIX + psttUri->idAdam       ) , 0 ) ;
                            const countT hashContainer = hashF( (byteT*)psttContainer , sizeof( strokeS ) * ( CSpREFIX + psttContainer->idAdam ) , 0 ) ;

                            //}
                            //    etThread.traceF( tinP , T("[nnHe,time,method,bucket,container,uri,query,protocol,code,cb,browser]:    ")+tSay ) ;
                            //
                            //    ;
                            //
                            //        +tb4+tBrowser
                            //        +tb4+TF4(cbRequest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                            //        +tb4+TF4(code,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                            //        +tb4+tProtocol
                            //        +tb4+tQuery
                            //        +tb4+tUri
                            //        +tb4+tContainer
                            //        +tb4+tLogBucket
                            //        +tb4+tMethod
                            //        +tb4+TT(timeW1,timeW2)
                            //        T(nnHe)
                            //
                            //    TN( tSay , "" ) ; tSay =
                            //
                            //    TN( tBrowser   , psttBrowser   ) ;
                            //    TN( tProtocol  , psttProtocol  ) ;
                            //    TN( tQuery     , psttQuery     ) ;
                            //    TN( tUri       , psttUri       ) ;
                            //    TN( tContainer , psttContainer ) ;
                            //    TN( tLogBucket , psttLogBucket ) ;
                            //    TN( tMethod    , psttMethod    ) ;
                            //{

                            // A:ASSUME:  THIS CODE ASSUMES THAT EVENTS ARE UNIQUELY IDENTIFIED BY [hash,idJot,time,nn]; MULTIPLE EVENTS WILL RESULT IN MULTIPLE VALUES FOR THE FIELDS

                            //etThread.traceF( tinP , T(psttUri) ) ;

                            // *****************************************************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            // ********                         ********************************************************************************************************************************************************************************************************************
                            // ********  PROCESS WO BOOK ENTRY  ********************************************************************************************************************************************************************************************************************
                            // ********                         ********************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            _IO_
                        {
                        else
                        if( getNegAM( finger ) != FINGERnEG_ACCESSeVENTrAW || idFormat != 1 ) etThread.traceF( tinP , T("unexpected format [finger,idFormat]:    ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        sBookEntry >> psttBrowser ;             ___( psttBrowser ) ;
                        sBookEntry >> cbRequest ;
                        sBookEntry >> code ;
                        sBookEntry >> psttProtocol ;            ___( psttProtocol ) ;
                        sBookEntry >> psttQuery ;               ___( psttQuery ) ;
                        sBookEntry >> psttUri ;                 ___( psttUri ) ;
                        sBookEntry >> psttContainer ;           ___( psttContainer ) ;
                        sBookEntry >> psttLogBucket ;           ___( psttLogBucket ) ;
                        sBookEntry >> psttMethod ;              ___( psttMethod ) ;
                        sBookEntry >> nnHe ;
                        sBookEntry >> *(countT*)&timeW2 ;
                        sBookEntry >> timeW1 ;
                        sBookEntry >> idFormat ;
                        sBookEntry >> finger ;

                        ZE( strokeS* , psttBrowser   ) ;
                        ZE( countT   , cbRequest     ) ;
                        ZE( countT   , code          ) ;
                        ZE( strokeS* , psttProtocol  ) ;
                        ZE( strokeS* , psttQuery     ) ;
                        ZE( strokeS* , psttUri       ) ;
                        ZE( strokeS* , psttContainer ) ;
                        ZE( strokeS* , psttLogBucket ) ;
                        ZE( strokeS* , psttMethod    ) ;
                        nicNameC       nnHe            ;
                        ZE( sCountT  , timeW2        ) ;
                        ZE( countT   , timeW1        ) ;
                        ZE( countT   , idFormat      ) ;
                        ZE( countT   , finger        ) ;

                        }
                            etThread.delF( tinP , pbPageCopy ) ;
                            }
                                sBookEntry.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , *pPageEvent , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;

                                bksAccessEventsP.unlockF( tinP ) ;
                                etThread.memCopyF( tinP , pbPageCopy , pbzPage , cbzPage ) ;
                                const byteT* pbzPage = *pPageEvent ;
                                bksAccessEventsP.lockF( tinP , TAG( TAGiDnULL ) ) ;
                            {
                            if( !POOP )

                            __Z( pbPageCopy ) ;
                            etThread.newF( tinP , LF , pbPageCopy , cbzPage ) ; ___( pbPageCopy ) ;
                            ZE( byteT* , pbPageCopy ) ;

                            countT cbzPage = *pPageEvent ;
                        {
                        soulC sBookEntry( tinP , TAG( TAGiDnULL ) ) ;

                        _IO_
                    {
                    if( pPageEvent )

                    wsP.st_pPageEvent.ungrabF( tinP ) ;
                    wsP.st_pPageEvent >> *(countT*)&pPageEvent ;
                    ZE( pageC* , pPageEvent ) ;
                    _IO_
                {
                while( wsP.st_pPageEvent )
                wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;

                stackC stIdJotUri(       tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_countT ) ;
                stackC stIdJotContainer( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_countT ) ;

                _IO_
            {
            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            _IO_
        {
        else
        }
            //etThread.traceF( tinP , T("napped") ) ;
            ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //etThread.traceF( tinP , T("napping") ) ;
        {
        if( !wsP.st_pPageEvent )
        _IO_
    {
    while( !ether && !etThread && !POOP )

    TN( tb4 , "    " ) ;

    booksC& bksAccessEventsP = *(booksC*)pTaskP->c2 ;
    workS&  wsP              =  *(workS*)pTaskP->c1 ;
    _IO_

    thirdC::c_memcpyIF( tinP , (byteT*)tinP.ppJot , (byteT*)pTaskP->pTinDad->ppJot , sizeof tinP.ppJot ) ;    //U:: MOVE TO BASE (flTHREADlAUNCH)
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )

}
    listC::dictionaryReplaceOsTextIF( tinP , pczfBrowser        ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczfCbRequest      ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczfCode           ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczfProtocol       ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczfQuery          ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczfUri            ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczfContainer      ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczfLogBucket      ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczfMethod         ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczfNicName        ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczfTime           ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczfIdJotUri       ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczfIdJotContainer ) ;
    listC::dictionaryReplaceOsTextIF( tinP , pczPrefix          ) ;

    puseC pu( puseEvents ) ;

    // *****************************************************************************************************************************************************************************************************************************************************
    // *****************************************************************************************************************************************************************************************************************************************************
    // ********                   **************************************************************************************************************************************************************************************************************************
    // ********  LOAD DICTIONARY  **************************************************************************************************************************************************************************************************************************
    // ********                   **************************************************************************************************************************************************************************************************************************
    // *****************************************************************************************************************************************************************************************************************************************************
    // *****************************************************************************************************************************************************************************************************************************************************
{
puseAT( tinP , ifcIDpOOL_ADAMtEMP )
puseEvents( tinP , "uri.access.events" , flPOOLc_DOnOTiNDEXdURINGcT , ifcIDsTATEsPACE_MULTIPLEaDAMS , 3 , 6 , pczHintPreallocation ) ,
idOut( 0 ) ,
idIn( 0 ) ,
cWorkers( 0 ) ,
st_pPageEvent( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_countT ) ,
jhsOther(      tinP , "jotAccessEvents.hash.string.other"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [STRING]; WO JOT PER UNIQUE STRING
jhsBrowser(    tinP , "jotAccessEvents.hash.string.browser" , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsQuery(      tinP , "jotAccessEvents.hash.string.query"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsUri(        tinP , "jotAccessEvents.hash.string.uri"     , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
workS::workS( tinS& tinP , etherC& etherP ) :

;
}
    workS( tinS& tinP , etherC& etherP ) ;

    puseC   puseAT ;
    puseC   puseEvents ;

    countT  idOut ;
    countT  idIn ;
    countT  cWorkers ;

    stackC  st_pPageEvent ;

    jotC    jhsOther   ;
    jotC    jhsBrowser ;
    jotC    jhsQuery   ;
    jotC    jhsUri     ;       //CS:CODEsYNC: 73a 740 (THESE MUST BE CT IN THE SAME ORDER SO THAT THE SAME TAG VALES ARE ASSIGNED
{
struct workS

countT pczfBrowser          [] = { (countT)"browser"        , 0 } ;
countT pczfCbRequest        [] = { (countT)"cbRrequest"     , 0 } ;
countT pczfCode             [] = { (countT)"code"           , 0 } ;
countT pczfProtocol         [] = { (countT)"protocol"       , 0 } ;
countT pczfQuery            [] = { (countT)"query"          , 0 } ;
countT pczfUri              [] = { (countT)"uri"            , 0 } ;
countT pczfContainer        [] = { (countT)"container"      , 0 } ;
countT pczfLogBucket        [] = { (countT)"bucket"         , 0 } ;
countT pczfMethod           [] = { (countT)"method"         , 0 } ;
countT pczfNicName          [] = { (countT)"nicName"        , 0 } ;
countT pczfTime             [] = { (countT)"time"           , 0 } ;
countT pczfIdJotUri         [] = { (countT)"idJotUri"       , 0 } ;
countT pczfIdJotContainer   [] = { (countT)"idJotContainer" , 0 } ;
    
countT pczPrefix            [] = { LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION , (countT)"listAccessEeventsByContainerUri" , 0 } ;

} ;
    HINTeXPcBdROPeXPsLOTS( 0x05 , 0x0b ) ,
    HINTeXPcBdROPeXPsLOTS( 0x04 , 0x0c ) ,
    HINTeXPcBdROPeXPsLOTS( 0x03 , 0x0d ) ,

    HINTeXPcBdROPeXPsLOTS( 0x05 , 0x0c ) ,
    HINTeXPcBdROPeXPsLOTS( 0x04 , 0x0d ) ,
    HINTeXPcBdROPeXPsLOTS( 0x03 , 0x0e ) ,

    HINTeXPcBdROPeXPsLOTS( 0x05 , 0x0d ) ,
    HINTeXPcBdROPeXPsLOTS( 0x04 , 0x0e ) ,
    HINTeXPcBdROPeXPsLOTS( 0x03 , 0x0f ) ,

    HINTeXPcBdROPeXPsLOTS( 0x05 , 0x0e ) ,
    HINTeXPcBdROPeXPsLOTS( 0x04 , 0x0f ) ,
    HINTeXPcBdROPeXPsLOTS( 0x03 , 0x10 ) ,

    HINTeXPcBdROPeXPsLOTS( 0x05 , 0x0f ) ,
    HINTeXPcBdROPeXPsLOTS( 0x04 , 0x10 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x03 , 0x11 ) ,

    HINTeXPcBdROPeXPsLOTS( 0x05 , 0x10 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x04 , 0x11 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x03 , 0x12 ) ,

    HINTeXPcBdROPeXPsLOTS( 0x05 , 0x11 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x04 , 0x12 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x03 , 0x13 ) ,

    HINTeXPcBdROPeXPsLOTS( 0x05 , 0x12 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x04 , 0x13 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x03 , 0x14 ) ,

    HINTeXPcBdROPeXPsLOTS( 0x05 , 0x13 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x04 , 0x14 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x03 , 0x15 ) ,

    HINTeXPcBdROPeXPsLOTS( 0x05 , 0x14 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x04 , 0x15 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x03 , 0x16 ) ,

    HINTeXPcBdROPeXPsLOTS( 0x05 , 0x15 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x04 , 0x16 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x03 , 0x17 ) ,

    HINTeXPcBdROPeXPsLOTS( 0x05 , 0x16 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x04 , 0x17 ) ,
    HINTeXPcBdROPeXPsLOTS( 0x03 , 0x18 ) ,
{
countT pczHintPreallocation [] =

/*1*/WAKEhIDE( "ifcIDaDAM_ACCESSeVENTSlISToLD" )/*1*/
/**/
*/
i eat access events (soulC instances) from a booksC instance and add them to a persistent list (database)
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
