
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("loafing") ) ;

}
    }
        while( ~hWalk1 && !ether ) ;
        }
            while( ~hWalk2 ) ;
            }
                else if( psttfn2 == psttfn1 ) bFound1 = 1 ;
                }
                    etThread.delF( tinP , pbBuffer2 ) ;
                    etThread.delF( tinP , pbBuffer1  ) ;

                    }
                        }
                            etThread.traceF( tinP , psttfn2 ) ;
                            etThread.traceF( tinP , psttfn1 ) ;
                            etThread.traceF( tinP , TF2(pcLever[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tc+TF2(pcLever[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        if( bSame )

                        }
                            }
                                }
                                    break ;
                                    bSame = 0 ;
                                {
                                if( etThread.memCompareF( tinP , pbBuffer1 , pbBuffer2 , cbBite ) )

                                __( cbActual != cbBite ) ;
                                etThread.fileReadF( tinP , pbBuffer2 , cbActual , hFile2 ) ;
                                cbActual = cbBite ;

                                __( cbActual != cbBite ) ;
                                etThread.fileReadF( tinP , pbBuffer1  , cbActual , hFile1 ) ;
                                countT cbActual = cbBite ;

                                if( was < cbDo ) cbDoHigh -- ;
                                cbDo -= cbBite ;
                                countT was = cbDo ;

                                ;
                                        : cbBuffer
                                        ? cbDo
                                    : cbDo < cbBuffer
                                    ? cbBuffer
                                countT cbBite = cbDoHigh
                            {
                            while( cbDo || cbDoHigh )
                            countT cbDoHigh = pcLever[ 1 ] ;
                            countT cbDo     = pcLever[ 0 ] ;
                        {
                        boolT bSame = 1 ;
                    {
                    if( pbBuffer1 && pbBuffer2 )

                    etThread.newF( tinP , LF , pbBuffer2 , cbBuffer ) ; ___( pbBuffer2 ) ;
                    etThread.newF( tinP , LF , pbBuffer1 , cbBuffer ) ; ___( pbBuffer1 ) ;

                    ;
                            : CBmYbUFFER
                            ? pcLever[ 0 ]
                        : pcLever[ 0 ] < CBmYbUFFER
                        ? CBmYbUFFER
                    const countT cbBuffer = pcLever[ 1 ]
                    ZE( byteT* , pbBuffer2 ) ;
                    ZE( byteT* , pbBuffer1  ) ;

                    etThread.fileOpenF( tinP , hFile2 , countTC() , tPath+T(psttfn2) ) ;
                    etThread.fileOpenF( tinP , hFile1 , countTC() , tPath+T(psttfn1) ) ;
                    handleC hFile2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                    handleC hFile1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                {
                if( bFound1 )

                strokeS* psttfn2 = (strokeS*)swsFile.downF( tinP , hWalk2 ) ;
            {
            do
            handleC hWalk2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( boolT , bFound1 ) ;

            strokeS* psttfn1 = (strokeS*)swsFile.downF( tinP , hWalk1 ) ;
        {
        do
        handleC hWalk1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( swsFile )

    if( !pcLever[ 0 ] && !pcLever[ 1 ] ) continue ;

    etThread.memCopyF( tinP , (byteT*)pcLever , (byteT*)swsFile.leverF( tinP , idf ) , sizeof pcLever ) ;
{
for( countT idf = 1 ; !ether && idf <= cFlavors ; idf ++ )
countT cFlavors = swsFile.cFlavorsF( tinP ) ;

}
    while( ~hFind && !ether ) ;
    }
        DEL( pInfo ) ;
        }
            etThread.delF( tinP , psttShort ) ;

            #endif

            }
                }
                {
                if( pInfoDad && pInfoDad->cbUsed == pInfo->cbUsed && pInfoDad->cbUsedHigh == pInfo->cbUsedHigh )
                etThread.diskFileQueryF( tinP , pInfoDad , hDad ) ;
                ZE( infoFileS* , pInfoDad ) ;


                etThread.traceF( tinP , tInspecting ) ;
            {
            else
            if( !etThread.diskFileExistsF( tinP , psttDadFile ) ) etThread.diskMoveFileOrDirF( tinP , psttDadFile , pInfo->psttIfoName ) ;

            #if defined( NEVERdEFINED )

            swsFile << psttShort ; psttShort = 0 ;
            pcLever[ 1 ] = pInfo->cbUsedHigh ;
            pcLever[ 0 ] = pInfo->cbUsed     ;

            if( !( ( ++ idIn ) % TUCK ) ) etThread.traceF( tinP , psttShort ) ;

            }
                etThread.delF( tinP , psttPath ) ;
                ___( psttShort ) ;
                ___( psttPath  ) ;
                etThread.strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                ZE( strokeS* , psttPath ) ;
            {
            ZE( strokeS* , psttShort ) ;
        {
        )
            pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ] != '/'
            &&
            !etThread.strIdF( tinP , tSlashDotDotSlash , pInfo->psttIfoName )
            &&
            !etThread.strIdF( tinP , tSlashDotSlash , pInfo->psttIfoName )
            &&
            pInfo
        (
        if
        etThread.diskFindFileOrDirOldF( tinP , pInfo , hFind , tLike ) ; ___( pInfo ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    ZE( countT , idIn ) ;
    TN( tb4               , "    " ) ;
    TN( tDistinct         , "distinct" ) ;
    TN( tInspecting       , "inspecting " ) ;
    TN( tSlash            , "/" ) ;
    TN( tSlashDotSlash    , "/./" ) ;
    TN( tSlashDotDotSlash , "/../" ) ;
    TN( tLike , "" ) ; tLike = tPath+T("*") ;
    //TN( tLike , "" ) ; tLike = tPath+T("!ideafarm.6.20140622@1847.001.!.transcript.log.ttt") ;
{
switchStackC swsFile( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , (byteT*)pcLever , sizeof pcLever , flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ;
TN( tc , ":" ) ;
countT pcLever[] = { 0 , 0 } ;
TN( tPath , "///d/tmp/x.merge.archive/merged/archive/" ) ;
//TN( tPath , "///d/tmp/x/" ) ;

TODO

#define CBmYbUFFER ( TICK << 0 )

/*1*/WAKEsHOWtEXT( "tool.detect.identical.archive.files" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

