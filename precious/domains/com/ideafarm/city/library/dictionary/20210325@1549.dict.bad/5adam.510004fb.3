
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#endif

DONE( tmHooF )
}
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ; //INTENTIONALLY NOT RESTORED
    grab1.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( bNap )

    boolT  bNap  =          pTaskP->c2 ;
    grabC& grab1 = *(grabC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmHooF )

#if defined( NEVERdEFINED )

DONE( tmGooF )
}
    THREADmODE1rESTORE ;
    //CONoUTrAW3( "tmGooF/" , tinP.monitor.idThread , ": you'll never see this\r\n" ) ;
    grab2.grabF( tinP , TAG( TAGiDnULL ) ) ;
    //CONoUTrAW3( "tmGooF/" , tinP.monitor.idThread , ": grabbing (this should deadlock)\r\n" ) ;
    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    grab1.grabF( tinP , TAG( TAGiDnULL ) ) ;
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;

    grabitC& grab2 = *(grabitC*)pTaskP->c2 ;
    grabitC& grab1 = *(grabitC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmGooF )

DONE( tmFooF )
}
    THREADmODE1rESTORE ;
    //CONoUTrAW3( "tmFooF/" , tinP.monitor.idThread , ": you'll never see this\r\n" ) ;
    grab2.grabF( tinP , TAG( TAGiDnULL ) ) ;
    //CONoUTrAW3( "tmFooF/" , tinP.monitor.idThread , ": grabbing (this should deadlock)\r\n" ) ;
    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    grab1.grabF( tinP , TAG( TAGiDnULL ) ) ;
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;

    grabC& grab2 = *(grabC*)pTaskP->c2 ;
    grabC& grab1 = *(grabC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmFooF )

DONE( tmConsoleF )
}
    }
        ++ s ; etThread.osSleepF( tinP , TOCK * 0x8 ) ;
   
        }
            etThread.delF( tinP , psttr ) ;

            }
                etThread.delF( tinP , psttf ) ;
                etThread.boxPutGenerationF( tinP , psttf , T("///d/ideafarm.rpt.monitor.console") , TUCK , (osTextT*)tRpt , tRpt.csF( tinP ) ) ; ___( psttf ) ;
                ZE( strokeS* , psttf ) ;
                TN( tRpt , psttr ) ;
            {
            else
            if( !( F(thirdC::third_flagsModeProcess1I_IF(tinP)) & flMODEpROCESS1_SERVICE ) ) etThread.strokeF( tinP , psttr ) ;

            swMemorySpaceP.ungrabF( tinP ) ;
            }
                memorySpace.grab.ungrabF( tinP ) ;

                }
                    }
                        while( ~hWalk ) ;
                        }
                            }
                                }
                                    }
                                        }
                                            ) ;
                                        
                                                +top+TF2(pCopyGrab->idLineCt,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcp+tcr
                                                TP("",0x29)+TF2(pCopyGrab->idiFileCt,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)
                                        
                                            etThread.strFuseF( tinP , psttr ,
                                        {
                                        else
                                        if( !bOk || getNegAM( pCopyGrab->finger ) != FINGERnEG_GRABc ) pCopyGrab = 0 ;
                                        thirdC::dosReadProcessMemoryIF( tinP , pbCopyGrab , sizeof( grabC ) , bOk , (voidT*)pCopyTin->pPanLifiRecurseGrabbedLevel[ off ] , info.osPid ) ;
                                        ZE( boolT , bOk ) ;
                                        grabC* pCopyGrab = (grabC*)pbCopyGrab ;
                                        byteT pbCopyGrab[ sizeof( grabC ) ] ;
                                    {
                                    if( pCopyTin->pPanLifiRecurseGrabbedLevel[ off ] )
                                {                                                                                                                              //U::BUG: SHOULD BE off += 5?
                                for( countT off = 0 ; off < sizeof pCopyTin->pPanLifiRecurseGrabbedLevel / sizeof pCopyTin->pPanLifiRecurseGrabbedLevel[ 0 ] ; off ++ ) //U::OBSOLETED BY MIGRATION TO pPanLifiRecurseGrabbedLevel; SEE tmReportF
    
                                etThread.strFuseF( tinP , psttr , tcr ) ;
    
                                ) ;
                                    
                                    +top+TF2(pCopyTin->monitor.pPanLifiGrabbing[1],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcp
                                    tb+TF2(pCopyTin->monitor.pPanLifiGrabbing[2],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)
                                    
                                etThread.strFuseF( tinP , psttr ,
    
                                ) ;
            
                                    +TP(info.postThreadName,0x20)
                                    TF3(info.idThread,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)
                            
                                etThread.strFuseF( tinP , psttr , 
                            {
                            if( pCopyTin && pCopyTin->monitor.pPanLifiGrabbing[ 0 ] )
    
                            }
                                if( !bOk || getNegAM( pc2[ 0 ] ) != FINGERnEG_TINs || info.idSerial != pc2[ 1 ] ) pCopyTin = 0 ;
                                thirdC::dosReadProcessMemoryIF( tinP , (byteT*)pc2 , sizeof pc2 , bOk , (voidT*)info.ip , info.osPid ) ;
                                bOk = 0 ;
                                countT pc2[ 2 ] ; //CODE SYNC: ad40104 003002a: fingerprint idSerial MUST BE AT OFFSETS 0 4
                            {
                            else
                            if( !bOk || getNegAM( pCopyTin->fingerprint ) != FINGERnEG_TINs || info.idSerial != pCopyTin->idSerial ) pCopyTin = 0 ;
                            thirdC::dosReadProcessMemoryIF( tinP , pbCopyTin , sizeof( tinS ) , bOk , (voidT*)info.ip , info.osPid ) ;
                            ZE( boolT , bOk ) ;
                            tinS* pCopyTin = (tinS*)pbCopyTin ;
                            byteT pbCopyTin[ sizeof( tinS ) ] ;
    
                            tinEntryS& info = *(tinEntryS*)&memorySpace.swsTin.downF( tinP , hWalk ) ;
                        {
                        do
                        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( memorySpace.swsTin )

                    ) ;
    
                        +T("swsTin       : ")+TF2(memorySpace.swsTin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcr
                         T("Memory space: ")+TF2(cLeverIdMemoryP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcr
    
                    etThread.strFuseF( tinP , psttr , 

                    memorySpace.pczLeverAdam = (countT*)memorySpace.swsTin.leverF( tinP , idf ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                const countT cFlavors = memorySpace.swsTin.cFlavorsF( tinP ) ;

                memorySpace.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
                
                memorySpaceS& memorySpace = *(memorySpaceS*)&(countT&)swMemorySpaceP ;
                cLeverIdMemoryP = swMemorySpaceP.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swMemorySpaceP.cFlavorsF( tinP ) ;
            swMemorySpaceP.grabF( tinP , TAG( TAGiDnULL ) ) ;

            etThread.strMakeF( tinP , LF , psttr , T("\fIPDOS (tm) <> IdeaFarm " "(tm) Piggyback Distributed Operating System\r\nPerformance Monitor\r\ncycle: ")+TF2(++icCycle,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") , TOCK ) ; ___( psttr ) ;
            ZE( strokeS* , psttr ) ;
        {
        if( !( F(thirdC::third_flagsModeProcess1I_IF(tinP)) & flMODEpROCESS1_SERVICE ) )

        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    while( !POOP && !bQuitConsoleP )
    TN( tcp , ")" ) ;
    TN( top , "(" ) ;
    TN( tb , " " ) ;
    TN( tcr , "\r\n" ) ;
    ZE( countT , icCycle ) ;

    switchC& swMemorySpaceP  = *(switchC*)pTaskP->c3 ;
    countT&  cLeverIdMemoryP =  *(countT*)pTaskP->c2 ;
    boolT&   bQuitConsoleP   =   *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmConsoleF )

#include postADAMhEADER

/*1*//*ifcIDaDAM_KERNEL2MONITOR 3*//*1*/

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

