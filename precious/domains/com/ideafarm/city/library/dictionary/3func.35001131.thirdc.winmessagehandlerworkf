
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return rc ;

    if( bDoDefault ) rc = thirdC::winDefaultMessageHandlerIF( tinP , oshWindowP , idCmdP , p1P , p2P ) ;

    }
        }
            WHATsw
            TELL( "winMessageHandlerWorkF: returned control to os's message pump code" )
        {
        if( bOkToUseIfcObjects )

        }
            //}
            //    }
            //        etThread.winPostMessageAfterNapF( tinP , TUCK * 0x20 , hWindow , idwm_BECOMEaCTIVE ) ;
            //        timeL2 = timeN2 ;
            //        timeL1 = timeN1 ;
            //    {
            //    if( timeE2 || timeE1 > TOCK )
            //
            //    etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeL1 , timeL2 ) ;
            //    sCountT timeE2 = timeN2 ;
            //    countT  timeE1 = timeN1 ;
            //
            //    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            //    ZE( sCountT , timeN2 ) ;
            //    ZE( countT , timeN1 ) ;
            //
            //    static sCountT timeL2 ;
            //    static countT timeL1 ;
            //{
            //else
            //if( oshWindowP == (countT)GetForegroundWindow() ) ;
            //DOES NOT WORK

            }
                THREADmODE1rESTORE //LEGACY WORKAROUND (DO THIS FOR ALL HANDLING SO DON'T NEED TO FIGURE OUT WHAT CAUSES FAIL)
                TINSL
            {
            else
            if( bOkToUseIfcObjects ) THREADmODE1rESTORE //LEGACY WORKAROUND (DO THIS FOR ALL HANDLING SO DON'T NEED TO FIGURE OUT WHAT CAUSES FAIL)

            }
                default: { rc = thirdC::winDefaultMessageHandlerIF( tinP , oshWindowP , idCmdP , p1P , p2P ) ; break ; }
                }
                    break ;

                    }
                        etThread.delF( tinP , pc3p ) ;
                        }
                            thThread.winPostMessageF( tinP , hWindow , pc3p->c1 , pc3p->c2 , pc3p->c3 ) ;
                        {
                        if( pc3p )
                        count3S* pc3p = (count3S*)p2P ;
                    {
                    else
                    }
                        thThread.winPostMessageF( tinP , hWindow , idCmdP , p1P - 1 , p2P ) ;
                        //Beep ( 0x100 + p1P * 0x10 , 0x40 ) ;
                    {
                    if( p1P )

                    // p2P: THE MESSAGE TO SEND AFTER THE DELAY SPIN
                    // p1P: NUMBER OF TIMES TO SEND MYSELF TO DELAY
                    TELL( "winMessageHandlerWorkF: idwm_SPINpOST" )
                {
                case idwm_SPINpOST :
                }
                    break ;

                    BOSpOOP
                    BOS( WHATgbo , BOSoK , SetForegroundWindow( (HWND)oshWindowP ) )
                    //Beep ( TUCK << 2 , TUCK ) ;

                    //countT rc2 = (countT)SetActiveWindow( (HWND)oshWindowP ) ; //ADDED TO DEBUG A BUG
                    //countT rc1 = (countT)SetFocus( (HWND)oshWindowP ) ;
                    //LOGrAW( "idwm_BECOMEaCTIVE: setting focus\r\n" ) ; //U::
                    //Beep ( 0x100 , 0x40 ) ;
                {
                case idwm_BECOMEaCTIVE :
                }
                    break ;
                    }
                        etThread.winPostMessageAfterNapF( tinP , TUCK * 0x20 , hWindow , idwm_BECOMEaCTIVE ) ; //DELAY IS NEEDED; OTHERWISE TASKBAR RETAINS ACTIVE STATUS AND I RECEIVE A DEACTIVATION
                        etThread.winPostMessageAfterNapF( tinP , TUCK * 0x10 , hWindow , idwm_SHOW , idcWINsHOW_SHOW ) ; //DELAY IS NEEDED; OTHERWISE TASKBAR RETAINS ACTIVE STATUS AND I RECEIVE A DEACTIVATION
                        //etherC::ifcSayIF( T("idwm_TASKbARiCON: asking for show to be posted after TOCK nap") , flSAY_APPEND | flSAY_LOG ) ;
                    {
                    if( p2P == WM_LBUTTONDOWN )
                    TELL( "winMessageHandlerWorkF: idwm_TASKbARiCON" )
                {
                case idwm_TASKbARiCON :
                }
                    break ;
                    TELL( "winMessageHandlerWorkF: idwm_TEST" )
                {
                case idwm_TEST :
                }
                    break ;
    
                    thThread.delF( tinP , postt ) ;
                    rc = thThread.winSetTitleF( tinP , postt , hWindow ) ;
                    osTextT* postt = (osTextT*)p1P ;
                    TELL( "winMessageHandlerWorkF: idwm_SETwINDOWtEXT" )
                {
                case idwm_SETwINDOWtEXT :
                }
                    break ;
    
                    etThread.delF( tinP , pc2 ) ;
                    else __1
                    }
                        etThread.delF( tinP , pc8b ) ;
                        etThread.delF( tinP , pc8a ) ;
                        }
                            thThread.winPaintNowF( tinP , hWindow ) ;
                            //U::TO CATCH A BUG: thThread.winShowWindowF( tinP , hWindow , idcWINsHOW_SHOW ) ;
                            thThread.winCreateWindowF( tinP , hWindow , *phWindow , MAINwINDOWcLASSnAME , MAINwINDOWcLASSnAME , bRoot ? idtWIN_ROOT : idtWIN_KID , idCol , idRow , cCol , cRow , cColClient , cRowClient , thirdC::third_hWindowingClientIF( tinP ) , bNotVisible ) ;
                            //LOGrAWtID4( "idwm_CREATEwINDOW calling winCreateWindowF (cColP,cRowP): " , cCol , " " , cRow ) ;
        
                            countT   cTries      =           pc8b->c3 ;
                            countT   bNotVisible =           pc8b->c2 ;
                            handleC* phWindow    = (handleC*)pc8b->c1 ;
                            countT   bRoot       =           pc8a->c8 ;
                            countT   cRowClient  =           pc8a->c7 ;
                            countT   cColClient  =           pc8a->c6 ;
                            countT   cRow        =           pc8a->c5 ;
                            countT   cCol        =           pc8a->c4 ;
                            countT   idRow       =           pc8a->c3 ;
                            countT   idCol       =           pc8a->c2 ;
                            __( hWindow != *(windowOldC*)pc8a->c1 ) ;
                        {
                        if( pc8a && pc8b && pc8b->c1 )

                        count8S* pc8b = (count8S*)pc2->c2 ;
                        count8S* pc8a = (count8S*)pc2->c1 ;
                    {
                    if( pc2 )
                    count2S* pc2 = (count2S*)p1P ;
                    TELL( "winMessageHandlerWorkF: idwm_CREATEwINDOW" )
                {
                case idwm_CREATEwINDOW :
                }
                    break ;
                    thThread.winShowWindowF( tinP , hWindow , (countT)p1P ) ;

                    }
                        default                         : { idTone = 0x1 ; break ; }
                        case idcWINsHOW_HIDE            : { idTone = 0x2 ; break ; }
                        case idcWINsHOW_MINIMIZE        : { idTone = 0x7 ; break ; }
                        case idcWINsHOW_SHOWnOaCTIVATE  : { idTone = 0x8 ; break ; }
                        case idcWINsHOW_SHOW            : { idTone = 0x9 ; break ; }
                        case idcWINsHOW_MAXIMIZE        : { idTone = 0xa ; break ; }
                        case idcWINsHOW_DEFAULT         : { idTone = 0xb ; break ; }
                    {
                    switch( p1P )
                    ZE( countT , idTone ) ;
                    TELL( "winMessageHandlerWorkF: idwm_SHOW" )
                {
                case idwm_SHOW :
                }
                    break ;
    
                    thThread.winPostMessageF( tinP , hWindow , idwm_RENDER ) ;

                    thPaint = 0 ;

                    }
                        if( hDrawWindow == pRootI->hDrawWindowF() ) hDrawWindow.resetF() ;
                        thPaint.winEndPaintF( tinP , hDrawWindow ) ;
        
                        }
                            pRootI->letRefF() ;
                            BOSpOOP
                            BOS( WHATgbd , BOSoK , SetWindowOrgEx( (HDC)hDrawWindow.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , pRootI->mIdColOsOriginF() + 0.5 , pRootI->mIdRowOsOriginF() + 0.5 , 0 ) )
                        {
                        if( pRootI )
                        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
                    {
                    if( ~hDrawWindow )

                    }
                        thPaint.winBeginPaintF( tinP , hDrawWindow , hWindow , idColMin , idRowMin , idColMax , idRowMax ) ;
                        ZE( sCountT , idRowMax ) ;
                        ZE( sCountT , idColMax ) ;
                        ZE( sCountT , idRowMin ) ;
                        ZE( sCountT , idColMin ) ;
                    {
                    handleC hDrawWindow( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DRAWpRIVATE ) ;
        
                    //}
                    //    }
                    //        pRootI->mColsRowsF( tinP , cCols , cRows ) ;
                    //        ((thirdC&)etThread).winClientSizeF( tinP , cCols , cRows , *pRootI ) ;
                    //        ZE( countT , cRows ) ;
                    //        ZE( countT , cCols ) ;
                    //    {
                    //    if( pRootI )
                    //    windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
                    //{
                    //NEEDS TO BE DONE HERE SO THAT winBeginPaintF WILL HAVE THE CURRENT mRows VALUE

                    thirdC& thPaint = (thirdC&)etherC::etPaintIF( tinP ) ;
    
                    TELL( "winMessageHandlerWorkF: WM_PAINT" )
                {
                case WM_PAINT :
                }
                    break ;
                    }
                        }
                            DEL( pwDoomed ) ;
        
                            }
                                pRootI->letRefF() ;
                                }
                                    BOSnOvALUE( WHATgbo , PostQuitMessage( 0 ) )
    
                                    //Shell_NotifyIcon( NIM_DELETE , &info ) ;
                                    //    
                                    //thirdC::c_strncpyIF( tinP , info.szTip , oston , sizeof info.szTip ) ;
                                    //}
                                    //    OStEXTAK( oston , ")" )
                                    //    OStEXTC(  oston , processGlobal1I.idHome , 0 )
                                    //    OStEXTAK( oston , " (Home " )
                                    //{
                                    //if( processGlobal1I.idHome > 1 )
                                    //OStEXTAK( oston , "IPDOS (tm) IdeaFarm " "(tm) Piggyback Distributed Operating System" )
                                    //OStEXT( oston , 0x80 )
                                    //    
                                    //info.hIcon = LoadIcon( (HINSTANCE)thirdC::third_hWindowingClientIF( tinP ).osF( ifcIDtYPEhANDLE_WINDOWINGcLIENT ) , MAKEINTRESOURCE( 1 ) ) ;
                                    //info.uCallbackMessage = idwm_TASKbARiCON ;
                                    //info.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP ;
                                    //info.uID = 0x1 ;
                                    //info.hWnd = (HWND)( (const handleC&)*pRootI ).osF( ifcIDtYPEhANDLE_WINDOW ) ;
                                    //info.cbSize = sizeof info ;
                                    //NOTIFYICONDATA info ;
                                {
                                if( pwDoomed == pRootI )
                            {
                            if( pRootI )
                            windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
                        {
                        if( pwDoomed )
                        windowOldC* pwDoomed = windowOldC::pWindowIF( tinP , hWindow ) ;
                    {
                    TELL( "winMessageHandlerWorkF: WM_DESTROY" )
                {
                case WM_DESTROY :
                case idwm_DESTROY :
                }
                    break ;
                    //bDoDefault = 0 ;
                    }
                        pRootI->letRefF() ;
                        pRootI->keyUpF( tinP , p2P ) ;
                    {
                    if( pRootI )
                    windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
                {
                case WM_SYSKEYUP :
                case WM_KEYUP :
                }
                    break ;
                    //bDoDefault = 0 ; //PREVENT WINDOWS FROM SEEING ANY KEYSTROKES FOR SYSTEM PURPOSES
                    }
                        TELL( "winMessageHandlerWorkF: WM_CHAR WM_KEYDOWN WM_SYSKEYDOWN" )
                        }
                            pRootI->letRefF() ;
                            pRootI->keyDownF( tinP , idCmdP , p1P , p2P ) ;
                        {
                        if( pRootI )
                        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
                        TELL( "winMessageHandlerWorkF: WM_CHAR WM_KEYDOWN WM_SYSKEYDOWN" )
                    {
                    if( bDo )

                    }
                        }
                            }
                                break ;
                                bDo = 1 ;
                            {
                            case VK_OEM_CLEAR :
                            case VK_PA1 :
                            case VK_NONAME :
                            case VK_ZOOM :
                            case VK_PLAY :
                            case VK_EREOF :
                            case VK_EXSEL :
                            case VK_CRSEL :
                            case VK_ATTN :
                            case VK_PROCESSKEY :
                            case VK_RMENU :
                            case VK_LMENU :
                            case VK_RCONTROL :
                            case VK_LCONTROL :
                            case VK_RSHIFT :
                            case VK_LSHIFT :
                            case VK_SCROLL :
                            case VK_NUMLOCK :
                            case VK_F24 :
                            case VK_F23 :
                            case VK_F22 :
                            case VK_F21 :
                            case VK_F20 :
                            case VK_F19 :
                            case VK_F18 :
                            case VK_F17 :
                            case VK_F16 :
                            case VK_F15 :
                            case VK_F14 :
                            case VK_F13 :
                            case VK_F12 :
                            case VK_F11 :
                            case VK_F10 :
                            case VK_F9 :
                            case VK_F8 :
                            case VK_F7 :
                            case VK_F6 :
                            case VK_F5 :
                            case VK_F4 :
                            case VK_F3 :
                            case VK_F2 :
                            case VK_F1 :
                            //case VK_DIVIDE :
                            //case VK_DECIMAL :
                            //case VK_SUBTRACT :
                            case VK_SEPARATOR :
                            //case VK_ADD :
                            //case VK_MULTIPLY :
                            //case VK_NUMPAD9 :
                            //case VK_NUMPAD8 :
                            //case VK_NUMPAD7 :
                            //case VK_NUMPAD6 :
                            //case VK_NUMPAD5 :
                            //case VK_NUMPAD4 :
                            //case VK_NUMPAD3 :
                            //case VK_NUMPAD2 :
                            //case VK_NUMPAD1 :
                            //case VK_NUMPAD0 :
                            case VK_APPS :
                            case VK_RWIN :
                            case VK_LWIN :
                            case VK_HELP :
                            case VK_DELETE :
                            case VK_INSERT :
                            case VK_SNAPSHOT :
                            case VK_EXECUTE :
                            case VK_PRINT :
                            case VK_SELECT :
                            case VK_DOWN :
                            case VK_RIGHT :
                            case VK_UP :
                            case VK_LEFT :
                            case VK_HOME :
                            case VK_END :
                            case VK_NEXT :
                            case VK_PRIOR :
                            //case VK_SPACE :
                            //case VK_ESCAPE :
                            case VK_CAPITAL :
                            case VK_PAUSE :
                            case VK_MENU :
                            case VK_CONTROL :
                            case VK_SHIFT :
                            //case VK_RETURN :
                            case VK_CLEAR :
                            //case VK_TAB :
                            //case VK_BACK :
                            case VK_MBUTTON :
                            case VK_CANCEL :
                            case VK_RBUTTON :
                            case VK_LBUTTON :
                        {
                        switch( p1P )
                    {
                    if( !bDo )
                    boolT bDo = idCmdP == WM_CHAR ;
                {
                case WM_SYSKEYDOWN :
                case WM_KEYDOWN :
                case WM_CHAR :
                }
                    break ;

                    }
                        }
                            pRootI->letRefF() ;
                    
                            paperOldC::callSadamsIF( tinP , ether , ifcIDtYPEsTROKEcALLbACK_MOUSE , c8n , 0 ) ;
                            count8S c8n( 1 , 4 , idTool , idAction , xpRaw + 1 , pRootI->mRowsF() - ypRaw ) ;
    
                            //LOGrAW( T("mouse message ")+T(processGlobal3I.mapWindowMessage(idCmdP))+T(": xpRaw,ypRaw is ")+TF1(xpRaw)+T(" ")+TF1(ypRaw)+T(" ")+TF1(winIfColIF(xpRaw))+T(" ")+TF1(winIfRowIF(ypRaw,pRoot->mRowsF()))+T("\r\n") ) ;
                            //etThread.beeClickF( tinP ) ;
                        
                            const countT ypRaw = p2P >> 0x10 ;
                            const countT xpRaw = p2P & 0xffff ;

                            ((backOldC*)pRootI)->setToolFlagsF( tinP , idTool , flagsOn , flagsOff ) ;
                            }
                                case WM_RBUTTONUP     : { idTool = ifcIDtYPEtOOL_MOUSEbUTTONrIGHT  ; idAction = ifcIDtYPEaCTION_UP   ; flagsOff = flTOOL_DOWN ; break ; }
                                case WM_RBUTTONDOWN   : { idTool = ifcIDtYPEtOOL_MOUSEbUTTONrIGHT  ; idAction = ifcIDtYPEaCTION_DOWN ; flagsOn  = flTOOL_DOWN ; break ; }
                                case WM_MBUTTONUP     : { idTool = ifcIDtYPEtOOL_MOUSEbUTTONcENTER ; idAction = ifcIDtYPEaCTION_UP   ; flagsOff = flTOOL_DOWN ; break ; }
                                case WM_MBUTTONDOWN   : { idTool = ifcIDtYPEtOOL_MOUSEbUTTONcENTER ; idAction = ifcIDtYPEaCTION_DOWN ; flagsOn  = flTOOL_DOWN ; break ; }
                                case WM_LBUTTONUP     : { idTool = ifcIDtYPEtOOL_MOUSEbUTTONlEFT   ; idAction = ifcIDtYPEaCTION_UP   ; flagsOff = flTOOL_DOWN ; break ; }
                                case WM_LBUTTONDOWN   : { idTool = ifcIDtYPEtOOL_MOUSEbUTTONlEFT   ; idAction = ifcIDtYPEaCTION_DOWN ; flagsOn  = flTOOL_DOWN ; break ; }
                                case WM_MOUSEMOVE     : { idTool = ifcIDtYPEtOOL_MOUSEpOSITION     ; idAction = ifcIDtYPEaCTION_MOVE ; break ; }
                            {
                            switch( idCmdP )
                            flagsT flagsOff = flTOOL_null ;
                            flagsT flagsOn  = flTOOL_null ;
                            ZE( countT , idAction ) ;
                            ZE( countT , idTool ) ;

                            ((backOldC*)pRootI)->freshToolsMousePositionF( tinP ) ;
                            ((backOldC*)pRootI)->resetToolMousePositionFlagsF( tinP ) ;
                        {
                        if( pRootI )
                        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
                    {
                    TELL( "winMessageHandlerWorkF: WM_MOUSEMOVE" )
                {
                case WM_MBUTTONDBLCLK :
                case WM_MBUTTONUP :
                case WM_MBUTTONDOWN :
                case WM_RBUTTONDBLCLK :
                case WM_RBUTTONUP :
                case WM_RBUTTONDOWN :
                case WM_LBUTTONDBLCLK :
                case WM_LBUTTONUP :
                case WM_LBUTTONDOWN :
                case WM_MOUSEMOVE :
                }
                    break ;

                    //bDoDefault = 0 ; //WAS 1 (SET TO 0 ON 7/26/2004)

                    }
                        //THREADmODE1rESTORE
                        //}
                        //    while( !( F(thirdC::third_flagsProcessStateI_IF(tinP)) & flPROCESSsTATE_MAINtHREADcLEANUPiScOMPLETE ) ) { ++ s ; thirdC::dosSleepRawIF( tinP , 250 ) ; }
                        //    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        //{
                        //THREADmODE1oN( flTHREADmODE1_ALLOWuNMONITOREDsLEEP )
                        //CONJ: THE PURPOSE OF THIS BLOCKAGE WAS TO ENSURE THAT SHUTDOWN DOES NOT COMPLETE UNTIL MAIN COMPLETES

                        //MAY NOT REFER TO IFC OBJECTS NOW SINCE MAIN IS DELETING THEM ALL
                        thirdC::third_flagsProcessStateI_IF( tinP , flPROCESSsTATE_WM_CLOSE_RECEIVED , 1 ) ; // main WILL PROCEED TO CLEANUP WHEN IT SEES THIS
    
                        DEL( etherC::ether_pMainRefsIF( tinP ) ) ; // NO FURTHER USE FOR THIS
                        TINSL //WILL REFERENCE sf.tinEarlyLate
                    {







                    }                                                                                                                    \
                        (pEtThread) = 0 ;                                                                                                      \
                        THREADmODE2rESTORE                                                                                               \
                        delete (pEtThread) ;                                                                                                   \
                        THREADmODE2oFF( flTHREADmODE2_DOnOTcaLLdELif )                                                                   \
                    {                                                                                                                    \
                    if( *(countT*)&(pEtThread) )                                                                                               \









                    //DEL( pEtThread ) ; //THIS ALSO CAUSES tinP TO BE DESTROYED









                    if( thirdC::third_idPhaseProcess_IF() < ifcIDpHASEpROCESS_WORKINGwINDOWtINgONE ) thirdC::third_idPhaseProcess_IF() = ifcIDpHASEpROCESS_WORKINGwINDOWtINgONE ;
                    DEL( tinP.pScoopEtThread ) ; /*CODEsYNC: 0010056 1020171 */
                    DEL( tinP.pEtScratch ) ;

                    bOkToUseIfcObjects = 0 ; hWindow.closeIfF() ;
                    etThread.etherFireImpersonateMonitorIF( tinP ) ;

                    DEL( tinP.pSwsRecycle ) ; //TO MAKE SURE THAT etRock EXISTS WHEN THESE ARE DELETED
                    }
                        THREADmODE1rESTORE
                        }
                            }
                                }
                                    }
                                        default                            : { BLAMMO                           ; break ; }
                                        case ifcIDtYPErECYCLE_switchStackC : { DEL( *(switchStackC**)&pObject ) ; break ; }
                                        case ifcIDtYPErECYCLE_switchC      : { DEL(      *(switchC**)&pObject ) ; break ; }
                                        case ifcIDtYPErECYCLE_stackC       : { DEL(       *(stackC**)&pObject ) ; break ; }
                                        case ifcIDtYPErECYCLE_soulC        : { DEL(        *(soulC**)&pObject ) ; break ; }
                                    {
                                    switch( *tinP.pczl_pSwsRecycle )
                                {
                                if( tinP.pczl_pSwsRecycle && pObject )

                                //LOGrAWtID4( "deleting object " , (countT)pObject , " using pcz lever at " , tinP.pczl_pSwsRecycle ) ; //U::
            
                                *tinP.pSwsRecycle >> *(countT*)&pObject ;
                                ZE( voidT* , pObject ) ;
                            {
                            while( *tinP.pSwsRecycle )
            
                            tinP.pczl_pSwsRecycle = (countT*)tinP.pSwsRecycle->leverF( tinP , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        countT cFlavors = tinP.pSwsRecycle->cFlavorsF( tinP ) ;
                        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                    {
                    if( tinP.pSwsRecycle )
                    //PSEUDODUPLICATE CODE: 1450002 12f0002 1030003 1020171

                    }
                        thThread.winSendMessageF( tinP , hr , idwm_DESTROY ) ;
                        }
                            pRootI->letRefF() ;
                            hr.osF( ifcIDtYPEhANDLE_WINDOW , ((const handleC&)*pRootI).osF(  ifcIDtYPEhANDLE_WINDOW ) , 0 , 1 ) ;
                        {
                        if( pRootI )
                        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
                        //U:: 2011.06.24: WHY IS THIS HERE?: handleC hi( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_WINDOW ) ;
                        handleC hr( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_WINDOW ) ;
                    {

                    TELL( "winMessageHandlerWorkF: WM_CLOSE" )
                {
                case idwm_CLOSE :
                }
                    break ;
                    //bDoDefault = 0 ;
                    etThread.etherFireImpersonateMonitorIF( tinP ) ;
                {
                case WM_CLOSE :
                }
                    break ;
                    //bDoDefault = 0 ; //WAS 1

                    }
                        }
                            pRootI->letRefF() ;

                            else thThread.winShowWindowF( tinP , hWindow , idcWINsHOW_SHOW ) ;
                            }
                                //if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DEBUG ) ) thThread.winShowWindowF( tinP , hWindow , bHideWithIcon ? idcWINsHOW_HIDE : idcWINsHOW_MINIMIZE ) ;
                                const boolT bHideWithIcon = !!( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_HIDEwITHiCON ) ;
    
                                ((backOldC*)pRootI)->resetAllF( tinP ) ;
                            {
                            if( idMyNewState == WA_INACTIVE )
                        {
                        if( pRootI )
                        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
                    {
                    if( bRoot )
                    
                    paperOldC::callSadamsIF( tinP , ether , idMyNewState == WA_INACTIVE ? ifcIDtYPEsTROKEcALLbACK_SLEEP : ifcIDtYPEsTROKEcALLbACK_WAKE , 0 , 0 , idMyNewState != WA_INACTIVE ? flCALLsADAMS_FIFO : flCALLsADAMS_null ) ;

                    }
                        pRootI->letRefF() ;
                        else                              pRootI->setModeFlagsF( tinP , flPAPERbACKmODE_null   , flPAPERbACKmODE_ABSENT ) ;
                        if( idMyNewState == WA_INACTIVE ) pRootI->setModeFlagsF( tinP , flPAPERbACKmODE_ABSENT , flPAPERbACKmODE_null   ) ;
                    {
                    if( pRootI )
                    windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;

                    }
                        }
                            pRootI->letRefF() ;

                             }
                                 ((backOldC*)pRootI)->freshToolsMouseButtonsNotPresentF( tinP ) ;
                                 bDone = 1 ;
                             {
                             if( !bDone )
                             static boolT bDone ;

                            ((backOldC*)pRootI)->freshToolsMousePositionF( tinP ) ;
                            //SetCursorPos( winOsColIF( tinP.brcRaw / 2 ) , winOsRowIF( 1 ) ) ;
                            //BOSpOOP
                            //BOS( WHATgbo , BOSoK , GetSystemMetrics( SM_CXSCREEN ) )
    
                            //((backOldC*)pRootI)->rowBack.ro.pcToolState_22[ offmc ] = pRootI->mIdRowInDad ;
                            //((backOldC*)pRootI)->rowBack.ro.pcToolState_12[ offmc ] = pRootI->mIdColInDad ;
                            //countT       offm  = ifcIDtYPEtOOL_MOUSEpOSITION - ifcIDtYPEtOOL_x2Begin - 1 ;
                            //const countT offmc = ifcIDtYPEtOOL_MOUSEpOSITION - ifcIDtYPEtOOL_x2Begin - 1 ;
                            //USE FOR DEBUGGING, TO POSITION CURSOR AT LOWER LEFT CORNER
    
                            ((backOldC*)pRootI)->freshToolsAllFlagOnDownF( tinP ) ;
                        {
                        if( pRootI )
                        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;

                        }
                            //dosBeepIF( tinP , TUCK , TUCK ) ;
                            if( !bDown ) break ;
                            }
                                if( tinP.brcRaw & 0x8000 ) bDown |= 1 ;
                                BOSpOOP
                                BOS( WHATgbo , BOSoK , GetAsyncKeyState( vki ) )
                            {
                            for( countT vki = 0 ; vki <= 0xff ; vki ++ )
                            ZE( boolT , bDown ) ;
                        {
                        while( cTries -- ) //BLOCK UNTIL ALL KEYS AND MOUSE BUTTONS ARE UP; THIS IS SO I CAN APPLY WINDOW MESSAGES TO A KNOWN INITIAL STATE TO MAINTAIN TOOL STATE ARRAY
                        countT cTries = 0x10 ;
                        //SO IT HAS BEEN MODIFIED TO BEEP WHEN IT TERMINATES WITH A KEY REPORTEDLY DOWN
                        //THIS HAS BEEN SEEN TO BLOCK FOREVER FOR A KEYBOARD THAT WAS DROPPED AND IS KNOWN TO BE PARTIALLY NONFUNCTIONAL
                    {
                    else
                    }
                        if( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_ENABLEsECURITYsHUTDOWN && etThread.diskFileExistsF( tinP , T("///d/ideafarm.home.")+TF1(etherC::ifc_idHomeIdisk_IF())+T(".setting.flag.secure") ) ) etThread.osFireF( tinP ) ;

                        // CAUSES ICON TO NOT FUNCTION
                        // CAUSES ICON TO DISAPPEAR
                        // SOMETIMES ONLY LOGS OFF
                        //U::WHEN USE ExitWindowsEx, DOES NOT WORK: MULTIPLE DEFECT BEHAVIORS
                    {
                    if( idMyNewState == WA_INACTIVE )

                    countT hWindowOther = p2P ;
                    boolT bWasMinimized = tinP.brcRaw ;
                    BOSdOnOTtEST( WHATgbo , HIWORD( p1P ) )
                    countT idMyNewState = tinP.brcRaw ;
                    BOSdOnOTtEST( WHATgbo , LOWORD( p1P ) )
                    TELL( "winMessageHandlerWorkF: WM_ACTIVATE" )
                {
                case WM_ACTIVATE :
                }
                    break ;
                    }
                        //etThread.winPostMessageAfterNapF( tinP , TOCK , hWindow , idwm_SHOW , idcWINsHOW_SHOW ) ; //U::CONJ: THIS WILL WORKAROUND FOCUS AND ACTIVATION PROBLEM
                        //etherC::ifcSayIF( T("WM_ACTIVATEAPP: asking for show to be posted after TOCK nap") , flSAY_APPEND | flSAY_LOG ) ;
                    {
                    if( bRoot && p1P )
                    TELL( "winMessageHandlerWorkF: WM_ACTIVATEAPP" )
                {
                case WM_ACTIVATEAPP :
                }
                    break ;

                    }
                        }
                            pRootI->letRefF() ;
                            paperOldC::ungrabIF( tinP ) ;
                            paper.flushF( tinP ) ;
                            paperOldC& paper = (paperOldC&)pRootI->selectPaperF(tinP,ifcIDcMDpAPERsELECT_QUERYsHOW) ;
                            paperOldC::grabIF( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( pRootI )
                        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
                    {

                    }
                        pRootI->letRefF() ;

                        //pRootI->signShown.giveF( tinP ) ;
                        paperOldC::requestTabFreshIF( tinP ) ;
                        pRootI->strokeAllPapersF( tinP ) ;

                        //LOGrAWtID4( "idwm_RENDER (cCols,cRows): " , cCols , " " , cRows ) ;
                        ((HANDLEaPPnOTEScOUNTcLASS&)hDrawWindow).c2 = ((HANDLEaPPnOTEScOUNTcLASS&)hWindow).c2 = cRows ;
                        ((HANDLEaPPnOTEScOUNTcLASS&)hDrawWindow).c1 = ((HANDLEaPPnOTEScOUNTcLASS&)hWindow).c1 = cCols ;
                        handleC& hDrawWindow = pRootI->hDrawWindowF() ;
                        handleC& hWindow     = (handleC&)(const handleC&)*pRootI ;

                        pRootI->mColsRowsF( tinP , cCols , cRows ) ;
                        ((thirdC&)etThread).winClientSizeF( tinP , cCols , cRows , *pRootI ) ;
                        ZE( countT , cRows ) ;
                        ZE( countT , cCols ) ;
                    {
                    if( pRootI )
                    windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
                {
                case idwm_RENDER :
                }
                    break ;
                    //bDoDefault = 1 ; //CAUSES SLIVER OF WINDOWS DESKTOP TO APPEAR AT BOTTOM OF DISPLAY; WIN32 DOC SAYS IT IS OK TO NOT PASS TO DFLT HANDLER IF DON'T WANT VALIDATION OF NEW SIZE

                    }
#endif
                        thThread.winPostMessageF( tinP , hWindow , idwm_RENDER ) ;
                        //LOGrAW( "WM_WINDOWPOSCHANGING: posting idwm_RENDER\r\n" )
                        
                        }
                            else pInfo->flags &= ~( SWP_NOMOVE | SWP_NOSIZE ) ;
                            }
                                pInfo->flags &= ~( SWP_SHOWWINDOW ) ;
                                pInfo->flags |= SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE ;
                            {
                            if( bEndSessionPending )

                            //pInfo->cy >>= 1 ; //FOR DIGITAL VOICE EDITOR, WHICH IS A SUCKY PROGRAM THAT INSISTS ON RETAINING THE FOREGROUND
                            //pInfo->y += TUCK ; //FOR DIGITAL VOICE EDITOR, WHICH IS A SUCKY PROGRAM THAT INSISTS ON RETAINING THE FOREGROUND

                            pInfo->cy = info.bottom - info.top + 1 ;
                            pInfo->cx = info.right - info.left + 1 ;
                            pInfo->y = info.top ;
                            pInfo->x = info.left ;
                                        
                            BOSpOOP
                            BOS( WHATgbo , BOSoK , AdjustWindowRect( &info , WS_OVERLAPPEDWINDOW , 0 ) )
                            info.bottom = tinP.brcRaw - 1 ;
                            BOSpOOP
                            BOS( WHATgbo , BOSoK , GetSystemMetrics( SM_CYSCREEN ) )
                            info.right  = tinP.brcRaw - 1 ;
                            BOSpOOP
                            BOS( WHATgbo , BOSoK , GetSystemMetrics( SM_CXSCREEN ) )
                            info.top    = 0 ;
                            info.left   = 0 ;
                            RECT info ;
                        
                            WINDOWPOS* pInfo = (WINDOWPOS*)p2P ;
                        {
                        if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DEBUG ) )
#if defined( NEVERdEFINED )
                        // ENABLE FOR PRODUCTION
                    {
                    if( bRoot )
                {
                case WM_WINDOWPOSCHANGING :
                }
                    break ;
                    }
                        // while( !( F(processGlobal1I._thirdC_flagsProcessState) & flPROCESSsTATE_MAINtHREADcLEANUPiScOMPLETE ) ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
                        // sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        // etThread.etherFireImpersonateMonitorIF( tinP ) ;
                        // thirdC::third_flagsProcessStateI_IF( tinP , flPROCESSsTATE_WM_CLOSE_RECEIVED , 1 ) ; // main WILL PROCEED TO CLEANUP WHEN IT SEES THIS
                        // }
                        //     TELLc1( ifcIDtYPEtELL_READYtOdIE ) ;
                        //     state C::writeToDiskIfIF( tinP ) ;
                        // {
                        // if( !( F( thirdC::third_flagsModeProcess1I_IF( tinP ) ) & flMODEpROCESS1_QUITaTsHUTDOWN ) )
                        // //THIS WOULD LOAD THE CPU WITH CLEANUP ACTIVITY: ((poolOld SideS&)poolC::poolOld RootIF( tinP )).flags ForestFire |= flFORESTfIRE_SHUTDOWN ;
                        //U::REMOVE THIS OBSOLETED CODE AFTER STUDYING WHAT IT DOES WITH STATE INFO

                        thThread.winSendMessageCloseF( tinP , hWindow ) ;
                    {
                    if( p1P && !p2P ) //SESSION ENDING AND NOT BECAUSE OF LOGOFF
                    bEndSessionPending = 0 ;
                {
                case WM_ENDSESSION :
                }
                    break ;
                    bDoDefault = 1 ;
                    bEndSessionPending = 1 ;
                {
                case WM_QUERYENDSESSION :
            {
            switch( idCmdP )
            tinS* pTinDebug3 = &tinP ; //U::
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //LEGACY WORKAROUND (DO THIS FOR ALL HANDLING SO DON'T NEED TO FIGURE OUT WHAT CAUSES FAIL)

            //WWiNIT

            tinS* pTinDebug2 = &tinP ; //U::

            //}
            //    LOGrAW( tn ) ;
            //    tn += T("\r\n") ;
            //    }
            //        }
            //            if( pInfo->flags & SWP_NOSIZE ) tn += T(" SWP_NOSIZE") ;
            //            if( pInfo->flags & SWP_NOMOVE ) tn += T(" SWP_NOMOVE") ;
            //            if( pInfo->flags & SWP_NOZORDER ) tn += T(" SWP_NOZORDER") ;
            //            if( pInfo->flags & SWP_NOREDRAW ) tn += T(" SWP_NOREDRAW") ;
            //            if( pInfo->flags & SWP_NOACTIVATE ) tn += T(" SWP_NOACTIVATE") ;
            //            if( pInfo->flags & SWP_FRAMECHANGED ) tn += T(" SWP_FRAMECHANGED") ;
            //            if( pInfo->flags & SWP_SHOWWINDOW ) tn += T(" SWP_SHOWWINDOW") ;
            //            if( pInfo->flags & SWP_HIDEWINDOW ) tn += T(" SWP_HIDEWINDOW") ;
            //            if( pInfo->flags & SWP_NOCOPYBITS ) tn += T(" SWP_NOCOPYBITS") ;
            //            if( pInfo->flags & SWP_NOOWNERZORDER ) tn += T(" SWP_NOOWNERZORDER") ;
            //            if( pInfo->flags & SWP_NOSENDCHANGING ) tn += T(" SWP_NOSENDCHANGING") ;
            //            if( pInfo->flags & SWP_DEFERERASE ) tn += T(" SWP_DEFERERASE") ;
            //            if( pInfo->flags & SWP_ASYNCWINDOWPOS ) tn += T(" SWP_ASYNCWINDOWPOS") ;
            //
            //            tn += T("    (x,y,cx,cy): (")+TF1(pInfo->x)+T(",")+TF1(pInfo->y)+T(",")+TF1(pInfo->cx)+T(",")+TF1(pInfo->cy)+T(")") ;
            //        {
            //        if( pInfo )
            //        WINDOWPOS* pInfo = (WINDOWPOS*)p2P ;
            //    {
            //    if( idCmdP == WM_WINDOWPOSCHANGING )
            //    tn += TT(timeN1,timeN2)+T("| ")+TF3(p1P,flFORMAT_UNSIGNED,9)+TF3(p2P,flFORMAT_UNSIGNED,9)+(postw?T(postw):TF1(idCmdP)) ;
            //    const osTextT* const postw = processGlobal3I.mapWindowMessage( idCmdP ) ;
            //    TN( tn , "" ) ;
            //
            //    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            //    ZE( sCountT , timeN2 ) ;
            //    ZE( countT , timeN1 ) ;
            //{
            //if( bRoot )
            //FOR DEBUGGING ONLY; COMMENT OUT FOR RELEASE

            }
                }
                    }
                        //else fileWriteGF( ostoFile , "unkwm\r\n" , 7 , 1 ) ;
                        //}
                        //    fileWriteGF( ostoFile , "\r\n" , 2 , 1 ) ;
                        //    fileWriteGF( ostoFile , postWm , thirdC::c_strlenIF( postWm ) , 1 ) ;
                        //{
                        //if( postWm )
                        //OStEXTAK( ostoFile , ".log" ) ;
                        //OStEXTC( ostoFile , processGlobal1I.idHome , 0 ) ;
                        //OStEXTAK( ostoFile , "\\ideafarm.rpt." ) ;
                        //OStEXT( ostoFile , 0x100 )
                        //
                        //etherC::ifcSayIF( te , flSAY_APPEND | flSAY_LOG ) ;
                        //te += idCmdP == idwm_TASKbARiCON ? T(processGlobal3I.mapWindowMessage(p2P)) : TF3(p2P,flFORMAT_UNSIGNED,9) ;
                        //te += TF3(p1P,flFORMAT_UNSIGNED,9) ;
                        //te += postWm ? TP(postWm,0x21) : TF3( idCmdP,flFORMAT_UNSIGNED,8)+TP("",0x19) ;
                        //te += TT(timeN1,timeN2)+T("| wm: ") ;
                        //TN( te , "" ) ;
                        //osTextT* postWm = processGlobal3I.mapWindowMessage( idCmdP ) ;
                        //
                        //etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                        //ZE( sCountT , timeN2 ) ;
                        //ZE( countT , timeN1 ) ;

                        //LOGrAW( TT(timeN1,timeN2)+T("| ")+(postWm?T(postWm):TF1(idCmdP))+T(" ")+TF3(p1P,flFORMAT_UNSIGNED,9)+TF3(p2P,flFORMAT_UNSIGNED,8)+T("\r\n") ) ;
                        //osTextT* postWm = processGlobal3I.mapWindowMessage( idCmdP ) ;
                        //etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                        //ZE( sCountT , timeN2 ) ;
                        //ZE( countT , timeN1 ) ;
                    {
                    //default :
                    //case WM_WINDOWPOSCHANGING :
                    //case WM_ENDSESSION :
                    //case WM_SHOWWINDOW :
                    //case idwm_SHOW :
                    //case WM_ACTIVATE :
                {
                //switch( idCmdP )
            {
            //if( !bOkToUseIfcObjects )

            const boolT bWorkingPhase = ifcIDpHASEhANDOFFoLD_WORKING == thirdC::osProcessIdPhaseAdamIF( tinP ) ;

            }
                }
                    pRootI->letRefF() ;
                    bRoot = hWindow == *pRootI ;
                {
                if( pRootI )
                windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
            {
            ZE( boolT , bRoot ) ;

            thirdC&  thThread  = etThread ;
            etherC&  etThread   = *pEtThread ;
            etherC*& pEtThread  = etherC::ether_pMainRefsIF( tinP )->pEtThread ;
            etherC&  ether      = etherC::ether_pMainRefsIF( tinP )->ether ;
            //tinS&    tinP      = etherC::ether_pMainRefsIF( tinP )->tin ; //THIS IS OBSOLETE; REMOVE IT
            if( &tinP != &etherC::ether_pMainRefsIF( tinP )->tin ) BLAMMO ;
            TELL( "winMessageHandlerWorkF: setting up" )
        {
        else
        }
            }
                default: { rc = thirdC::winDefaultMessageHandlerIF( tinP , oshWindowP , idCmdP , p1P , p2P ) ; break ; }
                }
                    break ;
                    }
                        hDrawWindow.resetF() ; //A:ASSUME: PRIVATE DEVICE CONTEXT THAT WILL BE CLOSED BY ~windowOldC
                        thThread.winEndPaintF( tinP , hDrawWindow ) ;
                    {
                    if( ~hDrawWindow )
                    thThread.winBeginPaintF( tinP , hDrawWindow , hWindow , idColMin , idRowMin , idColMax , idRowMax ) ;
                    ZE( sCountT , idRowMax ) ;
                    ZE( sCountT , idColMax ) ;
                    ZE( sCountT , idRowMin ) ;
                    ZE( sCountT , idColMin ) ;
                    handleC hDrawWindow( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DRAWpRIVATE ) ;
                {
                case WM_PAINT :
                }
                    break ;
                    BOSnOvALUE( WHATgbo , PostQuitMessage( 0 ) )
                {
                case WM_DESTROY :
                }
                    break ;
                {
                case WM_CLOSE :
                case idwm_CLOSE :
            {
            switch( idCmdP )
    
            TELL( "winMessageHandlerWorkF: defaulting because tinP.pAdamGlobal1->_etherC_.pMainRefs is 0" )
            thirdC& thThread = etherC::etThreadIF( tinP ) ;
        {
        if( !etherC::ether_pMainRefsIF( tinP ) ) //U::
        WHATga
    {
    else
    }
        //}
        //    if( postName ) ;
        //{
        //if( cSkip && !( -- cSkip ) )
        //osTextT* postName = processGlobal3I.mapWindowMessage( idCmdP ) ; //THIS IS ALL FOR DEBUGGING
        //static countT cSkip = 0x100 ;
        bDoDefault = 1 ;
    {
    if( !bOkToUseIfcObjects )
    ZE( countT , rc ) ;
    ZE( boolT , bDoDefault ) ;

    hWindow.osF( ifcIDtYPEhANDLE_WINDOW , oshWindowP , 0 , 1 ) ;
    handleC hWindow( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_WINDOW ) ;

    //}
    //    LOGrAW( ostoBuf ) ;
    //
    //    OStEXTAK( ostoBuf , "\r\n" ) ;
    //    OStEXTC( ostoBuf , (countT)&tinP , 0 ) ;
    //    OStEXTAK( ostoBuf , "win handler ref tinS at " ) ;
    //    OStEXT( ostoBuf , 0x100 )
    //{
    //U::

    TINSL
    ebpTlsAM() = processGlobal1I.ebp_tmWindowsF_ ; //THIS IS NEEDED BECAUSE SOMETIMES THE TLS IS NOT IN THE STACK CHAIN (CONJ: WHEN CALLED BY INTERRUPT E.G. MOUSE)
{
/*1*/countT thirdC::winMessageHandlerWorkF( const countT oshWindowP , const countT idCmdP , const countT p1P , const countT p2P )/*1*/

boolT bOkToUseIfcObjects = 1 ;

//#endif

#endif

    ;
    }
        0x0000 , "WM_NULL"
        0x0001 , "WM_CREATE"                             ,
        0x0002 , "WM_DESTROY"                            ,
        0x0003 , "WM_MOVE"                               ,
        0x0005 , "WM_SIZE"                               ,
        0x0006 , "WM_ACTIVATE"                           ,
        0x0007 , "WM_SETFOCUS"                           ,
        0x0008 , "WM_KILLFOCUS"                          ,
        0x000A , "WM_ENABLE"                             ,
        0x000B , "WM_SETREDRAW"                          ,
        0x000C , "WM_SETTEXT"                            ,
        0x000D , "WM_GETTEXT"                            ,
        0x000E , "WM_GETTEXTLENGTH"                      ,
        0x000F , "WM_PAINT"                              ,
        0x0010 , "WM_CLOSE"                              ,
        0x0011 , "WM_QUERYENDSESSION"                    ,
        0x0012 , "WM_QUIT"                               ,
        0x0013 , "WM_QUERYOPEN"                          ,
        0x0014 , "WM_ERASEBKGND"                         ,
        0x0015 , "WM_SYSCOLORCHANGE"                     ,
        0x0016 , "WM_ENDSESSION"                         ,
        0x0018 , "WM_SHOWWINDOW"                         ,
        0x001A , "WM_WININICHANGE WM_SETTINGCHANGE"      ,
        0x001B , "WM_DEVMODECHANGE"                      ,
        0x001C , "WM_ACTIVATEAPP"                        ,
        0x001D , "WM_FONTCHANGE"                         ,
        0x001E , "WM_TIMECHANGE"                         ,
        0x001F , "WM_CANCELMODE"                         ,
        0x0020 , "WM_SETCURSOR"                          ,
        0x0021 , "WM_MOUSEACTIVATE"                      ,
        0x0022 , "WM_CHILDACTIVATE"                      ,
        0x0023 , "WM_QUEUESYNC"                          ,
        0x0024 , "WM_GETMINMAXINFO"                      ,
        0x0026 , "WM_PAINTICON"                          ,
        0x0027 , "WM_ICONERASEBKGND"                     ,
        0x0028 , "WM_NEXTDLGCTL"                         ,
        0x002A , "WM_SPOOLoLDERSTATUS"                      ,
        0x002B , "WM_DRAWITEM"                           ,
        0x002C , "WM_MEASUREITEM"                        ,
        0x002D , "WM_DELETEITEM"                         ,
        0x002E , "WM_VKEYTOITEM"                         ,
        0x002F , "WM_CHARTOITEM"                         ,
        0x0030 , "WM_SETFONT"                            ,
        0x0031 , "WM_GETFONT"                            ,
        0x0032 , "WM_SETHOTKEY"                          ,
        0x0033 , "WM_GETHOTKEY"                          ,
        0x0037 , "WM_QUERYDRAGICON"                      ,
        0x0039 , "WM_COMPAREITEM"                        ,
        0x0041 , "WM_COMPACTING"                         ,
        0x0044 , "WM_COMMNOTIFY"                         ,
        0x0046 , "WM_WINDOWPOSCHANGING"                  ,
        0x0047 , "WM_WINDOWPOSCHANGED"                   ,
        0x0048 , "WM_POWER"                              ,
        0x004A , "WM_COPYDATA"                           ,
        0x004B , "WM_CANCELJOURNAL"                      ,
        0x004E , "WM_NOTIFY"                             ,
        0x0050 , "WM_INPUTLANGCHANGEREQUEST"             ,
        0x0051 , "WM_INPUTLANGCHANGE"                    ,
        0x0052 , "WM_TCARD"                              ,
        0x0053 , "WM_HELP"                               ,
        0x0054 , "WM_USERCHANGED"                        ,
        0x0055 , "WM_NOTIFYFORMAT"                       ,
        0x007B , "WM_CONTEXTMENU"                        ,
        0x007C , "WM_STYLECHANGING"                      ,
        0x007D , "WM_STYLECHANGED"                       ,
        0x007E , "WM_DISPLAYCHANGE"                      ,
        0x007F , "WM_GETICON"                            ,
        0x0080 , "WM_SETICON"                            ,
        0x0081 , "WM_NCCREATE"                           ,
        0x0082 , "WM_NCDESTROY"                          ,
        0x0083 , "WM_NCCALCSIZE"                         ,
        0x0084 , "WM_NCHITTEST"                          ,
        0x0085 , "WM_NCPAINT"                            ,
        0x0086 , "WM_NCACTIVATE"                         ,
        0x0087 , "WM_GETDLGCODE"                         ,
        0x00A0 , "WM_NCMOUSEMOVE"                        ,
        0x00A1 , "WM_NCLBUTTONDOWN"                      ,
        0x00A2 , "WM_NCLBUTTONUP"                        ,
        0x00A3 , "WM_NCLBUTTONDBLCLK"                    ,
        0x00A4 , "WM_NCRBUTTONDOWN"                      ,
        0x00A5 , "WM_NCRBUTTONUP"                        ,
        0x00A6 , "WM_NCRBUTTONDBLCLK"                    ,
        0x00A7 , "WM_NCMBUTTONDOWN"                      ,
        0x00A8 , "WM_NCMBUTTONUP"                        ,
        0x00A9 , "WM_NCMBUTTONDBLCLK"                    ,
        0x0100 , "WM_KEYDOWN WM_KEYFIRST"                ,
        0x0101 , "WM_KEYUP"                              ,
        0x0102 , "WM_CHAR"                               ,
        0x0103 , "WM_DEADCHAR"                           ,
        0x0104 , "WM_SYSKEYDOWN"                         ,
        0x0105 , "WM_SYSKEYUP"                           ,
        0x0106 , "WM_SYSCHAR"                            ,
        0x0107 , "WM_SYSDEADCHAR"                        ,
        0x0108 , "WM_KEYLAST"                            ,
        0x010D , "WM_IME_STARTCOMPOSITION"               ,
        0x010E , "WM_IME_ENDCOMPOSITION"                 ,
        0x010F , "WM_IME_KEYLAST WM_IME_COMPOSITION"     ,
        0x0110 , "WM_INITDIALOG"                         ,
        0x0111 , "WM_COMMAND"                            ,
        0x0112 , "WM_SYSCOMMAND"                         ,
        0x0113 , "WM_TIMER"                              ,
        0x0114 , "WM_HSCROLL"                            ,
        0x0115 , "WM_VSCROLL"                            ,
        0x0116 , "WM_INITMENU"                           ,
        0x0117 , "WM_INITMENUPOPUP"                      ,
        0x011F , "WM_MENUSELECT"                         ,
        0x0120 , "WM_MENUCHAR"                           ,
        0x0121 , "WM_ENTERIDLE"                          ,
        0x0132 , "WM_CTLCOLORMSGBOX"                     ,
        0x0133 , "WM_CTLCOLOREDIT"                       ,
        0x0134 , "WM_CTLCOLORLISTBOX"                    ,
        0x0135 , "WM_CTLCOLORBTN"                        ,
        0x0136 , "WM_CTLCOLORDLG"                        ,
        0x0137 , "WM_CTLCOLORSCROLLBAR"                  ,
        0x0138 , "WM_CTLCOLORSTATIC"                     ,
        0x0200 , "WM_MOUSEMOVE WM_MOUSEFIRST"            ,
        0x0201 , "WM_LBUTTONDOWN"                        ,
        0x0202 , "WM_LBUTTONUP"                          ,
        0x0203 , "WM_LBUTTONDBLCLK"                      ,
        0x0204 , "WM_RBUTTONDOWN"                        ,
        0x0205 , "WM_RBUTTONUP"                          ,
        0x0206 , "WM_RBUTTONDBLCLK"                      ,
        0x0207 , "WM_MBUTTONDOWN"                        ,
        0x0208 , "WM_MBUTTONUP"                          ,
        0x0209 , "WM_MBUTTONDBLCLK WM_MOUSELAST"         ,
        0x0210 , "WM_PARENTNOTIFY"                       ,
        0x0211 , "WM_ENTERMENULOOP"                      ,
        0x0212 , "WM_EXITMENULOOP"                       ,
        0x0213 , "WM_NEXTMENU"                           ,
        0x0214 , "WM_SIZING"                             ,
        0x0215 , "WM_CAPTURECHANGED"                     ,
        0x0216 , "WM_MOVING"                             ,
        0x0218 , "WM_POWERBROADCAST"                     ,
        0x0219 , "WM_DEVICECHANGE"                       ,
        0x0220 , "WM_MDICREATE"                          ,
        0x0221 , "WM_MDIDESTROY"                         ,
        0x0222 , "WM_MDIACTIVATE"                        ,
        0x0223 , "WM_MDIRESTORE"                         ,
        0x0224 , "WM_MDINEXT"                            ,
        0x0225 , "WM_MDIMAXIMIZE"                        ,
        0x0226 , "WM_MDITILE"                            ,
        0x0227 , "WM_MDICASCADE"                         ,
        0x0228 , "WM_MDIICONARRANGE"                     ,
        0x0229 , "WM_MDIGETACTIVE"                       ,
        0x0230 , "WM_MDISETMENU"                         ,
        0x0231 , "WM_ENTERSIZEMOVE"                      ,
        0x0232 , "WM_EXITSIZEMOVE"                       ,
        0x0233 , "WM_DROPFILES"                          ,
        0x0234 , "WM_MDIREFRESHMENU"                     ,
        0x0281 , "WM_IME_SETCONTEXT"                     ,
        0x0282 , "WM_IME_NOTIFY"                         ,
        0x0283 , "WM_IME_CONTROL"                        ,
        0x0284 , "WM_IME_COMPOSITIONFULL"                ,
        0x0285 , "WM_IME_SELECT"                         ,
        0x0286 , "WM_IME_CHAR"                           ,
        0x0290 , "WM_IME_KEYDOWN"                        ,
        0x0291 , "WM_IME_KEYUP"                          ,
        0x0300 , "WM_CUT"                                ,
        0x0301 , "WM_COPY"                               ,
        0x0302 , "WM_PASTE"                              ,
        0x0303 , "WM_CLEAR"                              ,
        0x0304 , "WM_UNDO"                               ,
        0x0305 , "WM_RENDERFORMAT"                       ,
        0x0306 , "WM_RENDERALLFORMATS"                   ,
        0x0307 , "WM_DESTROYCLIPBOARD"                   ,
        0x0308 , "WM_DRAWCLIPBOARD"                      ,
        0x0309 , "WM_PAINTCLIPBOARD"                     ,
        0x030A , "WM_VSCROLLCLIPBOARD"                   ,
        0x030B , "WM_SIZECLIPBOARD"                      ,
        0x030C , "WM_ASKCBFORMATNAME"                    ,
        0x030D , "WM_CHANGECBCHAIN"                      ,
        0x030E , "WM_HSCROLLCLIPBOARD"                   ,
        0x030F , "WM_QUERYNEWPALETTE"                    ,
        0x0310 , "WM_PALETTEISCHANGING"                  ,
        0x0311 , "WM_PALETTECHANGED"                     ,
        0x0312 , "WM_HOTKEY"                             ,
        0x0317 , "WM_PRINT"                              ,
        0x0318 , "WM_PRINTCLIENT"                        ,
        0x0358 , "WM_HANDHELDFIRST"                      ,
        0x035F , "WM_HANDHELDLAST"                       ,
        0x0360 , "WM_AFXFIRST"                           ,
        0x037F , "WM_AFXLAST"                            ,
        0x0380 , "WM_PENWINFIRST"                        ,
        0x038F , "WM_PENWINLAST"                         ,
        0x0400 , "WM_USER"                               ,
        0x8000 , "WM_APP"                                ,
    {
    const wmSymbolS pWmSymbol[] =
    // "CT" = "compressed, title"

#if defined( NEVERdEFINED )

;
}
    osTextT*    post ;
    countT      id ;
{
struct wmSymbolS

boolT bEndSessionPending ;

// winMessageHandlerWorkF IS TO BE UNAFFECTED BY ether I.E. WHETHER THE CELL HAS BEEN FIRED

//#if defined( NEVERdEFINED )
//FOR DEBUGGING USE: THIS IS A COMPLETE LIST OF WM_ CODES AND SYMBOLS, OBTAINED BY EDITING wmuser.h
//U::

/**/
*/
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.0b0001b.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$winMessageHandlerWorkF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

