
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

ether.loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    etThread.osThreadF( TaRG1( tmWorkerF ) , (countT)ptRoot[ offt ] , (countT)pcArgInner ) ;

    countT pcArgInner[] = { (countT)&etThread , (countT)&sttq , (countT)ptRoot[ offt ] , (countT)&tPatternOld } ;
{
for( countT offt = 0 ; offt < sizeof ptRoot / sizeof ptRoot[ 0 ] ; offt ++ )

textC* ptRoot[] = { &tRootZ } ;

TN( tRootZ , "///z/archive/" ) ;
TN( tRootY , "///y/archive/" ) ;
TN( tRootX , "///x/archive/" ) ;
TN( tRootW , "///w/archive/" ) ;
//TN( tRootE , "///e/archive/" ) ;
TN( tRootG , "///g/archive/" ) ;


strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

TN( tPatternOld , "" ) ;

TODO

DONE( tmWorkerF )
}
    etThread.traceF( tinP , T("root ---- [cFiles,cDirs]:    ")+*ptRootP+tb4+TF2(cFiles,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(cDirs,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
    etThread.diskWalkF( tinP , cDirs , cFiles , *ptRootP , ether , flDISKwALK_null , healCBF , pcArgInnerP , 0 , 0 ) ;
    etThread.traceF( tinP , T("root ++++               :    ")+*ptRootP ) ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs ) ;

    TN( tb4 , "    " ) ;
    countT* pcArgInnerP = (countT*)pTaskP->c2 ;
    textC*  ptRootP     =  (textC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )


}
    return 0 ;

    }
        }
            etherP.delF( tinP , psttRelative ) ;
            etherP.traceF( tinP , T("[relative name:    ")+T(psttRelative) ) ;
            etherP.strSubstringF( tinP , psttRelative , idf , idl , tNameOld ) ; ___( psttRelative ) ;
            ZE( countT , idl ) ;
            ZE( strokeS* , psttRelative ) ;
        {
        if( !POOP )

        __( idHit - 1 ) ;
        countT idHit = etherP.strIdF( tinP, idf , sttqP , tRootP , tNameOld ) ;
        countT idf = 1 ;

        TN( tNameOld , ifName ) ;
        ifFileNameC ifName( tinP , etherP , postNameP ) ;

        textC&  tPatternOldP =   *(textC*)pcArgP[ 1 ] ;
        textC&  tRootP       =   *(textC*)pcArgP[ 2 ] ;
        strokeS sttqP        = *(strokeS*)pcArgP[ 1 ] ;
        etherC& etherP       =  *(etherC*)pcArgP[ 0 ] ;
    {
    if( postNameP )
{
boolT healCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )


/*1*/WAKEsHOWtEXT( "heal.arbitrary.directory.trees" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
