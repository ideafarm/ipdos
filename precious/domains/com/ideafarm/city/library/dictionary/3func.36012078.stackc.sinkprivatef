
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUTbATONsTACKc_
    if( cPlates < *p_idCursor || ( *p_idCursor && !*p_ppCursor ) ) { BLAMMO ; } //U::

    }
        }
            }
                }
                    }
                        if( pSgnEvent && F(flags) & flSTACKc_GIVEsIGNnEWpLATE ) pSgnEvent->giveF( tinP ) ;
                        newTabsIfF( tinP , ppNew , 0 ) ;
                    {
                    if( idSlotP )
    
                    else idSlotP = 0 ;
                    }
                        }
                            cPlates ++ ;
                            }
                                ppNew->ppD = ppc ;
                                ppc->ppU = ppNew ;
                                ppNew->ppU = ppc->ppU ;
                                if( ppc->ppU ) ((plateS*)ppc->ppU)->ppD = ppNew ;
                            {
                            else
                            }
                                ppTop = ppNew ;
                                ppNew->ppD = ppTop ;
                                ppTop->ppU = ppNew ;
                            {
                            if( ppc == ppTop )
                            adjustRefsF( tinP , idSlotP , ifcIDaCTIONsTACKaDJUSTrEFS_NEWaBOVE , ppNew ) ;
                        {
                        if( ppNew )

                        }
                            ppNew->resetF() ; // DATA SECTION IS NOT INITIALIZED
                            ppNew = ppValueP ; ppValueP = 0 ;
                        {
                        else
                        if( !ppValueP ) newPlateF( tinP , ppNew , valueP ) ;
                    {
                    else if( heavy < 0 || !( F(flagsP) & flSTACKsINK_UNIQUE ) ) //INSERT ME JUST ABOVE ppc (idSlotP)
                    }
                        }
                            adjustRefsF( tinP , ++ idSlotP , ifcIDaCTIONsTACKaDJUSTrEFS_REFERENCE , ppNew ) ;
                            cPlates ++ ; //U::
                            ppNew->ppU = ppc ;
                            ppBottom = ppc->ppD = ppNew ;
                        {
                        if( ppNew )

                        }
                            ppNew->resetF() ; // DATA SECTION IS NOT INITIALIZED
                            ppNew = ppValueP ; ppValueP = 0 ;
                        {
                        else
                        if( !ppValueP ) newPlateF( tinP , ppNew , valueP ) ;
                    {
                    if( heavy > 0 ) //I AM HEAVIER THAN THE PLATE AT THE BOTTOM OF THE STACK, SO INSERT ME BELOW ppc (idSlotP)
                {
                else
                }
                    }
                        adjustRefsF( tinP , idSlotP , ifcIDaCTIONsTACKaDJUSTrEFS_REFERENCE , ppc ) ;
                    {
                    else
                    if( heavy ) idSlotP = 0 ;
                {
                if( F(flagsP) & flSTACKsINK_QUERY )
    
                }
                    }
                        }
                            }
                                }
                                    idSlotP = 1 ;
                                    ppc = ppTop ;
                                {
                                else
                                }
                                    idSlotP = pcTabIdSlot[ oTab - 1 ] ;
                                    ppc = ppTab[ oTab - 1 ] ;
                                {
                                else if( oTab )
                                }
                                    idSlotP = pcTabIdSlot[ oTab ] ;
                                    ppc = ppTab[ oTab ] ;
                                {
                                if( heavy > 0 )
                                bJump = 0 ;
                            {
                            else
                            }
                                ppc = ppTab[ oTab ] ;
                                oTab = oTabNew ;
                            {
                            if( oTabNew != oTab )
                            countT oTabNew = ( oTabFloor + oTabCeiling ) >> 1 ;
                        {
                        if( bJump )
    
                        }
                            else oTabCeiling = oTab ;
                            }
                                ppc = ppc->ppD ;
                                idSlotP ++ ;
                                if( !ppc->ppD ) break ; //I AM HEAVIER THAN THE PLATE AT THE BOTTOM OF THE STACK
                            {
                            if( !bJump )
                        {
                        else                            // I AM DENSER THAN ppc (idSlotP) SO WILL CONTINUE TO SINK DOWN THE STACK
                        }
                            else         oTabFloor = oTab ;
                            if( !bJump ) break ;
                        {
                        else if( heavy < 0 )            // I AM LESS DENSE THAN ppc (idSlotP) SO WILL FLOAT ABOVE IT
                        }
                            else         oTabFloor = oTab ;
                            if( !bJump ) break ;
                        {
                        if( !heavy )                    // MY DENSITY EQUALS ppc (idSlotP)
    
                        }
                            if( F(flags) & flSTACKc_SINKrEVERSE ) heavy = - heavy ;
                            //if( tinP.pEther && tinP.pcUtility[ 0 ] ) tinP.pEther->traceF( tinP , T("sinking: calculated heavy [heavy]:    ")+TF2(heavy,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO TEST
                            heavy = (*pSubtractF)( tinP , pEther , valuen , valuec , cArg ) ;
                            countT cArg = subtractionParmP ? subtractionParmP : cbd ;
                        {

                        }
                            default                    : { valuen = valueP ; valuec =         PLATE_countT_REF( ppc ) ; break ; } //U: CONJ: "valuen =" WOULD NOT BE NEEDED IF WE PREVENTED pSubtractF FROM MODIFYING valuen
                                                         { valuen = valueP ; valuec = (countT)PLATE_byteT_PTR(  ppc ) ; break ; }
                            case ifcSTACKtYPE_BLOB     :
                            case ifcSTACKtYPE_timeS    :
                            case ifcSTACKtYPE_nicNameC :
                        {
                        switch( idType )
                        //TEST A PLATE (CALCULATE heavy)
                    {
                    while( !third )
    
                    countT cbd = idType == ifcSTACKtYPE_BLOB ? cbData : 0 ; //U::CONJ: BUG: EDIT THIS TO HANDLE VARIABLE LENGTH BLOBS
                    ZE( countT , valuec ) ;
                    ZE( countT , valuen ) ;
                    countT pEther = (countT)third.third_pEtherContainsMe_F() ;
    
                    }
                        idSlotP = 1 ; //IF NOT JUMPING, THEN idSlotP WILL TELL ME WHERE I AM
                        ppc = ppTop ;
                    {
                    else
                    }
                        ppc = ppTab[ oTab ] ;
                        oTab = cTabs >> 1 ; //IF JUMPING, THEN oTab WILL TELL ME WHERE I AM
                    {
                    if( bJump )
                    ZE( countT , oTab ) ;
                    countT oTabFloor = cTabs ? cTabs - 1 : 0 ;
                    countT oTabCeiling = 0 ;
                    boolT bJump = cTabs ? 1 : 0 ; //U::
                    //
                    // when oTabCeiling and oTabFloor are adjacent, set ppc (and idSlotP) to point to oTabFloor
                    // oTabFloor is a plate that is not lighter
                    // oTabCeiling is a plate that is lighter
                    // jumping: squeeze until oTabCeiling and oTabFloor are adjacent; initialize ppc and idSlotP for a walk; walk
                    // walking: keep walking until heavy <= 0; leaving ppc and idSlotP pointing to the lath plate tested
                    // when jumping, the ppTab array is used
                    // when walking, the plateS pointers ppU and ppD are used
                    // this loop works in oo modes, walking and jumping, to set ppc (and idSlotP) to the lightest plate not lighter than the new plate
                    //
                    // IOW, ppc MOVES DOWN THE STACK UNTIL IT POINTS TO A PLATE THAT IS NOT LIGHTER THAN THE NEW PLATE
                    // RECIPE: THIS LOOP SETS ppc AND idSlotP TO POINT TO THE LEAST UPPER BOUND (IN TERMS OF WEIGHT) PLATE
                {
                ZE( plateS* , ppc ) ; //THIS ALWAYS POINTS TO THE PLATE CURRENTLY BEING INSPECTED
                ZE( sCountT , heavy ) ;

                }
                    newTabsIfF( tinP , 0 , 0 ) ;
                    cTabAge = - 1 ;
                    flagsState |= flSTACKsTATE_MAINTAINtABS ;
                {
                if( !( F(flagsState) & flSTACKsTATE_MAINTAINtABS ) )
            {
            else
            }

                newTabsIfF( tinP , ppNew , 0 ) ;

                adjustRefsF( tinP , idSlotP , ifcIDaCTIONsTACKaDJUSTrEFS_REFERENCE , ppTop ) ;

                idSlotP = 1 ;
                if( pSgnEvent && F(flags) & flSTACKc_GIVEsIGNnEWpLATE ) pSgnEvent->giveF( tinP ) ;
                cPlates ++ ; //U::
                ppBottom = ppTop = ppNew ;
                }
                    ppNew->resetF() ; // DATA SECTION IS NOT INITIALIZED
                    ppNew = ppValueP ; ppValueP = 0 ;
                {
                else
                if( !ppValueP ) newPlateF( tinP , ppNew , valueP ) ;
            {
            if( !ppTop )
            ZE( plateS* , ppNew ) ;
        {
        else
        if( !ppTop && F(flagsP) & flSTACKsINK_QUERY ) ;
    {
    if( !third )
    __( !*p_idCursor - !*p_ppCursor ) ;
    __( *p_idLathRef && !*p_ppLathRef ) ;

    LATHrEF

    if( cPlates < *p_idCursor || ( *p_idCursor && !*p_ppCursor ) ) { BLAMMO ; } //U::

    CURSOR

    if( !pSubtractF ) pSubtractF = subtractF ;
    ifc4FT pSubtractF = pSubtractFP ;
    _INbATONsTACKc_

    }
        if( third ) return ;
        __( F(flags) & flSTACKc_XRAY ) ;
        __( ( F(flagsP) & flSTACKsINK_QUERY ) && ( F(flagsState) & flSTACKsTATE_SHIFTlEFTuSED ) ) ;
        __NZ( !( F(flags) & flSTACKc_ALLOWzE ) && !valueP ) ;
        FV( flSTACKsINK , flagsP ) ;
        __( idSlotP ) ;
        if( third ) return ;
    {
    IFbEcAREFUL
    SCOOP   
{
/*1*/voidT stackC::sinkPrivateF( tinS& tinP , countT& idSlotP , const countT valueP , plateS*& ppValueP , const flagsT flagsP , ifc4FT pSubtractFP , const countT subtractionParmP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

