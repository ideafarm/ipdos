
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

REST

}
    }
        if( !cIn ) ether.osSleepF( tinP , TOCK * 0x10 ) ;
        TELL( "taking my cycle nap" ) ;

        }
            etThread.delF( tinP , pstt1m ) ;
            }
                etThread.osThreadF( tinP , countTC() , tmSuperF , 0 , flTHREADlAUNCH_null , 0 , (countT)psttFile ) ;

                etThread.diskMoveFileOrDirF( tinP , psttFile , psttc1 ) ;
                etThread.strMakeF( tinP , psttFile , tStage2+TI(ifcIDtEXTgEN_UNIQUE) ) ; ___( psttFile ) ;
                ZE( strokeS* , psttFile ) ;
            {
            FORsTRINGSiN1( pstt1m )
            const countT cToDo = etThread.boxMenuF( tinP , soul1m , tStage1+tStar ) ; ___( pstt1m ) ;
            ZE( strokeS* , pstt1m ) ;
        {
        TELL( "promoting each stage 1 file to stage 2 and launching a supervisor thread for it" ) ;

        }
            etThread.delF( tinP , pstt1m ) ;
            FORsTRINGSiN1( pstt1m ) etThread.diskMoveFileOrDirF( tinP , tStage1+TI(ifcIDtEXTgEN_UNIQUE) , psttc1 ) ;
            cIn = etThread.boxMenuF( tinP , soul1m , tIn+tStar ) ; ___( pstt1m ) ;
            ZE( strokeS* , pstt1m ) ;
        {
        ZE( countT , cIn ) ;
        TELL( "moving new job files into the stage 1 directory" ) ;

        TN( tStage2  , "" ) ; tStage2 = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+T(DDNUMB)+T("/2/") ;
        TN( tStage1  , "" ) ; tStage1 = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+T(DDNUMB)+T("/1/") ;
        etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT , timeN1 ) ;
    {
    while( !ether && !etThread )
    TN( tIn , "" ) ; tIn = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+T(DDNUMB)+T("/in/" ) ;
    strokeS sttr('-') ;
    TN( tStar    , "*" ) ;

    //U::{ countT idAdam = 0x4010441 ; etThread.ifcHireF( tinP , T("sentient.asynch.job.supervisor") , idAdam , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ; }
    TELL( "hiring 144" )

    etThread.ifcChatF( tinP , 0 , DDNUMB , jobFillCourseF , jobHearOrderF ) ;
    TELL( "preparing to accept chat clients" ) ;
    stateS state( tinP , etThread ) ;
    TELL( "setting up" )
{

TELL( "preparing for work" ) ;
TODO

DONE( tmSuperF )
}
    etThread.delF( tinP , psttFile ) ;
    doWoF( tinP , etThread , psttFile ) ;
    strokeS* psttFile = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmSuperF )

}
    etThread.diskMoveFileOrDirF( tinP , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+T(DDNUMB)+T("/done/")+TI(ifcIDtEXTgEN_UNIQUE) , psttFileP ) ;

    etThread.ifcJobF( tinP , stCourses , idAdam , sOrder , stOrders , TF1(DDNUMB)+T("/sentient.asynch.job.supervisor/doWoF") , 1 ) ;
    stOrders << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
    stackC stOrders(  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stCourses( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;

    souIn >> sOrder ;
    soulC sOrder( tinP , TAG( TAGiDnULL ) ) ;

    souIn >> idAdam ;
    ZE( countT , idAdam ) ;

    __( (countT)souIn - 2 ) ;
    etThread.delF( tinP , pbs ) ;
    souIn.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbs , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
    soulC souIn( tinP , TAG( TAGiDnULL ) ) ;

    __( cbs - sizeof( countT ) - *(countT*)pbs ) ;
    etThread.boxGetShadowF( tinP , pbs , cbs , psttFileP ) ; ___( pbs ) ;
    ZE( countT , cbs ) ;
    ZE( byteT* , pbs ) ;
{
voidT doWoF( tinS& tinP , etherC& etThread , const strokeS* const psttFileP )

STATE0

}
    if( ether && *tinP.zEtScratch && cArgP && c8argP.c1 && sDataP && sNotesTextP && sNotesDataP && idChatSessionP ) ;

    }
        }
            break ;

            }
                }
                    break ;
                    etThread.delF( tinP , psttJobType ) ;

                    else __1
                    }
                    {
                    if( !etThread.strCompareF( tinP , psttJobType , T("!fooey") ) )

                    sOrderP >> psttJobType ; ___( psttJobType ) ;
                    ZE( strokeS* , psttJobType )
                {
                case ifcIDcMDjOBoRDER_NAMED :
                }
                    break ;

                    etThread.delF( tinP , psttBody ) ;
                    etThread.delF( tinP , psttFrom ) ;

                    }
                        etThread.delF( tinP , postBody ) ;
                        etThread.delF( tinP , psttu ) ;
                        etThread.boxPutUniqueF( tinP , psttu , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(DDNUMB)+T("/in/ignored/in") , postBody , costBody ) ;
                        ZE( strokeS* , psttu ) ;

                        countT costBody = etThread.strMakeF( tinP , postBody , psttBody ) ; ___( postBody ) ;
                        ZE( osTextT* , postBody ) ;
                    {

                    sOrderP >> psttBody ; ___( psttBody ) ;
                    ZE( strokeS* , psttBody ) ;

                    __( idAdamTo - DDNUMB ) ;
                    __Z(  idAdamTo ) ;
                    sOrderP >> idAdamTo ;
                    ZE( countT , idAdamTo ) ;

                    __(  psttFrom && !psttFrom->idAdam ) ;
                    __Z( psttFrom ) ;
                    sOrderP >> psttFrom ; ___( psttFrom ) ;
                    ZE( strokeS* , psttFrom ) ;
                {
                case ifcIDcMDjOBoRDER_MAIL :
            {
            switch( idJobType )

            sOrderP >> idJobType ;
            ZE( countT , idJobType ) ;
        {
        case 1 :
    {
    switch( idCourseP )

    __( idAdamP - DDNUMB ) ;
{
voidT jobFillCourseF( tinS& tinP , etherC& ether , etherC& etThread , soulC& sDataP , soulC& sNotesTextP , soulC& sNotesDataP , const countT idCourseP , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

}
    if( cArgP && c8argP.c1 && sOrderP && ether && idChatSessionP ) ;

    __( idAdamP - DDNUMB ) ;
{
voidT jobHearOrderF( tinS& tinP , etherC& ether , etherC& etThread , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

/*1*/WAKEhIDE( "sentient.asynch.job.supervisor" )/*1*/
/**/
*/
i supervise jobs that are dropped into my in box directory
\<A HREF=\"5.9440104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

