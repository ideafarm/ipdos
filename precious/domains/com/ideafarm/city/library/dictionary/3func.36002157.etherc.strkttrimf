
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cDiscarded ;

    _OUT_

    }
        if( bDeleteOld ) delF( tinP , (strokeS*&)psttOld ) ;
        
        }
            }
                else strFuseF( tinP , psttNewP , sttc ) ;
                }
                    sttAttach = 0 ;
                    strFuseF( tinP , psttNewP , sttAttach ) ;
                    __( sttc.idCaste - scOld_KTaTTACH ) ;
                {
                if( (countT)sttAttach )
            {
            if( !bSkip )

            }
                }
                    bSkip = !!cToDiscard ;
                    }
                        cToDiscard -- ;
                        __Z( cToDiscard ) ;
                    {
                    else
                    }
                        if( cToDiscard ) sttAttach = sttc ;
                    {
                    if( !bSkip )
                {
                if( idLevel == 2 )
    
                }
                    case saOLD_KTaTTACHdOWN : { idLevel -- ; break ; }
                    case saOLD_KTaTTACHuP   : { idLevel ++ ; break ; }
                {
                switch( sttc.idAdam )
            {
            if( sttc.idCaste == scOld_KTaTTACH )
    
            const strokeS& sttc = psttOld[ CSpREFIX - 1 + ids ] ;
        {
        for( countT ids = 1 ; ids <= psttOld->idAdam ; ids ++ )
        strokeS sttAttach ;
        ZE( boolT , bSkip ) ;
        idLevel = 1 ;
        POSTPONEtEST( psttNewP ) ;
        strMakeF( tinP , psttNewP , T("") , psttOld->idAdam + csttExtraP ) ; //CALLER MUST TAG
    {
    else
    }
        }
            POSTPONEtEST( psttNewP ) ;
            strMakeF( tinP , psttNewP , psttOld , csttExtraP ) ; //CALLER MUST TAG ___( psttNewP ) ;
        {
        else
        if( bDeleteOld ) psttNewP = (strokeS*)psttOld ;
    {
    if( !cToDiscard )

    countT cToDiscard = cTotalAt2 > cKeepP ? cTotalAt2 - cKeepP : 0 ;
    }
        }
            if( idLevel == 2 ) cTotalAt2 ++ ;

            }
                case saOLD_KTaTTACHdOWN : { idLevel -- ; break ; }
                case saOLD_KTaTTACHuP   : { idLevel ++ ; break ; }
            {
            switch( sttc.idAdam )
        {
        if( sttc.idCaste == scOld_KTaTTACH )

        const strokeS& sttc = psttOld[ CSpREFIX - 1 + ids ] ;
    {
    for( countT ids = 1 ; ids <= psttOld->idAdam ; ids ++ )
    ZE( countT , cTotalAt2 ) ;
    countT idLevel = 1 ;

    // MY JOB IS TO ELIMINATE EARLY BRANCHES SO THAT THERE ARE NO MORE THAN cKeepP BRANCHES AT LEVEL 2
    // EACH SUBSEQUENT BRANCH BEGINS WITH ITS ATTACH STROKE
    // THE WOTH ATTACH MUST BE "UP"
    // THERE IS WO LEVEL 1 BRANCH
    //
    //CONCEPTS

    }
        bDeleteOld = 1 ;
        psttNewP = 0 ;
        psttOld = psttNewP ;
    {
    else
    if( psttOldP ) psttOld = psttOldP ;
    ZE( boolT , bDeleteOld ) ;
    ZE( const strokeS* , psttOld ) ;
    ZE( countT , cDiscarded ) ;
    _INoLD_

    }
        if( POOP ) return 0 ;
        __( !psttNewP == !psttOldP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/countT etherC::strKTTrimF( tinS& tinP , strokeS*& psttNewP , const strokeS* const psttOldP , const countT cKeepP , const countT csttExtraP )/*1*/

/**/
*/
\<A HREF=\"5.10301a0.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strKTTrimF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

