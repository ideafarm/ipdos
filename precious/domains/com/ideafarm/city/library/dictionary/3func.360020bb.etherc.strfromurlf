
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    #endif

        }
            delF( tinP , psttOld2 ) ;
            strReplaceF( tinP , psttP , 0 , psttOld2 , tNew ) ;
            strReplaceF( tinP , psttP , 0 , tOld     , tNew ) ;
    
            strConvertToUpperCaseF( tinP , psttOld2 ) ; ___( psttOld2 ) ;
            strMakeF( tinP , psttOld2 , tOld ) ; ___( psttOld2 ) ;
            ZE( strokeS* , psttOld2 ) ;
            textC tOld = T("%")+TF3(vv,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,2) ;
    
            TN( tNew , postn ) ;
            const osTextT postn[] = { (osTextT)vv , 0 } ;
    
            continue ; //ASSUME: PLAIN ALPHANUMERIC VALUES ARE NOT ENCODED (THIS IS A SPEED OPTIMIZATION)
            )
                ( vv == ' ' )
                ( vv >= '0' && vv <= '9' ) ||
                ( vv >= 'A' && vv <= 'Z' ) ||
                ( vv >= 'a' && vv <= 'z' ) ||
            (
            if
        {
        for( countT vv = 1 ; vv <= 0x7f ; vv ++ ) // FOR EACH ASCII VALUE (7 BITS)
        // REPLACE %HH SYMBOLS WITH NON-ALPHANUMERICS
    
        strReplaceF( tinP , psttP , 0 , T("+") , T(" ") ) ;
    
        if( psttOld ) { strFuseF( tinP , psttP , psttOld ) ; ___( psttP ) ; }

    #else
    //OLD CODE

        if( !psttOldP ) delF( tinP , *(strokeS**)&psttOld ) ;
        delF( tinP , postOld ) ;
        delF( tinP , postNew ) ;

        }
            POSTPONEtEST( psttP ) ;
            strMakeF( tinP , psttP , T(postNew) ) ; //CALLER MUST TAG ___( psttP ) ;

            postNew[ offo ++ ] = 0 ;
            }
                }
                    default  : { postNew[ offo ++ ] = postOld[ offi ] ; break ; }
                    }
                        break ;

                        }
                            postNew[ offo ++ ] = (osTextT)vv ;
                            }
                                else if( code >= 'A' && code <= 'F' ) vv += 0xa + code - 'A' ;
                                else if( code >= 'a' && code <= 'f' ) vv += 0xa + code - 'a' ;
                                     if( code >= '0' && code <= '9' ) vv +=       code - '0' ;
                                countT code = postOld[ ++ offi ] ;
                                vv <<= 4 ;
                            {
                            while( cToDo -- )
                            countT cToDo = 2 ;
                            ZE( countT , vv ) ;
                        {
                        if( offi + 2 < costOld )
                    {
                    case '%' :
                    case '+' : { postNew[ offo ++ ] = ' ' ; break ; }
                {
                switch( postOld[ offi ] )
            {
            for( countT offi = 0 ; offi < costOld ; offi ++ )
            ZE( countT , offo ) ;
        {
        if( postOld && postNew )

        newF( tinP , LF , postNew , costOld + 1 ) ; ___( postNew ) ;
        ZE( osTextT* , postNew ) ;

        countT costOld = strMakeF( tinP , postOld , psttOld ) ; ___( postOld ) ;
        ZE( osTextT* , postOld ) ;

        __NZ( psttP ) ;
        __Z( psttOld ) ;

        }
                      psttP = 0 ;
            psttOld = psttP ;
        {
        else
        if( psttOldP ) psttOld = psttOldP ;
        ZE( const strokeS* , psttOld ) ;

    #if !defined( NEVERdEFINED )
    //NEW CODE

    _INoLD_

    }
        if( POOP ) return ;
        __( !psttP && !psttOldP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::strFromUrlF( tinS& tinP , strokeS*& psttP , const strokeS* const psttOldP )/*1*/

/**/
*/
 psttOldP
 psttP
arguments
psttOldP can be 0
  normally, hexadecimal digits must be in lower case
 this is an exception to the norm within IdeaFarm " "(tm) City
  %bc  %BC  %bC  %Bc  are treated identically
 xx can be in lower or upper or mixed case
it replaces occurances of "%xx" with the corresponding character
this function replaces occurances of "+" with " "
   xx denotes two hexadecimal digits
  each non-alphanumeric is represented by a %xx
  each blank is represented by a "+"
 urls that contain queries typically are encoded
decodes a url, typically one that contains a query
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.10300d6.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strFromUrlF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

