
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        }
            }
                etThread.winSetTitleF( tinP , TF1(state.idMe)+tb+TF1(++state.cThreads)+tb+TF1(cThreads) ) ;
                cAll ++ ;
                cThreads ++ ;
            {
            if( !etThread )
            etThread.osThreadF( tinP , countTC() , tmNullF ) ;
        {
        else
        if( cThreads > 0x10 ) ether.osSleepF( tinP , TOCK ) ;
    {
    while( !ether && !etThread )
    ZE( countT , cAll ) ;
    TN( tb , " " ) ;

    if( !( F(napDebug.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) ) napDebug.formattingIsDoneF( tinP ) ;
    napkinC napDebug( tinP , LF , (byteT*)bits , "2a40104/1" , 0 , 1 ) ;
    bitsC bits( tinP , CbITSlIFI , 0 , 1 ) ;
    //boxC boxDebug( tinP , etThread , T("///ideafarm/ephemeral/domains/com/ideafarm/debug/")+TF1(DDNUMB)+T("/1") ) ; //U::CONJ: WILL LOCK UP DURING CT

    //U::{ countT idAdam = DDNUMB ; etThread.ifcHireF( tinP , T("tool.gorilla.monitor.1.cell.generations") , idAdam , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ; }
    stateS state( tinP , etThread ) ;
{

TODO

DONE( tmNullF )
cThreads -- ;
}
    etThread.osSleepF( tinP , TOCK ) ;
    if( !( F(napDebug.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) ) napDebug.formattingIsDoneF( tinP ) ;
    napkinC napDebug( tinP , LF , (byteT*)bits , "2a40104/1" , 0 , 1 ) ;
    bitsC bits( tinP , CbITSlIFI , 0 , 1 ) ;
    //boxC boxDebug( tinP , etThread , T("///ideafarm/ephemeral/domains/com/ideafarm/debug/")+TF1(DDNUMB)+T("/2") ) ; //U::CONJ: WILL LOCK UP DURING CT
{
TASK( tmNullF )

countT cThreads ;

}
{                                                                                                                                                       \
stateC( tinP , etherP , sizeof *this , 0 , translateStateF )                                                                                            \
stateS::stateS( tinS& tinP , etherC& etherP ) :                                                                                                         \
                                                                                                                                                            \
TRANSLATEsTATE_END                                                                                                                                      \
    state.idMe ++ ;                                                                                                                                     \
TRANSLATEsTATE_MIDDLE                                                                                                                                   \
    case 1 : { state.idMe = stateOther.idMe ; state.cThreads = stateOther.cThreads ; }                                                                                           \
TRANSLATEsTATE_BEGIN( stateS , 1 )                                                                                                                      \
                                                                                                                                                            \
;                                                                                                                                                       \
}                                                                                                                                                       \
    stateS( tinS& tinP , etherC& etherP ) ;                                                                                                             \

    countT cThreads ;                                                                                                                                                            \
    countT idMe ;                                                                                                                                       \
    countT idVersion ;                                                                                                                                  \
{                                                                                                                                                       \
struct stateS : public stateC                                                                                                                           \

/*1*/WAKEhIDE( "tool.gorilla.monitor.1.cell.generations" )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

