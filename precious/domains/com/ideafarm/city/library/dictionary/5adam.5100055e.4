
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        replaceButtonsF( tinP , etherP , cArgP , tButtons , CSTTmINbUTTONS , T("IPDOS (tm)  buttons") ) ;
        if(      paramP.treeKt.rightF( 1 , 1 ) ) tButtons += T(" ")+paramP.buClimbRight ;
        if(      paramP.treeKt.leftF(  1 , 1 ) ) tButtons += T(" ")+paramP.buClimbLeft  ;
        if( 2 == paramP.treeKt.upF(    2 , 1 ) ) tButtons += T(" ")+paramP.buClimbUp    ;
        if( 2 == paramP.treeKt.downF(  2 , 1 ) ) tButtons += T(" ")+paramP.buClimbDown  ;
        TN( tButtons , "" ) ; tButtons = paramP.buEscape+T(" ")+paramP.buF1/*+T(" ")+paramP.buF2*/+T(" ")+paramP.buSubscribe ;

        resizeIfF( tinP , cArgP , etherP ) ;
        paramP.treeKt.downF( 2 ) ;
    {
    if( 2 == paramP.treeKt.downF( 2 , 1 ) )
    ARGgET( cArgP )
{
voidT doDownF( tinS& tinP , etherC& etherP , const countT cArgP )

}
    treeP.newF( tinP , LF , (countT)pbMe , flagsP ) ;
    cbContentP += etherP.strEncodeF( tinP , pbMe , psttP , pbEndP ) ;
    byteT* pbMe = pbContentP + cbContentP ;
{
voidT brF( tinS& tinP , etherC& etherP , treeC& treeP , byteT*& pbContentP , countT& cbContentP , const byteT* const pbEndP , const flagsT flagsP , const strokeS* const psttP )

}
    else            paramP.vtView.setF( tinP , T("")+S2(1+incv02AM(paramP.idEventViewSelectLath),sc_NULL) ) ;
    if( !bNewSize ) freshViewOfBranchesF( tinP , etherP , cArgP ) ;

    }
        }
            break ;
            BLAMMO ; //CODEsYNC: ifcIDvIEW_max
        {
        default :
        }
            break ;
            if( paramP.cRight !=   0 ) { bNewSize = 1 ; paramP.cRight =   0 ; }
            if( paramP.cLeft  !=   0 ) { bNewSize = 1 ; paramP.cLeft  =   0 ; }
            if( paramP.cUp    !=   1 ) { bNewSize = 1 ; paramP.cUp    =   1 ; }
            if( paramP.cDown  != - 1 ) { bNewSize = 1 ; paramP.cDown  = - 1 ; }
        {
        case ifcIDvIEW_HUGE :
        }
            break ;
            if( paramP.cRight !=   1 ) { bNewSize = 1 ; paramP.cRight =   1 ; }
            if( paramP.cLeft  !=   1 ) { bNewSize = 1 ; paramP.cLeft  =   1 ; }
            if( paramP.cUp    !=   1 ) { bNewSize = 1 ; paramP.cUp    =   1 ; }
            if( paramP.cDown  !=   4 ) { bNewSize = 1 ; paramP.cDown  =   4 ; }
        {
        case ifcIDvIEW_HOLLYWOOD :
    {
    switch( paramP.idView )
    ZE( boolT , bNewSize ) ;

    ARGgET( cArgP )
{
voidT resizeIfF( tinS& tinP , countT cArgP , etherC& etherP )

}
    }
        ppvtClockP[ offo ++ ]->setF( tinP , T("")+S2(0,scOld_FRAMEaTTACH)+S3(mFrames,scOld_mmFRAMEcELLS,(measureT)1.0)+T(psttLabelP)+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAMEdETACH) ) ;
        strokeS::renderSizeIF( tinP , etherP , psttLabelP , mCols , mPads , mFrames ) ;
        ZE( measureT , mFrames ) ;
        ZE( measureT , mPads ) ;
        ZE( measureT , mCols ) ;
    {
    if( psttLabelP )

    }
        ) ;

            +S2(0,scOld_POPcOLOR)
            +S2(0,scOld_DISCARDnOTEsET)
            +S2(0,scOld_POPfRAMEdETACH)

                +S3(0.0,scOld_mmLINEeNDtO,0.0)
                +S2(0,scOld_cOVERRIDEnEXTsTROKE)
                +S3(4,scOld_ccPUSHoVERRIDEnOTEnOTE,5)
                +S2(0,scOld_POPiF)
                    +S2(0,scOld_POPiF)
                        +S2(0,scOld_POPiF)
                            +S2(0,scOld_POPiF)
                                +S3(1.0,scOld_mmLINEtO,0.0)
                            +S3(6,scOld_cmIFnOTElITERALnOTlESStHAN,4.0)
                            +S3(1.0,scOld_mmLINEtO,1.0)
                        +S3(6,scOld_cmIFnOTElITERALnOTlESStHAN,3.0)
                        +S3(0.0,scOld_mmLINEtO,1.0)
                    +S3(6,scOld_cmIFnOTElITERALnOTlESStHAN,2.0)
                    +S3(0.0,scOld_mmLINEtO,0.0)
                +S3(6,scOld_cmIFnOTElITERALnOTlESStHAN,1.0)
        
                +S3(0.5,scOld_mmMOVEtO,0.0)

            +S2(0,scOld_FRAMEdETACH)
            +S2(0,scOld_POPnOTESoNoFF)
            +S3(prFoo[off],scOld_mmRADIAL,rReachP)
            +S2(0,scOld_NOTESoN)
            +S2(pmRgb[off%6],scOld_cPUSHcOLOR)
            T("")
            //STROKE A SQUARC

        ppvtClockP[ offo ++ ]->setF( tinP ,
    {
    for( countT off = idWothP - 1 ; off < idLath ; off ++ )
    ZE( countT , offo ) ;

    const measureT pmRgb[] = { ifcRGB_P4 , ifcRGB_P4 , ifcRGB_Y4 , ifcRGB_Y4 , ifcRGB_C4 , ifcRGB_C4 } ;

    TIMEpARTSrELaRRAY( Foo , time1P , time2P )

    }
        }
            pvtHintP->setF( tinP , T("")+S3(1.0,scOld_mmFRAMEtO,1.0)/*+S3(1.0,scOld_mmPADfORsADAMfRAMES,0.0)*/+S3(mFrames,scOld_mmFRAMEcELLS,(measureT)1.0)+tHint+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME) ) ;
            strokeS::renderSizeIF( tinP , etherP , tHint , mCols , mPads , mFrames ) ;
            ZE( measureT , mFrames ) ;
            ZE( measureT , mPads ) ;
            ZE( measureT , mCols ) ;
        {
    
        }
            }
                }
                    offPush ++ ;
                    }
                        case 2 : { *(measureT*)&psttHint[ CSpREFIX + off ].idAdam = ifcRGB_C4 ; break ; }
                        case 1 : { *(measureT*)&psttHint[ CSpREFIX + off ].idAdam = ifcRGB_Y4 ; break ; }
                        case 0 : { *(measureT*)&psttHint[ CSpREFIX + off ].idAdam = ifcRGB_P4 ; break ; }
                    {
                    switch( offPush / 2 % 3 )
                {
                if( psttHint[ CSpREFIX + off ].idCaste == scOld_cPUSHcOLOR )
            {
            for( countT off = 0 ; off < csttHint ; off ++ )
            countT offPush = idWothP ? idWothP - 1 : 0 ;
            countT   csttHint = psttHint->idAdam ;
            strokeS* psttHint = tHint ;
        {
    
        TN( tHint , "" ) ; tHint = T("")+S2(ifcRGB_W4,scOld_cPUSHcOLOR)+textC(time1P,time2P,tinP,TAG(TAGiDnULL),flFORMAT_null,idWothP,idLath,S1C('.'),T(" ")+S2(0,scOld_POPcOLOR)+S2(ifcRGB_W4,scOld_cPUSHcOLOR),ifcIDfORMATtIME_TEXT)+S2(0,scOld_POPcOLOR) ;
    {
    if( pvtHintP )

    countT idLath = idWothP - 1 + cpvtClockP - !!psttLabelP ;
    if( !idWothP ) idWothP = 0x5 ;
{
voidT setClockHandsF( tinS& tinP , etherC& etherP , vTextC** ppvtClockP , const countT cpvtClockP , vTextC* const pvtHintP , countT time1P , sCountT time2P , const measureT rReachP , const strokeS* const psttLabelP , countT idWothP )

}
    return csNeeded ;

    }
        while( cToDo -- ) etherP.strFuseF( tinP , psttP , tn+S2(0,scOld_POPfRAME) ) ;
        countT cToDo = 1 + cpvtClockP ;

        for( countT off = 0 ; off < cpvtClockP ; off ++ ) etherP.strFuseF( tinP , psttP , tn+S2(0,scOld_FRAMEdETACH)+*ppvtClockP[off]+S3(rShrinkP,scOld_mmMOVEtO,rShrinkP)+S2(0,scOld_POPfRAMEdETACH)+S3(rShrinkTo,scOld_mmFRAMEtO,rShrinkTo) ) ;
    
        etherP.strFuseF( tinP , psttP , tn+S3(1.0,scOld_mmFRAMEtO,1.0) , csNeeded - 1 ) ;
        TN( tn , "" ) ;
        const measureT rShrinkTo = 1.0 - rShrinkP ;
    {
    if( ppvtClockP )
    const countT csNeeded =  2 + cpvtClockP * 7 ;

    //LOGrAW( T("rShrinkP: ")+TF1(rShrinkP)+T("\r\n") ) ; //U::
{
countT clockPhraseF( tinS& tinP , etherC& etherP , strokeS*& psttP , vTextC** const ppvtClockP , const countT cpvtClockP , const measureT rShrinkP )

}
    etherP.delF( tinP , pSee ) ;
    }
        //paramP.win.baton.ungrabF( tinP ) ;
    
        }
            etherP.strokeF( tinP , T("\r\n") ) ;
    
            }
                etherP.delF( tinP , psttw ) ;
                }
                    etherP.delF( tinP , psttSay ) ;
                    paramP.pptcView[ offb ]->setF( tinP , T("")+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(mCs,scOld_mmFRAMEcELLS,(measureT)1.0)+T(psttSay)+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME) ) ;
                    measureT mCs = squeezeF( tinP , etherP , psttSay , psttw , 0x10 ) ; ___( psttSay ) ;
                    ZE( strokeS* , psttSay ) ;
                {
                else
                if( bMale ) paramP.pptcView[ offb ]->setF( tinP , T("")+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(24.0,scOld_mmFRAMEcELLS,8.0)+S2(0,scOld_WRAPoN)+T(psttw)+S2(0,scOld_WRAPoFF)+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME) ) ;
                etherP.strDecodeF( tinP , psttw , (byteT*)pSee[offb].c2 ) ; ___( psttw ) ;
                ZE( strokeS* , psttw ) ;
            {
            else
            if( F(pSee[offb].c1) & flBRANCHs_MISSING ) paramP.pptcView[ offb ]->setF( tinP , tn ) ;
    
            countT cBelow = offu * cAtLevel ;
    
            boolT  bMale = paramP.cDown == - 1 ? 1 : offu % 2 ; //U::KLUDGE TO GET HUGE TO WORK
            countT offr = offb % cAtLevel ;
            countT offu = offb / cAtLevel ;
        {
        for( countT offb = 0 ; offb < cSee ; offb ++ )
    
        //paramP.win.baton.grabF( tinP , TAG( TAGiDnULL ) ) ; //TO PREVENT POSSIBLE RENDERING OF A VOLATILE IN A NEW BRANCH BEFORE IT IS ERASED IN THE OLD BRANCH
        const countT cAtLevel = 1 + paramP.cLeft + paramP.cRight ;
    {
    if( pSee ) //TEST ADDED WITHOUT ANALYSIS

    paramP.treeKt.lookF( tinP , pSee , cSee , paramP.cDown , paramP.cUp , paramP.cLeft , paramP.cRight ) ; ___( pSee ) ;
    ZE( countT , cSee ) ;
    ZE( count2S* , pSee ) ;//U::O: PREALLOCATE THIS WHEN CHANGE SIZE
    TN( tn , "" ) ;

    ARGgET( cArgP )
{
voidT freshViewOfBranchesF( tinS& tinP , etherC& etherP , countT cArgP )

}
    ;
    
        S2(0,scOld_POPfRAME)
            S2(0,scOld_POPfRAME)+
                S2(0,scOld_POPfRAME)+
                    S2(0,scOld_POPfRAME)+
                        S2((countT)animateHoverPadCBF,scOld_cANIMATEcBF)+
                        paramP.buHoverPad+
                        S3(4.0,scOld_mmMOVEpEL,-4.0)+
                    S3(0.4,scOld_mmFRAMEtO,0.3)+
                    S2(0,scOld_POPfRAMEdETACH)+
                    S3(0.0,scOld_mmMOVEtO,0.2)+
                    S2(0,scOld_FRAMEdETACH)+
                    S2(0,scOld_POPfRAME)+
                        paramP.vtHint+
                    S3(1.0,scOld_mmFRAMEtO,0.95)+
                    S2(0,scOld_POPfRAMEdETACH)+
                    S3(0.0,scOld_mmMOVEtO,1.0)+
                    S2(0,scOld_FRAMEdETACH)+
                S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+
            S3(1.0,scOld_mmFRAMEtO,1.0)+
            S2(0,scOld_POPfRAME)+
                S2((countT)animateViewsCBF,scOld_cANIMATEcBF)+
                paramP.vtView+
            S3(1.0,scOld_mmFRAMEtO,1.0)+
        S3(1.0,scOld_mmFRAMEtO,1.0)+
        T("\f")+
    
    tP =

    }
        csShort = mFrames ;
        strokeS::renderSizeIF( tinP , etherP , tNameShort , mCols , mPads , mFrames ) ;
        ZE( measureT , mFrames ) ;
        ZE( measureT , mPads ) ;
        ZE( measureT , mCols ) ;
    {
    ZE( countT , csShort ) ;
    
    setTmShortF( tinP , tNameShort ) ;
    TN( tNameShort , "" ) ;
    
    }
        csLong = mFrames ;
        strokeS::renderSizeIF( tinP , etherP , tNameLong , mCols , mPads , mFrames ) ;
        ZE( measureT , mFrames ) ;
        ZE( measureT , mPads ) ;
        ZE( measureT , mCols ) ;
    {
    ZE( countT , csLong ) ;

    hintF( tinP , etherP , cArgP , paramP.tHintDefault , 0 , flHINT_EVENiFfULLsCREEN ) ;
    paramP.tHintDefault = T("") ;
    
    setTmLongF( tinP , tNameLong ) ;
    TN( tNameLong , "" ) ;

    ARGgET( cArgP )
{
voidT setFullScreenConsoleF( tinS& tinP , etherC& etherP , textC& tP , const countT cArgP )

}
    ;
    
        S2(0,scOld_POPfRAME)
            S2(0,scOld_POPfRAME)+
                S2((countT)animateViewsCBF,scOld_cANIMATEcBF)+
                paramP.vtView+
                S2(0,scOld_POPoFFfRAME)+
                S3(1.0,scOld_mmFRAMEtO,1.0)+
                S2(1,scOld_cPUSHoFFfRAME)+
                T("\r\n")+
                paramP.vtButtons+
                T("\r\n")+
                paramP.vtHint+
            S3(1.0,scOld_mmFRAMEcELLS,16.0)+
        S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+
        T("\f")+
    
    tP =

    }
        csShort = mFrames ;
        strokeS::renderSizeIF( tinP , etherP , tNameShort , mCols , mPads , mFrames ) ;
        ZE( measureT , mFrames ) ;
        ZE( measureT , mPads ) ;
        ZE( measureT , mCols ) ;
    {
    ZE( countT , csShort ) ;
    
    setTmShortF( tinP , tNameShort ) ;
    TN( tNameShort , "" ) ;
    
    }
        csLong = mFrames ;
        strokeS::renderSizeIF( tinP , etherP , tNameLong , mCols , mPads , mFrames ) ;
        ZE( measureT , mFrames ) ;
        ZE( measureT , mPads ) ;
        ZE( measureT , mCols ) ;
    {
    ZE( countT , csLong ) ;

    hintF( tinP , etherP , cArgP , paramP.tHintDefault , 0 ) ;
    paramP.tHintDefault = tNameLong ;
    
    setTmLongF( tinP , tNameLong ) ;
    TN( tNameLong , "" ) ;

    ARGgET( cArgP )
{
voidT setConsoleF( tinS& tinP , etherC& etherP , textC& tP , const countT cArgP )

}
    paramP.idFloor = idFloorP ;

    }
        }
            break ;
            replaceButtonsF( tinP , etherP , cArgP , tButtons , CSTTmINbUTTONS ) ;

            etherP.strMakeF( tinP , LF , paramP.psttHintEscape , T("escape (to confidential disclosure)") ) ; ___( paramP.psttHintEscape ) ;
            etherP.delF( tinP , paramP.psttHintEscape ) ;

            if(      paramP.treeKt.rightF( 1 , 1 ) ) tButtons += T(" ")+paramP.buClimbRight ;
            if(      paramP.treeKt.leftF(  1 , 1 ) ) tButtons += T(" ")+paramP.buClimbLeft  ;
            if( 2 == paramP.treeKt.upF(    2 , 1 ) ) tButtons += T(" ")+paramP.buClimbUp    ;
            if( 2 == paramP.treeKt.downF(  2 , 1 ) ) tButtons += T(" ")+paramP.buClimbDown  ;
            TN( tButtons , "" ) ; tButtons = paramP.buEscape+T(" ")+paramP.buF1/*+T(" ")+paramP.buF2*/+T(" ")+paramP.buSubscribe ;
            hintF( tinP , etherP , cArgP , T("this is the IPDOS (tm) operator interface") ) ;
        {
        case ifcIDfLOOR_CONSOLE :
        }
            break ;
            loadSpeechF( tinP , etherP , cArgP , ifcIDsPEECH_FLOORdISCLOSURE ) ;
            replaceButtonsF( tinP , etherP , cArgP , paramP.buEscape+T(" ")+paramP.buSubscribe+T(" ")+paramP.buIntro+T(" ")+paramP.buCredits+T(" ")+paramP.buSermon+T(" ")+paramP.buConsole , CSTTmINbUTTONS ) ;

            etherP.strMakeF( tinP , LF , paramP.psttHintEscape , T("escape (to list of authorized users)") ) ; ___( paramP.psttHintEscape ) ;
            etherP.delF( tinP , paramP.psttHintEscape ) ;

            }
                etherP.strokeF( tinP , T("\f")+tBanner ) ;
                //etherP.strokeF( tinP , T("\f")+S3(16.0,scOld_mmFRAMEcELLS,(measureT)1.0)+T("Fooey")+S2(0,scOld_POPfRAME)/*U::tBanner*/ ) ;
                TN( tBanner , "" ) ; setBannerF( tinP , etherP , tBanner , cArgP ) ;
                etherP.delF( tinP , paramP.psttLabelRemaining ) ;
                paramP.rReachRemaining = 1.0 / 128.0 ;
            {
            if( F(flagsP) & flSETfLOOR_ESCAPE )
            hintF( tinP , etherP , cArgP , T("the disclosure will begin in a moment") ) ;
        {
        case ifcIDfLOOR_DISCLOSURE :
        }
            break ;
            replaceButtonsF( tinP , etherP , cArgP , paramP.buEscape+T(" ")+paramP.prPrompt , CSTTmINbUTTONS ) ;
            loadSpeechF( tinP , etherP , cArgP , ifcIDsPEECH_FLOORsECRET ) ;
            hintF( tinP , etherP , cArgP , T("instructions for entering the gate key will appear in a moment") ) ;

            etherP.strMakeF( tinP , LF , paramP.psttHintEscape , T("escape (to list of authorized users)") ) ; ___( paramP.psttHintEscape ) ;
            etherP.delF( tinP , paramP.psttHintEscape ) ;
        {
        case ifcIDfLOOR_PROMPTfORsECRET :
        }
            break ;
            etherP.osThreadF( TaRG1( tmSetFloorUsersF ) , cArgP ) ;
            loadSpeechF( tinP , etherP , cArgP , ifcIDsPEECH_FLOORuSERS ) ;
            hintF( tinP , etherP , cArgP , T("instructions for identifying yourself will appear in a moment") ) ;
        {
        case ifcIDfLOOR_USERS :
        }
            break ;
            replaceButtonsF( tinP , etherP , cArgP , paramP.buEscape+T(" ")+paramP.buIntro+T(" ")+paramP.buCredits+T(" ")+paramP.buSermon+T(" ")+paramP.buGate , CSTTmINbUTTONS ) ;
            loadSpeechF( tinP , etherP , cArgP , ifcIDsPEECH_FLOORbANNER ) ;

            etherP.strMakeF( tinP , LF , paramP.psttHintEscape , T("escape (to base operating system operator's console)") ) ; ___( paramP.psttHintEscape ) ;
            etherP.delF( tinP , paramP.psttHintEscape ) ;

            }
                etherP.strokeF( tinP , T("\f")+tBanner ) ;
                TN( tBanner , "" ) ; setBannerF( tinP , etherP , tBanner , cArgP ) ; //PRODUCTION
                //TN( tBanner , "" ) ; setConsoleF( tinP , etherP , tBanner , cArgP ) ; //TESTING
            {
            else
            if( F(flagsP) & flSETfLOOR_ESCAPE ) paramP.bQuitTmUsers = 1 ;

            hintF( tinP , etherP , cArgP , paramP.tHintDefault ) ;
        {
        case ifcIDfLOOR_BANNER :
    {
    switch( idFloorP )

    }
        if( idFloorP == ifcIDfLOOR_PROMPTfORsECRET ) idFloorP -- ;
        idFloorP = paramP.idFloor - 1 ;
        if( idFloorP || paramP.idFloor <= ifcIDfLOOR_BANNER ) { BLAMMO ; }
    {
    if( F(flagsP) & flSETfLOOR_ESCAPE )

    if( paramP.idFloor == ifcIDfLOOR_USERS ) paramP.bQuitTmUsers = 1 ;

    ARGgET( cArgP )
{
voidT setFloorF( tinS& tinP , etherC& etherP , const countT cArgP , countT idFloorP , const flagsT flagsP )

}
    ;
    
        //S2(0,scOld_RENDERfLAGScONTROLpOP)+
        //S2(0,scOld_RENDERpADrIGHTpOP)+
        S2(0,scOld_POPcOLOR)
        T("-DOS")+
        S2(0,scOld_POPfRAME)+
            S2(saA1_TRADEmARK,sc_cALPHABET1)+
        S3(0.6,scOld_mmFRAMEtO,0.2)+
        S2(0,scOld_POPfRAMEdETACH)+
            S3(0.4,scOld_mmMOVEtO,0.0)+
        S2(0,scOld_FRAMEdETACH)+
        T("IP")+
        S2(ifcRGB_CYAN,scOld_cPUSHcOLOR)+
        //S2(8.0,scOld_mRENDERpADrIGHTpUSH)+
        //,scOld_cRENDERfLAGScONTROLpUSH)+
        //    flRENDERcONTROL_PADrIGHT
        //S2(
        T("")+
    
    tP =
{
voidT setTmShortF( tinS& tinP , textC& tP )

}
    ;
    
        S2(0,scOld_POPcOLOR)
        T("   Piggyback Distributed Operating System")+
        S2(ifcRGB_BROWN,scOld_cPUSHcOLOR)+
        S2(0,scOld_POPcOLOR)+
        S2(0,scOld_POPfRAME)+
            S2(saA1_TRADEmARK,sc_cALPHABET1)+
        S3(2.0,scOld_mmFRAMEtO,0.25)+
        T("IdeaFarm")+
        S2(ifcRGB_CYAN,scOld_cPUSHcOLOR)+
        T("")+
    
    tP =
{
voidT setTmLongF( tinS& tinP , textC& tP )

}
    etherP.delF( tinP , psttOldClock ) ;
    ;
    
        S2(0,scOld_POPfRAME)
            S2(0,scOld_POPfRAME)+
                S2(0,scOld_POPfRAME)+
                    S2(0,scOld_POPfRAME)+
                        S2(0,scOld_POPfRAME)+
                            S2(0,scOld_POPfRAME)+
                                S2(0,scOld_POPfRAME)+
                                    tNameShort+
                                S3((measureT)csShort,scOld_mmFRAMEcELLS,(measureT)1.0)+
                                //S3(8.0,scOld_mmPADfORsADAMfRAMES,8.0)+
                            S3(1.0,scOld_mmFRAMEtO,1.0)+             //SHORT NAME FRAME
                            S2(0,scOld_POPfRAMEdETACH)+
                                S3(0.0,scOld_mmMOVEtO,0.8)+
                            S2(0,scOld_FRAMEdETACH)+
                            S2(0,scOld_POPfRAME)+
                                S2(0,scOld_POPcOLOR)+
                                S2((countT)animateSpeechCBF,scOld_cANIMATEcBF)+
                                paramP.vtSpeech+
                                S2(ifcRGB_W4,scOld_cPUSHcOLOR)+
                            S3(1.0,scOld_mmFRAMEtO,0.55)+             //MIDDLE BLOCK FRAME
                            S2(0,scOld_POPfRAMEdETACH)+
                                S3(0.0,scOld_mmMOVEtO,0.45)+
                            S2(0,scOld_FRAMEdETACH)+
                            S2(0,scOld_POPfRAME)+
                                paramP.vtSlidesRemaining+
                            S3(0.05,scOld_mmFRAMEtO,0.43)+             //SLIDES REMAINING COUNTER
                            S2(0,scOld_POPfRAMEdETACH)+
                                S3(0.0,scOld_mmMOVEtO,0.38)+
                            S2(0,scOld_FRAMEdETACH)+
                            S2(0,scOld_POPfRAME)+
                                S2(0,scOld_POPfRAME)+
                                    tNameLong+
                                S3((measureT)csLong,scOld_mmFRAMEcELLS,(measureT)1.0)+
                            S3(1.0,scOld_mmFRAMEtO,0.2)+             //LONG NAME FRAME
                        S3(0.95,scOld_mmFRAMEtO,0.95)+               //NET CONTENT FRAME (ALL CONTENT ABOVE BUTTONS)
                        S2(0,scOld_POPfRAMEdETACH)+
                            S3(0.05,scOld_mmMOVEtO,0.05)+
                        S2(0,scOld_FRAMEdETACH)+
                        S2(0,scOld_POPoFFfRAME)+
                    S3(1.0,scOld_mmFRAMEtO,1.0)+
                    S2(1,scOld_cPUSHoFFfRAME)+
                    T("\r\n")+
                S3(32.0,scOld_mmFRAMEcELLS,16.0)+
                S2(0,scOld_POPfRAME)+
                    paramP.vtButtons+
                    T("\r\n")+
                    paramP.vtHint+
                S3(1.0,scOld_mmFRAMEcELLS,16.0)+
            S3(rsbr,scOld_mmFRAMEtO,rsbr)+
            S2(0,scOld_POPfRAMEdETACH)+
                S3(rsb,scOld_mmMOVEtO,rsb)+
                S2((countT)animateClockBannerCBF,scOld_cANIMATEcBF)+
                T(psttOldClock)+
                S2(0,scOld_POPfRAME)+
                    paramP.buClockBanner+
                S3(1.0,scOld_mmFRAMEtO,1.0)+
            S2(0,scOld_FRAMEdETACH)+
        S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+
        T("")+
    
    tP =
    const measureT rsbr = 1.0 - rsb ;
    const measureT rsb  = 0.10 ;

    clockPhraseF( tinP , etherP , psttOldClock , paramP.ppvtClockBanner , paramP.cpvtClockBanner , 1.0 / 128.0 ) ;
    ZE( strokeS* , psttOldClock ) ;

    }
        csShort = mFrames ;
        strokeS::renderSizeIF( tinP , etherP , tNameShort , mCols , mPads , mFrames ) ;
        ZE( measureT , mFrames ) ;
        ZE( measureT , mPads ) ;
        ZE( measureT , mCols ) ;
    {
    ZE( countT , csShort ) ;
    
    setTmShortF( tinP , tNameShort ) ;
    TN( tNameShort , "" ) ;
    
    }
        csLong = mFrames ;
        strokeS::renderSizeIF( tinP , etherP , tNameLong , mCols , mPads , mFrames ) ;
        ZE( measureT , mFrames ) ;
        ZE( measureT , mPads ) ;
        ZE( measureT , mCols ) ;
    {
    ZE( countT , csLong ) ;
    
    setTmLongF( tinP , tNameLong ) ;
    TN( tNameLong , "" ) ;

    ARGgET( cArgP )
{
voidT setBannerF( tinS& tinP , etherC& etherP , textC& tP , const countT cArgP )

}
    stSpeechP << (byteT*)&c3p ;
    count3S c3p( (countT)psttw , (countT)pstth , timeHint1P ) ; pstth = psttw = 0 ;

    if( psttHintP ) { etherP.strMakeF( tinP , LF , pstth , psttHintP ) ; ___( pstth ) ; }
    ZE( strokeS* , pstth ) ;
    squeezeF( tinP , etherP , psttw , psttP , CSTTmINsPEAK ) ; ___( psttw ) ;
    ZE( strokeS* , psttw ) ;
{
voidT speakF( tinS& tinP , etherC& etherP , stackC& stSpeechP , const strokeS* const psttP , const strokeS* const psttHintP , const countT timeHint1P )

}
    }
        }
            etherP.delF( tinP , psttw ) ;
    
            else                               paramP.vtHint.setF( tinP , T("")                       +S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(mCs,scOld_mmFRAMEcELLS,(measureT)1.0)+T(psttw)+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME)                         ) ;
            if( ( F(flagsP) & flHINT_TRACE ) ) paramP.vtHint.setF( tinP , T("")+S2(0,scOld_TRACEoN)+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(mCs,scOld_mmFRAMEcELLS,(measureT)1.0)+T(psttw)+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME)+S2(0,scOld_TRACEoFF) ) ;
            //CODEsYNC: 4650104 4650104
    
            measureT mCs = squeezeF( tinP , etherP , psttw , psttP , CSTTmINhINT ) ; ___( psttw ) ;
            ZE( strokeS* , psttw ) ;
        
            }
                etherP.osTimeAddF( tinP , paramP.timeHintExpires1 , paramP.timeHintExpires2 , time1P ) ;
                etherP.osTimeNowF( tinP , paramP.timeHintExpires1 , paramP.timeHintExpires2 ) ; //U::SERIALIZE TO AVOID ANOTHER THREAD SETTING A VALUE AND MAKING ME FAIL
            {
            if( time1P )
            paramP.timeHintExpires2 = paramP.timeHintExpires1 = 0 ;
        {
        if( bDo )
    
        }
            etherP.delF( tinP , psttv ) ;
    
            bDo = 4 == etherP.strIdF( tinP , paramP.tHintDefault , psttv ) ;        //CODEsYNC: 4650104 4650104
            //IT CAN BE FIXED BY USING SUBSTRING TO RETRIEVE psttw FROM psttv
            //THIS IS NOT AS OF THIS WRITING A CONCERN
            //WILL MISTAKENLY SET bDo IF NONDEFAULT HINT BEGINS WITH THE DEFAULT HINT
    
            paramP.vtHint.getF( tinP , psttv ) ; ___( psttv ) ;
            ZE( strokeS* , psttv ) ;
        {
        if( !bDo )
        boolT bDo = !( F(flagsP) & flHINT_IFdEFAULT ) ;
    {
    if( !( F(paramP.flags) & flPARAM_FULLsCREEN ) || F(flagsP) & flHINT_EVENiFfULLsCREEN )

    ARGgET( cArgP )
{
voidT hintF( tinS& tinP , etherC& etherP , const countT cArgP , const strokeS* const psttP , const countT time1P , const flagsT flagsP )

}
    hintF( tinP , etherP , cArgP , tSay , 0 ) ;

    ;

        +S2(0,scOld_POPcOLOR)
        +S2(saA1_TOOLPAGEuP,sc_cALPHABET1)
        +TF1(angt)
        +S2(saA1_TOOLPAGEdOWN,sc_cALPHABET1)
        +S2(ifcRGB_B4,scOld_cPUSHcOLOR)
        +tb
        +S2(0,scOld_POPcOLOR)
        +S2(saA1_TOOLUP,sc_cALPHABET1)
        +TF1(angv)
        +S2(saA1_TOOLDOWN,sc_cALPHABET1)
        +S2(ifcRGB_G4,scOld_cPUSHcOLOR)
        +tb
        +S2(0,scOld_POPcOLOR)
        +S2(saA1_TOOLRIGHT,sc_cALPHABET1)
        +TF1(angh)
        +S2(saA1_TOOLLEFT,sc_cALPHABET1)
        +S2(ifcRGB_R4,scOld_cPUSHcOLOR)
        +T(") ")
        +TF1(paramP.zHullAt)
        +tc
        +TF1(paramP.yHullAt)
        +tc
        +TF1(paramP.xHullAt)
        T("(")

    TN( tSay , "" ) ; tSay =
    TN( tc , "," ) ;
    TN( tb , " " ) ;
    TN( tn , "" ) ;

    measureT angt = - 1.0 + 2.0 * paramP.offHullAimtTick / paramP.cHullAimtTicks ;
    measureT angv = - 1.0 + 2.0 * paramP.offHullAimvTick / paramP.cHullAimvTicks ;
    measureT angh = - 1.0 + 2.0 * paramP.offHullAimhTick / paramP.cHullAimhTicks ;

    ARGgET( cArgP )
{
voidT hintEyeF( tinS& tinP , etherC& etherP , const countT cArgP )

}
    etherP.delF( tinP , psttwp ) ;
    etherP.delF( tinP , psttw ) ;
    paramP.vtButtonsPad.setF( tinP , T("")+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(mCsp,scOld_mmFRAMEcELLS,(measureT)1.0)+T(psttwp)+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME) ) ;
    paramP.vtButtons.setF(    tinP , T("")+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(mCs,scOld_mmFRAMEcELLS,(measureT)1.0)+T(psttw)+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME) ) ;
    measureT mCsp = squeezeF( tinP , etherP , psttwp , bList.psttButtons , 0             ) ; ___( psttwp ) ;
    measureT mCs  = squeezeF( tinP , etherP , psttw  , bList.psttButtons , bList.csttMin ) ; ___( psttw  ) ;
    ZE( strokeS* , psttwp ) ;
    ZE( strokeS* , psttw ) ;  

    buttonListS& bList = *(buttonListS*)&paramP.stButtonList[ 0 ] ;

    ARGgET( cArgP )
{
voidT vtButtonsF( tinS& tinP , etherC& etherP , const countT cArgP )

}
    return mFrames + 2 * tPad.csF( tinP ) ;

    etherP.strMakeF( tinP , LF , psttOutP , tPad+T(psttInP)+tPad ) ; ___( psttOutP ) ;
    textC tPad( tinP , TAG( TAGiDnULL ) , flTEXTc_null , "" , cNeeded2 ) ;
    countT cNeeded2 = cNeeded - cNeeded1 ;
    countT cNeeded1 = cNeeded / 2 ;
    countT cNeeded = mFrames < csttMinP ? csttMinP - mFrames : 0 ;
    strokeS::renderSizeIF( tinP , etherP , psttInP , mCols , mPads , mFrames ) ;
    ZE( measureT , mFrames ) ;
    ZE( measureT , mPads ) ;
    ZE( measureT , mCols ) ;
{
countT squeezeF( tinS& tinP , etherC& etherP , strokeS*& psttOutP , const strokeS* const psttInP , const countT csttMinP )

}
    paramP.stSpeech.ungrabF( tinP ) ;
    }
        etherP.delF( tinP , *(strokeS**)&c3p.c2 ) ;
        etherP.delF( tinP , *(strokeS**)&c3p.c1 ) ;
        paramP.stSpeech >> pb_c3p ;
        byteT* pb_c3p = (byteT*)&c3p ;
        count3S c3p ;
    {
    while( paramP.stSpeech )
    paramP.stSpeech.grabF( tinP , TAG( TAGiDnULL ) ) ;
    ARGgET( cArgP )
{
voidT purgeSpeechF( tinS& tinP , etherC& etherP , const countT cArgP )

}
    ++ s ; etherP.osSleepF( tinP , time1P ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{
voidT napF( tinS& tinP , etherC& etherP , const countT time1P )

}
    paramP.win.filterGrabMouseF( tinP , paramP.vtEye.idAdamF( tinP ) , F(paramP.flags) & flPARAM_EYEbUTTONSrENDERED && F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) ;
    //THE OLD SYSTEM CODE WORKED, BUT I DON'T KNOW WHY IT WORKED; c1 WAS NEVER USED
    //FILTER SYSTEM CODE WAS EDITED TO FILTER ON idAdam; THIS HAS NOT BEEN TESTED FOR THIS OR ANY OTHER APPLICATION CODE
    ARGgET( cArgP )
{
voidT filterGrabMouseF( tinS& tinP , const countT cArgP )

#include postHEADER

/*1*//*miscellaneous functions*//*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

