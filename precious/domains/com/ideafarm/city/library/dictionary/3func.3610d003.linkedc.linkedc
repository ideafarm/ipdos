
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    //}
    //    CONoUTrAW3( "\r\nlinkedC::linkedC for _handleC_linked_sm [idGrabLayerP]: " , idGrabLayerP , "\r\n" ) ;
    //{
    //if( this == &processGlobal3I._handleC_linked_sm )








































    putNegAM( finger , FINGERnEG_LINKEDc ) ;

    _INoLD_
{
idAdam( tinP.pAdamGlobal1->idAdam )
pKid( 0 ) ,
root( *this ) ,
idType( idTypeP ) ,
grabotC( tinP , idLineCtP , idiFileCtP , pbBitsCtP , this == &processGlobal3I._handleC_linked_sm ? flGRABITc_SHARElAYER | flGRABITc_SNEAKYlOVER : flGRABITc_SHARElAYER , 0 , idGrabLayerP ) ,
/*1*/linkedC::linkedC( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const countT idTypeP , const countT idGrabLayerP ) :/*1*/

/**/

*/
 idGrabLayerP
  application code can specify a unique idType value so that it can identify the derived class when walking heterogeneous linked instances
  normally 0
  for application use
 idTypeP
 pbBitsCtP
 idiFileCtP
 idLineCtP
 tinP
parameters
my idTypeP and idGrabLayerP are copied into each instance linked to me
the root has no application data associated with it
i am only for ct'ing the root of a linked list
 the root should not be of a derived type
it is illegal to use this ct'or to ct a derived class instance
use me to ct a root instance
/*

/*1*/WAKEsHOWtEXT( "scratch" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

