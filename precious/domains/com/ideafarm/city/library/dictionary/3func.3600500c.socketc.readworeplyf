
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

#endif

}
    return replyCode ;
    dec02AM( cFunctionsPending ) ;
    }
        _OUT_
    
        tinP.pAdamGlobal3->_socketC_.grab.ungrabF( tinP ) ;
        pOdometer->cbWrite += tinP.odoSockCbWrite - _odoSockCbWriteOpen ;
        pOdometer->cbRead  += tinP.odoSockCbRead  - _odoSockCbReadOpen  ;
        pOdometer = (sockOdometerS*)&(countT&)*tinP.pAdamGlobal3->_socketC_.pSwOdometer ;
        tinP.pAdamGlobal3->_socketC_.nnLever = nnPeer ;
        tinP.pAdamGlobal3->_socketC_.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        bRead.ungrabF( tinP ) ;
    
        if( idleTimeAllowedRead ) FRESHtIMEaTOMIC( *pEther , timeLathRead.time1 , timeLathRead.time2 )

        }
            pEther->delF( tinP , postLine ) ;

            }
                }
                    }
                        break ;
                        replyCode = pEther->strDigitsToSCountF( tinP , T(postLine) , 0xa , 1 ) ;
                        postLine[ 3 ] = 0 ;
                    {
                    if( postLine[ 3 ] == ' ' )

                    offo = 0 ;
                    pEther->strFuseF( tinP , psttP , T(postLine) ) ;
                    postLine[ offo ] = 0 ;
                {
                if( postLine[ offo - 1 ] == '\n' )

                postLine[ offo ++ ] = pbIn[ 0 ] ;

                //CONoUTrAW( "\r\n" ) ;
                //CONoUTrAW( pbIn ) ; //U::
                //CONoUTrAW3( "" , *pbIn , "    " ) ; //U::
                //CONoUTrAW( "[char]:    " ) ;
                readF( tinP , pbIn , 1 ) ;
                byteT pbIn[] = { 0 , 0 } ;
            {
            while( !POOP )
            ZE( countT , offo ) ;

            pEther->newF( tinP , LF , postLine , csttEstimateP ) ; ___( postLine ) ;
            ZE( osTextT* , postLine ) ;
        {

        pEther->strMakeF( tinP , psttP , 0 , csttEstimateP ) ; ___( psttP ) ;

        if( !csttEstimateP ) csttEstimateP = 0x100 ;

        _INoLD_

        bRead.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        const countT _odoSockCbWriteOpen = tinP.odoSockCbWrite ;
        const countT _odoSockCbReadOpen  = tinP.odoSockCbRead  ;
    
        }
            }
                return 0 ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
            __NZ( psttP ) ;
            }
                return 0 ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL    
        SCOOPP
    {
    ZE( countT , replyCode ) ;
    inc02AM( cFunctionsPending ) ;
{
/*1*/countT socketC::readWoReplyF( tinS& tinP , strokeS*& psttP , countT csttEstimateP )/*1*/


#else

}
    return replyCode ;
    dec02AM( cFunctionsPending ) ;
    }
        _OUT_
    
        tinP.pAdamGlobal3->_socketC_.grab.ungrabF( tinP ) ;
        pOdometer->cbWrite += tinP.odoSockCbWrite - _odoSockCbWriteOpen ;
        pOdometer->cbRead  += tinP.odoSockCbRead  - _odoSockCbReadOpen  ;
        pOdometer = (sockOdometerS*)&(countT&)*tinP.pAdamGlobal3->_socketC_.pSwOdometer ;
        tinP.pAdamGlobal3->_socketC_.nnLever = nnPeer ;
        tinP.pAdamGlobal3->_socketC_.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        bRead.ungrabF( tinP ) ;
    
        if( idleTimeAllowedRead ) FRESHtIMEaTOMIC( *pEther , timeLathRead.time1 , timeLathRead.time2 )

        CONoUTrAW( "\r\nout of loop\r\n" ) ;
    
        }
            }
                }
                    if( fBegin && !psttDash[ CSpREFIX ] ) break ;
                    fBegin = *pbIn == '\n' ;
                    pEther->strFuseF( tinP , psttP , T(pbIn) , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ csttEstimateP ) ; ___( psttP ) ;
                {
                if( !*pEther )
                CONoUTrAW( pbIn ) ; //U::
                readF( tinP , pbIn , 1 ) ;
                byteT pbIn[] = { 0 , 0 } ;
                CONoUTrAW( "$" ) ;
            {
            else
            }
                }
                    pEther->delF( tinP , psttFirst ) ;
    
                    }
                        }
                            if( !*pEther ) off ++ ;
                            CONoUTrAW( pbToss ) ; //U::
                            readF( tinP , pbToss , 1 ) ;
                            CONoUTrAW( "#" ) ;
                        {
                        while( !*pEther && off < 4 )
                        off = 0 ;
                        byteT pbToss[] = { 0 , 0 } ;
                        psttDash[ CSpREFIX + 3 ] = psttDash[ CSpREFIX + 2 ] = psttDash[ CSpREFIX + 1 ] = psttDash[ CSpREFIX ] = 0 ;
                    {
                    else if( !pEther->strCompareF( tinP , psttDash , psttFirst , 3 ) && (countT)psttFirst[ CSpREFIX + 3 ] == ' ' ) // TERMINATION CODE
                    }
                        }
                            if( !*pEther ) off ++ ;
                            CONoUTrAW( pbToss ) ; //U::
                            readF( tinP , pbToss , 1 ) ;
                            CONoUTrAW( "@" ) ;
                        {
                        while( !*pEther && off < 4 )
                        off = 0 ;
                        byteT pbToss[] = { 0 , 0 } ;
                    {
                    if( !pEther->strCompareF( tinP , psttDash , psttFirst , 4 ) )
    
                    pEther->strMakeF( tinP , psttFirst , T(pbFirst) ) ; ___( psttFirst ) ;
                    ZE( strokeS* , psttFirst ) ;
                    off = 4 ;
                    peekF( tinP , pbFirst , 4 ) ;
                    ZE( countT , off ) ;
                    byteT pbFirst[] = { 0 , 0 , 0 , 0 , 0 } ;
                {
                else // NEXT 4 CHARS ARE EITHER "CONTINUATION STUTTER" OR MOSTLY MATCH pbDash OR ARE MESSAGE TEXT
                }
                         psttDash[ CSpREFIX + 3 ] = psttDash[ CSpREFIX + 2 ] = psttDash[ CSpREFIX + 1 ] = psttDash[ CSpREFIX ] = 0 ;
                    if( !*pEther && psttDash[ CSpREFIX - 1 + off ] != '-' )
    
                    }
                        if( !*pEther ) psttDash[ CSpREFIX + off ++ ] = pbIn[ 0 ] ;
                        CONoUTrAW( pbIn ) ; //U::
                        readF( tinP , pbIn , 1 ) ;
                    {
                    if( !*pEther )
                    if( !*pEther ) replyCode = pEther->strDigitsToSCountF( tinP , psttDash , 0xa , 1 ) ;
                    }
                        if( !*pEther ) psttDash[ CSpREFIX + off ++ ] = pbIn[ 0 ] ;
                        CONoUTrAW( pbIn ) ; //U::
                        readF( tinP , pbIn , 1 ) ;
                        CONoUTrAW( "!" ) ;
                    {
                    while( !*pEther && off < 3 )
                    ZE( countT , off ) ;
                {
                if( !psttDash[ CSpREFIX ] ) // NEXT 3 CHARS ARE A CODE, FOLLOWED BY ' ' OR '-'
                fBegin = 0 ;
            {
            if( fBegin )
            CONoUTrAW( "." ) ;

            }
                countT foo = 2 ;
            {
            if( ++ idCycle == 7 )
        {
        while( !*pEther )
        ZE( countT , idCycle ) ;
        fBegin = 1 ;
        ZE( boolT , fBegin ) ; // AM ABOUT TO READ THE FIRST CHAR IN A LINE
        ZE( countT , fLF ) ;
        psttDash[ CSpREFIX + 3 ] = 0 ;
        psttDash[ CSpREFIX + 2 ] = 0 ;
        psttDash[ CSpREFIX + 1 ] = 0 ;
        psttDash[ CSpREFIX     ] = 0 ;
        SETpREFIX( psttDash , 4 , 0 ) ;
        strokeS psttDash[ CSpREFIX + 4 ] ;
        byteT pbIn[] = { 0 , 0 } ;
        if( !csttEstimateP ) csttEstimateP = 0x100 ;
        _INoLD_
        bRead.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        const countT _odoSockCbWriteOpen = tinP.odoSockCbWrite ;
        const countT _odoSockCbReadOpen  = tinP.odoSockCbRead  ;
    
        }
            }
                return 0 ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL    
        SCOOPP
    {
    ZE( countT , replyCode ) ;
    inc02AM( cFunctionsPending ) ;
{
/*1*/countT socketC::readWoReplyF( tinS& tinP , strokeS*& psttP , countT csttEstimateP )/*1*/

// BEFORE REWRITE (THIS CODE DOES NOT WORK; IT HANGS WHILE PROCESSING MULTILINE RESPONSE DURING SMTP INITIALIZATION)

#if defined( NEVERdEFINED )

/**/
*/
  if the actual line input is longer than this, the bad coding style condition will be set
  if 0 then 100 is implied
  can be 0
 csttEstimateP
 psttP
arguments
this function is inefficient
to be used only on a telnet protocol connection
reads a reply from the peer
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.107000d.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$readWoReplyF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

