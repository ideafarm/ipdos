
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bOk ;

    }
        pGrabHandleAll->ungrabF( tinP ) ;
        }
            bOk = 1 ;
            (nicNameC&)*pIdptHandleAll = (countT)0 ;
                       *pIdptHandleAll = (countT)0 ;
        {
        if( *pIdptHandleAll == idptMeP )
        pGrabHandleAll->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !pczChannelP )
    ZE( boolT , bOk ) ;
{
/*1*/boolT nodeOldC::handleUnregisterIF( tinS& tinP , portTimeC idptMeP , const countT* const pczChannelP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bOk ;

    }
        pGrabHandleAll->ungrabF( tinP ) ;
        }
            tinP.pEther->traceF( tinP , T("i am now the handle port for this adam [idAdam,idptHandleAll]:    ")+TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T((nicNameC&)*pIdptHandleAll)+T(" ( ")+TF2((countT)*pIdptHandleAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ;
            bOk = 1 ;
            *pIdptHandleAll = idptMeP ;
        {
        if( !*pIdptHandleAll || idptMeP - *pIdptHandleAll < 0 )
        pGrabHandleAll->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !pczChannelP )
    ZE( boolT , bOk ) ;
{
/*1*/boolT nodeOldC::handleRegisterMeIfIF( tinS& tinP , portTimeC idptMeP , const countT* const pczChannelP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bOk ;

    }
        pGrabHandleAll->ungrabF( tinP ) ;
        }
            bOk = 1 ;
            *pIdptHandleAll = idptMeP ;
        {
        if( *pIdptHandleAll == idptMeP )
        pGrabHandleAll->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !pczChannelP )
    ZE( boolT , bOk ) ;
{
/*1*/boolT nodeOldC::handleRefreshTimeStampIF( tinS& tinP , portTimeC idptMeP , const countT* const pczChannelP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idpth ;

    }
        }
            tinP.pEther->delF( tinP , pnn ) ;
            }
                else            (countT&)idpth = pnn->pcId[ 0 ] & 0xffff ; // THE HIGH ORDER 01 BITS OF spaceport.ideafarm.com ARE NOW SET TO MAKE THE IPv4 ADDRESS ROUTABLE, BECAUSE getaddrinfo RETURNS WSANO_DATA WHEN THE HIGH WORD IS NULL
                //else            (countT&)idpth = ( pnn->pcId[ 0 ] & 0xffff ) + 0x4 ; //U:: TO FIND A BUG: THIS IS AN INTENTIONAL SMUDGE SO THAT I WILL NEVER BE ABLE TO CONNECT WITH HANDLE
                if( idDo == 1 )          idpth = *pnn ;
            {
            if( cnn == 1 ) //U::IPV6
            THREADmODE1rESTORE
            socketC::nicNameIF( tinP , *tinP.pEther , pnn , cnn , T(idDo==1?"spacenn.ideafarm.com":"spaceport.ideafarm.com") ) ;
            //OLD:socketC::nicNameIF( tinP , *tinP.pEther , pnn , cnn , T(idDo==1?"nicname.":"port.")+TF1(idSpace)+T(".space.ideafarm.com") ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;
            ZE( countT    , cnn ) ;
            ZE( nicNameC* , pnn ) ;
        {
        for( countT idDo = 1 ; idDo <= 2 ; idDo ++ )

        //}
        //    }
        //        case 5 : { idSpace = 2 ; break ; }
        //        case 4 : { idSpace = 2 ; break ; }
        //        case 3 : { idSpace = 2 ; break ; }
        //        case 2 : { idSpace = 2 ; break ; }
        //        case 1 : { idSpace = 3 ; break ; }
        //    {
        //    else switch( idHomeDisk )
        //    if( idSpacew && idSpacew <= 3 ) idSpace = idSpacew ;
        //    tinP.pEther->delF( tinP , psttw ) ;
        //    if( psttw ) idSpacew = tinP.pEther->strDigitsToSCountF( tinP , psttw ) ;
        //    ZE( countT , idSpacew ) ;
        //    THREADmODE1rESTORE
        //    tinP.pEther->boxGetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF( tinP , psttw , T("///d/ideafarm.home.")+TF1(idHomeDisk)+T(".setting.keyValue.idSpace") ) ; ___( psttw ) ;
        //    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;
        //    countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;
        //    ZE( strokeS* , psttw ) ;
        //{
        //ENABLE WHEN A PRODUCTION RELAY SYSTEM EXISTS AND NEED TO DO DEVELOPMENT IN A SANDBOX
        countT idSpace = 1 ;
    {
    if( !*tinP.pEther )

    //}
    //    pGrabHandleAll->ungrabF( tinP ) ;
    //    idpth = *pIdptHandleAll ;
    //    pGrabHandleAll->grabF( tinP , TAG( TAGiDnULL ) ) ;
    //{
    //if( !pczChannelP )
    portTimeC idpth ;
{
/*1*/portTimeC nodeOldC::handleQueryIF( tinS& tinP , const countT* const pczChannelP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( tinP.fingerprint ) ;

    /* 7   */ sBagP << idTypeP ;
    /* 6   */ sBagP << flagsP ;
    /* 5   */ sBagP << (countT)( 1 + incv02AM( idSerialLathHeaderP ) ) ;
    /* 1-4 */ idptP >> sBagP ;
{
/*1*/voidT nodeOldC::hdrBagIF( tinS& tinP , soulC& sBagP , portTimeC& idptP , countT& idSerialLathHeaderP , const flagsT flagsP , const countT idTypeP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    stIdptTempP.purgeF( tinP ) ;
    }
        while( !stIdptOpenP.third && ~hDown ) ;
        }
            stIdptOpenP.sinkF( tinP , countTC() , (byteT*)&idpt , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
            portTimeC& idpt = *(portTimeC*)&stIdptTempP.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stIdptTempP )
    stIdptOpenP.purgeF( tinP ) ;
    }
        while( !stIdptOpenP.third && ~hDown ) ;
        }
            stIdptTempP.sinkF( tinP , countTC() , (byteT*)&idpt , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
            portTimeC& idpt = *(portTimeC*)&stIdptOpenP.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stIdptOpenP )
    stIdptTempP.purgeF( tinP ) ;
{
/*1*/voidT nodeOldC::sortOpenIF( tinS& tinP , stackC& stIdptOpenP , stackC& stIdptGossipP , stackC& stIdptTempP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    stRelayP.ungrabF( tinP ) ;
    }
        while( !stRelayP.third && ~hDown ) ;
        do *(portTimeC*)&stRelayP.downF( tinP , hDown ) >> soulP ;
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stRelayP )
    soulP << (countT)stRelayP ;
    stRelayP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    _IO_
{
/*1*/voidT nodeOldC::myListIF( tinS& tinP , soulC& soulP , stackC& stRelayP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cRelays ;
    }
        if( idpt ) stP.sinkF( tinP , countTC() , (byteT*)&idpt , flSTACKsINK_UNIQUE , subtractIdPortTimesF , &stP == &stIdptGossipP ? - 1 : (countT)&stIdptGossipP ) ;
        portTimeC idpt = portTimeC::fieldF( tinP , soulP , idFieldP ) ; idFieldP += portTimeC::cFieldsF( tinP ) ;
    {
    while( cToDo -- )
    }
    {
    if( &stP == &stIdptGossipP )
    countT cToDo = cRelays ;
    const countT cRelays = soulP.cFieldF( tinP , idFieldP ++ ) ;
    _IO_
{
/*1*/countT nodeOldC::hisListIF( tinS& tinP , stackC& stP , soulC& soulP , stackC& stIdptGossipP , countT& idFieldP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        //tinP.pEther->traceF( tinP , T("popIF / ----") ) ;

        }
            }
                }
                    }
                        //if( bDebug ) { CONoUTrAW3( "popping secret packet " , idSerialBag , " RIGHT\r\n" ) ; }
                        *pStPop4P << psBagCopy ; psBagCopy = 0 ;
                        //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / popping up lateral to 4 / doing") ) ;

                        }
                            flags &= ~( F(flRELAYpOP_DOWN) | F(flRELAYpOP_UP) ) ;
                            flagsT& flags = psBagCopy->cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                            //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / popping up lateral to 4 / dud") ) ;
                        {
                        if( bDudP )
                        *psBagCopy = sBagP ;
                    {
                    if( psBagCopy )
                    soulC* psBagCopy = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBagCopy ) ;
                    //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / popping up lateral to 4") ) ;
                {
                if( pStPop4P )
                
                }
                    }
                        //if( bDebug ) { CONoUTrAW3( "popping secret packet " , idSerialBag , " LEFT\r\n" ) ; }
                        *pStPop3P << psBagCopy ; psBagCopy = 0 ;
                        //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / popping up lateral to 3 / doing") ) ;

                        }
                            flags &= ~( F(flRELAYpOP_DOWN) | F(flRELAYpOP_UP) ) ;
                            flagsT& flags = psBagCopy->cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                            //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / popping up lateral to 3 / dud") ) ;
                        {
                        if( bDudP )
                        *psBagCopy = sBagP ;
                    {
                    if( psBagCopy )
                    soulC* psBagCopy = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBagCopy ) ;
                    //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / popping up lateral to 3") ) ;
                {
                if( pStPop3P )
            {
            if( bLateral )
            
            }
                }
                    //if( bDebug ) { CONoUTrAW3( "popping secret packet " , idSerialBag , " UP2\r\n" ) ; }
                    *pStPop2P << psBagCopy ; psBagCopy = 0 ;
                    //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / popping up to 2 / doing") ) ;

                    }
                        flags &= ~( F(flRELAYpOP_DOWN) | F(flRELAYpOP_UP) ) ;
                        flagsT& flags = psBagCopy->cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                        //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / popping up to 2 / dud") ) ;
                    {
                    if( bDudP )
                    *psBagCopy = sBagP ;
                {
                if( psBagCopy )
                soulC* psBagCopy = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBagCopy ) ;
                //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / popping up to 2") ) ;
            {
            if( flagsUp & 2 && pStPop2P )
        
            }
                }
                    //if( bDebug ) { CONoUTrAW3( "popping secret packet " , idSerialBag , " UP1\r\n" ) ; }
                    *pStPop1P << psBagCopy ; psBagCopy = 0 ;
                    //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / popping up to 1 / doing") ) ;

                    }
                        flags &= ~( F(flRELAYpOP_DOWN) | F(flRELAYpOP_UP) ) ;
                        flagsT& flags = psBagCopy->cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                        //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / popping up to 1 / dud") ) ;
                    {
                    if( bDudP )
                    *psBagCopy = sBagP ;
                {
                if( psBagCopy )
                soulC* psBagCopy = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBagCopy ) ;
                //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / popping up to 1") ) ;
            {
            if( flagsUp & 1 && pStPop1P )
    
            }
                DEL( psWrap ) ;
                }
                    }
                        //CONoUTrAW3( "popIF: flagsUp: " , flagsUp , "\r\n" ) ;
                        DEL( psTo ) ;
                        }
                            UNGRABrELAYlISTS
                            }
                                }
                                    //tinP.pEther->traceF( tinP , T("[idRankTo,flagsUp]:    ")+TF2(idRankTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flagsUp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    flagsUp |= flagsUpF( idRankMe , idRankTo , idRankMax ) ;
                                {
                                if( idRankTo )
    
                                //THREADmODE1rESTORE
                                //CONoUTrAW( T("popIF: idRankTo: ")+TF1(idRankTo)+T(" ")+T(idptTo)+T("\r\n") ) ;
                                //THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    
                                }
                                    if( idptTo ) idRankTo = stIdptOpenP( (byteT*)&idptTo , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                    idptTo << *psTo ;
                                    portTimeC idptTo ;
                                {
                                ZE( countT , idRankTo ) ;
                            {
                            if( idRankMe ) while( (countT)*psTo && flagsUp != 3 ) //U:: EDIT soulC TO ELIMINATE THE NEED TO CAST TO countT TO GET THE NUBMER OF ITEMS
                            //tinP.pEther->traceF( tinP , T("[idRankMax,idRankMe]:    ")+TF2(idRankMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idRankMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            const countT idRankMax = stIdptOpenP ;
                            //CONoUTrAW3( "popIF: idRankMe: " , idRankMe , "\r\n" ) ;
                            countT idRankMe = stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                            GRABrELAYlISTS
    
                            psTo->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbs , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                            //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / is a wrap / inspecting / sTo is not empty / inspecting psTo") ) ;
                        {
                        if( psTo )
                        soulC* psTo = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psTo ) ; // WILL CONTAIN EITHER sTo OR sToMediator
    
                        }
                            //CONoUTrAW3( "popIF: bDebugUsingMediator: " , bDebugUsingMediator , "\r\n" ) ;
                            ;
                                : ( bDebugUsingMediator = 0 , psWrap->pbFieldF( tinP , idType , flags , cbf , ifcIDfIELDwRAP_TO         ) )
                                ? ( bDebugUsingMediator = 1 , psWrap->pbFieldF( tinP , idType , flags , cbf , ifcIDfIELDwRAP_TOmEDIATOR ) )
                            pbs = !( F(flagsPut) & flCIOpUT_IGNOREmEDIATORlIST ) && !psWrap->bKidEmptyF( tinP , ifcIDfIELDwRAP_TOmEDIATOR )
                            ZE( countT , cbf ) ;
                            ZE( flagsT , flags ) ;
                            ZE( countT , idType ) ;
    
                            flagsT flagsPut = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_FLAGS ) ;
                        {
                        ZE( byteT* , pbs ) ;
                        ZE( boolT , bDebugUsingMediator ) ;
    
                        flagsUp = bLateral = 0 ; //THIS IS A POINT TO POINT PACKET SO DON'T POP SIDE TO SIDE (REDUNDANT, TO MAKE BROADCAST MORE ROBOST)
                        //if( !psWrap->bKidEmptyF( tinP , ifcIDfIELDwRAP_TOmEDIATOR ) ) { CONoUTrAW( "sToMediator is not empty\r\n" ) ; }
                        //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / is a wrap / inspecting / sTo is not empty") ) ;
                    {
                    if( !psWrap->bKidEmptyF( tinP , ifcIDfIELDwRAP_TO ) )
    
                    psWrap->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbsWrap , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                    //O: THIS IS EXPENSIVE; CAN ELIMINATE BY COPYING sTo TO THE OUTER ENVELOPE
                    //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / is a wrap / inspecting") ) ;
                {
                if( psWrap )
                soulC* psWrap = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrap ) ;
    
                byteT* pbsWrap = sBagP.pbFieldF( tinP , idTypesWrap , flagssWrap , cbfsWrap , ifcIDfIELDbAG_WRAP ) ;
                ZE( countT , cbfsWrap ) ;
                ZE( flagsT , flagssWrap ) ;
                ZE( countT , idTypesWrap ) ;
                //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP / is a wrap") ) ;
            {
            if( sBagP.cFieldF( tinP , ifcIDfIELDbAG_IDtYPE ) == ifcIDtYPEbAG_WRAP )
            flagsT flagsUp = 3 ; //BOTH UP LEFT AND UP RIGHT
            boolT bLateral = 1 ;
            //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_UP") ) ;
        {
        if( F(flags) & flRELAYpOP_UP )
    
        }
            }
                }
                    //if( bDebug ) { CONoUTrAW3( "popping secret packet " , idSerialBag , " DOWN\r\n" ) ; }
                    *pStPop0P << psBagCopy ; psBagCopy = 0 ;
                    //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_DOWN / pushing to *pStPop0P") ) ;

                    }
                        flags &= ~( F(flRELAYpOP_DOWN) | F(flRELAYpOP_UP) ) ;
                        flagsT& flags = psBagCopy->cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                        //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_DOWN / dud") ) ;
                    {
                    if( bDudP )
                    *psBagCopy = sBagP ;
                {
                if( psBagCopy )
                soulC* psBagCopy = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBagCopy ) ;
            {
            if( pStPop0P )
            //tinP.pEther->traceF( tinP , T("popIF / flRELAYpOP_DOWN") ) ;
        {
        if( F(flags) & flRELAYpOP_DOWN )
        flagsT flags = sBagP.cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
    
        }
            //if( bDebug ) { CONoUTrAW3( "popIF got a secret STROKEStOcONSOLE " , idSerialBag , "\r\n" ) ; }
        {
    
        }
            }
                }
                    }
                        idSerialBag = sBagP.cFieldF( tinP , ifcIDfIELDbAG_IDsERIAL ) ;
                        bDebug = 1 ;
                    {
                    if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATED && pczChannel[ 2 ] == ifcIDaDAM_SECRETsERVICE && pczChannel[ 3 ] == ifcIDaDAM_CONSOLE && pczChannel[ 4 ] == ifcIDcHANNELfUNCTION_STROKEcONSOLE )
                    countT* pczChannel = (countT*)soulC::pbFieldIF( tinP , idTypeChannel , flagsChannel , cbfChannel , ifcIDfIELDwRAP_CHANNEL , pbsWrap ) ;
                    ZE( countT , cbfChannel ) ;
                    ZE( flagsT , flagsChannel ) ;
                    ZE( countT , idTypeChannel ) ;
                {
                if( idType == ifcIDtYPEwRAP_GIFT )
                countT idType = soulC::cFieldIF( tinP , ifcIDfIELDwRAP_IDtYPE , pbsWrap ) ;
            {
            if( soulC::cFieldsIF( tinP , pbsWrap ) >= ifcIDfIELDwRAP_IDtYPE )
            
            byteT* pbsWrap = sBagP.pbFieldF( tinP , idTypesWrap , flagssWrap , cbfsWrap , ifcIDfIELDbAG_WRAP ) ;
            ZE( countT , cbfsWrap ) ;
            ZE( flagsT , flagssWrap ) ;
            ZE( countT , idTypesWrap ) ;
        {
        if( sBagP.cFieldF( tinP , ifcIDfIELDbAG_IDtYPE ) == ifcIDtYPEbAG_WRAP )
        ZE( countT , idSerialBag ) ;
        ZE( boolT , bDebug ) ;
        //U::

        //tinP.pEther->traceF( tinP , T("popIF / ++++") ) ;
    
        _IO_
    
        //}
        //    }
        //        }
        //            LOGrAW( TF3(idrTo,flFORMAT_UNSIGNED,9)+TF1(flagsUp)+T("\r\n") ) ;
        //            flagsT flagsUp = flagsUpF( idrMe , idrTo , idrMax ) ;
        //        {
        //        for( countT idrTo = idrMe + 1 ; idrTo <= idrMax ; idrTo ++ )
        //        LOGrAW( T("\r\nidrMe: ")+TF1(idrMe)+T("\r\n") ) ;
        //    {
        //    for( countT idrMe = 1 ; idrMe <= idrMax ; idrMe ++ )
        //    LOGrAW( T("idrMax: ")+TF1(idrMax)+T("\r\n") ) ;
        //    const countT idrMax = 0x10 ;
        //{
        //if( !incv02AM( cIn ) )
        //static countT cIn ;
        //TESTER CODE FOR flagsUpF
    {
    IFsCRATCH
{
/*1*/voidT nodeOldC::popIF( tinS& tinP , stackC* pStPop0P , stackC* pStPop1P , stackC* pStPop2P , stackC* pStPop3P , stackC* pStPop4P , soulC& sBagP , stackC& stIdptOpenP , stackC& stIdptGossipP , portTimeC& idptP , const boolT bDudP )/*1*/

//
//  n: (2**n)*x ................ (2**n)*x+(2**(n-1))-1 | (2**n)*x+(2**(n-1)) ............ (2**n)*(x+1)-1
//
//  4: 01x+0 01x+1 01x+2 01x+3 01x+4 01x+5 01x+6 01x+7 | 01x+8 01x+9 01x+a 01x+b 01x+c 01x+d 01x+e 01x+f
//  3: 8x+0        8x+1        8x+2        8x+3        | 8x+4        8x+5        8x+6        8x+7
//  2: 4x+0                    4x+1                    | 4x+2                    4x+3
//  1: 2x+0                                            | 2x+1
//  0: x
//
// x: idRankMeP

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( tinP.fingerprint ) ;
    idWorkInvert2P = idWorkP == IDtYPErELAYpOPcLIENTwORK_EXPLODE1 ? IDtYPErELAYpOPcLIENTwORK_EXPLODE2 : 0 ;

    ;
                    : IDtYPErELAYpOPcLIENTwORK_LEFT
                    ? IDtYPErELAYpOPcLIENTwORK_RIGHT
                : idWorkP == IDtYPErELAYpOPcLIENTwORK_LEFT
                ? IDtYPErELAYpOPcLIENTwORK_IMPLODE
            : idWorkP == IDtYPErELAYpOPcLIENTwORK_EXPLODE2
            ? IDtYPErELAYpOPcLIENTwORK_IMPLODE
        : idWorkP == IDtYPErELAYpOPcLIENTwORK_EXPLODE1
        ? IDtYPErELAYpOPcLIENTwORK_EXPLODE1
        idWorkP == IDtYPErELAYpOPcLIENTwORK_IMPLODE
    idWorkInvert1P =
    _IO_     TLNA( "idWorkInvertIF" )
{
/*1*/voidT nodeOldC::idWorkInvertIF( tinS& tinP , countT& idWorkInvert1P , countT& idWorkInvert2P , const countT idWorkP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bListed ;
    UNGRABrELAYlISTS
    }
        while( !stIdptOpenP.third && ~hDown ) ;
        }
            }
                break ; //SPEC: I MUST LEAVE THE LATHREF CURSOR AT THE PLATE THAT I FOUND
                bListed = 1 ;
            {
            if( idpt == idptP ) //THIS LOOKS AT idPort; SINK LOOKS AT TIME
            portTimeC& idpt = *(portTimeC*)&stIdptOpenP.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stIdptOpenP )
    ZE( boolT , bListed ) ;
    GRABrELAYlISTS
{
/*1*/boolT nodeOldC::bListedIF( tinS& tinP , stackC& stIdptOpenP , stackC& stIdptGossipP , const portTimeC& idptP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    UNGRABrELAYlISTS

    }
        }
            case IDtYPErELAYpOPcLIENTwORK_EXPLODE1 : { portTimeC nt ; idptSelectPeerIF( tinP , nt , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_IMPLODE  , flSELECTpEER_DUPLICATEiSoK ) ; if( idptPeerP == nt ) idptPeerP = 0 ; }
            case IDtYPErELAYpOPcLIENTwORK_EXPLODE2 : { portTimeC nt ; idptSelectPeerIF( tinP , nt , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_EXPLODE1 , flSELECTpEER_DUPLICATEiSoK ) ; if( idptPeerP == nt ) idptPeerP = 0 ; }
            case IDtYPErELAYpOPcLIENTwORK_LEFT     : { portTimeC nt ; idptSelectPeerIF( tinP , nt , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_EXPLODE2 , flSELECTpEER_DUPLICATEiSoK ) ; if( idptPeerP == nt ) idptPeerP = 0 ; }
            case IDtYPErELAYpOPcLIENTwORK_RIGHT    : { portTimeC nt ; idptSelectPeerIF( tinP , nt , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_LEFT     , flSELECTpEER_DUPLICATEiSoK ) ; if( idptPeerP == nt ) idptPeerP = 0 ; }
        {
        switch( idMyWorkP ) // idptP IS SET IFF A DISTINCT RELAY EXISTS
    {
    if( !( F(flagsP) & flSELECTpEER_DUPLICATEiSoK ) )

    }
        }
            case  IDtYPErELAYpOPcLIENTwORK_RIGHT    : {                                    idptPeerP = cRelays > 1 ? *(portTimeC*)&stIdptOpenP[ ideMe < cRelays ? ideMe + 1 : 1       ] : idptNull ; break ; }
            case  IDtYPErELAYpOPcLIENTwORK_LEFT     : {                                    idptPeerP = cRelays > 1 ? *(portTimeC*)&stIdptOpenP[ ideMe > 1       ? ideMe - 1 : cRelays ] : idptNull ; break ; }
            case  IDtYPErELAYpOPcLIENTwORK_EXPLODE2 : { if( stIdptOpenP >= ideMe * 2 + 1 ) idptPeerP =               *(portTimeC*)&stIdptOpenP[ ideMe * 2 + 1                         ]            ; break ; }
            case  IDtYPErELAYpOPcLIENTwORK_EXPLODE1 : { if( stIdptOpenP >= ideMe * 2     ) idptPeerP =               *(portTimeC*)&stIdptOpenP[ ideMe * 2                             ]            ; break ; }
            case  IDtYPErELAYpOPcLIENTwORK_IMPLODE  : { if(           1 != ideMe         ) idptPeerP =               *(portTimeC*)&stIdptOpenP[ ideMe / 2                             ]            ; break ; }
        {
        switch( idMyWorkP ) // idptP IS SET IFF A DISTINCT RELAY EXISTS
        portTimeC idptNull ;
    {
    if( ideMe )

    }
        if( !bFound ) ideMe = 0 ;
        UNGRABrELAYlISTS
        }
            while( !stIdptOpenP.third && ~hDown ) ;
            }
                }
                    break ;
                    bFound = 1 ;
                {
                if( idpt == idptP ) //THIS LOOKS AT idPort; SINK LOOKS AT TIME
                portTimeC& idpt = *(portTimeC*)&stIdptOpenP.downF( tinP , hDown ) ;
                ideMe ++ ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( stIdptOpenP )
        GRABrELAYlISTS
        ZE( boolT , bFound ) ;
    {
    if( !ideMe ) //WILL BE TRUE IF I HAVE JUST RESTAMPED MYSELF

    }
        }
            while( !stIdptOpenP.third && ~hDown ) ;
            }
                tinP.pEther->traceF( tinP , T("idptSelectPeerIF: open [idPlate,idpt]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((nicNameC&)idpt)+T(" ( ")+TF2((countT)idpt,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ; //U:: TO FIND A BUG
                portTimeC& idpt = *(portTimeC*)&stIdptOpenP.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , idPlate ) ;
        {
        if( stIdptOpenP )

        tinP.pEther->traceF( tinP , T("idptSelectPeerIF: open list [cRelays,ideMe]:    ")+TF2(cRelays,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(ideMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG
    {
    if( F(flagsP) & flSELECTpEER_TRACE )

    }
        }
            while( !stIdptGossipP.third && ~hDown ) ;
            }
                tinP.pEther->traceF( tinP , T("idptSelectPeerIF: gossip [idPlate,idpt]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((nicNameC&)idpt)+T(" ( ")+TF2((countT)idpt,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ; //U:: TO FIND A BUG
                portTimeC& idpt = *(portTimeC*)&stIdptGossipP.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , idPlate ) ;
        {
        if( stIdptGossipP )

        tinP.pEther->traceF( tinP , T("idptSelectPeerIF: gossip list") ) ; //U:: TO FIND A BUG
    {
    if( F(flagsP) & flSELECTpEER_TRACE )

    countT ideMe = stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
    countT cRelays = stIdptOpenP ;

    GRABrELAYlISTS

    if( stIdptOpenP.third ) { BLAMMO ; }
    if( idptPeerP ) { BLAMMO ; }
    _IO_     TLNA( "idptSelectPeerIF" )

    }
        if( POOP ) return ;
        //FV( flSELECTpEER , flagsP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT nodeOldC::idptSelectPeerIF( tinS& tinP , portTimeC& idptPeerP , stackC& stIdptOpenP , portTimeC& idptP , stackC& stIdptGossipP , const countT idMyWorkP , const flagsT flagsP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    UNGRABrELAYlISTS
    }
        }
            case  IDtYPErELAYpOPcLIENTwORK_RIGHT    : {                                idptPeer1P = cRelays > 1 ? *(portTimeC*)&stIdptOpenP[ ideMe > 1      ? ideMe - 1 : cRelays ] : idptNull ; break ; }
            case  IDtYPErELAYpOPcLIENTwORK_LEFT     : {                                idptPeer1P = cRelays > 1 ? *(portTimeC*)&stIdptOpenP[ ideMe < cRelays ? ideMe + 1 : 1      ] : idptNull ; break ; }
            case  IDtYPErELAYpOPcLIENTwORK_EXPLODE2 : { if( 1 < ideMe                ) idptPeer1P =              *(portTimeC*)&stIdptOpenP[ ideMe / 2                           ]            ; break ; }
            case  IDtYPErELAYpOPcLIENTwORK_EXPLODE1 :
            case  IDtYPErELAYpOPcLIENTwORK_IMPLODE  : { if( stIdptOpenP >= ideMe * 2 ) idptPeer1P =              *(portTimeC*)&stIdptOpenP[ ideMe * 2                           ]            ; if( stIdptOpenP >= ideMe * 2 + 1 ) idptPeer2P = *(portTimeC*)&stIdptOpenP[ ideMe * 2 + 1 ] ; break ; }
        {
        switch( idHisWorkP ) // idptP IS SET IFF A DISTINCT RELAY EXISTS
        portTimeC idptNull ;
    {
    if( ideMe )
    countT ideMe = stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
    countT cRelays = stIdptOpenP ;

    GRABrELAYlISTS

    if( stIdptOpenP.third ) { BLAMMO ; }
    if( idptPeer2P ) { BLAMMO ; }
    if( idptPeer1P ) { BLAMMO ; }
    _IO_     TLNA( "portTimeClientIF" )
{
/*1*/voidT nodeOldC::portTimeClientIF( tinS& tinP , portTimeC& idptPeer1P , portTimeC& idptPeer2P , stackC& stIdptOpenP , portTimeC& idptP , stackC& stIdptGossipP , const countT idHisWorkP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        { portTimeC n1 ; portTimeC n2 ; portTimeClientIF( tinP , n1 , n2 , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_RIGHT    ) ; if( n1 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n1 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; if( n2 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n2 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; }
        { portTimeC n1 ; portTimeC n2 ; portTimeClientIF( tinP , n1 , n2 , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_LEFT     ) ; if( n1 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n1 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; if( n2 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n2 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; }
        { portTimeC n1 ; portTimeC n2 ; portTimeClientIF( tinP , n1 , n2 , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_EXPLODE2 ) ; if( n1 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n1 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; if( n2 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n2 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; }
        { portTimeC n1 ; portTimeC n2 ; portTimeClientIF( tinP , n1 , n2 , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_EXPLODE1 ) ; if( n1 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n1 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; if( n2 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n2 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; }
        { portTimeC n1 ; portTimeC n2 ; portTimeClientIF( tinP , n1 , n2 , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_IMPLODE  ) ; if( n1 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n1 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; if( n2 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n2 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; }
    {
    else
    }
        }
            }
                stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n1 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; if( n2 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n2 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ;
            {
            if( n1 )
            portTimeClientIF( tinP , n1 , n2 , stIdptOpenP , idptP , stIdptGossipP , idWorkP  ) ;
            portTimeC n2 ;
            portTimeC n1 ;
        {
        // { portTimeC n1 ; portTimeC n2 ; portTimeClientIF( tinP , n1 , n2 , stIdptOpenP , idptP , stIdptGossipP , idWorkP  ) ; if( n1 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n1 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; if( n2 ) stRelayExpectedP.sinkF( tinP , countTC() , (byteT*)&n2 , flSTACKsINK_UNIQUE , subtractIdPortTimesF , - 1 ) ; }
    {
    if( idWorkP )
{
/*1*/voidT nodeOldC::portTimeClientsExpectedIF( tinS& tinP , stackC& stRelayExpectedP , stackC& stIdptOpenP , stackC& stIdptGossipP , portTimeC& idptP , const countT idWorkP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idptGossipped ;

    }
        }
            break ;
            }
                (*tinP.pEther)( tinP , psBagPop ) ;
                popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBagPop , stIdptOpenP , stIdptGossipP , idptP ) ;
                idptGossipP >> *psBagPop ;
                hdrBagIF( tinP , *psBagPop , idptP , idSerialLathHeaderP , flRELAYpOP_DOWN , ifcIDtYPEbAG_CLIENTpOPgOSSIP ) ;
            {
            if( psBagPop )
        
            UNGRABrELAYlISTS
            }
                else (*tinP.pEther)( tinP , psBagPop , TAG( TAGiDnULL ) ) ;
                }
                    sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                    stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptGossipP , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
                {
                if( pnRoot && *pnRoot == idptP )
                portTimeC* pnRoot = stIdptOpenP ? (portTimeC*)&stIdptOpenP[ 1 ] : 0 ;
                idptGossipped = idptGossipP ;
            {
            )
                !stIdptGossipP( (byteT*)&idptGossipP , subtractIdPortsF , - 1 )
                 stRelayAbsentP( (byteT*)&idptGossipP , subtractIdPortsF , - 1 ) &&
            (
            if
            GRABrELAYlISTS
            ZE( soulC* , psBagPop ) ;
        {
        case IDtYPErELAYpOPcLIENTwORK_IMPLODE :
    {
    switch( idWorkP )
    portTimeC idptGossipped ;
{
/*1*/portTimeC nodeOldC::gossipIfIF( tinS& tinP , countT& idSerialLathHeaderP , stackC* const pStPop0P , stackC* const pStPop1P , stackC* const pStPop2P , stackC* const pStPop3P , stackC* const pStPop4P , stackC& stIdptOpenP , stackC& stIdptGossipP , stackC& stIdptTempP , stackC& stRelayAbsentP , portTimeC& idptGossipP , portTimeC& idptP , const countT idWorkP )/*1*/
/**/
*/
if idptGossipP is absent and is not already gossipped, then gossip about it
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bOk ;
    }
        }
            }
                bOk = 0 ;
                POOPR
            {
            if( POOP )

            (*tinP.pEtScratch)( tinP , psBagOk ) ;
            (*tinP.pEtScratch)( tinP , psBag ) ;
            }
                TELL( "reading ok-" )
                VERIFYrELAY2( sock , *psBagOk ) ;
                TELL( "reading ok+ 15" )
                sock.writeF( tinP , *psBag ) ;
    
                hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flRELAYpOP_DOWN , ifcIDtYPEbAG_CLIENTnULL ) ;
            {
            if( psBag && psBagOk )
            (*tinP.pEtScratch)( tinP , psBagOk , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psBagOk ) ;
            (*tinP.pEtScratch)( tinP , psBag , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psBag ) ;
        {
        else
        }
            tinP.pEther->traceF( tinP , T("testIF: could not connect [idptTestP:nn,idPort]:    ")+T((nicNameC&)idptTestP)+T("    ")+TF2((countT&)idptTestP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            bOk = 0 ;
            POOPRqUIET
        {
        if( POOP )
        sock.connectF( tinP , idptTestP , (nicNameC&)idptTestP ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
        SCOOPS
    {
    IFsCRATCH
    boolT bOk = 1 ;
{
/*1*/boolT nodeOldC::testIF( tinS& tinP , portTimeC& idptP , countT& idSerialLathHeaderP , portTimeC& idptTestP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            //CONoUTrAW( "helloToHandleIF: 0 end of loop snippet\r\n" ) ;
            handleUnregisterIF( tinP , idpthc ) ;
            //CONoUTrAW( "helloToHandleIF: 1 unregistering handle\r\n" ) ;
    
            if( bOk ) break ;
            //CONoUTrAW3( "helloToHandleIF: 2 bOk:" , bOk , "\r\n" ) ;

            }
                }
                    tinP.pEther->traceF( tinP , T("helloToHandleIF / could not say hello to handle [idpthc:nn,idPort]:    ")+T((nicNameC&)idpthc)+T("    ")+TF2((countT&)idpthc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                {
                if( POOP )

                }
                    DEL( psBagOk ) ;
                    DEL( psBag ) ;
                    }
                        }
                            tinP.pEther->traceF( tinP , T("could not verify that my hello was received") ) ;
                            POOPRqUIET
                        {
                        else
                        if( !POOP ) bOk = 1 ;
                        VERIFYrELAY2( sock , *psBagOk ) ;

                        sock.writeF( tinP , *psBag ) ; //ASSUME: SERVER WILL, IF ROOT, ADD ME TO ITS LIST
                        tinP.pEther->traceF( tinP , T("writing hello bag") ) ;
            
                        idptP >> *psBag ;
                        idptP >> *psBag ;
                        hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flRELAYpOP_DOWN , ifcIDtYPEbAG_CLIENTpOPuNgOSSIP ) ;
                    {
                    if( psBag && psBagOk )
                    soulC* psBagOk = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBagOk ) ;
                    soulC* psBag = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBag ) ;
                {
                if( !POOP )
                sock.connectF( tinP , idpthc , (nicNameC&)idpthc ) ;

                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL )/*U:: , 0 , flSOCKETc_TOPsECRET*/ ) ;
                SCOOPS
            {
            ZE( boolT , bOk ) ;
    
            if( !idpthc ) break ;
    
            portTimeC idpthc = handleQueryIF( tinP ) ;
        {
        for(;;)
    {
    IFsCRATCH
{
/*1*/voidT nodeOldC::helloToHandleIF( tinS& tinP , portTimeC& idptP , countT& idSerialLathHeaderP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        DEL( psWrap ) ;
        }
            }
                swsWrapRefP.ungrabF( tinP ) ;
                }
                    }
                        }
                            swsWrapRefP << (countT)pc2WrapRef ; //W: WARNING: THESE DUPLICATE POINTERS MUST ONLY BE DELETED WHEN !cRef, I.E. ONLY WO TIME
                            cLeverPayloadP = swsWrapRefP.leverF( tinP , idf ) ;
                            //CONoUTrAW( "doWrapLocallyIfIF: pushed a wrap ref\r\n" ) ; //U::
                        {
                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        pc2WrapRef->c2 = cFlavors ; //cRef
                        pc2WrapRef->c1 = (countT)psWrap ; psWrap = 0 ;
                    {
                    if( pc2WrapRef )
                    etThread.newF( tinP , LF , pc2WrapRef ) ; ___( pc2WrapRef ) ;
                    ZE( count2S* , pc2WrapRef ) ;
                {
                else
                if( !cFlavors ) etThread( tinP , psWrap ) ;
                countT cFlavors = swsWrapRefP.cFlavorsF( tinP ) ;
                swsWrapRefP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                //}
                //    }
                //        }
                //            }
                //                etThread( tinP , psGift ) ;
                //                }
                //                    etThread( tinP , psSecret ) ;
                //                    }
                //                        etThread.delF( tinP , psttw ) ;
                //                        }
                //                            etThread.delF( tinP , psttw2 ) ;
                //                            }
                //                                etThread.delF( tinP , psttw3 ) ;
                //                                }
                //                                    etThread.strokeF( tinP , T("\f")+TF1(idMsg1Lath)+T(" ")+TF1(idMsg2Lath)+T(bM?" MEDIATED":" FINAL") ) ;
                //
                //                                    ( bM ? idMsg1Lath : idMsg2Lath ) = idMessage ;
                //                                    static countT idMsg2Lath ;
                //                                    static countT idMsg1Lath ;
                //
                //                                    countT bM = soulC::cFieldsIF( tinP , pbsToM ) ;
                //                                    byteT* pbsToM = psWrap->pbFieldF( tinP , idTypesToM , flagssToM , cbfsToM , ifcIDfIELDwRAP_TOmEDIATOR ) ;
                //                                    ZE( countT , cbfsToM ) ;
                //                                    ZE( flagsT , flagssToM ) ;
                //                                    ZE( countT , idTypesToM ) ;
                //                                {
                //                                countT idMessage = etThread.strDigitsToSCountF( tinP , psttw3 ) ;
                //                                etThread.strSubstringF( tinP , psttw3 , idf , idl , psttw2 ) ; ___( psttw3 ) ;
                //                                countT idl = idBlank - 1 ;
                //                                countT idf = 1 ;
                //                                ZE( strokeS* , psttw3 ) ;
                //                            {
                //                            if( idBlank )
                //                            countT idBlank = etThread.strIdF( tinP , T(" ") , psttw2 ) ;
                //                            etThread.strSubstringF( tinP , psttw2 , idf , idl , psttw ) ; ___( psttw2 ) ;
                //                            ZE( countT , idl ) ;
                //                            countT idf = idColon + 1 ;
                //                            ZE( strokeS* , psttw2 ) ;
                //                        {
                //                        if( idColon )
                //                        countT idColon = etThread.strIdF( tinP , T(":") , psttw ) ;
                //    
                //                        *psSecret >> psttw ; ___( psttw ) ;
                //                        ZE( strokeS* , psttw ) ;
                //                    {
                //                    if( psSecret )
                //                    etThread.cioGetSecretF( tinP , psSecret , *psGift ) ; ___( psSecret ) ;
                //                    ZE( soulC* , psSecret ) ;
                //
                //                    psGift->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                //                {
                //                if( psGift )
                //                etThread( tinP , psGift , TAG( TAGiDnULL ) ) ;
                //                ZE( soulC* , psGift ) ;
                //            {
                //            if( pbsGift )
                //
                //            byteT* pbsGift = soulC::pbFieldIF( tinP , idTypeGift , flagsGift , cbGift , ifcIDfIELDwRAP_GIFT , pbsWrapP ) ;
                //            ZE( countT , cbGift ) ;
                //            ZE( flagsT , flagsGift ) ;
                //            ZE( countT , idTypeGift ) ;
                //        {
                //        if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATED && pczChannel[ 2 ] == ifcIDaDAM_SECRETsERVICE && pczChannel[ 3 ] == ifcIDaDAM_CONSOLE && pczChannel[ 4 ] == ifcIDcHANNELfUNCTION_STROKEcONSOLE )
                //
                //        countT* pczChannel = (countT*)soulC::pbFieldIF( tinP , idTypeC , flagsC , cbC , ifcIDfIELDwRAP_CHANNEL , pbsWrapP ) ;
                //        ZE( countT , cbC ) ;
                //        ZE( flagsT , flagsC ) ;
                //        ZE( countT , idTypeC ) ;
                //    {
                //    if( pbidType && *(countT*)pbidType == ifcIDtYPEwRAP_GIFT )
                //
                //    byteT* pbidType = soulC::pbFieldIF( tinP , idTypeidType , flagsidType , cbidType , ifcIDfIELDwRAP_IDtYPE , pbsWrapP ) ;
                //    ZE( countT , cbidType ) ;
                //    ZE( flagsT , flagsidType ) ;
                //    ZE( countT , idTypeidType ) ;
                //{
                //THIS BLOCK WILL FAIL IF THE SECRET IS EMPTY OR NOT OF THE EXPECTED CONTENTS
                //THIS BLOCK IS JUST FOR DEBUGGING AND SHOULD BE COMMENTED OUT IN PRODUCTION

                }
                    }
                        }
                            }
                                DEL( psGift ) ;
                                }
                                    }
                                        if( idCmd == ifcIDcMDrEGISTERmEDIATOR_AMaLIVE && idAdam == ifcIDaDAM_SECRETsERVICE ) homeS::homeIF().cSecretServerRegistrationsSeen ++ ;
                            
                                        *psGift >> idAdam ;
                                        ZE( countT , idAdam ) ;
                                        *psGift >> idCmd ;
                                        ZE( countT , idCmd ) ;
                                    {
                                    if( *psGift == 2 )
                            
                                    psGift->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                                {
                                if( psGift )
                                soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psGift ) ;
                            {
                            if( pbsGift )

                            byteT* pbsGift = soulC::pbFieldIF( tinP , idTypeGift , flagsGift , cbGift , ifcIDfIELDwRAP_GIFT , pbsWrapP ) ;
                            ZE( countT , cbGift ) ;
                            ZE( flagsT , flagsGift ) ;
                            ZE( countT , idTypeGift ) ;
                        {
                        if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATORrEGISTRATION )
                
                        countT* pczChannel = (countT*)soulC::pbFieldIF( tinP , idTypeC , flagsC , cbC , ifcIDfIELDwRAP_CHANNEL , pbsWrapP ) ;
                        ZE( countT , cbC ) ;
                        ZE( flagsT , flagsC ) ;
                        ZE( countT , idTypeC ) ;
                    {
                    if( pbidType && *(countT*)pbidType == ifcIDtYPEwRAP_GIFT )
                
                    byteT* pbidType = soulC::pbFieldIF( tinP , idTypeidType , flagsidType , cbidType , ifcIDfIELDwRAP_IDtYPE , pbsWrapP ) ;
                    ZE( countT , cbidType ) ;
                    ZE( flagsT , flagsidType ) ;
                    ZE( countT , idTypeidType ) ;
                {
                //CONoUTrAW( "doWrapLocallyIfIF: bDo is true\r\n" ) ;
            {
            if( bDo )
        
            }
                }
                    DEL( psTo ) ;
                    }
                        }
                            }
                                }
                                    break ;
                                    bTargeted = bDo = 1 ;
                                {
                                if( idptTo == idptP )
                                idptTo << *psTo ;
                                portTimeC idptTo ;
                            {
                            while( (countT)*psTo )
                            bDo = 0 ;
                        {
                        if( *psTo )
            
                        psTo->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbsToOrToM , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                    {
                    if( psTo )
                    soulC* psTo = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psTo ) ;
                {
                if( pbsToOrToM )
        
                byteT* pbsToOrToM = psWrap->pbFieldF( tinP , idTypesToOrToM , flagssToOrToM , cbfsToOrToM , bToMediators ? ifcIDfIELDwRAP_TOmEDIATOR : ifcIDfIELDwRAP_TO ) ;
                ZE( countT , cbfsToOrToM ) ;
                ZE( flagsT , flagssToOrToM ) ;
                ZE( countT , idTypesToOrToM ) ;

                //bDo WAS RESET HERE ; ON 2011.01.13 THE RESET LINE WAS MOVED SO THAT RESET ONLY OCCURS IF *psTo ; WAS NOT GETTING OWN WRAP ON A DUT WITH RELAY IN LONE HOME
        
                boolT bToMediators = !( F(flagsPut) & flCIOpUT_IGNOREmEDIATORlIST ) && !psWrap->bKidEmptyF( tinP , ifcIDfIELDwRAP_TOmEDIATOR ) ;
                flagsT flagsPut = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_FLAGS ) ;
            {
            if( !psWrap->bKidEmptyF( tinP , ifcIDfIELDwRAP_TO ) )
            boolT bDo = 1 ;
            ZE( boolT , bTargeted ) ; //U::

            psWrap->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbsWrapP , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
        {
        if( psWrap )
        soulC* psWrap = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrap ) ;
    {
    if( !idPhaseP || idPhaseP == 2 )

    }
        }
            }
                }
                    }
                        swsIdptMediatorP.ungrabF( tinP ) ;

                        }
                            }
                                break ;
                                }
                                    if( ids ) ppSws[ off ]->extractF( 0 , tinP ) ;
                                    ppSws[ off ]->sinkF( tinP , ids , (byteT*)&idptOriginP , flSTACKsINK_QUERY , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                    ZE( countT , ids ) ;
                                {
                                for( countT off = 0 ; off < 2 ; off ++ )

                                switchStackC* ppSws[] = { &swsIdptMediatorP , &swsIdptMediatorAltP } ;

                                THREADmODE1rESTORE
                                etThread.strokeF( tinP , T("m-: ")+TF1(idAdam)+T(" ")+T(idptOriginP)+T("\r\n") ) ;
                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                            {
                            case ifcIDcMDrEGISTERmEDIATOR_AMdEAD  :
                            }
                                break ;
                                swsIdptMediatorP.sinkF( tinP , countTC() , (byteT*)&idptOriginP , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;

                                //THREADmODE1rESTORE
                                //etThread.strokeF( tinP , T("m+: ")+TF1(idAdam)+T(" ")+T(idptOriginP)+T("\r\n") ) ;
                                //THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                            {
                            case ifcIDcMDrEGISTERmEDIATOR_AMaLIVE :
                        {
                        switch( idCmd )

                        idAdamMediatorP = idAdam ;
                        swsIdptMediatorP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                                
                        countT idAdam = *(countT*)pb_idAdam ;
                        countT idCmd  = *(countT*)pb_idCmd ;
                    {
                    if( idptOriginP && pb_idCmd && pb_idAdam )
    
                    byteT* pb_idAdam = soulC::pbFieldIF( tinP , idType2 , flags2 , cb2 , 2 , pbsGift ) ;
                    ZE( countT , cb2 ) ;
                    ZE( flagsT , flags2 ) ;
                    ZE( countT , idType2 ) ;
    
                    byteT* pb_idCmd = soulC::pbFieldIF( tinP , idType1 , flags1 , cb1 , 1 , pbsGift ) ;
                    ZE( countT , cb1 ) ;
                    ZE( flagsT , flags1 ) ;
                    ZE( countT , idType1 ) ;
    
                    byteT* pbsGift = soulC::pbFieldIF( tinP , idTypeGift , flagsGift , cbGift , ifcIDfIELDwRAP_GIFT , pbsWrapP ) ;
                    ZE( countT , cbGift ) ;
                    ZE( flagsT , flagsGift ) ;
                    ZE( countT , idTypeGift ) ;
                {
                if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATORrEGISTRATION )
                                
                countT* pczChannel = (countT*)soulC::pbFieldIF( tinP , idTypec , flagsc , cbc , ifcIDfIELDwRAP_CHANNEL , pbsWrapP ) ;
                ZE( countT , cbc ) ;
                ZE( flagsT , flagsc ) ;
                ZE( countT , idTypec ) ;
            {
            if( soulC::cFieldsIF( tinP , pbsWrapP ) >= ifcIDfIELDwRAP_GIFT && soulC::cFieldIF( tinP , ifcIDfIELDwRAP_IDtYPE , pbsWrapP ) == ifcIDtYPEwRAP_GIFT )
    
            }
                }
                    }
                        }
                            off += 4 ;
            
                            }
                                //}
                                //    THREADmODE1rESTORE
                                //    etThread.strokeF( tinP , T("patched to ")+TF1(*(countT*)pb_idPort)+T(*(nicNameC*)pb_nn)+T("\r\n") ) ; //U::
                                //    etThread.strokeF( tinP , T("patched from ")+T(idptm)+T("\r\n") ) ; //U::
                                //    etThread.strokeF( tinP , T("top plate is ")+T(idptms)+T("\r\n") ) ; //U::
                                //    portTimeC& idptms = *(portTimeC*)&swsIdptMediatorP[ 1 ] ;
                                //    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                //{
    
                                *(countT*)pb_time2  = time.time2 ;
                                *(countT*)pb_time1  = time.time1 ;
                                const timeS& time   = idptm ;
                                *(nicNameC*)pb_nn   = (nicNameC&)idptm ;
                                *(countT*)pb_idPort = idptm ;
        
                                swsIdptMediatorP.ungrabF( tinP ) ;
                                swsIdptMediatorAltP.ungrabF( tinP ) ;
    
                                //THREADmODE1rESTORE
                                //etThread.strokeF( tinP , T("patched null mediator to ")+TF1(idAdamMediatorP)+T(" mediator\r\n")+T(idptm)+T("\r\n") ) ; //U::
                                //THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                                }
                                    LOGrAW7( bAlt ? "could not assign a mediator because -->" : "could not assign a mediator because <--" , swsIdptMediatorP , " " , swsIdptMediatorAltP , " cells of " , idAdamMediator , " are registered\r\n" ) ;
                                    tinP.pEther->traceF( tinP , T(bAlt?"could not assign a mediator because --> ":"could not assign a mediator because <-- ")+TF2(swsIdptMediatorP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(swsIdptMediatorAltP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" cells of ")+TF2(idAdamMediator,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" are registered") ) ;
                                {
                                if( !idptm )
                                swsm.randomF( tinP , pb_idptm ) ;
                                byteT* pb_idptm = (byteT*)&idptm ;
                                portTimeC idptm ;
                                switchStackC& swsm = bAlt ? swsIdptMediatorAltP : swsIdptMediatorP ;

                                ;
                                        : 1
                                        ? 0
                                    : swsIdptMediatorP
                                    ? ( tinP.ranUni % TUCK ) / TUCK * 2
                                const boolT bAlt = swsIdptMediatorP && swsIdptMediatorAltP
                                idAdamMediatorP = idAdamMediator ;
    
                                swsIdptMediatorAltP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                swsIdptMediatorP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            {
                            else if( !*(countT*)pb_idPort )
                            if( !pb_time2 ) break ;
        
                            byteT* pb_time2 = soulC::pbFieldIF( tinP , idType_time2 , flags_time2 , cb_time2 , off + 4 , pbsToM ) ;
                            ZE( countT , cb_time2 ) ;
                            ZE( flagsT , flags_time2 ) ;
                            ZE( countT , idType_time2 ) ;
        
                            byteT* pb_time1 = soulC::pbFieldIF( tinP , idType_time1 , flags_time1 , cb_time1 , off + 3 , pbsToM ) ;
                            ZE( countT , cb_time1 ) ;
                            ZE( flagsT , flags_time1 ) ;
                            ZE( countT , idType_time1 ) ;
        
                            byteT* pb_nn = soulC::pbFieldIF( tinP , idType_nn , flags_nn , cb_nn , off + 2 , pbsToM ) ;
                            ZE( countT , cb_nn ) ;
                            ZE( flagsT , flags_nn ) ;
                            ZE( countT , idType_nn ) ;
        
                            byteT* pb_idPort = soulC::pbFieldIF( tinP , idType_idPort , flags_idPort , cb_idPort , off + 1 , pbsToM ) ;
                            ZE( countT , cb_idPort ) ;
                            ZE( flagsT , flags_idPort ) ;
                            ZE( countT , idType_idPort ) ;
                        {
                        for(;;)
                        ZE( countT , off ) ;
                        if( portTimeC::cFieldsF( tinP ) - 4 ) { BLAMMO ; }
    
                        countT idAdamMediator = pczChannel[ 2 ] ;
                    {
                    if( pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATED && pczChannel[ 2 ] )
                {
                if( pczChannel && pbsToM )
        
                byteT* pbsToM = soulC::pbFieldIF( tinP , idTypesToM , flagssToM , cbsToM , ifcIDfIELDwRAP_TOmEDIATOR , pbsWrapP ) ;
                ZE( countT , cbsToM ) ;
                ZE( flagsT , flagssToM ) ;
                ZE( countT , idTypesToM ) ;

                countT* pczChannel = (countT*)soulC::pbFieldIF( tinP , idTypeC , flagsC , cbC , ifcIDfIELDwRAP_CHANNEL , pbsWrapP ) ;
                ZE( countT , cbC ) ;
                ZE( flagsT , flagsC ) ;
                ZE( countT , idTypeC ) ;
            {
            if( pbidType && *(countT*)pbidType == ifcIDtYPEwRAP_GIFT )
        
            byteT* pbidType = soulC::pbFieldIF( tinP , idTypeidType , flagsidType , cbidType , ifcIDfIELDwRAP_IDtYPE , pbsWrapP ) ;
            ZE( countT , cbidType ) ;
            ZE( flagsT , flagsidType ) ;
            ZE( countT , idTypeidType ) ;
        {
        if( pnRoot && *pnRoot == idptP )
        UNGRABrELAYlISTS
        portTimeC* pnRoot = stIdptOpenP ? (portTimeC*)&stIdptOpenP[ 1 ] : 0 ;
        GRABrELAYlISTS
    {
    if( !idPhaseP || idPhaseP == 1 )

    RELAYiNFOf
{
/*1*/voidT nodeOldC::doWrapLocallyIfIF( tinS& tinP , etherC& etThread , RELAYiNFOpARMS , const byteT* const pbsWrapP , const portTimeC& idptOriginP , const countT idPhaseP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        TELL( "nodeOldC: cleaning up" )
    
        THREADmODE1rESTORE
        DEL( pStPop4 ) ;
        DEL( pStPop3 ) ;
        DEL( pStPop2 ) ;
        DEL( pStPop1 ) ;
        DEL( pStPop0 ) ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        TELL( "deleting bang stacks" )
    
        if( pStPop4 ) { cPoof += *pStPop4 ; }
        if( pStPop3 ) { cPoof += *pStPop3 ; }
        if( pStPop2 ) { cPoof += *pStPop2 ; }
        if( pStPop1 ) { cPoof += *pStPop1 ; }
        if( pStPop0 ) { cPoof += *pStPop0 ; }
        TELL( "unregistering my bang stacks and calc poof" )
        ZE( countT , cPoof ) ;
    
        handleUnregisterIF( tinP , idpt ) ; //P: ENDING NODE DEREGISTERS ITSELF AS HANDLE
    
        sgnDone_tmNodeInitiatorF.waitF( tinP ) ;
        sgnDone_tmNodeKillF.waitF( tinP ) ;
        sgnDone_tmNodePopClientF4.waitF( tinP ) ;
        sgnDone_tmNodePopClientF3.waitF( tinP ) ;
        sgnDone_tmNodePopClientF2.waitF( tinP ) ;
        sgnDone_tmNodePopClientF1.waitF( tinP ) ;
        sgnDone_tmNodePopClientF0.waitF( tinP ) ;
        sgnDone_tmNodeTeatAcceptorF.waitF( tinP ) ;
    
        }
            }
                ++ s ; tinP.pEtScratch->osSleepF( tinP , TUCK * 0x40 ) ;
    
                if( sgnDone_tmNodeTeatAcceptorF ) break ;

                }
                    SCOOPSdEL
                    POOPR
                {
                else
                }
                    break ;
                    SCOOPSdEL
                {
                if( !POOP )
                sock.connectF( tinP , home.idpTeat , (nicNameC&)home.idpTeat , 1 ) ;
                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                SCOOPSnEW
            {
            while( !sgnDone_tmNodeTeatAcceptorF )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        
            //}
            //    while( !POOP && !home.idpTeat ) { ++ s ; tinP.pEtScratch->osSleepF( tinP , TUCK * 0x40 ) ; }
            //    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //    SCOOPS
            //{
        {
        if( bLaunchedAcceptor )
        bQuit = 1 ; //U::ADDED WITHOUT STUDY
    
        }
            }
                }
                    }
                        DEL( pso ) ;
                        SCOOPS
                        pso->etherF( tinP , *tinP.pEtScratch ) ;
                    {
                    else 
                    if( !ether && pso ) etThread.osThreadF( tinP , countTC() , tmNodeServerCatchBagF , 0 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , (countT)pso , (countT)&sListen , (countT)&stIdptPopClient , (countT)&cLooksForNewPing ) ;
                    TELL( "launching tmNodeServerCatchBagF" )
    
                    //else { CONoUTrAW( "z" ) ; } //U::
                    }
                        break ;
                        DEL( pso ) ;
                        SCOOPS
                        pso->etherF( tinP , *tinP.pEtScratch ) ;
                        //etherC::ifcSayIF( T("gasp!") , flSAY_APPEND | flSAY_LOG ) ;
                        TELL( "quitting" )
                    {
                    else if( bQuit )
                    }
                        continue ;
    
                        if( !etThread ) bLaunchedAcceptor = 1 ;
                        etThread.osThreadF( tinP , countTC() , tmNodeTeatAcceptorF , &sgnDone_tmNodeTeatAcceptorF , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS ) ;
                        etThread.osThreadF( tinP , countTC() , tmNodeInitiatorF    , &sgnDone_tmNodeInitiatorF    , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , (countT)&stIdptPopClient , (countT)&cLooksForNewPing , (countT)&bReadyP ) ;
                        etThread.osThreadF( tinP , countTC() , tmNodeKillF         , &sgnDone_tmNodeKillF         , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS ) ;
    
                        }
                            etThread.osThreadF( tinP , countTC() , tmNodePopClientF , &sgnDone_tmNodePopClientF4 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , IDtYPErELAYpOPcLIENTwORK_RIGHT    ) ;
                            etThread.osThreadF( tinP , countTC() , tmNodePopClientF , &sgnDone_tmNodePopClientF3 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , IDtYPErELAYpOPcLIENTwORK_LEFT     ) ;
                            etThread.osThreadF( tinP , countTC() , tmNodePopClientF , &sgnDone_tmNodePopClientF2 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , IDtYPErELAYpOPcLIENTwORK_EXPLODE2 ) ;
                            etThread.osThreadF( tinP , countTC() , tmNodePopClientF , &sgnDone_tmNodePopClientF1 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , IDtYPErELAYpOPcLIENTwORK_EXPLODE1 ) ;
                            etThread.osThreadF( tinP , countTC() , tmNodePopClientF , &sgnDone_tmNodePopClientF0 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , IDtYPErELAYpOPcLIENTwORK_IMPLODE  ) ;
    
                        {
                        if( pStPop0 && pStPop1 && pStPop2 && pStPop3 && pStPop4 )
        
                        TELL( "setting up 2.3" )
                    
                        pStPop4 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        pStPop3 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        pStPop2 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        pStPop1 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        pStPop0 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        TELL( "setting up 2.4" )
                    
                        }
                            if( idpthc && NICnAMElOCAL != ((nicNameC&)(portC&)idpthc).pcId[ 0 ] ) stIdptOpen.sinkF( tinP , countTC() , (byteT*)&idpthc , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossip ) ;
                            portTimeC idpthc = handleQueryIF( tinP ) ;
                        {
                        stIdptOpen.sinkF( tinP , countTC() , (byteT*)&idpt   , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossip ) ;
                        //P: A NEWBIE CLIENT KNOWS ABOUT ITSELF AND THE HANDLE
            
                        DEL( pso ) ;
                        }
                            }
                                etThread.traceF( tinP , T("could not write sBagOk for woth client") ) ;
                                POOPRqUIET
                            {
                            if( POOP )
                            pso->writeF( tinP , sBagOk ) ;
                            soulC sBagOk( tinP , TAG( TAGiDnULL ) , flSOUL_null , (countT)ifcIDtYPEbAG_SERVERoK ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        bWoth = 0 ;
                        pso->etherF( tinP , *tinP.pEtScratch ) ;
                        etThread.traceF( tinP , T("writing woth bag ifcIDtYPEbAG_SERVERoK") ) ;
                    {
                    if( bWoth ) //WOTH CLIENT MUST NOT BE REFUSED
            
                    }
                        //CONoUT( "client accepted" ) ;
                        //etThread.traceF( tinP , T("accepted [nnPeer,idPortPeer]:    ")+T(nnPeer)+T("    ")+TF2(idPortPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        sListen.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ;
                        ZE( countT , idPortPeer ) ;
                        nicNameC nnPeer ;
                        boolT bRefuse = /*++ idClient == tinP.monitor.idThread && !( bRefused ++ ) ? 1 :*/ 0 ;
                        //static boolT bRefused ;
                    {
                    TELL( "waiting for a client to connect" )
                    ZE( socketC* , pso ) ;
        
                    if( bWoth ) etThread.osThreadF( tinP , countTC() , tmNodeTickleF , 0 , flTHREADlAUNCH_null , 0 , (countT)(portC*)&idpt , (countT)&bWoth ) ;
                {
                while( !POOP && !ether && !bQuit )
                ZE( countT , idClient ) ;
                boolT bWoth = 1 ;
            
                etThread.osTimeNowF( tinP , timeB1 , timeB2 ) ;
                ZE( sCountT , timeB2 ) ;
                ZE( countT  , timeB1 ) ;
            
                TELL( "setting up 2.b" )
                if( !ether ) sListen.listenF( tinP ) ;
                TELL( "setting up 2.c" )
            {
            if( idpt )
            TELL( "setting up 2" )
        {
        signC sgnDone_tmNodeInitiatorF( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmNodeKillF( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmNodePopClientF4( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmNodePopClientF3( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmNodePopClientF2( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmNodePopClientF1( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmNodePopClientF0( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmNodeTeatAcceptorF( tinP , TAG( TAGiDnULL ) ) ;
        ZE( boolT , bLaunchedAcceptor ) ;
        ZE( countT , cLooksForNewPing ) ;
        stackC*& pStPop4 = *(stackC**)&_c8ni2P.c1 ;
        stackC*& pStPop3 = *(stackC**)&_c8ni1P.c8 ;
        stackC*& pStPop2 = *(stackC**)&_c8ni1P.c7 ;
        stackC*& pStPop1 = *(stackC**)&_c8ni1P.c6 ;
        stackC*& pStPop0 = *(stackC**)&_c8ni1P.c5 ;
    
        count8S _c8ni3P( (countT)&idSerialLathHeader , (countT)&idPortOrigin , (countT)&swsIdSerialReceived , (countT)&bAltSws , (countT)&cLeverPayload , (countT)&swsWrapRef ) ;
        count8S _c8ni2P( 0 , (countT)&stIdptTemp , (countT)&stIdptOpen , (countT)&stIdptGossip , (countT)&idAdamMediator , (countT)&swsIdptMediator , (countT)&swsIdptMediatorAlt , (countT)&cGossipIn ) ;
        count8S _c8ni1P( (countT)&idpt , (countT)&bQuit , (countT)&stPsoServer , (countT)&swsIdSerialReceived , 0 , 0 , 0 , 0 ) ;
    
        ZE( boolT , bAltSws ) ;
        ZE( countT , idSerialLathHeader ) ;
        ZE( countT , cGossipIn ) ;
        ZE( boolT , bTalk ) ;
    
        //}
        //    }
        //        if( !cTries && !handleQueryIF( tinP ) ) handleRegisterMeIfIF( tinP , idpt ) ; //P: A NEWBIE NODE WILL POLL FOR 4 TOCKS BEFORE REGISTERING ITSELF AS HANDLE
        //
        //        }
        //            if( handleQueryIF( tinP ) ) break ;
        //            ether.osSleepF( tinP , TOCK ) ;
        //        {
        //        while( !ether && cTries && cTries -- )
        //        countT cTries = TUCK / /* 8 */0x40 ;
        //        sleepC s( tinP , TAG( TAGiDnULL ) ) ; //GIVE EXISTING NODES TIME TO ASSUME THE HANDLE ROLE
        //    {
        //{
        //if( !handleQueryIF( tinP ) )
    
        idpt.timeStampIfF( tinP , etThread ) ;
        idpt = idPort ;
        portTimeC idpt ;
    
        idPort = socketC::nicNameIF( tinP , etThread ) ;

        sListen.etherF( tinP , etThread ) ;

        }
            }
                }
                    idpTry ++ ;
                    etThread.traceF( tinP , T("could not bind to requested port [idPort]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    idPort = portC() ;
                    POOPRqUIET
                {
                else
                }
                    break ;
                    etThread.traceF( tinP , T("bind aok to requested port [idPort]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( !POOP )
                idPort = sListen.bindF( tinP , idpTry , nicNameC() , 1 ) ;
            {
            for(;;)
            countT idpTry = ifcIDpORT_RELAY ;

            SCOOPS
        {
        portC idPort ;
        socketC sListen( tinP , *tinP.pEtScratch , TAG( TAGiDnULL )/*U:: , 0 , flSOCKETc_TOPsECRET*/ ) ;
    {
    IFsCRATCH

    portTimeC idptHandle = handleQueryIF( tinP ) ;

    switchStackC swsWrapRef( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , cLeverPayload , flSTACKc_FIFO|flSTACKc_GIVEsIGNnEWpLATE ) ;
    ZE( countT , cLeverPayload ) ;
    homeS& home = homeS::homeIF() ;
    ZE( boolT , bQuit ) ;
    ranUniC ruZeWo( tinP , 1 , 1 ) ;
    const countT cKidThreadsSave = tinP.cKidThreads ;

    switchStackC swsIdptMediatorAlt(    tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idAdamMediator , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    switchStackC swsIdptMediator(       tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idAdamMediator , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    ZE( countT , idAdamMediator ) ;
    stackC stIdptPopClient(             tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    stackC stIdptGossip(                tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ; // { idpt , timeBorn1 , timeBorn2 }, SORTED BY TIME BORN
    stackC stIdptOpen(                  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ; // { idpt , timeBorn1 , timeBorn2 }, SORTED BY TIME BORN
    stackC stIdptTemp(                  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ; // { idpt , timeBorn1 , timeBorn2 }, SORTED BY TIME BORN
    switchStackC swsIdSerialReceivedAlt( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , pbLever , sizeof idPortOrigin ) ;
    switchStackC swsIdSerialReceived(    tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , pbLever , sizeof idPortOrigin ) ;
    const byteT* pbLever = (const byteT*)&idPortOrigin ;
    portC idPortOrigin ;
    stackC stPsoServer(                  tinP , etThread , TAG( TAGiDnULL ) ) ;
    etherC& ether = etherC::etPrimeIF() ;
    _IO_
{
/*1*/nodeOldC::nodeOldC( tinS& tinP , etherC& etThread , boolT& bReadyP )/*1*/





#include postADAMhEADER


/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

