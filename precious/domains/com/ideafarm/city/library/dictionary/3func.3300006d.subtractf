
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return sgn ;

    _OUT_

    }
        if( !tinP.pPoolUse ) pcpP = 0 ;

        ;
                : 0
                ? 1
            : (sCountT)pcpP[ *pcpP ] > 0
            ? - 1
        sgn = (sCountT)pcpP[ *pcpP ] < 0

        }
            if( bSignedP ) while( *pcpP > 1 && pcpP[ *pcpP ] == - 1 && (sCountT)pcpP[ *pcpP - 1 ] < 0 ) -- *pcpP ;
    
            while( *pcpP > 1 && !pcpP[ *pcpP ] ) -- *pcpP ;
    
            }
                pcpP[ offi ] -- ;
                ++ *pcpP ;
            {
            if( bCarry && !bSignedP )
    
            }
                if( pcpP[ offi ] > save ) bCarry = 1 ;
        
                pcpP[ offi ] -= pcp2P[ offi ] ;
                countT save = pcpP[ offi ] ;
        
                }
                    bCarry = pcpP[ offi ] == - 1 ;
                    pcpP[ offi ] -- ;
                {
                if( bCarry )
            {
            for( offi = 1 ; offi <= cci ; offi ++ )
            ZE( countT , offi ) ;
            const countT cci = *pcp2P ;
            ZE( boolT , bCarry ) ;
    
            }
                *pcpP += *pcp2P - *pcpP ;
    
                }
                    for( countT offo = *pcpP + 1 ; offo <= *pcp2P ; offo ++ ) pcpP[ offo ] = - 1 ; //PROPOGATE SIGN
                {
                if( (sCountT)pcpP[ *pcpP ] < 0 )
            {
            if( *pcpP < *pcp2P )
    
            thirdC::c_memcpyIF( tinP , (byteT*)pcpP , (byteT*)pcp1P , sizeof( countT ) * ( 1 + *pcp1P ) ) ;
            thirdC::c_memsetIF( tinP , (byteT*)pcpP , sizeof( countT ) * ( 2 + ccMax ) ) ;
        {
        if( pcpP )

        }
            POSTPONEtEST( pcpP ) ;
            PUSE.newF( tinP , LF , *(byteT**)&pcpP , sizeof( countT ) * ( ( 1 + !bSignedP ) + ccMax ) ) ; ___( pcpP ) ;
        {
        else
        if( !tinP.pPoolUse ) pcpP = pcpi ;
    {
    if( !POOP )
    ZE( sCountT , sgn ) ;

    __( sizeof pcpi < ( 1 + ccMax ) * sizeof( countT ) ) ;

    ;
        : *pcp2P
        ? *pcp1P
    const countT ccMax = *pcp1P > *pcp2P

    _INoLD_

    }
        if( POOP ) return 0 ;
        __( !tinP.pPoolUse && tinP.monitor.idThread != 1 ) ;
        __Z( pcp2P ) ;
        __Z( pcp1P ) ;
        __NZ( pcpP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/sCountT subtractF( tinS& tinP , countT*& pcpP , countT* const pcp1P , const countT* const pcp2P , const boolT bSignedP )/*1*/

countT pcpi[ TUCK ] ;

/**/
*/
 -1: pcp1P < pcp2P
 0: pcp1P == pcp2P
 1: pcp1P > pcp2P
i evaluate to wo of {-1,0,1}
i calculate pcp1P - pcp2P
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

