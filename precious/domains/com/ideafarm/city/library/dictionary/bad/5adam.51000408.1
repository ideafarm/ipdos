
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE
//DISCARDABLE

REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    ether.osSleepF( tinP , TUCK * 0x20 ) ;

    }
        etThread.delF( tinP , pc8i ) ;
        }
            etThread.delF( tinP , psttThreadName ) ;
            etThread.strokeF( tinP , TF3(pc8i->c1,0,9)+TF3(pc8i->c2,0,9)+TF3(pc8i->c3,0,9)+TF3(pc8i->c4,0,9)+T(psttThreadName)+T("\r\n") ) ;
            strokeS* psttThreadName = (strokeS*)pc8i->c5 ;
        {
        if( pc8i )
        stLines >> pc8i ;
        ZE( count8S* , pc8i ) ;
    {
    while( stLines )
    etThread.strokeF( tinP , T("\f") ) ;

    etThread.osThreadSwitchingOnF( tinP ) ;
    ungrabF( tinP , ps.grab_off_aIdaTin ) ;
    }
        }
            }
                stLines.sinkF( tinP , countTC() , pc8i , 0 , subtract_a040104_F ) ;
                pc8i->c5 = (countT)psttThreadName ;
                pc8i->c4 = tin.idStep   ;
                pc8i->c3 = tin.idiOwner ;
                pc8i->c2 = tin.idThread ;
                pc8i->c1 = tin.idClient ;

                etThread.strMakeF( tinP , psttThreadName , T(tin.postThreadName) ) ; ___( psttThreadName ) ;
                ZE( strokeS* , psttThreadName ) ;
            {
            if( pc8i )
            etThread.newF( tinP , LF , pc8i ) ; ___( pc8i ) ;
            ZE( count8S* , pc8i ) ;

            tinS& tin = *(tinS*)(byteT*)ap_artmentOldC( tinP , pcIdaTin[ idIda ] ) ;

            if( !pcIdaTin[ idIda ] ) break ;
        {
        for( countT idIda = 1 ; idIda <= ccIdaTin ; idIda ++ )
        countT  ccIdaTin = *pcIdaTin ;
    {
    if( pcIdaTin )
    countT* pcIdaTin = (countT*)(byteT*)ap_artmentOldC( tinP , ps.off_aIdaTin ) ;
    grabF( tinP , ps.grab_off_aIdaTin ) ;
    etThread.osThreadSwitchingOffF( tinP ) ; // PREVENTS ANOTHER THREAD FROM CREATING A DEBUG EVENT THAT DEADLOCKS ON ps.grab_off_aIdaTin
{
while( !ether && !etThread )
stackC stLines( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_count8S ) ;
poolOld SideS& ps = poolC::poolOldRootIF( tinP ) ;
ZE( countT , idTry ) ;

TODO

}
    return scSgn ;
    #endif
        if( tinP.fingerprint && c1P && c2P && pEtherP && c3P ) ;
    #else
        if( c3P ) ;
        }
            scSgn = ether.strCompareF( tinP , (countT*)c1P , (countT*)c2P , 2 ) ;
            etherC& ether = *(etherC*)pEtherP ;
        {
        if( pEtherP )
    #if !defined( __SW_ZM )
    ZE( sCountT , scSgn ) ;

    }
        if( !c1P || !c2P ) return 0 ;
    {
    IFbEcAREFUL
{
countT subtract_a040104_F( tinS& tinP , countT& pEtherP , countT& c1P , countT& c2P , countT& c3P )

/*1*/WAKEhIDE( "utility.monitor.threads" )/*1*/
/**/
*/
\<A HREF=\"5.a040104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

