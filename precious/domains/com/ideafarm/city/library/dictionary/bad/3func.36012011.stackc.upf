
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pv ? *pv : *(countT*)pbnu ;

    _OUTbATONsTACKc_
    }
        handleP.osF( ifcIDtYPEhANDLE_STACKwALK , (countT)(*p_ppLathRef)->ppU ) ;
        pv = &PLATE_countT_REF( *p_ppLathRef ) ;

        }
            setIdLathRefF( tinP ) ;
            *p_idLathRef = 0 ;
        {
        else
        }
            }
                setIdLathRefF( tinP ) ;
                *p_idLathRef = 0 ;
            {
            else if( ppBefore      != *p_ppLathRef )
            //U::else if( ppBefore->ppD == *p_ppLathRef ) ++ *p_idLathRef ;
            //U::     if( ppBefore->ppU == *p_ppLathRef ) -- *p_idLathRef ;
            else if( (plateS*)ppBefore->ppD == *p_ppLathRef ) ++ *p_idLathRef ;
                 if( (plateS*)ppBefore->ppU == *p_ppLathRef ) -- *p_idLathRef ;
        {
        if( ppBefore )
        *p_ppLathRef = (plateS*)handleP.osF( ifcIDtYPEhANDLE_STACKwALK ) ;
        plateS* ppBefore = *p_ppLathRef ;

        LATHrEF
    {    
    if( ~handleP )
    ZE( countT* , pv ) ;

    if( !handleP ) handleP.osF( ifcIDtYPEhANDLE_STACKwALK , (countT)ppBottom ) ;
    _INbATONsTACKc_

    }
        }
            return *(countT*)pbnu ;
            handleP.osF( ifcIDtYPEhANDLE_STACKwALK , 0 ) ; //TO PREVENT CPU SPIN IF *this IS IMPOTENT
        {
        if( POOP )
    {
    IFbEcAREFUL

    // ASSUME: handleP IS EITHER 0 OR POINTS TO THE PLATE WHOSE VALUE IS TO BE RETURNED
    SCOOP
{
/*1*/countT& stackC::upF( tinS& tinP , handleC& handleP )/*1*/
/**/
*/
 handleP
arguments
see the documentation for stackC::downF
 instead, construct the stackC object as a fifo stack, and use downF to retrieve its values in normal order
this function should not be used to implement a fifo stack
 warning: code that fails to do this for ifcSTACKtYPE_nicNameC will work for IPv4 but will fail for IPv6 long values
 for example, if idType == ifcSTACKtYPE_nicNameC, my value stFoo[ 2 ] must be cast to *(nicNameC*)&stFoo[ 2 ]
the application must cast my value to a reference to the appropriate class when the data on each plate is not of size sizeof( countT )
 for a fifo stack, upF retrieves the plate values in lifo order
 for a normal (lifo) stack, upF retrieves the plate values in fifo order
call this repeatedly to obtain each value in the stack in reverse order (bottom up)
  \<A HREF=\"5.cd10104.1.1.0.html\"\>cd10104:  WAKEsHOW( "example.simplest.func.1150011.stackC.upF" )\</A\>
 simplest
examples
\<A HREF=\"5.1150011.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$upF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

