
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            break ;
            ether.delF( tinP , psttw ) ;
            }
                //E.G. POPUPsOIXLoLD(/*5*/osTextT*/*5*/postP)
                //ALT: REQUIRE TYPING INFO TO BE PRESENT IN THE MACRO #define STATEMENT WO'TH TOKEN
                //ISSUE: SHOULD SUPPORT FOR MACRO (SUCH AS POPUP) BE HARDCODED HERE OR GENERATED: CONJ: HANDCODED HERE (THERE IS NO TYPE INFO IN THE MACRO)
                //ISSUE: SHOULD SUPPORT FOR GLOBAL API'S BE HARDCODED HERE OR GENERATED: CONJ: GENERATED AND INCLUDED HERE
                //DO NOT PUT API'S TO CLASSES HERE; DERIVE CLASSES FROM baseSoilXxxxC; SEE etherC AS AN EXAMPLE

                else if( !( F(tinP.flagsThreadMode2) & flTHREADmODE2_SOIXLoLDnOpOPUPoNeRROR ) ) { POPUPsOIXLoLD( T("The word \"")+T(psttw)+T("\" is not a root word.") ) ; }
                }
                    }
                        ether.delF( tinP , psttw ) ;

                        POPUPsOIXLoLD( T(psttw) ) ;
                        //CONoUTrAW( T("POPUP suppressed: \"")+T(psttw)+T("\"\r\n") ) ;

                        slP >> psttw ; ___( psttw ) ; idArgNext ++ ;
                        ZE( strokeS* , psttw ) ;
                    {
                    else
                    IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_strokeSptr )
                {
                else if( !ether.strCompareF( tinP , psttw , T("POPUP") ) )
                }
                {
                else if( !ether.strCompareF( tinP , psttw , T("null") ) )
                }
                    }
                        }
                            PUSE( tinP , *(byteT**)&psttDo ) ;
                            PUSE( tinP , *(byteT**)&psttExpr ) ;
                        
                            }
                                if( bAbort ) break ;

                                }
                                    }
                                        break ;
                                        slP >> vv ; idArgNext ++ ;
                                        ZE( countT , vv ) ;
                                    {
                                    if( !cExpr )
                                    countT& cExpr = slP.cFieldF( tinP ) ;
                                    bAbort = 0 ;
                                {
                                else
                                IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_countT )
                                slP << psttExpr O(*pParser) ;
                                boolT bAbort = 1 ;

                                slP << psttDo O(*pParser) ;
                            {
                            for(;;)
                    
                            slP >> psttDo ; ___( psttDo ) ; idArgNext ++ ;
                            ZE( strokeS* , psttDo ) ;
                        {
                        else
                        IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_strokeSptr )
                
                        slP >> psttExpr ; ___( psttExpr ) ; idArgNext ++ ;
                        ZE( strokeS* , psttExpr ) ;
                    {
                    else
                    IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_strokeSptr )
                {
                else if( !ether.strCompareF( tinP , psttw , T("dowhile") ) )
                }
                    }
                        }
                            PUSE( tinP , *(byteT**)&psttDo ) ;
                            PUSE( tinP , *(byteT**)&psttExpr ) ;
                        
                            }
                                if( bAbort ) break ;

                                }
                                    slP << psttDo O(*pParser) ;
                                    }
                                        break ;
                                        slP >> vv ; idArgNext ++ ;
                                        ZE( countT , vv ) ;
                                    {
                                    if( !cExpr )
                                    countT& cExpr = slP.cFieldF( tinP ) ;
                                    bAbort = 0 ;
                                {
                                else
                                IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_countT )
                                slP << psttExpr O(*pParser) ;
                                boolT bAbort = 1 ;
                            {
                            for(;;)
                    
                            slP >> psttDo ; ___( psttDo ) ; idArgNext ++ ;
                            ZE( strokeS* , psttDo ) ;
                        {
                        else
                        IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_strokeSptr )
                
                        slP >> psttExpr ; ___( psttExpr ) ; idArgNext ++ ;
                        ZE( strokeS* , psttExpr ) ;
                    {
                    else
                    IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_strokeSptr )
                {
                else if( !ether.strCompareF( tinP , psttw , T("whiledo") ) )
                }
                    }
                        }
                            }
                                }
                                    PUSE( tinP , *(byteT**)&psttEpilog ) ;
                                    PUSE( tinP , *(byteT**)&psttDo ) ;
                                    PUSE( tinP , *(byteT**)&psttProlog ) ;
                                    PUSE( tinP , *(byteT**)&psttExpr ) ;
                        
                                    }
                                        if( bAbort ) break ;
            
                                        }
                                            slP << psttProlog O(*pParser) << psttDo O(*pParser) << psttEpilog O(*pParser) ;
                                            }
                                                break ;
                                                slP >> vv ; idArgNext ++ ;
                                                ZE( countT , vv ) ;
                                            {
                                            if( !cExpr )
                                            countT& cExpr = slP.cFieldF( tinP ) ;
                                            bAbort = 0 ;
                                        {
                                        else
                                        IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_countT )
                                        slP << psttExpr O(*pParser) ;
                                        boolT bAbort = 1 ;
                                    {
                                    for(;;)
                    
                                    slP >> psttEpilog ; ___( psttEpilog ) ; idArgNext ++ ;
                                    ZE( strokeS* , psttEpilog ) ;
                                {
                                else
                                IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_strokeSptr )
                    
                                slP >> psttDo ; ___( psttDo ) ; idArgNext ++ ;
                                ZE( strokeS* , psttDo ) ;
                            {
                            else
                            IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_strokeSptr )
                
                            slP >> psttProlog ; ___( psttProlog ) ; idArgNext ++ ;
                            ZE( strokeS* , psttProlog ) ;
                        {
                        else
                        IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_strokeSptr )
                
                        slP >> psttExpr ; ___( psttExpr ) ; idArgNext ++ ;
                        ZE( strokeS* , psttExpr ) ;
                    {
                    else
                    IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_strokeSptr )
                {
                else if( !ether.strCompareF( tinP , psttw , T("for") ) )
                }
                    }
                        }
                            }
                                slP O(*pParser) ;
                        
                                PUSE( tinP , *(byteT**)&psttThen ) ;
                                PUSE( tinP , *(byteT**)&psttElse ) ;
                        
                                else        slP << psttElse ;
                                if( bThen ) slP << psttThen ;
                        
                                slP >> bThen ; idArgNext ++ ;
                                ZE( boolT , bThen ) ;
                            {
                            else
                            IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_countT )
                    
                            slP >> psttThen ; ___( psttThen ) ; idArgNext ++ ;
                            ZE( strokeS* , psttThen ) ;
                        {
                        else
                        IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_strokeSptr )
                
                        slP >> psttElse ; ___( psttElse ) ; idArgNext ++ ;
                        ZE( strokeS* , psttElse ) ;
                    {
                    else
                    IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_strokeSptr )
                {
                else if( !ether.strCompareF( tinP , psttw , T("if") ) )
                }
                    }
                        slP << ++ vv ;
                        slP >> vv ; idArgNext ++ ;
                        ZE( countT , vv ) ;
                    {
                    else
                    IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_countT )
                {
                else if( !ether.strCompareF( tinP , psttw , T("++") ) )
                }
                    }
                        slP << -- vv ;
                        slP >> vv ; idArgNext ++ ;
                        ZE( countT , vv ) ;
                    {
                    else
                    IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_countT )
                {
                else if( !ether.strCompareF( tinP , psttw , T("--") ) )
                }
                    }
                        slP << vv << vv ;
                        slP >> vv ; idArgNext ++ ;
                        ZE( countT , vv ) ;
                    {
                    else
                    IFbADpEEK( slP , psttw , ifcIDtYPEsOULiTEM_countT )
                {
                else if( !ether.strCompareF( tinP , psttw , T("dup") ) )
                }
                    POPUP( T(postName)+T(": \"?\" received.") ) ;
                {
                if( !ether.strCompareF( tinP , psttw , T("?") ) )
            
                ZE( countT , cbFieldNext ) ;
                ZE( flagsT , flagsNext ) ;
                ZE( countT , idTypeNext ) ;
                ZE( byteT* , pbFieldNext ) ;
                countT idArgNext = 1 ;
            {
            if( psttw && pParser )

            slP >> *(baseSoilXxxxC**)&pParser ;
            ZE( soixlOldSpaceC* , pParser ) ;

            slP >> psttw ; ___( psttw ) ;
            ZE( strokeS* , psttw ) ;
        {
        case ifcIDcMDbASE_CMDdEFAULT :
        }
            break ;
            slP.flags = save ;
            slP << (baseSoilXxxxC*)this ;
            slP.flags &= ~( F(flSOUL_LIVE) ) ;
            flagsT save = slP.flags ;
        {
        case ifcIDcMDbASE_REFERENCE :
        }
            break ;
        {
        case ifcIDcMDbASE_TOCK :
        }
            break ;
        {
        case ifcIDcMDbASE_TICK :
        }
            break ;
            slP << (strokeS*)T(postName) ;
        {
        case ifcIDcMDbASE_INSTANCEnAME :
        }
            break ;
            slP << (strokeS*)T(tinP.pAdamGlobal1->_rootWordC_.postOldClassName) ;
        {
        case ifcIDcMDbASE_CLASSnAME :
    {
    switch( idCmdBase )
    slP >> idCmdBase ;
    ZE( countT , idCmdBase ) ;

    }
        if( pMeI != (baseSoilXxxxC*)this ) { BLAMMO ; }
        slP >> pMeI ;
        ZE( baseSoilXxxxC* , pMeI ) ;
    {
{
/*1*/voidT rootWordC::operator ()( tinS& tinP , soulC& slP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

