
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbData ;

    //}
    //    LOGrAWtID2( "tinS::newF [pb]: " , pbData ) //U:: TO FIND A BUG: REMOVE IN PRODUCTION FOR SPEED
    //    tinS& tinP = *this ;
    //{

    }
        }
            cTls ++ ;
            if( postNameP ) thirdC::c_memsetIF( tinP , pbData , cbP ) ; //staticC RELIES ON THIS LINE TO SMUDGE ITS FOOT FINGERPRINTS
            pbData = pbc ;
            if( pbe < pbc + cbP ) { BLAMMO ; } //IF BLOW HERE THEN NEED TO MAKE TLS LARGER FOR THIS THREAD

            }
                thirdC::c_memcpyIF( tinP , pbc , postInGroupP , costaInGroupP )  ; pbc += costaInGroupP    ; // postInGroup
                if( pbe < pbc + costaInGroupP ) { BLAMMO ; } //IF BLOW HERE THEN NEED TO MAKE TLS LARGER FOR THIS THREAD
            {
            if( costaInGroupP )
            }
                thirdC::c_memcpyIF( tinP , pbc , postNameP , costaNameP )           ; pbc += costaNameP       ; // postName
                if( pbe < pbc + costaNameP ) { BLAMMO ; } //IF BLOW HERE THEN NEED TO MAKE TLS LARGER FOR THIS THREAD
            {
            if( costaNameP )
            *(countT*)pbc = costaInGroupP                                                        ; pbc += sizeof( countT ) ; // costaInGroup
            *(countT*)pbc = costaNameP                                                           ; pbc += sizeof( countT ) ; // costaName
            *(countT*)pbc = 0                                                                    ; pbc += sizeof( countT ) ; // offNextInGroup
            *(countT*)pbc = 0                                                                    ; pbc += sizeof( countT ) ; // offNextObject
            *(countT*)pbc = offElder                                                             ; pbc += sizeof( countT ) ; // offElder
            *(countT*)pbc = 1                                                                    ; pbc += sizeof( countT ) ; // cRef
            *(countT*)pbc = sizeof( countT ) * 6 + costaNameP + costaInGroupP + cbP              ; pbc += sizeof( countT ) ; // cbEntry
            //if( tinP.pc Utility[ 0 ] && costaInGroupP ) { CONoUTrAW( postInGroupP ) ; CONoUTrAW( "\r\n" ) ; }
            //if( tinP.pc Utility[ 0 ] && costaNameP    ) { CONoUTrAW( postNameP    ) ; CONoUTrAW( "\r\n" ) ; }
            //if( tinP.pc Utility[ 0 ]                  ) { CONoUTrAW3( "tinS::newF/entry formatted at " , (countT)pbc , "\r\n" ) ; }
            //if( tinP.pc Utility[ 0 ] ) tinP.pc Utility[ 1 ] ++ ;
            const byteT* const pbe = pbTls + cbTls ;
            byteT*             pbc = pbTls + offTopEntry ;
        
            }
                }
                    offCursor = ( (countT*)( pbTls + offCursor ) )[ TLSeNTRYoFF_offElder ] ;
        
                    }
                        break ;
                        offNextInGroup = offTopEntry ;
                        if( offNextInGroup ) { BLAMMO ; }
                        countT& offNextInGroup = ( (countT*)( pbTls + offCursor ) )[ TLSeNTRYoFF_offNextInGroup ] ;
                    {
                    )
                        ( costaInGroupP && postInGroup && !thirdC::c_strcmpIF( tinP , postInGroup , postInGroupP ) )
                        ||
                        ( !costaInGroup && !costaInGroupP )
                    (
                    if
        
                    const osTextT* const postInGroup  = !costaInGroup ? 0 : (byteT*)&costaInGroup + sizeof( countT ) + costaName ;
                    countT&              costaInGroup = ( (countT*)( pbTls + offCursor ) )[ TLSeNTRYoFF_costaInGroup ] ;
                    countT&              costaName    = ( (countT*)( pbTls + offCursor ) )[ TLSeNTRYoFF_costaName    ] ;
                {
                while( offCursor )
                countT offCursor = offElder ;
        
                offNextObject = offTopEntry ;                                               // elder.offNextObject
                if( offNextObject ) { BLAMMO ; }
                countT& offNextObject = ( (countT*)( pbTls + offElder ) )[ TLSeNTRYoFF_offNextObject ] ;
            {
            if( offElder )

            if( cbTls <= offTopEntry + 7 * sizeof( countT ) ) { BLAMMO ; } //IF BLOW HERE THEN NEED TO MAKE TLS LARGER FOR THIS THREAD
            if( cbTls <= offTopEntry                        ) { BLAMMO ; } //IF BLOW HERE THEN THE FOLLOWING CODE HAS A BUG
        
            ;
                : offElder + sizeof( countT ) + ( (countT*)( pbTls + offElder ) )[ TLSeNTRYoFF_cbEntry ]
                ? sizeof( countT )
            offTopEntry = !offElder
            const countT offElder = offTopEntry ;

            }
                }
                    countT foo = 2 ;
                {
                if( idIn == 0x16256 )

                countT idIn = 1 + incv02AM( idInLath ) ;
            {
            if( tinP.monitor.idThread == 1 )
            static countT idInLath ;
            //U:: TO CATCH A BUG
        {
        if( !pbData )
    
        }
            }
                offMe = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_offElder ] ;
        
                }
                    }
                        break ;
                        pbData = (byteT*)&costaInGroup + sizeof( countT ) + costaName + costaInGroup ;
                        __( !( cRef ++ ) ) ;
                        countT& cRef = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_cRef ] ;
                    {
                    if( postName && !thirdC::c_strcmpIF( tinP , postName , postNameP ) )
                {
                if( !postInGroupP || ( postInGroup && !thirdC::c_strcmpIF( tinP , postInGroup , postInGroupP ) ) )
        
                const osTextT* const postInGroup  = !costaInGroup ? 0 : (byteT*)&costaInGroup + sizeof( countT ) + costaName ;
                const osTextT* const postName     = !costaName    ? 0 : (byteT*)&costaInGroup + sizeof( countT ) ;
                countT&              costaInGroup = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_costaInGroup ] ;
                countT&              costaName    = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_costaName    ] ;
            {
            while( offMe )
            countT offMe = costaNameP ? offTopEntry : 0 ;
        {
        countT& offTopEntry = *(countT*)pbTls ;
    
        const countT costaInGroupP = !postInGroupP ? 0 : 1 + thirdC::c_strlenIF( tinP , postInGroupP ) ;
        const countT costaNameP    = !postNameP    ? 0 : 1 + thirdC::c_strlenIF( tinP , postNameP    ) ;
    {
    ZE( byteT* , pbData ) ;
    POOPIES

    }
        scoopC _scoop( tinP , _poop ) ;
        poopC _poop( flPOOP_SMELLY ) ;
    {
    //THIS BUG WAS FOUND; IT WAS A ZOMBIE tinP REFERENCE; THE TEST IS RETAINED TO DETECT NEW INTRODUCTIONS OF THAT BUG

    }
        *pcBlammo = -1 ;
        ZE( countT* , pcBlammo ) ;

        LOGrAW(    postSay ) ;
        CONoUTrAW( postSay ) ;

        ;
            : "\r\nerror:  tlsNewF called on raw thread (tmBreakF)\r\n"
            ? "\r\nerror:  tlsNewF called on raw thread (tmHeartF)\r\n"
        osTextT* postSay = tinP.idTinNamed == ifcIDtINnAMED_tinHeartI
    {
    if( tinP.idTinNamed == ifcIDtINnAMED_tinHeartI || tinP.idTinNamed == ifcIDtINnAMED_tinBreakI  ) // RAW THREAD, SO CANNOT CALL TINSL

    _IO_

    tinS& tinP = *this ;
{
/*1*/byteT* tinS::tlsNewF( const countT cbP , const osTextT* const postNameP , const osTextT* const postInGroupP )/*1*/

//
//    postInGroup
//    postName
//    costaInGroup (includes null terminator; if 0 then class is unnamed)
//    costaName (includes null terminator; if 0 then object is unnamed)
//    offNextInGroup (set to 0 by constructing entry)
//    offNextObject (set to 0 by constructing entry; if null then terminates the tls stack
//    offElder (address of entry immediately below me) (0 indicates that i am the bottommost entry)
//    cRef (number of instances including the constructing instance; is never 0)
//    cbEntry (exclusive prefix)
//   tls entry
//    offTopEntry (address of lath entry constructed); this is redundant; it is for speed and to detect corruption
//   tls header
//
// TLS LAYOUT

/**/
*/
caller must d elete tls pointers lifo
if i allocate unnamed bytes then i do not initialize them
if i allocate named bytes then i initialize those bytes to 0
if there was no bytes associated with this name and group, i allocate those bytes
i evaluate to the address of cbP bytes associated with the specified name and group
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

