
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.loafIF( tinP ) ;
etThread.osThreadF( tinP , countTC() , tmWorkF , 0 , flTHREADlAUNCH_null , 0 , 1/*U::OBSOLETE*/ ) ;
etThread.osThreadF( tinP , countTC() , tmWorkF , 0 , flTHREADlAUNCH_null , 0 , 1 ) ;

TODO

DONE( tmWorkF )
}
    }
        if( POOP ) POOPR
        }
            }
                sgnDone_tmPutPayloadsF.waitF( tinP ) ;
                bQuit = 1 ;
                }
                    }
                        else       { etThread.strokeF( tinP , T("payload arrived\r\n") ) ; }
                        if( POOP ) POOPR
    
                        idptRelay << sIn ;
                        idPortTimeC idptRelay ;
    
                        sIn >> sPay ;
                        soulC sPay( tinP , TAG( TAGiDnULL ) ) ;
    
                        sIn >> flags ;
                        ZE( flagsT , flags ) ;
    
                        sIn >> sToMediator ;
                        soulC sToMediator( tinP , TAG( TAGiDnULL ) ) ;
    
                        sIn >> sTo ;
                        soulC sTo( tinP , TAG( TAGiDnULL ) ) ;
    
                        etThread.delF( tinP , pczChannel ) ;
                        sIn >> pczChannel ;
                        ZE( countT* , pczChannel ) ;
                    {
                    else if( idCmd == ifcIDtYPEwRAP_GIFT )
                         if( idCmd == ifcIDtYPEwRAP_QUIT    ) break ;
            
                    sIn >> idCmd ;
                    ZE( countT , idCmd ) ;
            
                    __( idVersion - 1 ) ;
                    sIn >> idVersion ;
                    ZE( countT , idVersion ) ;
            
                    __( idProtocol - ifcIDpROTOCOL_RELAYwRAP ) ;
                    sIn >> idProtocol ;
                    ZE( countT , idProtocol ) ;
            
                    etThread.delF( tinP , psttTradeMark ) ;
                    __( tinP.pEtScratch->strCompareF( tinP , psttTradeMark , T("IdeaFarm " "(tm)") ) ) ;
                    sIn >> psttTradeMark ;
                    ZE( strokeS* , psttTradeMark ) ;
            
                    sock.readF( tinP , sIn ) ;
                    soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                {
                while( !ether && !etThread && !POOP )
    
                etThread.osThreadF( tinP , countTC() , tmPutPayloadsF , &sgnDone_tmPutPayloadsF , flTHREADlAUNCH_null , 0 , (countT)&sock , (countT)&bQuit ) ;
                signC sgnDone_tmPutPayloadsF( tinP , TAG( TAGiDnULL ) ) ;
                ZE( boolT , bQuit ) ;
            
                sock.connectF( tinP , idpTeat2 , (nicNameC&)idpTeat2 ) ;
                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
            {
            if( idpTeat2 )
            idPortC idpTeat2 = host.idpTeat ;
            
            }
                while( !ether && !idpTeat ) { ++ s ; ether.osSleepF( tinP , TUCK * 0x40 ) ; }
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
        {
        while( !ether && !etThread )
        idPortC& idpTeat = host.idpTeat ;
        homeS& host = homeS::homeIF() ;
        SCOOPS
    {
    IFsCRATCH

    const countT idRelay = pTaskP->c1 ; //U::OBSOLETE
{
if( pTaskP && pTaskP->c1 )
TASK( tmWorkF )

DONE( tmPutPayloadsF )
}
    }
        }
            ++ s ; ether.osSleepF( tinP , TOCK ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    
            if( POOP ) POOPR
            
            sockP.writeF( tinP , sWrap ) ;
            etThread.strokeF( tinP , T(USCORE79 "\r\n") ) ;
    
            /* a-d */ homeS::homeIF().idptRelay >> sWrap ;
            /* 9 */ sWrap << sGift ;
            /* 8 */ sWrap << flags ;
            /* 7 */ sWrap << sToMediator ;
            /* 6 */ sWrap << sTo ;
            /* 5 */ sWrap << (countT*)c8Channel ;
            /* 4 */ sWrap << (countT)ifcIDtYPEwRAP_GIFT ;
            /* 3 */ sWrap << (countT)1 ; // idVersion
            /* 2 */ sWrap << (countT)ifcIDpROTOCOL_RELAYwRAP ;
            /* 1 */ sWrap << (strokeS*)tTM ;
            soulC sGift( tinP , TAG( TAGiDnULL ) ) ;
            flagsT flags = flCIOpUT_null ;
            soulC sToMediator( tinP , TAG( TAGiDnULL ) ) ;
            soulC sTo( tinP , TAG( TAGiDnULL ) ) ;
            soulC sWrap( tinP , TAG( TAGiDnULL ) ) ;
        {
        while( !ether && !bQuitP && !etThread )
        count8S c8Channel( 1 , 2 , 3 , 4 ) ;
        TN( tTM , "IdeaFarm " "(tm)" ) ;
        SCOOPS
    {
    IFsCRATCH

    boolT&   bQuitP =   *(boolT*)pTaskP->c2 ;
    socketC& sockP  = *(socketC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmPutPayloadsF )

/*1*/WAKEhIDE( "ifcIDaDAM_SPACElOAD.kernel.space.load.simulator" )/*1*/
/**/
*/
    sleep
    write a soulC
   while not fired
  tmLoadF
    say "payload received"
   for each incoming soulC
   if leaf relay then launch tmLoadF
   connect
  tmWorkF
 for each target relay
pseudocode
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

