
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

//etherC::loafIF( tinP ) ;
//etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS1gATHERuNPACK / -") ) ;

}
    //etThread.traceF( tinP , T("called  zlib to unpack all gz files in ")+tNew ) ;
    etThread.delF( tinP , postBuffer ) ;
    while( ~hFind && !POOP ) ;
    }
        DEL( pInfo ) ;
        }
            }
                etThread.diskMoveFileOrDirF( tinP , tToGzDone+tShort , tIfoName , 0 ) ;

                etThread.boxPutF( tinP , tPath+tShorter /*+tDotLog*/ , postBuffer , info1.total_out ) ;     // RACKSPACE FILES END WITH ".log.gz" SO DON'T NEED ANOTHER ".log"; CHANGING THIS BEHAVIOR WILL BREAK CODE THAT PARSES THESE FILE NAMES TO OBTAIN BUCKET AND CONTAINER

                etThread.delF( tinP , posti ) ;

                rc = (*pg1.zlib_pInflateEndF)(   &info1 ) ;
                rc = (*pg1.zlib_pInflateF)(      &info1 ,  Z_FINISH ) ;
                rc = (*pg1.zlib_pInflateInit2F)( &info1 , 15 + 32 , "1.2.11" , sizeof info1 ) ;            // WRONG VERSION, BUT THE EARLY DLL DOESN'T CARE

                info1.avail_out = costBuffer ;
                info1.next_out  = (Bytef*)postBuffer ;
                info1.avail_in  = costi ;
                info1.next_in   = (Bytef*)posti ;

                static z_stream info1 ;

                ZE( countT , rc ) ;

                processGlobal1S& pg1 = processGlobal1S::_processGlobal1I_IF() ;

                etThread.boxGetShadowF( tinP , posti , costi , tIfoName ) ; ___( posti ) ;
                ZE( countT   , costi ) ;
                ZE( osTextT* , posti ) ;

                }
                    etThread.delF( tinP , psttnu ) ;
                    etThread.delF( tinP , psttShorter ) ;
                    tShorter  = T(psttShorter) ;
                    etThread.strBisectF( tinP , psttShorter , psttnu , tShort , tDot , - 1 , flSTRbISECT_null ) ; ___( psttShorter ) ; ___( psttnu ) ;
                    ZE( strokeS* , psttnu ) ;
                    ZE( strokeS* , psttShorter ) ;
                {
                TN( tShorter , "" ) ;

                }
                    etThread.delF( tinP , psttShort ) ;
                    etThread.delF( tinP , psttPath ) ;
                    tShort = T(psttShort) ;
                    tPath  = T(psttPath) ;
                    etThread.strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                    ZE( strokeS* , psttShort ) ;
                    ZE( strokeS* , psttPath ) ;
                {
                TN( tShort , "" ) ;
                TN( tPath  , "" ) ;
            {
            if( !bDir )

            const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;

            TN( tIfoName , pInfo->psttIfoName ) ;
        {
        else
        }
            break ;
            DEL( pInfo ) ;
        {
        if( !pInfo || !pInfo->psttIfoName )

        etThread.diskFindFileOrDirF( tinP , pInfo , hFind , fnLike.pathF() , &pat ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    //etThread.traceF( tinP , T("calling zlib to unpack all gz files in ")+tNew ) ;

    patternC pat( tinP , etThread , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
    fileNameC fnLike( tinP , etThread , tNew+tStarDotGz ) ;


    etThread.newF( tinP , LF , postBuffer , costBuffer ) ; ___( postBuffer ) ;
    const countT   costBuffer = TOCK ;
    ZE( osTextT* , postBuffer ) ;

    etThread.diskFileOrDirDeleteF( tinP , tIncoming , flFILEoRdIRdELETE_RECURSE ) ;
    //etThread.traceF( tinP , T("deleting ")+tIncoming+T("; WARNING: i assume that no other process is downloading or otherwise modifying the contents of ")+tIncoming ) ;

    //etThread.traceF( tinP , T("new access logs [cDirs,cFiles]:    ")+TF2(cDirs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.diskWalkGatherF( tinP , cDirs , cFiles , countTC() , tNew , tIncoming , 0 , pcArgs ) ;
    countT pcArgs[] = { 2 } ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs ) ;
    //etThread.traceF( tinP , T("gathering the poured files into the single directory ")+tNew+T(" from ")+tIncoming ) ;
{

TN( tStarDotGz  , "*.gz" ) ;
//TN( tDotLog , ".log" ) ;
TN( tDot   , "." ) ;
TN( tSlash , "/" ) ;
TN( tb4 , "    " ) ;
TN( tb , " " ) ;
TN( tToGzDone  , "///d/tmp/cloud.access.log.entries.all.gz/" ) ;
TN( tNew       , "///d/tmp/cloud.access.log.entries.new/" ) ;
TN( tIncoming  , "///d/tmp/cloud.access.log.entries.incoming/" ) ;

//etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS1gATHERuNPACK / +") ) ;

TODO

// OBSOLETES BY 5100071e

/*1*/WAKEhIDE( "ifcIDaDAM_ACCESSeVENTS1gATHERuNPACK" )/*1*/
/**/
*/
 the input directory can also contain log files generated by Windows, which have a slightly different format
i receive new rax (Rackspace Cloud Files) access log files, gather tham into wo directory, and unpack them (from GZ files)
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

