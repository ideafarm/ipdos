
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    etThread.strokeF( tinP , TP("idMe: ",0x10)+TF1(state.idMe)+T("\r\n")+TP("idCycle: ",0x10)+TF1(state.idCycle)+T("\r\n") ) ;
    state.idCycle += 0x100 ;
    stateS state( tinP , etThread ) ;
{

TODO

    }
    {
    stateC( tinP , etherP , sizeof *this , 0 , translateStateF )
    stateS::stateS( tinS& tinP , etherC& etherP ) :

    TRANSLATEsTATE_END
        state.idMe ++ ;
    TRANSLATEsTATE_MIDDLE
        }
            state.idMe = stateOther.idMe ;
        {
        case 1 :
        }
            state.idCycle = stateOther.idCycle ;
        {
        case 2 :
    TRANSLATEsTATE_BEGIN( stateS , 2 )

    ;
    }
        stateS( tinS& tinP , etherC& etherP ) ;

        countT idCycle ;
        countT idMe ;
        countT idVersion ;
    {
    struct stateS : public stateC

/*1*/WAKEhIDE( "example.other.stateC" )/*1*/
/**/
*/
 the purpose of the STATEn symbols is to avoid the need to write state code such as mine when crafting a brand new adam class
 when adding a new state member, replace the STATEn line with code similar to what i have
 use the STATE1-STATE8 symbols to craft the initial definition
instructions
i am an example of what an adam def looks like after it uses a state version higher than 1
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

