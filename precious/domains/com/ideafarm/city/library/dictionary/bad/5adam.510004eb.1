
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.loafIF( tinP ) ;

etThread.strokeF( tinP , T("\felapsed time: ")+TT(timeB1,timeB2) ) ;
etThread.osTimeSubtractF( tinP , timeB1 , timeB2 , timeA1 , timeA2 ) ;
etThread.osTimeNowF( tinP , timeB1 , timeB2 ) ;
ZE( sCountT , timeB2 ) ;
ZE( countT , timeB1 ) ;

}
    //++ s ; etThread.osSleepF( tinP , TOCK ) ;
    //sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    linesF( tinP , etThread , st_a ) ;
    st_a[ 1 ] = step ;
    etThread.strokeF( tinP , T("\f(")+TF1(*(measureT*)&st_a[1])+T(",")+TF1(*(measureT*)&st_a[2])+T(",")+TF1(*(measureT*)&st_a[3])+T(")") ) ;
{
for( measureT step = 0.0 ; !ether && step <= 0.1 ; step += 0.001 )

etThread.osTimeNowF( tinP , timeA1 , timeA2 ) ;
ZE( sCountT , timeA2 ) ;
ZE( countT , timeA1 ) ;

st_a[ 3 ] = (measureT)1.0 ;
st_a[ 2 ] = (measureT)0.0 ;
st_a[ 1 ] = (measureT)0.0 ;
measureT st_a[ 1 + CdIM ] ;

TODO

}
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b[ 3 ] =(measureT)110.0 ;
    st_b[ 2 ] =(measureT)1.0 ;
    st_b[ 1 ] =(measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP , 1 ) ;
    st_b[ 3 ] =(measureT)100.0 ;
    st_b[ 2 ] =(measureT)1.0 ;
    st_b[ 1 ] =(measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b[ 3 ] =(measureT)110.0 ;
    st_b[ 2 ] =(measureT)1.0 ;
    st_b[ 1 ] =(measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP , 1 ) ;
    st_b[ 3 ] =(measureT)100.0 ;
    st_b[ 2 ] =(measureT)1.0 ;
    st_b[ 1 ] =(measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b[ 3 ] =(measureT)110.0 ;
    st_b[ 2 ] =(measureT)-1.0 ;
    st_b[ 1 ] =(measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP , 1 ) ;
    st_b[ 3 ] =(measureT)100.0 ;
    st_b[ 2 ] =(measureT)-1.0 ;
    st_b[ 1 ] =(measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b[ 3 ] =(measureT)110.0 ;
    st_b[ 2 ] =(measureT)-1.0 ;
    st_b[ 1 ] =(measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP , 1 ) ;
    st_b[ 3 ] =(measureT)100.0 ;
    st_b[ 2 ] =(measureT)-1.0 ;
    st_b[ 1 ] =(measureT)-1.0 ;
    
    
    
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b[ 3 ] =(measureT)110.0 ;
    st_b[ 2 ] =(measureT)-1.0 ;
    st_b[ 1 ] =(measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b[ 3 ] =(measureT)110.0 ;
    st_b[ 2 ] =(measureT)1.0 ;
    st_b[ 1 ] =(measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b[ 3 ] =(measureT)110.0 ;
    st_b[ 2 ] =(measureT)1.0 ;
    st_b[ 1 ] =(measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b[ 3 ] =(measureT)110.0 ;
    st_b[ 2 ] =(measureT)-1.0 ;
    st_b[ 1 ] =(measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP , 1 ) ;
    st_b[ 3 ] =(measureT)110.0 ;
    st_b[ 2 ] =(measureT)-1.0 ;
    st_b[ 1 ] =(measureT)-1.0 ;




    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b[ 3 ] =(measureT)100.0 ;
    st_b[ 2 ] =(measureT)-1.0 ;
    st_b[ 1 ] =(measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b[ 3 ] =(measureT)100.0 ;
    st_b[ 2 ] =(measureT)1.0 ;
    st_b[ 1 ] =(measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b[ 3 ] =(measureT)100.0 ;
    st_b[ 2 ] =(measureT)1.0 ;
    st_b[ 1 ] =(measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b[ 3 ] =(measureT)100.0 ;
    st_b[ 2 ] =(measureT)-1.0 ;
    st_b[ 1 ] =(measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP , 1 ) ;
    st_b[ 3 ] =(measureT)100.0 ;
    st_b[ 2 ] =(measureT)-1.0 ;
    st_b[ 1 ] =(measureT)-1.0 ;



    measureT st_b[ 1 + CdIM ] ;
{
voidT linesF( tinS& tinP , etherC& etThread , measureT* st_aP )

}
    //U: O: 3/4 OF ALL PROCESSING TIME IS SPENT IN THE PRECEDING LINE
    etThread.strokeF( tinP , T("")+(bWothP?OLDmOVEtO(xx*10000+400,yy*10000+300):OLDlINEtO(xx*10000+400,yy*10000+300))/*+T(". (")+TF1(xx)+T(",")+TF1(yy)+T(")")+OLDmOVEtO(xx*100,yy*100)*/ ) ;
    measureT yy = st_bP[ 2 ] ;
    measureT xx = st_bP[ 1 ] ;
    mapF( tinP , etThread , st_bP , st_aP ) ;
{
voidT lineF( tinS& tinP , etherC& etThread , measureT* st_bP , measureT* st_aP , const boolT bWothP = 0 )

}
    /*while( st_bP > 2 )*/ visionF( tinP , etThread , st_bP , st_aP ) ;
{
voidT mapF( tinS& tinP , etherC& etThread , measureT* st_bP , measureT* st_aP )

}
    //if( *(measureT*)&st_bP[ CdIM ] ) { BLAMMO ; }

    projectionF( tinP , etThread , st_bP , st_a2 , st_b2 ) ;

    }
        st_b2[ idd ] = st_bP[ idd ] + lb * st_t[ idd ] ;
        st_a2[ idd ] = st_aP[ idd ] + la * st_t[ idd ] ;
    {
    for( countT idd = 1 ; idd <= CdIM ; idd ++ )
    measureT st_b2[ 1 + CdIM ] ;
    measureT st_a2[ 1 + CdIM ] ;
    const measureT lb = lengthF( st_bP ) ;
    const measureT la = lengthF( st_aP ) ;

    }
        projectionF( tinP , etThread , st_t , st_aP , st_b ) ;

        for( countT idd = 1 ; idd <= CdIM ; idd ++ ) st_b[ idd ] = (measureT)( idd < CdIM ? 0.0 : 1.0 ) ;
        measureT st_b[ 1 + CdIM ] ;
    {
    measureT st_t[ 1 + CdIM ] ;
{
voidT visionF( tinS& tinP , etherC& etThread , measureT* st_bP , measureT* st_aP )

}
    }
        st_tP[ idd ] = st_d[ idd ] - st_c[ idd ] ;
    {
    for( countT idd = 1 ; idd <= CdIM ; idd ++ )

    }
        st_d[ idd ] = st_bP[ idd ] * rr ;
    {
    for( countT idd = 1 ; idd <= CdIM ; idd ++ )
    measureT st_d[ 1 + CdIM ] ;

    const measureT rr = 1.0 / innerProductF( st_bP , st_c ) ;

    }
        st_c[ idd ] = st_aP[ idd ] / la ;
    {
    for( countT idd = 1 ; idd <= CdIM ; idd ++ )

    measureT st_c[ 1 + CdIM ] ;

    const measureT la = lengthF( st_aP ) ;
{
voidT projectionF( tinS& tinP , etherC& etThread , measureT* st_tP , measureT* st_aP , measureT* st_bP )

}
    return ip ;

    }
        ip += st1P[ idd ] * st2P[ idd ] ;
    {
    for( countT idd = 1 ; idd <= CdIM ; idd ++ )
    ZE( measureT , ip ); 
{
measureT innerProductF( measureT* st1P , measureT* st2P )

}
    return thirdC::c_sqrtIF( ll ) ;

    }
        ll += vv * vv ;
        measureT vv = stP[ idd ] ;
    {
    for( countT idd = 1 ; idd <= CdIM ; idd ++ )

    ZE( measureT , ll ) ;
{
measureT lengthF( measureT* stP )

#define CdIM 3

/*1*/WAKEhIDE( "doodle.eye.2" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

