
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    bArm = 1 ;    

    //etThread.traceF( tinP , T("[cNapping1,cNapping2]: ")+TF2(cNapping1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb+TF2(cNapping2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    etThread.traceF( tinP , TF3(++icCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T("speed [mean,cDoneNew,time1E,cDonePerTime,cDone1,cDone2]: ")+TF3(mean,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb+TF3(cDoneNew,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb+TF3(time1E,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb+TF3(cDonePerTime,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb+TF3(cDone1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tDot+TF3(cDone2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8) ) ;

    mean /= cGot ;
    for( countT offi = 0 ; offi < cGot ; offi ++ ) mean += pcDonePerTime[ offi ] ;
    ZE( countT , mean ) ;

    ;
        : sizeof pcDonePerTime / sizeof pcDonePerTime[ 0 ]
        ? ccDonePerTime
    countT cGot = ccDonePerTime < sizeof pcDonePerTime / sizeof pcDonePerTime[ 0 ]

    ccDonePerTime ++ ;
    pcDonePerTime[ ccDonePerTime % ( sizeof pcDonePerTime / sizeof pcDonePerTime[ 0 ] ) ] = cDonePerTime ;

    countT cDonePerTime = cDoneNew /** TUCK*/ / time1E ; // REALLY PER TUCK, NOT PER TIME, DUE TO "* TUCK"

    etThread.osTimeSubtractF( tinP , time1E , time2E , time1LathSave , time2LathSave ) ;

    cDone1Lag = cDone1Snap ;
    countT cDoneNew = cDone1Snap - cDone1Lag ;
    if( cDone1Snap < cDone1Lag ) cDone2 ++ ;
    countT cDone2Snap = cDone2 ;
    countT cDone1Snap = cDone1 ;

    time2Lath = time2E ;
    time1Lath = time1E ;
    etThread.osTimeNowF( tinP , time1E , time2E ) ;
    ZE( sCountT , time2E ) ;
    ZE( countT  , time1E ) ;

    sCountT time2LathSave = time2Lath ;
    countT  time1LathSave = time1Lath ;

    }
        ++ s ; ether.osSleepF( tinP , TOCK << 0 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
{
while( !ether )
ZE( countT , icCycle ) ;

ZE( countT , ccDonePerTime ) ;
countT pcDonePerTime[ 0x10 ] ;

cDone2Lag = cDone2 ;
cDone1Lag = cDone1 ;

etThread.osTimeNowF( tinP , time1Lath , time2Lath ) ;
ZE( sCountT , time2Lath ) ;
ZE( countT  , time1Lath ) ;
TN( tDot , "." ) ;
TN( tb , " " ) ;

//etherC::loafIF( tinP ) ;
//etThread.traceF( tinP , T("ok") ) ;

//etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;

//WAITuNTILaLMOSTaLONE( 2 )

while( cDo -- ) etThread.osThreadF( TaRG1( tmGorilla5F ) /*, (countT)&grabFoo*/ ) ;

//etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , cDo ) ;
//countT cDo = 12 ;
countT cDo = 2 ;
//countT cDo = 1 ;

//grabC grabFoo( tinP , TAG( TAGiDnULL ) ) ;

etThread.traceF( tinP , T("[offo,bitsReally]: ")+TF2(idBit-ifcIDgRABITbIT_00,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(bitsReally,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
bitsReally = 0 ;

TODO

DONE( tmGorilla999F )

}
    inc02AM( cDone1 ) ;

    //tinP.cYield = 0 ;
    //thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) , 0 ) ;
    //tinP.cYield = 0 ;

    //gg.ungrabF( tinP ) ;

    //tinP.cYield = 0 ;
    //thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) , 0 ) ;
    //tinP.cYield = 0 ;

    //gg.grabF( tinP , TAG( TAGiDnULL ) ) ;

    //}
    //    }
    //        dec02AM( cNapping2 ) ;
    //        ++ s ; ether.osSleepF( tinP , TICK ) ;
    //        inc02AM( cNapping2 ) ;
    //
    //        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    //    {
    //    if( bDoze )
    //
    //    etThread.traceF( tinP , TF2(tinP.monitor.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb+TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(bDoze?" uh oh: will sleep for tick":"") ) ;
    //
    //                  idtLath =  tinP.monitor.idThread ;
    //    boolT bDoze = idtLath == tinP.monitor.idThread ;
    //
    //    static countT idtLath ;
    //{
    //if( !( idCycle % TOCK ) )
    idCycle ++ ;

    //}
    //    dec02AM( cNapping1 ) ;
    //    ++ s ; ether.osSleepF( tinP , TOCK ) ;
    //    inc02AM( cNapping1 ) ;
    //
    //    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    //{
    //if( setIfEqualsAM( bArm , 0 , 1 ) )
{
while( !ether )
countT idCycle ;
TN( tb , " " ) ;

//grabitC gg( tinP , TAG( TAGiDnULL ) , bb , ifcIDgRABITbIT_00 , 0 , 0 , flGRABITc_SUPPRESScTdT , TUCK , ifcIDgRABlAYER_7BASEmISC1 ) ;

TASK( tmGorilla999F )

DONE( tmGorilla6F )
}
    }
        grabFooP.ungrabF( tinP ) ;
        inc02AM( cDone1 ) ;
        grabFooP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        idCycle ++ ;
    {
    while( !ether )
    countT idCycle ;
    TN( tb , " " ) ;

    grabC& grabFooP = *(grabC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmGorilla6F )             // SPEED: 

DONE( tmGorilla5F )

//etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;

//etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
}
    gg.ungrabF( tinP ) ;
    inc02AM( cDone1 ) ;
    gg.grabF( tinP , TAG( TAGiDnULL ) ) ;
    idCycle ++ ;
{
while( !ether /*&& cDo --*/ )
countT cDo = TOCK << 2 ;
//etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
countT idCycle ;
TN( tb , " " ) ;

gNewC   gg ;
//grabitC gg( tinP , TAG( TAGiDnULL ) , bb , idBit , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_SUPPRESScTdT , TUCK , ifcIDgRABlAYER_7BASEmISC1 ) ;

//etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;

TASK( tmGorilla5F )             // SPEED: 3

DONE( tmGorilla4F )

}
    if( !was1 ) { BLAMMO ; }
    countT was1 = btrKeyedAM( &bb , keyIdThread , 0 , tinP.monitor.idThread ) ;

    cDone1 ++ ;
    //inc02AM( cDone1 ) ;

    }
        OSsLEEPf( 0 ) ;
    {
    while( btsKeyedAM( &bb , keyIdThread , 0 , tinP.monitor.idThread ) )
    idCycle ++ ;
{
while( !ether )
countT idCycle ;
TN( tb , " " ) ;

countT keyIdThread ;

TASK( tmGorilla4F )             // SPEED: 19 (58 when 12_9 gorillas)

DONE( tmGorilla3F )

}
    inc02AM( cDone1 ) ;
    OSsLEEPf( 0 ) ;
    idCycle ++ ;
{
while( !ether )
countT idCycle ;
TN( tb , " " ) ;

TASK( tmGorilla3F )             // SPEED: 3b1

DONE( tmGorilla2F )

}
    inc02AM( cDone1 ) ;
    idCycle ++ ;
{
while( !ether )
countT idCycle ;
TN( tb , " " ) ;

TASK( tmGorilla2F )             // SPEED: 1d3

DONE( tmGorilla1F )

}
    if( !was1 ) { BLAMMO ; }
    countT was1 = btrAM( &bb , 0 ) ;

    tinP.cYield = 0 ;
    }
        thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) , 0 ) ;
    {
    while( btsAM( &bb , 0 ) )
    tinP.cYield = 0 ;

    if( !( idCycle % TICK ) ) etThread.traceF( tinP , TF2(tinP.monitor.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb+TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    idCycle ++ ;
{
while( !ether )
countT idCycle ;
TN( tb , " " ) ;

thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
TASK( tmGorilla1F )

}
    if( !was1 ) { BLAMMO ; }
    countT was1 = btrAM( &bb , 0 ) ;
{
voidT gNewC::ungrabF( tinS& tinP )

}
    tinP.cYield = 0 ;
    }
        //thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) , 0 ) ;
        OSsLEEPf( 0 ) ; //U:: TO FIND A BUG
    {
    while( btsAM( &bb , 0 ) )
    tinP.cYield = 0 ;
{
voidT gNewC::grabF( tinS& tinP , const countT idLineP , const countT idiFileP , const byteT* const pbBitsP )

}
{
gNewC::gNewC( voidT )

}
{
gNewC::~gNewC( voidT )

;
}
    voidT ungrabF( tinS& tinP ) ;
    voidT grabF( tinS& tinP , const countT idLineP , const countT idiFileP , const byteT* const pbBitsP ) ;
    gNewC( voidT ) ;
    ~gNewC( voidT ) ;

    public :
{
class gNewC

countT cNapping2 ;
countT cNapping1 ;
countT cDone2Lag ;
countT cDone2 ;
countT cDone1Lag ;
countT cDone1 ;
boolT bArm ;

byteT& bb = *(byteT*)&bitsReally ;
countT bitsReally = -1 & ~( 1 << ( idBit - ifcIDgRABITbIT_00 ) ) ;
const countT idBit = ifcIDgRABITbIT_00 ;

/*1*/WAKEsHOWtEXT( "doodle.grabit.gorillas" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

