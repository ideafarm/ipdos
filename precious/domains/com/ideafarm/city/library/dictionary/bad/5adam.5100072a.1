
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}

#endif

    etThread.traceF( tinP , T("recording duration: ")+TF4(cHours,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T(":")+TF4(cMinutes,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T(":")+TF4(cSeconds,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa) ) ;

    cMinutes -= cHours * 60 ;
    countT cHours = cMinutes / 60 ;
    cSeconds -= cMinutes * 60 ;
    countT cMinutes = cSeconds / 60 ;
    countT cSeconds = mSeconds ;

    }
        ((byteT*)&head)[ 0 ] = pbTock[ 3 ] ;
        ((byteT*)&head)[ 1 ] = pbTock[ 2 ] ;
        ((byteT*)&head)[ 2 ] = pbTock[ 1 ] ;
        ((byteT*)&head)[ 3 ] = pbTock[ 0 ] ;

        etThread.fileReadF( tinP , pbTock , cbr , fi , 0 ) ; cbNotYetRead -= cbr ;
        cbr = sizeof head ;

        if( cbNotYetRead < sizeof head ) break ;

        // }
        //     if( pbTock[ 1 ] & 0xe0 == 0xe0 ) break ;
        // 
        //     etThread.fileReadF( tinP , pbTock + 1 , cbr , fi , 0 ) ; cbNotYetRead -- ;
        // {
        // while( cbNotYetRead )
        // //FIND A POSSIBLE SYNCoOTH
        // 
        // }
        //     if( *pbTock == 0xff ) break ;
        // 
        //     etThread.fileReadF( tinP , pbTock , cbr , fi , 0 ) ; cbNotYetRead -- ;
        // {
        // while( cbNotYetRead )
        // cbr = 1 ;
        // //FIND A POSSIBLE SYNCwOTH

        //**************************************************************************************************************************************************
        //**************************************************************************************************************************************************
        //****                                                                                                                                      ********
        //**** READ THE NEXT HEAD                                                                                                                   ********
        //****                                                                                                                                      ********
        //**************************************************************************************************************************************************
        //**************************************************************************************************************************************************

        }
            //etThread.delF( tinP , psttDump ) ;
            //LOGrAW( "------------------------------ END   -------------------------------------------------------------------\r\n" ) ;
            //LOGrAW( T(psttDump) ) ;
            //LOGrAW( "\r\n------------------------------ BEGIN -------------------------------------------------------------------\r\n" ) ;
            //etThread.strDumpIF( tinP , psttDump , pbTock , cbFrameBody , flSTRdUMP_null , 0x10 , 0x4 , '.' , 0x4 ) ; ___( psttDump ) ;
            //                                                                            //bPerLineP , bPerGroupP , bReadableP , bPerGrouprP
            //ZE( strokeS* , psttDump ) ;
        
            etThread.fileReadF( tinP , pbTock , cbr , fi , 0 ) ; cbNotYetRead -= cbr ; 
            cbr = cbFrameBody ;
        {

        if( cbFrameBody > cbNotYetRead  ) break ;
        if( cbFrameBody > sizeof pbTock ) { BLAMMO ; }
        countT cbFrameBody = cbFrame - sizeof head ;

        //**************************************************************************************************************************************************
        //**************************************************************************************************************************************************
        //****                                                                                                                                      ********
        //**** DUMP THE FRAME BODY                                                                                                                  ********
        //****                                                                                                                                      ********
        //**************************************************************************************************************************************************
        //**************************************************************************************************************************************************

        //}
        //    etThread.delF( tinP , psttSay ) ;
        //    etThread.traceF( tinP , psttSay ) ;
        //    etThread.strFuseF( tinP , psttSay , TF3(head.idEmphasis                 ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2) ) ;
        //    //etThread.strFuseF( tinP , psttSay , TF3(head.bOriginal                ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2) ) ;
        //    //etThread.strFuseF( tinP , psttSay , TF3(head.bCopyright               ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2) ) ;
        //    etThread.strFuseF( tinP , psttSay , TF3(head.idModeExtension            ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2) ) ;
        //    etThread.strFuseF( tinP , psttSay , TF3(head.idChannelMode              ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2) ) ;
        //    //etThread.strFuseF( tinP , psttSay , TF3(head.bPrivate                 ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2) ) ;
        //    etThread.strFuseF( tinP , psttSay , TF3(cbFrame                         ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,5) ) ;
        //    etThread.strFuseF( tinP , psttSay , TF3(head.bPadded                    ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2) ) ;
        //    etThread.strFuseF( tinP , psttSay , TF4(samplesPerSec                   ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,6,0xa)+tb ) ;
        //    //etThread.strFuseF( tinP , psttSay , TF3(head.idSamplingRate           ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2) ) ;
        //    etThread.strFuseF( tinP , psttSay , TF4(bitsPerSec                      ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,6,0xa)+tb ) ;
        //    //etThread.strFuseF( tinP , psttSay , TF3(head.idBitRate                ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2) ) ;
        //    etThread.strFuseF( tinP , psttSay , TF3(head.bNoCRC                     ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2) ) ;
        //    //etThread.strFuseF( tinP , psttSay , TF3(head.idLayer                  ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2) ) ;
        //    etThread.strFuseF( tinP , psttSay , T(ppostVersion[idMpegVersion])+tb ) ;
        //    //etThread.strFuseF( tinP , psttSay , TF3(head.idVersion                ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2) ) ;
        //    etThread.strFuseF( tinP , psttSay , TF3(cbNotYetRead                    ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8) ) ;
        //    etThread.strFuseF( tinP , psttSay , TF3(idFrame                       ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8) ) ;
        //    etThread.strMakeF( tinP , psttSay , 0 , TOCK ) ; ___( psttSay ) ;
        //    ZE( strokeS* , psttSay ) ;
        //{
        ++ idFrame ;

        //**************************************************************************************************************************************************
        //**************************************************************************************************************************************************
        //****                                                                                                                                      ********
        //**** REPORT THE HEAD                                                                                                                      ********
        //****                                                                                                                                      ********
        //**************************************************************************************************************************************************
        //**************************************************************************************************************************************************

        }
            mSeconds += 1152.0 / samplesPerSec ;

            cbFrame = !samplesPerSec ? 0 : 144 * bitsPerSec / samplesPerSec + !!head.bPadded ;

            }
                }
                    break ;
                    etThread.traceF( tinP , T("unrecognized MPEG version") ) ;
                {
                default :
                }
                    break ;
                    samplesPerSec = pSamplesPerSecMPEG25[ head.idSamplingRate ] ;
                {
                case 3 :
                }
                    break ;
                    samplesPerSec = pSamplesPerSecMPEG2[ head.idSamplingRate ] ;
                    bitsPerSec = pBitsPerSecMPEG2[ head.idBitRate ] ;
                {
                case 2 :
                }
                    break ;
                    samplesPerSec = pSamplesPerSecMPEG1[ head.idSamplingRate ] ;
                    bitsPerSec    = pBitsPerSecMPEG1[ head.idBitRate ] ;
                {
                case 1 :
            {
            switch( idMpegVersion )

            if( head.idLayer != 1 ) etThread.traceF( tinP , T("unexpected MPEG layer (not layer III)") ) ;
        {
        ZE( countT , samplesPerSec ) ;
        ZE( countT , bitsPerSec ) ;
        ZE( countT , cbFrame ) ;

        ;
                    : 3
                    ? 0
                : head.idVersion == 1
                ? 2
            : head.idVersion == 2
            ? 1
        countT idMpegVersion = head.idVersion == 3  //    1 : MPEG1    ;    2 : MPEG2    ,    3 : MPEG2.5

        //**************************************************************************************************************************************************
        //**************************************************************************************************************************************************
        //****                                                                                                                                      ********
        //**** CALCULATE THE SIZE OF THIS FRAME                                                                                                     ********
        //****                                                                                                                                      ********
        //**************************************************************************************************************************************************
        //**************************************************************************************************************************************************

        if( head.idSync != 0x7ff ) break ; // ASSUME: IS TRUE ONLY IF ENCOUNTER SUFFIX TAG (IDSV1)
    {
    while( cbNotYetRead && !ether )
    ZE( measure04T , mSeconds ) ;
    TN( tb , " " ) ;
    ZE( countT , idFrame ) ;

    countT pSamplesPerSecMPEG25[] = { 11025 , 12000 ,  8000 , 0 } ;
    countT pSamplesPerSecMPEG2[]  = { 22050 , 24000 , 16000 , 0 } ;
    countT pSamplesPerSecMPEG1[]  = { 44100 , 48000 , 32000 , 0 } ;

    ;
    }

        128000 , 256000 , 320000 ,      0
         64000 , 128000 , 160000 , 112000 ,
         32000 ,  64000 ,  80000 ,  56000 ,
             0 ,   8000 ,  16000 ,  24000 ,
    {
    countT pBitsPerSecMPEG2[] =

    ;
    }
        224000 , 256000 , 320000 ,      0
        112000 , 128000 , 160000 , 192000 ,
         56000 ,  64000 ,  80000 ,  96000 ,
             0 ,  32000 ,  40000 ,  48000 ,
    {
    countT pBitsPerSecMPEG1[] =

    ;
    }
        "MPEG-2.5" ,
        "MPEG-2" ,
        "MPEG-1" ,
        "invalid" ,
    {
    osTextT* ppostVersion[] =

    }
        wothHead = head ;

        ((byteT*)&head)[ 0 ] = pbTock[ 3 ] ;
        ((byteT*)&head)[ 1 ] = pbTock[ 2 ] ;
        ((byteT*)&head)[ 2 ] = pbTock[ 1 ] ;
        ((byteT*)&head)[ 3 ] = pbTock[ 0 ] ;

        etThread.fileReadF( tinP , pbTock + 1 , cbr , fi , 0 ) ; cbNotYetRead -= cbr ;
        cbr = 3 ;
        //READ REMAINDER OF WOTH HEAD (WOTH BYTE HAS ALREADY BEEN READ)
    {
    if( !POOP )
    frameHeadS head ;
    frameHeadS wothHead ;

    }
        __( cbNotYetRead < 3 ) ;
        cbNotYetRead = cbUsedNet - 1 ; //I HAVE ALREADY READ THE WOTH BYTE

        }
            DEL( pInfo ) ;
            if( pInfo ) cbUsedNet = pInfo->cbUsed - cbFileTag ;

            __Z( pInfo ) ;
            etThread.diskFileQueryF( tinP , pInfo , fi ) ; ___( pInfo ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        ZE( countT , cbUsedNet ) ;
    {
    if( !POOP )
    ZE( countT , cbNotYetRead ) ;

    __( pbTock[ 0 ] != 0xff ) ;

    }
        etThread.fileReadF( tinP , pbTock , cbr , fi , 0 ) ; // LOAD THE WOTH BYTE OF THE WOTH SYNC
        cbr = 1 ;

        }
            }
                }
                    cbToDo -= cbWo ;
                    etThread.fileReadF( tinP , pbTock , cbr , fi , 0 ) ;
                    cbr = cbWo ;

                    ;
                        : cbToDo
                        ? sizeof pbTock
                    countT cbWo = cbToDo > sizeof pbTock
                {
                while( cbToDo )
                countT cbToDo = cbId3 ;
            {
            else
            }
                etThread.fileReadF( tinP , pbTock , cbr , fi , 0 ) ;
                cbr = cbId3 ;
            {
            if( cbId3 <= sizeof pbTock )
        {
        if( !POOP )

        cbFileTag += cbId3 ;
        }
            __Z( cbId3 ) ;

            cbId3 |= size4 << 0x15 ;
            cbId3 |= size3 << 0xe ;
            cbId3 |= size2 << 0x7 ;
            cbId3 |= size1 ;

            countT size1 = pbTock[ 9 ] ;
            countT size2 = pbTock[ 8 ] ;
            countT size3 = pbTock[ 7 ] ;
            countT size4 = pbTock[ 6 ] ;
        {
        if( !POOP )
        ZE( countT , cbId3 ) ;

        __Z( cbr == 0x9 && pbTock[ 0 ] == 'I' && pbTock[ 1 ] == 'D' && pbTock[ 2 ] == '3' ) ;

        cbFileTag += cbr ;
        etThread.fileReadF( tinP , pbTock + 1 , cbr , fi , 0 ) ;
        cbr = 0x9 ;
        cbFileTag = 1 ;
    {
    if( pbTock[ 0 ] != 0xff ) // IF NOT A SYNC BYTE
    ZE( countT , cbFileTag ) ;

    etThread.fileReadF( tinP , pbTock , cbr , fi , 0 ) ;
    countT cbr = 1 ;

    //**************************************************************************************************************************************************
    //**************************************************************************************************************************************************
    //****                                                                                                                                      ********
    //**** READ THE WOTH HEADER                                                                                                                 ********
    //****                                                                                                                                      ********
    //**************************************************************************************************************************************************
    //**************************************************************************************************************************************************

    byteT pbTock[ TOCK ] ;

    byteT* pbMap = fw ;
    
    countT cbLo = fw ;
    
    fileWindowC fw( tinP , etThread , fi , 0 , 0 , cbWindow , flFILEwINDOW_WRITE ) ;
    const countT cbWindow = TUCK ;

#if defined( NEVERdEFINED )








    fileC fi( tinP , (strokeS*)T("///d/tmp/x/a.20150409@1024.mp3") , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 0 ) ;
{
etThread.traceF( tinP , T("opening the file") ) ;

TODO

;
}
    countT idSync            : 11 ;
    countT idVersion         : 2  ;
    countT idLayer           : 2  ;
    countT bNoCRC            : 1  ;
    // 2-3: NET-MSB

    countT idBitRate         : 4  ;
    countT idSamplingRate    : 2  ;
    countT bPadded           : 1  ;
    countT bPrivate          : 1  ;
    // 1

    countT idChannelMode     : 2  ;
    countT idModeExtension   : 2  ;
    countT bCopyright        : 1  ;
    countT bOriginal         : 1  ;
    countT idEmphasis        : 2  ;
    // 0: NET-LSB
{
struct frameHeadS

//54eb8fcf.7d93b000 | 00000000.00000000 | 00000000.00000000 | tm1F             |     1590-1        | opening the file
//768dcfcf.7d93b000 | 22a14000.00000000 | 22a14000.00000000 | tm1F             |     1590-1        | recording duration: 0:26:54
//ac8dcfcf.7d93b000 | 58a14000.00000000 | 36000000.00000000 | tm1F             |     1590-1        | ok
//THIS IS THE BASELINE BENCHMARK USING FILE I/O:

//BASELINE: 5adam.510006eb.1

/*1*/WAKEsHOWtEXT( "was.scratch.5.archived.20180508@1202.doodle.mp3.recording.duration.using.fileWindowC" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

