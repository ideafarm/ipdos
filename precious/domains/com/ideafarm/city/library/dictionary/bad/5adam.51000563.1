
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

    
REST

SW etThread.strokeF( tinP , T("\f") ) ;
etThread.strokeF( tinP , T("\f") ) ;

}
    ++ s ; ether.osSleepF( tinP , TOCK * ( idCycle % 2 ? 8 : 2 ) ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    //LOGrAW3( "cycle " , idCycle , " -\r\n" ) ;

    //win.baton.ungrabF( tinP ) ;

    }
        SW ST( etThread , "" )
        etThread.strokeF( tinP , T("\f") ) ;
        SW ST( etThread , "" )
        etThread.strokeF( tinP , T("\f") ) ;
    {
    if( !( idCycle % 2 ) )

    }
        SW ST( etThread , "" )
        etThread.strokeF( tinP , T("")+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(1.0,scOld_mmPADfORsADAMfRAMES,1.0)+S3(32.0,scOld_mmFRAMEcELLS,8.0)+buQuit2+T(" ")+buSwitch2+S2(0,scOld_POPfRAME) ) ;
        SW ST( etThread , "" )
        etThread.strokeF( tinP , T("")+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(1.0,scOld_mmPADfORsADAMfRAMES,1.0)+S3(32.0,scOld_mmFRAMEcELLS,8.0)+buQuit1+T(" ")+buSwitch1+S2(0,scOld_POPfRAME) ) ;
    {
    else
    }
        SW ST( etThread , "" )
        etThread.strokeF( tinP , T("")+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(1.0,scOld_mmPADfORsADAMfRAMES,1.0)+S3(32.0,scOld_mmFRAMEcELLS,8.0)+buQuit1+T(" ")+buSwitch1+S2(0,scOld_POPfRAME) ) ;
        SW ST( etThread , "" )
        etThread.strokeF( tinP , T("")+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(1.0,scOld_mmPADfORsADAMfRAMES,1.0)+S3(32.0,scOld_mmFRAMEcELLS,8.0)+buQuit2+T(" ")+buSwitch2+S2(0,scOld_POPfRAME) ) ;
    {
    if( 2 == win.idFaceF( tinP , 0 , ifcIDaCTIONpAPER_QUERYdRAW ) )
    ST( etThread , "" )

    //win.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;

    //LOGrAW3( "cycle " , idCycle , " +\r\n" ) ;
    idCycle ++ ;
{
while( !ether )
ZE( countT , idCycle ) ;

win.baton.ungrabF( tinP ) ;
win.cAnimateArg = (countT)&c8a ;
win.pAnimateCBF = animateCBF ;
win.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;

c8a1.c7 = (countT)&buSwitch2 ;
c8a1.c6 = (countT)&buSwitch1 ;
tcButtonC buSwitch2( tinP , buSwitchCBF , (countT)&c8a , flFeature , 0 , T("switch2") , 2 ) ;
tcButtonC buSwitch1( tinP , buSwitchCBF , (countT)&c8a , flFeature , 0 , T("switch1") , 2 ) ;

c8a1.c5 = (countT)&buQuit2 ;
c8a1.c4 = (countT)&buQuit1 ;

tcButtonC buQuit2( tinP , buQuitCBF , 0 , flFeature , 0 , T("quit2") , 2 ) ;
tcButtonC buQuit1( tinP , buQuitCBF , 0 , flFeature , 0 , T("quit1") , 2 ) ;
const flagsT flFeature = flTCfEATURE_defaultButton | flTCfEATURE_TABpARTICIPANT | flTCfEATURE_FLYOVERhIGHLIGHT | flTCfEATURE_DRAGGABLE ;

count8S c8a( (countT)&c8a1 ) ;
count8S c8a1( (countT)&win , (countT)&idFaceShow , (countT)&idFaceDraw , 0/*&buQuit1*/ , 0/*&buQuit2*/ , 0/*&buSwitch1*/ , 0/*&buSwitch2*/ ) ;

SW ST( etThread , "" )
ZE( countT , idFaceDraw ) ;
ZE( countT , idFaceShow ) ;
windowOldC& win = *thirdC::pWinRootIF() ;

TODO

}
    if( tinP.fingerprint && idCycleP && etherP && wP.bDoomed ) ;

    buSwitch2.setF( tinP , T("")+S3(9.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+TP("",8)+TF1(idCycleP%0xf)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
    buSwitch1.setF( tinP , T("")+S3(9.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+TP("",8)+TF1(idCycleP%0xf)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
    buQuit2.setF(   tinP , T("")+S3(7.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+TP("",6)+TF1(idCycleP%0xf)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
    buQuit1.setF(   tinP , T("")+S3(7.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+TP("",6)+TF1(idCycleP%0xf)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;

    ARGS( cArgP )
{
voidT animateCBF( tinS& tinP , etherC& etherP , paperBackC& backP , const countT idCycleP , const countT cArgP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;

    }
        }
            break ;
            }
                SW ST( etherP , "" )
                idEventLathDone = idEventP ;
            {
            if( idEventLathDone != idEventP )
            static countT idEventLathDone ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
    {
    switch( idTypeCallP )

    ARGS( cArgP )
{
voidT buSwitchCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;

    }
        }
            break ;
            etherP.etherFireImpersonateMonitorIF( tinP ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
    {
    switch( idTypeCallP )
{
voidT buQuitCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

#define SW win.idFaceF( tinP , 0 , ifcIDaCTIONpAPER_SWITCH , &idFaceShow , &idFaceDraw ) ;
#define ST(etherP,postP) etherP.winSetTitleF( tinP , T("show:")+TF1(idFaceShow)+T(" draw:")+TF1(idFaceDraw)+T(postP) ) ;
#define PERIOD 0x20

    tcButtonC& buSwitch2  = *(tcButtonC*)c8a1.c7 ;
    tcButtonC& buSwitch1  = *(tcButtonC*)c8a1.c6 ;                                      \
    tcButtonC& buQuit2    = *(tcButtonC*)c8a1.c5 ;                                      \
    tcButtonC& buQuit1    = *(tcButtonC*)c8a1.c4 ;                                      \
    countT&    idFaceDraw =    *(countT*)c8a1.c3 ;                                      \
    countT&    idFaceShow =    *(countT*)c8a1.c2 ;                                      \
    windowOldC&   win        =   *(windowOldC*)c8a1.c1 ;                                      \
    count8S&   c8a1       =    *(count8S*)c8a.c1 ;                                      \
    count8S&   c8a        =    *(count8S*)cArgP ;                                       \
                                                                                        \
#define ARGS(cArgP)                                                                     \

/*1*/WAKEsHOW( "example.other.persistent.dragging.func.144001f.windowOldC.idFaceF" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

