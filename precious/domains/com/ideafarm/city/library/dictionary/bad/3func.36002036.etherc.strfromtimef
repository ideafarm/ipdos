
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            break ;

            }
                ___( psttP ) ;
                if( bNeg ) strFuseF( tinP , psttP , T("-") ) ;
            
                }
                    case 8 : { strFuseF( tinP , psttP , TF3(dick,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; }
                    case 7 : { strFuseF( tinP , psttP , TF3(dock,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idLath == 7 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 6 : { strFuseF( tinP , psttP , TF3(duck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idLath == 6 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 5 : { strFuseF( tinP , psttP , TF3(dime,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idLath == 5 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 4 : { strFuseF( tinP , psttP , TF3(tick,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idLath == 4 ) break ; if( (countT)sttRadixP      ) strFuseF( tinP , psttP , sttRadixP     ) ; }
                    case 3 : { strFuseF( tinP , psttP , TF3(tock,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idLath == 3 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 2 : { strFuseF( tinP , psttP , TF3(tuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idLath == 2 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 1 : { strFuseF( tinP , psttP , TF3(time,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idLath == 1 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                {
                switch( idWoth )
            {
            else
            }
                ___( psttP ) ;
            
                }
                    case 1 : { strFuseF( tinP , psttP , TF3(time,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; }
                    case 2 : { strFuseF( tinP , psttP , TF3(tuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idWoth == 2 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 3 : { strFuseF( tinP , psttP , TF3(tock,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idWoth == 3 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 4 : { strFuseF( tinP , psttP , TF3(tick,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idWoth == 4 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 5 : { strFuseF( tinP , psttP , TF3(dime,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idWoth == 5 ) break ; if( (countT)sttRadixP      ) strFuseF( tinP , psttP , sttRadixP     ) ; }
                    case 6 : { strFuseF( tinP , psttP , TF3(duck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idWoth == 6 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 7 : { strFuseF( tinP , psttP , TF3(dock,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idWoth == 7 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 8 : { strFuseF( tinP , psttP , TF3(dick,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2) ) ; if( idWoth == 8 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                {
                switch( idLath )

                if( bNeg ) strFuseF( tinP , psttP , T("-") ) ;
            {
            if( F(flagsFormatP) & flFORMAT_FOREIGN ) //DEPRECATED EXCEPT WHERE CONVENIENT FOR SORTING (E.G. WITHIN FILE NAMES)
            
            const countT idLath  = idLathP  ? idLathP  : 8 ;
            const countT idWoth = idWothP ? idWothP : 1 ;
        
            dime %= 0x100 ;
            countT duck = dime / 0x100 ;
            dime %= 0x100 * 0x100 ;
            countT dock = dime / ( 0x100 * 0x100 ) ;
            dime %= 0x100 * 0x100 * 0x100 ;
            countT dick = dime / ( 0x100 * 0x100 * 0x100 ) ;
        
            tock %= 0x100 ;
            countT tick = tock / 0x100 ;
            tuck %= 0x100 ;
            countT tock = tuck / 0x100 ;
            time %= 0x100 ;
            countT tuck = time / 0x100 ;
            countT time = time1 ;
        
            ZE( strokeS* , psttw ) ;
        
            }
                dime = - time2 ;
                bNeg = 1 ;
            {
            else
            if( time2 >= 0 ) dime = time2 ;
            ZE( boolT , bNeg ) ;
        
            ZE( countT , dime ) ;
            sCountT time2 = time2P ;
            countT  time1 = time1P ;
        
            POSTPONEtEST( psttP ) ;
            strMakeF( tinP , psttP , T("") , 0x18 ) ; // CALLER MUST TAG. MUST ALLOW FOR MINUS SIGN
        {
        case ifcIDfORMATtIME_NUMERIC :
        }
            break ;

            }
                case 0x14 : { strFuseF( tinP , psttP , T(ppostBigit[offFooDickQtr   ])+T("'diq") ) ; if( idLath == 0x14 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x13 : { strFuseF( tinP , psttP , T(ppostBigit[offFooDickStrong])+T("'dis") ) ; if( idLath == 0x13 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x12 : { strFuseF( tinP , psttP , T(ppostBigit[offFooDick      ])+T("'di" ) ) ; if( idLath == 0x12 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x11 : { strFuseF( tinP , psttP , T(ppostBigit[offFooDockQtr   ])+T("'doq") ) ; if( idLath == 0x11 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x10 : { strFuseF( tinP , psttP , T(ppostBigit[offFooDockStrong])+T("'dos") ) ; if( idLath == 0x10 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x0f : { strFuseF( tinP , psttP , T(ppostBigit[offFooDock      ])+T("'do" ) ) ; if( idLath == 0x0f ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x0e : { strFuseF( tinP , psttP , T(ppostBigit[offFooDuckQtr   ])+T("'duq") ) ; if( idLath == 0x0e ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x0d : { strFuseF( tinP , psttP , T(ppostBigit[offFooDuckStrong])+T("'dus") ) ; if( idLath == 0x0d ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x0c : { strFuseF( tinP , psttP , T(ppostBigit[offFooDuck      ])+T("'du" ) ) ; if( idLath == 0x0c ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                }
                    strFuseF( tinP , psttP , tDelimiter ) ;
                    if( idLath == 0x0b ) break ;

                    }
                        strFuseF( tinP , psttP , tDelimiter+T(postName[offFooQtr]) ) ;

                        ;
                        }
                            "(the reaping)"
                            "(the tending)" ,
                            "(the sowing)"  ,
                            "(the fallow)"  ,
                        {
                        osTextT* postName[] =
                    {
                    if( F(flagsFormatP) & flFORMAT_TIMEqUARTERnAME )

                    strFuseF( tinP , psttP , T(ppostBigit[offFooQtr])+T("'qu" ) ) ;
                {
                case 0x0b :
                case 0x0a : { strFuseF( tinP , psttP , T(ppostBigit[offFooStrong    ])+T("'str") ) ; if( idLath == 0x0a ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x09 : { strFuseF( tinP , psttP , T(ppostBigit[offFooDay       ])+T("'da" ) ) ; if( idLath == 0x09 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x08 : { strFuseF( tinP , psttP , T(ppostBigit[offFooHour      ])+T("'ho" ) ) ; if( idLath == 0x08 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x07 : { strFuseF( tinP , psttP , T(ppostBigit[offFooTick      ])+T("'ti" ) ) ; if( idLath == 0x07 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x06 : { strFuseF( tinP , psttP , T(ppostBigit[offFooMinute    ])+T("'mi" ) ) ; if( idLath == 0x06 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x05 : { strFuseF( tinP , psttP , T(ppostBigit[offFooTock      ])+T("'to" ) ) ; if( idLath == 0x05 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x04 : { strFuseF( tinP , psttP , T(ppostBigit[offFooSecond    ])+T("'sc" ) ) ; if( idLath == 0x04 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x03 : { strFuseF( tinP , psttP , T(ppostBigit[offFooTuck      ])+T("'tu" ) ) ; if( idLath == 0x03 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x02 : { strFuseF( tinP , psttP , T(ppostBigit[offFooGrain     ])+T("'gr" ) ) ; if( idLath == 0x02 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x01 : { strFuseF( tinP , psttP , T(ppostBigit[offFooTime      ])+T("'tm" ) ) ; if( idLath == 0x01 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
            {
            switch( idWoth )
            POSTPONEtEST( psttP ) ;
            strMakeF( tinP , psttP , T("") , TUCK ) ; // CALLER MUST TAG
            TN( tDelimiter , " " ) ; if( psttDelimiterP ) tDelimiter = T(psttDelimiterP) ;

            const countT idLath  = idLathP  ? idLathP  : 0x14 ;
            const countT idWoth = idWothP ? idWothP : 1 ;

            } ;
                "fu" ,
                "ee" ,
                "de" ,
                "ce" ,
                "be" ,
                "ay" ,
                "ni" ,
                "ta" ,
                "ve" ,
                "se" ,
                "fi" ,
                "fo" ,
                "re" ,
                "oo" ,
                "wo" ,
                "ze" ,
            {
            static osTextT* ppostBigit[] =

            TIMEpARTSoFF( Foo , time1P , time2P )
        {
        case ifcIDfORMATtIME_TEXT :
    {
    switch( idFormatP )

    _IO_

    }
        if( POOP ) return ;
        FV(flFORMAT,flagsFormatP) ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::strFromTimeF( tinS& tinP , strokeS*& psttP , countT time1P , sCountT time2P , const countT idWothP , const countT idLathP , const strokeS sttRadixP , const strokeS* const psttDelimiterP , const countT idFormatP , const flagsT flagsFormatP )/*1*/

/**/
*/
 some of these flags are ignored
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001004c.flFORMAT!||
 flagsFormatP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00103e9.ifcIDfORMATtIME!||
 idFormatP
 sttRadixP
  meaning depends upon format
  can be 0
 idLathP
  meaning depends upon format
  can be 0
 idWothP
 time2P
 time1P
 psttP
arguments
  \<A HREF=\"5.d810104.1.1.0.html\"\>d810104:  WAKEsHOW( "example.simplest.func.103003e.etherC.strFromTimeF" )\</A\>
 simplest
examples
\<A HREF=\"5.103003e.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strFromTimeF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

