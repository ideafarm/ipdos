
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("loafing") ) ;

while( ~hFind && !ether ) ;
}
    DEL( pInfo ) ;
    }
        etThread.delF( tinP , psttShort ) ;
        etThread.delF( tinP , psttDadFile ) ;

        }
            }
                etThread.delF( tinP , pbBufferDad ) ;
                etThread.delF( tinP , pbBufferMe  ) ;

                }
                    else         etThread.diskFileOrDirDeleteF( tinP , pInfo->psttIfoName ) ;
                    if( !bSame ) etThread.traceF( tinP , tDistinct ) ;

                    }
                        }
                            }
                                break ;
                                bSame = 0 ;
                            {
                            if( etThread.memCompareF( tinP , pbBufferMe , pbBufferDad , cbBite ) )

                            __( cbActual != cbBite ) ;
                            etThread.fileReadF( tinP , pbBufferDad , cbActual , hDad ) ;
                            cbActual = cbBite ;

                            __( cbActual != cbBite ) ;
                            etThread.fileReadF( tinP , pbBufferMe  , cbActual , hMe ) ;
                            countT cbActual = cbBite ;

                            etThread.traceF( tinP , TF2(cbBite,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tc+TF2(cbDoHigh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tInspecting ) ;

                            if( was < cbDo ) cbDoHigh -- ;
                            cbDo -= cbBite ;
                            countT was = cbDo ;

                            ;
                                    : cbBuffer
                                    ? cbDo
                                : cbDo < cbBuffer
                                ? cbBuffer
                            countT cbBite = cbDoHigh
                        {
                        while( cbDo || cbDoHigh )
                        countT cbDoHigh = pInfo->cbUsedHigh ;
                        countT cbDo     = pInfo->cbUsed     ;

                        etThread.fileOpenF( tinP , hMe , countTC() , pInfo->psttIfoName ) ;
                        handleC hMe( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                    {
                    boolT bSame = 1 ;
                {
                if( pbBufferMe && pbBufferDad )

                etThread.newF( tinP , LF , pbBufferDad , cbBuffer ) ; ___( pbBufferDad ) ;
                etThread.newF( tinP , LF , pbBufferMe  , cbBuffer ) ; ___( pbBufferMe  ) ;
                const countT cbBuffer = pInfo->cbUsed < TICK << 2 ? pInfo->cbUsed : TICK << 2 ;
                ZE( byteT* , pbBufferDad ) ;
                ZE( byteT* , pbBufferMe  ) ;
            {
            if( pInfoDad && pInfoDad->cbUsed == pInfo->cbUsed && pInfoDad->cbUsedHigh == pInfo->cbUsedHigh )
            etThread.diskFileQueryF( tinP , pInfoDad , hDad ) ;
            ZE( infoFileS* , pInfoDad ) ;

            etThread.fileOpenF( tinP , hDad , countTC() , psttDadFile ) ;
            handleC hDad( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;

            etThread.traceF( tinP , tInspecting ) ;
        {
        else
        if( !etThread.diskFileExistsF( tinP , psttDadFile ) ) etThread.diskMoveFileOrDirF( tinP , psttDadFile , pInfo->psttIfoName ) ;

        }
            etThread.delF( tinP , psttMeFile ) ;
            etThread.delF( tinP , psttPathDad ) ;

            }
                etThread.delF( tinP , psttMe ) ;

                etThread.strFuseF( tinP , psttDadFile , psttShort ) ;
                etThread.strMakeF( tinP , psttDadFile , psttPathDad , psttShort->idAdam ) ; ___( psttDadFile ) ;

                etThread.traceF( tinP , TF2(pInfo->cbUsed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tc+TF2(pInfo->cbUsedHigh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttShort) ) ;

                ___( psttShort  ) ;
                ___( psttMe ) ;
                etThread.strBisectF( tinP , psttMe , psttShort , psttMeFile , tSlash , -1 ) ;
                ZE( strokeS* , psttMe ) ;
            {

            ___( psttMeFile  ) ;
            ___( psttPathDad ) ;
            etThread.strBisectF( tinP , psttPathDad , psttMeFile , pInfo->psttIfoName , tSlash , -2 , flSTRbISECT_APPENDdELIMITER ) ;
            ZE( strokeS* , psttMeFile ) ;
            ZE( strokeS* , psttPathDad ) ;
        {
        ZE( strokeS* , psttShort ) ;
        ZE( strokeS* , psttDadFile ) ;
    {
    )
        !etThread.strIdF( tinP , tSlashDotDotSlash , pInfo->psttIfoName )
        &&
        !etThread.strIdF( tinP , tSlashDotSlash , pInfo->psttIfoName )
        &&
        pInfo
    (
    if
    etThread.diskFindFileOrDirOldF( tinP , pInfo , hFind , tLike ) ; ___( pInfo ) ;
    ZE( infoFileS* , pInfo ) ;
{
do
handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
TN( tc                , ":" ) ;
TN( tb4               , "    " ) ;
TN( tDistinct         , "distinct" ) ;
TN( tInspecting       , "inspecting " ) ;
TN( tSlash            , "/" ) ;
TN( tSlashDotSlash    , "/./" ) ;
TN( tSlashDotDotSlash , "/../" ) ;
TN( tLike , "///d/tmp/x.merge.archive/merged/from.drive.a/eat/*" ) ;

TODO

/*1*/WAKEsHOWtEXT( "tool.merge.dad.kid.directory" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

