
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    //etThread.osSleepF( tinP , TOCK ) ;

    etThread.strokeF( tinP , T("S") ) ;
    __( idType - IDtYPE ) ;
    scs.readF( tinP , idType ) ;
    idType = 0 ;
    scs.writeF( tinP , IDtYPE ) ;
    scs.connectF( tinP , idPortMe ) ;
    scs.bindF( tinP ) ;
    socketC scs( tinP , etThread , TAG( TAGiDnULL ) ) ;

    etThread.strokeF( tinP , T("D") ) ;
    __( idType - IDtYPE ) ;
    scd.readF( tinP , idType , idPort , nicName ) ;
    nicNameC nicName ;
    ZE( countT , idPort ) ;
    ZE( countT , idType ) ;
    scd.writeF( tinP , idPortMe , nicNameC() , IDtYPE ) ;
{
while( !etThread && !ether )

scd.bindF( tinP ) ;
socketC scd( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

}
    etThread.strokeF( tinP , T("main: saw sReadyS\r\n") ) ;
    sReadyS.waitF( tinP ) ;
    etThread.strokeF( tinP , T("main: waiting for sReadyS\r\n") ) ;
    etThread.osThreadF( tinP , countTC() , tmServeStreamF , 0 , flTHREADlAUNCH_null , 0 , (countT)&sReadyS ) ;
    signC sReadyS( tinP , TAG( TAGiDnULL ) ) ;
{

}
    etThread.strokeF( tinP , T("main: saw sReadyD; idPortMe: ")+TF1(idPortMe)+T("\r\n") ) ;
    sReadyD.waitF( tinP ) ;
    etThread.strokeF( tinP , T("main: waiting for sReadyD\r\n") ) ;
    etThread.osThreadF( tinP , countTC() , tmServeDatagramF , 0 , flTHREADlAUNCH_null , 0 , (countT)&sReadyD ) ;
    signC sReadyD( tinP , TAG( TAGiDnULL ) ) ;
{

TODO

DONE( tmServeDatagramF )
}
    }
        ssd.writeF( tinP , idPort , nicName , idType ) ;
        etThread.strokeF( tinP , T("d") ) ;
        __( idType - IDtYPE ) ;
        ssd.readF( tinP , idType , idPort , nicName ) ;
        nicNameC nicName ;
        ZE( countT , idPort ) ;
        ZE( countT , idType ) ;
    {
    while( !etThread && !ether )

    ++ sReadyD ;
    idPortMe = ssd.bindF( tinP ) ;
    socketC ssd( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    signC& sReadyD = *(signC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmServeDatagramF )

DONE( tmServeStreamF )
}
    }
        DEL( pso ) ;
        }
            pso->readF( tinP , &bb , 1 , flSOCKETcrEAD_STILLhUNGRYiSoK ) ;
            ZE( byteT , bb ) ;
            pso->writeF( tinP , idType ) ;
            etThread.strokeF( tinP , T("s") ) ;
            __( idType - IDtYPE ) ;
            pso->readF( tinP , idType ) ;
            ZE( countT , idType ) ;
        {
        else if( pso )
        if( ether ) { DEL( pso ) ; }
        sss.acceptF( tinP , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        ZE( socketC* , pso ) ;
    {
    while( !etThread && !ether )

    ++ sReadyS ;
    sss.listenF( tinP ) ;
    __( sss.bindF( tinP , idPortMe ) - idPortMe ) ;
    socketC sss( tinP , etThread , TAG( TAGiDnULL ) ) ;

    signC& sReadyS = *(signC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmServeStreamF )

countT idPortMe ;

#define IDtYPE   0x13924829

/*1*/WAKEhIDE( "example.other.func.1070005.socketC.bindF" )/*1*/
/**/
*/
i bind both a datagram and a stream socket to the same idPort value
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

