
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    baton.ungrabF( tinP ) ;

    }
        }
            ether.delF( tinP , psttnu ) ;
            ether.boxPutUniqueF( tinP , psttnu , T("///ideafarm/ephemeral/domains/com/ideafarm/1350007/transactions/")+TF1(idcHirer)+T("/share") , (byteT*)&c2b , sizeof c2b ) ; ___( psttnu ) ;
            ZE( strokeS* , psttnu ) ;
            c2b.c2 = swShare ; // ASSUME: sizeof( measureT ) == sizeof( countT )
            c2b.c1 = idCitizen ;
            count2S c2b ;
            idCitizen = swShare.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swShare.cFlavorsF( tinP ) ;
    {
    if( swShare )

    }
        ether.delF( tinP , psttnu ) ;
        ether.boxPutUniqueF( tinP , psttnu , T("///ideafarm/ephemeral/domains/com/ideafarm/1350007/transactions/")+TF1(idcHirer)+T("/payin") , (byteT*)&c2b , sizeof c2b ) ; ___( psttnu ) ;
        ZE( strokeS* , psttnu ) ;
        c2b.c2 = *(countT*)&mPayin ; // ASSUME: sizeof( measureT ) == sizeof( countT )
        c2b.c1 = idcHirer ;
        count2S c2b ;
    {
    if( mPayin )

    }
        ether.delF( tinP , psttnu ) ;
        ether.boxPutUniqueF( tinP , psttnu , T("///ideafarm/ephemeral/domains/com/ideafarm/1350007/transactions/")+TF1(idcHirer)+T("/debit") , (byteT*)&c2b , sizeof c2b ) ; ___( psttnu ) ;
        ZE( strokeS* , psttnu ) ;
        c2b.c2 = *(countT*)&mPriceTotal ; // ASSUME: sizeof( measureT ) == sizeof( countT )
        c2b.c1 = idcHirer ;
        count2S c2b ;
    {

    ether.delF( tinP , psttr52 ) ;
    ether.delF( tinP , psttr51 ) ;
    ether.delF( tinP , psttr42 ) ;
    ether.delF( tinP , psttr41 ) ;
    ether.delF( tinP , psttr32 ) ;
    ether.delF( tinP , psttr31 ) ;
    ether.delF( tinP , psttr22 ) ;
    ether.delF( tinP , psttr21 ) ;
    ether.delF( tinP , psttr12 ) ;
    ether.delF( tinP , psttr11 ) ;

    ether.strFuseF( tinP , psttP , psttr52 ) ; ___( psttP ) ;
    ether.strFuseF( tinP , psttP , psttr51 ) ; ___( psttP ) ;
    ether.strFuseF( tinP , psttP , psttr42 ) ; ___( psttP ) ;
    ether.strFuseF( tinP , psttP , psttr41 ) ; ___( psttP ) ;
    ether.strFuseF( tinP , psttP , psttr32 ) ; ___( psttP ) ;
    ether.strFuseF( tinP , psttP , psttr31 ) ; ___( psttP ) ;
    ether.strFuseF( tinP , psttP , psttr22 ) ; ___( psttP ) ;
    ether.strFuseF( tinP , psttP , psttr21 ) ; ___( psttP ) ;
    ether.strFuseF( tinP , psttP , psttr12 ) ; ___( psttP ) ;
    ether.strFuseF( tinP , psttP , psttr11 ) ; ___( psttP ) ;
    if( psttr11 && psttr12 && psttr21 && psttr22 && psttr31 && psttr32 && psttr41 && psttr42 && psttr51 && psttr52 ) { ether.strMakeF( tinP , psttP , T("") , psttr11->idAdam + psttr12->idAdam + psttr21->idAdam + psttr22->idAdam + psttr31->idAdam + psttr32->idAdam + psttr41->idAdam + psttr42->idAdam + psttr51->idAdam + psttr52->idAdam ) ; ___( psttP ) ; }

    }
        ) ; ___( psttr52 ) ;

            "payIn received = ")+TF4(mPayin,flFORMAT_EXPONENT,2,6)+( mPayin ? T("  (thank you)\r\n") : T("") )
            "total cost = ")+TF4(mPriceTotal,flFORMAT_EXPONENT,2,6)+T("\r\n"
            T("cDatum = ")+TF1(cDatum)+T("\r\n"

        ether.strFuseF( tinP , psttr52 ,

        ) ; ___( psttr51 ) ;

            T("\r\n\r\nNotes"":\r\n\r\n")

        ether.strFuseF( tinP , psttr51 ,
    {
    ZE( strokeS* , psttr52 ) ;
    ZE( strokeS* , psttr51 ) ;

    }
        }
            }
                }
                    }
                        else               { ether.strFuseF( tinP , psttr42 , T("\r\n") ) ; ___( psttr42 ) ; }
                        if( pcPart[ off ] ) { ether.strFuseF( tinP , psttr42 , off < 5 ? T("  ") : T(".") ) ; ___( psttr42 ) ; }
                        ether.strFuseF( tinP , psttr42 , off < 3 ? TF3(pcPart[off++],flFORMAT_FILLzE|flFORMAT_UNSIGNED,8) : ( off == 3 ? TF3(pcPart[off++],flFORMAT_FILLzE|flFORMAT_UNSIGNED,7) : TF1(pcPart[off++]) ) ) ; ___( psttr42 ) ;
                    {
                    while( pcPart[ off ] )
                    ZE( countT , off ) ;

                    ether.strFuseF( tinP , psttr42 , ( mPrice ? TF4(mPrice,flFORMAT_EXPONENT,2,6) : TP("",0xd) )+T("  ")+TF3(qty,0,8)+T("  ") ) ; ___( psttr42 ) ;

                    mPriceTotal += mPrice ;
                    }
                        }
                            }
                                swShare = *(countT*)&mShareTotal ;
                                mShareTotal += mShare ;
                                measureT mShareTotal = *(measureT*)&cShareTotal ;
                                countT cShareTotal = swShare ;
                                idCitizen = idc ;
                                stShare >> idc ;
                                ZE( countT , idc ) ;
                            {
                            while( stShare )
                            measureT mShare = mPrice / (countT)stShare ;
                        {
                        if( stShare )

                        }
                            }
                                stShare << idCitizen ;
                                sock.readF( tinP , (byteT*)&idCitizen , sizeof idCitizen ) ;
                                ZE( countT , idCitizen ) ;
                            {
                            while( cShare -- )
                            sock.readF( tinP , (byteT*)&cShare , sizeof cShare ) ;
                            ZE( countT , cShare ) ;
                            sock.writeF( tinP , (byteT*)( pcPart + 4 ) , ccPart * sizeof( countT ) ) ;
                            sock.writeF( tinP , (byteT*)&ccPart , sizeof ccPart ) ;
                            sock.writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;
                            sock.connectF( tinP , ifcPORToLD1pRICEaUTHORITY , 0x01010103 ) ;
                            socketC sock( tinP , ether , TAG( TAGiDnULL ) ) ;
                        {
                        idCmd = idCMDpRICER_SHARE ;
                        stackC stShare( tinP , ether , TAG( TAGiDnULL ) ) ;

                        }
                            sock.readF( tinP , (byteT*)&mPrice , sizeof mPrice ) ;
                            sock.writeF( tinP , (byteT*)&qty , sizeof qty ) ;
                            sock.writeF( tinP , (byteT*)( pcPart + 4 ) , ccPart * sizeof( countT ) ) ;
                            sock.writeF( tinP , (byteT*)&ccPart , sizeof ccPart ) ;
                            sock.writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;
                            sock.connectF( tinP , ifcPORToLD1pRICEaUTHORITY , 0x01010103 ) ;
                            socketC sock( tinP , ether , TAG( TAGiDnULL ) ) ;
                        {
                        countT ccPart   = ether.strBodyLengthF( tinP , pcPart + 4 ) ; // pcPart IS PREFIXED WITH 4 countT OBJECTS THAT ARE NOT PART OF THE pcPart, NARROWLY DEFINED
                        countT idCmd = idCMDpRICER_PRICE ;
                    {
                    if( ccPartBig > 4 )
                    ZE( measureT , mPrice ) ;
                    countT ccPartBig = ether.strBodyLengthF( tinP , pcPart ) ;
                    countT qty = swUsage ;
                {
                else
                if( !pcPart ) __1
                pcPart = (countT*)swUsage.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )

            }
                ether.strMakeF( tinP , psttr42 , T("") , csn ) ; ___( psttr42 ) ;
                }
                    csn += 0x20 * ( ccPart + 2 ) ; // (A FEW MORE PER LINE THAN WE REALLY NEED) //U: 0x10
                    countT ccPart = ether.strBodyLengthF( tinP , (countT*)swUsage.leverF( tinP , idf ) ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                ZE( countT , csn ) ;
            {

            ether.strMakeF( tinP , psttr41 , T("\r\n\r\nParts Usage:\r\n\r\n")+TPS("cost",0xd,S1C('-'))+T("  ")+TPS("qty",8,S1C('-'))+T("  ")+TPS("type",8,S1C('-'))+T("  ")+TPS("nicNameV4",8,S1C('-'))+T("  ")+TPS("idComp",8,S1C('-'))+T("  ")+TPS("idOwner",7,S1C('-'))+T("  ")+TPS("idPart",0x14,S1C('-'))+T("\r\n") ) ; ___( psttr41 ) ;
        {
        else
        if( !cFlavors ) { ether.strMakeF( tinP , psttr41 , T("") ) ; ___( psttr41 ) ; ether.strMakeF( tinP , psttr42 , T("") ) ; ___( psttr42 ) ; }
        const countT cFlavors = swUsage.cFlavorsF( tinP ) ;
    {
    ZE( strokeS* , psttr42 ) ;
    ZE( strokeS* , psttr41 ) ;
    ZE( measureT , mPriceTotal ) ;
    switchC swShare( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , idCitizen ) ;
    ZE( countT , idCitizen ) ;

    }
        }
            while( ~handle ) ;
            }
                if( psttl ) { ether.strFuseF( tinP , psttr32 , T(psttl)+T("\r\n") ) ; ___( psttr32 ) ; }
                strokeS* psttl = (strokeS*)stLog.downF( tinP , handle ) ;
            {
            do

            }
                ether.strMakeF( tinP , psttr32 , T("") , csn ) ; ___( psttr32 ) ;
                while( ~handle ) ;
                }
                    if( psttl ) { csn += psttl->idAdam + 2 ; }
                    strokeS* psttl = (strokeS*)stLog.downF( tinP , handle ) ;
                {
                do
                ZE( countT , csn ) ;
            {

            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ether.strMakeF( tinP , psttr31 , T("\r\n\r\nEvents which did not result in impotence:\r\n\r\n") ) ; ___( psttr31 ) ;
        {
        else
        if( !stLog ) { ether.strMakeF( tinP , psttr31 , T("") ) ; ___( psttr31 ) ; ether.strMakeF( tinP , psttr32 , T("") ) ; ___( psttr32 ) ; }
    {
    ZE( strokeS* , psttr32 ) ;
    ZE( strokeS* , psttr31 ) ;

    }
        }
            while( ~handle ) ;
            }
                if( psttl ) { ether.strFuseF( tinP , psttr22 , T(psttl)+T("\r\n") ) ; ___( psttr22 ) ; }
                strokeS* psttl = (strokeS*)stLogImpotence.downF( tinP , handle ) ;
            {
            do

            }
                ether.strMakeF( tinP , psttr22 , T("") , csn ) ; ___( psttr22 ) ;
                while( ~handle ) ;
                }
                    if( psttl ) { csn += psttl->idAdam + 2 ; }
                    strokeS* psttl = (strokeS*)stLogImpotence.downF( tinP , handle ) ;
                {
                do
                ZE( countT , csn ) ;
            {

            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

            ether.strMakeF( tinP , psttr21 , T("\r\n\r\nImpotence events"":\r\n\r\n") ) ; ___( psttr21 ) ;
        {
        else
        if( !stLogImpotence ) { ether.strMakeF( tinP , psttr21 , T("") ) ; ___( psttr21 ) ; ether.strMakeF( tinP , psttr22 , T("") ) ; ___( psttr22 ) ; }
    {
    ZE( strokeS* , psttr22 ) ;
    ZE( strokeS* , psttr21 ) ;

    }
        ether.strFuseF( tinP , psttr12 , T("") ) ; ___( psttr12 ) ;
        ether.strFuseF( tinP , psttr11 , T("IdeaFarm " "(tm) City / Citizen ")+TF1(idcHirer)+T(" Activity Report / http://www.ideafarm.com\r\n") ) ; ___( psttr11 ) ;
    {
    ZE( strokeS* , psttr12 ) ;
    ZE( strokeS* , psttr11 ) ;

    baton.grabF( tinP , TAG( TAGiDnULL ) ) ;

    _IO_

    if( ether ) return ;
{
/*1*/voidT carC::strF( tinS& tinP , strokeS*& psttP )/*1*/

/**/
*/
  should be 0 unless caller knows for sure how many strokes will be used
  if 0 then will always allocate enough strokes for psttP
  if not 0, then must have enough extra strokes to receive an appended string
  can be 0
 psttP
 tinP
arguments
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.1350007.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

