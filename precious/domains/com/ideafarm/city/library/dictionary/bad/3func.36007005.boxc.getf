
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    else __1
    }
        else __1
        }
            }
                ether.memCopyF( tinP , pbP , pbNapkin , cbP ) ;
                ether.newF( tinP , LF , pbP , cbP ) ; ___( pbP ) ;
                if( !POOP ) cbP = cbNapkin ;
                __( cbP ) ;
                countT cbNapkin = *(countT*)( pbNapkin - sizeof(countT) ) ;
            {
            if( pbNapkin )
        {
        else if( !ether.strCompareF( tinP , psttType , T("napkin.make") ) || !ether.strCompareF( tinP , psttType , T("napkin") ) )
        }
            if( !ether && pHoseProcessError ) { pHoseProcessError->getF( tinP , pbP , cbP ) ; ___( pbP ) ; }
        {
        else if( !ether.strCompareF( tinP , psttType , T("process.error") ) )
        }
            if( !ether && pHoseProcessOut ) { pHoseProcessOut->getF( tinP , pbP , cbP ) ; ___( pbP ) ; }
        {
        else if( !ether.strCompareF( tinP , psttType , T("process.out") ) )
        }
        {
        else if( !ether.strCompareF( tinP , psttType , T("process.in") ) )
        }
        {
        else if( !ether.strCompareF( tinP , psttType , T("process") ) )
        }
            #endif
                }
                    else break ;
                    }
                        }
                            ++ s ; ether.osSleepF( tinP ) ;
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        ether = 0 ;
                    {
                    if( POOP )
                    pBatHPC->ungrabF( tinP ) ;
                    ether.fileReadF( tinP , pbP , cbP , hHoseCommand ) ;
                    pBatHPC->grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                while( !ether )
                if( !POOP ) pbP[ cbP ] = 0 ;
                ether.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
                }
                    else break ;
                    }
                        }
                            ++ s ; ether.osSleepF( tinP ) ;
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        ether = 0 ;
                    {
                    if( POOP )
                    pBatHPC->ungrabF( tinP ) ;
                    ether.fileReadF( tinP , (byteT*)&cbP , cb1 , hHoseCommand ) ;
                    countT cb1 = sizeof cbP ;
                    pBatHPC->grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                while( !ether )
                //U:ASSUME: MESSAGES ARE SMALL ENOUGH THAT FILE POINTER WILL NEVER BE MOVED UNLESS THE ENTIRE MESSAGE CAN BE READ
                //U:NT: ENHANCE THIS CODE TO IMPLEMENT cbP == -1 I.E. CLIENT DOES NOT KNOW HOW MANY BYTES IT WILL WRITE TO THIS HOSE
            #elif defined( __NT__ )
                ether.fileReadF( tinP , pbP , cbP , handle , fStupidClient ) ;
                }
                    else                pbP[ cbP ] = 0 ;
                    if( fStupidClient ) ether.memSetF( tinP , pbP , cbP + 1 ) , *pbP = '\xDB' ;
                {
                if( !ether && pbP )
                ether.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
                if( cbP == - 1 ) fStupidClient = 1 , cbP = CBlIMITfROMsTUPIDcLIENT ;
                ether.fileReadF( tinP , (byteT*)&cbP , cb1 , handle ) ;
                countT cb1 = sizeof cbP ;
                ZE( boolT , fStupidClient ) ;
            #ifdef __OS2__
        {
        else if( !ether.strCompareF( tinP , psttType , T("tap") ) )
        }
            #endif
                }
                    else break ;
                    }
                        }
                            ++ s ; ether.osSleepF( tinP ) ;
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        ether = 0 ;
                    {
                    if( POOP )
                    pBatHPR->ungrabF( tinP ) ;
                    ether.fileReadF( tinP , pbP , cbP , hHoseReply ) ;
                    pBatHPR->grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                while( !ether )
                if( !POOP ) pbP[ cbP ] = 0 ;
                ether.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
                }
                    else break ;
                    }
                        }
                            ++ s ; ether.osSleepF( tinP ) ;
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        ether = 0 ;
                    {
                    if( POOP )
                    pBatHPR->ungrabF( tinP ) ;
                    ether.fileReadF( tinP , (byteT*)&cbP , cb1 , hHoseReply ) ;
                    countT cb1 = sizeof cbP ;
                    pBatHPR->grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                while( !ether )
                //U:ASSUME: MESSAGES ARE SMALL ENOUGH THAT FILE POINTER WILL NEVER BE MOVED UNLESS THE ENTIRE MESSAGE CAN BE READ
            #elif defined( __NT__ )
                ether.fileReadF( tinP , pbP , cbP , handle ) ;
                if( !POOP ) pbP[ cbP ] = 0 ;
                ether.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
                ether.fileReadF( tinP , (byteT*)&cbP , cb1 , handle ) ;
                countT cb1 = sizeof cbP ;
            #ifdef __OS2__
        {
        else if( !ether.strCompareF( tinP , psttType , T("hose") ) )
        }
            }
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
                }
                    cbP = 0 ;
                    ether.delF( tinP , pbP ) ;
                {
                if( POOP )

linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
                ether.fileReadF( tinP , pbP , cbP , handle ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
                }
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
                    ether.delF( tinP , psttMapped ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
                    ether.fileOpenF( tinP , handle , flagsResult , psttMapped , ifcOPENaCCESS_WR , 0 , flOPENdETAILS_FAIL | flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , 0 , 0 , cOpenTries ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
                    ether.diskMakeDirIfNeededF( tinP , psttMapped ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
                    ZE( countT , flagsResult ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
                    ether.diskMapFileNameF( tinP , psttMapped , psttAll ) ; ___( psttMapped ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
                    ZE( strokeS* , psttMapped ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
                {
                if( !handle )
            {
            if( cbP )
            if( pbP ) pbP[ cbP ] = 0 ;
            if( !POOP ) { ether.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ; }
            cbP = cbFileF( tinP ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
        {
        if( psttType && !psttType->idAdam )
        __NZ( cbP ) ;
    {
    else if( !psttHost->idAdam )
    }
        so.writeF( tinP , soulo2 ) ;
        soulC soulo2( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_BYE ) ;

        souli.shiftRightF( tinP , pbP , cbP , ifcIDtYPEsOULiTEM_byteTptr ) ; ___( pbP ) ;
        __( idCmd - ifcIDcMDsESSION_GETfYLErEPLY ) ;
        souli >> idCmd ;
        ZE( countT , idCmd ) ;
        so.readF( tinP , souli ) ;
        soulC souli( tinP , TAG( TAGiDnULL ) ) ;

        so.writeF( tinP , soulo ) ;
        so.connectF( tinP , ifcPORToLD2_CHAT , socketC::nicNameIF( tinP , ether , T(WWWiDEAFARMcOM) ) ) ;
        socketC so( tinP , ether , TAG( TAGiDnULL ) ) ;

        soulo << psttName ;
        soulC soulo( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_GETfYLE ) ;
    {
    else if( !ether.strCompareF( tinP , psttType , T("fyle") ) )
    }
        }
            }
                ether.delF( tinP , pstti ) ;
                cbP = ether.strMakeF( tinP , pbP , pstti ) ; ___( pbP ) ;
                pSControl->readWoMultilineF( tinP , pstti , T(".") , 0x10000 ) ; ___( pbP ) ; //U: csttEstimateP
                ZE( strokeS* , pstti ) ;
            {
            if( !POOP )
            //U: info.fZombie = 0 ;
            verifyReplyF( tinP , 215 ) ;
            pSControl->writeF( tinP , (osTextT*)T("list newsgroups\r\n") ) ;

            //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
            infoBoxGetPutS info( tinP , ether , *pSControl ) ;

            __( cbP ) ;
        {
        else
        }
            }
                ether.delF( tinP , pstti ) ;
                cbP = ether.strMakeF( tinP , pbP , pstti ) ; ___( pbP ) ;
                pSControl->readWoMultilineF( tinP , pstti , T(".") , 0x10000 ) ; ___( pbP ) ; //U: csttEstimateP
                ZE( strokeS* , pstti ) ;
            {
            if( !POOP )
            //U: info.fZombie = 0 ;
            verifyReplyF( tinP , 220 ) ;
            ether.delF( tinP , psttIdWanted ) ;
            { textC txt = T("article ")+T(psttIdWanted)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }

            //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
            infoBoxGetPutS info( tinP , ether , *pSControl ) ;

            }
                ether.strFromF( tinP , psttIdWanted , idWanted , flFORMAT_NObASE|flFORMAT_FOREIGN , 0 , 10 ) ; ___( psttIdWanted ) ;
                cbP = 0 ;
                __Z( idWanted ) ;
                sCountT idWanted = cbP ;
            {
            ZE( strokeS* , psttIdWanted ) ;
        {
        if( psttName && psttName->idAdam )
    {
    else if( !ether.strCompareF( tinP , psttType , T("news") ) && pSControl )
    }
        }
            ether.delF( tinP , pstti ) ;
            cbP = ether.strMakeF( tinP , pbP , pstti ) ; ___( pbP ) ;
            pSControl->readWoMultilineF( tinP , pstti , T(".") , 0x10000 ) ; ___( pbP ) ; //U: csttEstimateP
            ZE( strokeS* , pstti ) ;
        {
        if( !POOP )

        //U: info.fZombie = 0 ;
        verifyReplyF( tinP ) ;
        ether.delF( tinP , psttIdWanted ) ;
        else { textC txt = T("retr ") + T(psttIdWanted) + T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }
        }
            ether.delF( tinP , psttTop ) ;
            { textC txt = T("top ") + T(psttIdWanted) + T(" ") + T(psttTop) + T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }
        {
        if( psttTop )
        //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
        infoBoxGetPutS info( tinP , ether , *pSControl ) ;

        }
            ether.strFromF( tinP , psttIdWanted , idWanted , flFORMAT_NObASE|flFORMAT_FOREIGN , 0 , 10 ) ; ___( psttIdWanted ) ;
            cbP = 0 ;
            __Z( idWanted ) ;
            }
                ether.strMakeF( tinP , psttTop , T("200") ) ; ___( psttTop ) ;
                idWanted = - idWanted ;
            {
            if( idWanted < 0 )
            sCountT idWanted = cbP ;
        {
        ZE( strokeS* , psttTop ) ;
        ZE( strokeS* , psttIdWanted ) ;
    {
    else if( !ether.strCompareF( tinP , psttType , T("pop") ) && pSControl )
    }
        }
            while( !ether && ( bNoQuitEarly || ( cTries && -- cTries ) ) ) ; // thirdC::thPrimeIF( tinP ) IS NOT CHECKED HERE BECAUSE IT WOULD HANG IF I AM CALLED DURING TERMINATION, AFTER thPrimeIF HAS BEEN DESTROYED
            }
                }
                    ++ s ; ether.osSleepF( tinP ) ;
                    ether.traceF( tinP , T("boxC::getF / napping for a wink") ) ;

                    if( POOP ) POOPR

                    }
                        pSControl->connectF( tinP , /*port 80*/idPort , hidIfo , cOpenTries ) ;
                        nicNameC hidIfo = socketC::nicNameIF( tinP , ether , psttHost->idAdam ? psttHost : 0 ) ;
                    {
                    if( !POOP )

                    pSControl->etherF( tinP , *tinP.pEtScratch ) ;

                    __Z( pSControl ) ;
                    pSControl = new( 0 , tinP , LF ) socketC( tinP , ether , TAG( TAGiDnULL ) ) ; ___( pSControl ) ;
                    //DUPLICATEcODE: 36007001 36007005

                    DEL( pSControl ) ;

                    pSControl->etherF( tinP , etSave ) ;

                    POOPR
                {
                else
                }
                    break ;
                    pSControl->etherF( tinP , etSave ) ;
                {
                if( !POOP )

                }
                    }
                        }
                            }
                                if( !pSControl->readF( tinP , &ostWo , 1 ) ) { BLAMMO ; } ; // '\n'
                                if( !pSControl->readF( tinP , &ostWo , 1 ) ) { BLAMMO ; } ; // '\r'

                                }
                                    }
                                        costDo   -= costGot ;
                                        cbP += costGot ;
                                    {
                                    if( !POOP )

                                    __Z( costGot ) ;
                                    countT costGot = pSControl->readF( tinP , pbP + cbP , costDo ) ;
                                {
                                while( costDo && !POOP )

                                if( !pSControl->readF( tinP , &ostWo , 1 ) ) { BLAMMO ; } ; // '\n'
                                osTextT ostWo ;
                            {
                            else
                            if( !costDo ) break ;

                            offl = - 1 ;
                            countT costDo = ether.strDigitsToSCountF( tinP , T(postLengthBuffer) , 0 , 1 ) ;
                            thirdC::c_strlwrIF( tinP , postLengthBuffer) ;
                            postLengthBuffer[ offl ] = 0 ;
                        {
                        if( postLengthBuffer[ offl ] == '\r' )

                        if( !pSControl->readF( tinP , postLengthBuffer + offl , 1 ) ) { BLAMMO ; } ;
                    {
                    for( countT offl = 0 ; offl < sizeof postLengthBuffer - 1 ; offl ++ )
                    osTextT postLengthBuffer[ TUCK ] = { 0 } ;

                    __Z( pbP ) ;
                    ether.newF( tinP , LF , pbP , TOCK ) ; ___( pbP ) ; //CAPACITY LIMIT FOR BODY

                    __NZ( cbP ) ;
                    __NZ( pbP ) ;
                {
                else
                }
                    }
                        pbP[ cbP ] = 0 ;
                        else      cbP = 0 ;
                        if( cbe ) cbP = pSControl->readF( tinP , pbP , cbe , bLengthSet ? flSOCKETcrEAD_null : flSOCKETcrEAD_WObYTEpERbITE ) ; //U::BUG: WILL HANG IF IFC SERVER RETURNS HEADERS ONLY WITH NO CONTENT-LENGTH HEADER
                        //U::CONJ: flSOCKETcrEAD_WObYTEpERbITE WILL WORK AROUND APACHE SHIT BEHAVIOR OF CLOSING CONNECTION AFTER WOTH RECV
                    {
                    if( !POOP )

                    __Z( pbP ) ;
                    if( !POOP ) { ether.newF( tinP , LF , pbP , cbe + 1 ) ; ___( pbP ) ; }
                {
                if( !bChunked )

                countT cbe = bChunked ? 0 : bLengthSet ? cbP : TOCK ;
                }
                    ether.delF( tinP , psttl ) ;
                    }
                        else if( idf = 1 , 1 == ether.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tTransferEncoding , psttl ) ) bChunked = !!ether.strIdF( tinP , tChunked , psttl ) ;
                        }
                            bLengthSet = 1 ;
                            ether.delF( tinP , psttw ) ;
                            cbP = ether.strDigitsToSCountF( tinP , psttw , 0xa , 1 ) ;
                            ether.strTrimF( tinP , psttw , 0 , T(TbLACKnEWlINE) ) ; ___( psttw ) ;
                            ether.strSubstringF( tinP , psttw , idf , idl , psttl ) ; ___( psttw ) ;
                            ZE( countT , idl ) ;
                            //sttq = ze ;
                            ZE( strokeS* , psttw ) ;
                        {
                        else if( 1 == ether.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tContentLength , psttl ) )
                        }
                            }
                                ether.delF( tinP , pstt1w ) ;
                                }
                                    break ;
                                    if( ether.strCompareF( tinP , psttc1 , t200 ) && ether.strCompareF( tinP , psttc1 , t307 ) ) { __1 } ;
                                    if( ++ idWord == 1 ) continue ;
                                {
                                FORsTRINGSiN1( pstt1w )
                                ZE( countT , idWord ) ;
                                ether.strWordsF( tinP , pstt1w , psttl , sttq ) ; ___( pstt1w ) ;
                                ZE( strokeS* , pstt1w ) ;
                            {
                            if( !POOP )                        
                            if( psttl->idAdam > TUCK ) { __( psttl->idAdam ) ; } // DEFENSIVE
                            bWoth = 0 ;
                        {
                        else if( bWoth )
                        }
                            break ;
                            ether.delF( tinP , psttl ) ;
                            __NZ( bWoth ) ;
                        {
                        if( !psttl->idAdam )

                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                        countT idf = 1 ;
                        ether.strConvertToLowerCaseF( tinP , psttl ) ; ___( psttl ) ;
                    {
                    if( psttl )

                    }
                        break ;
                        ether.delF( tinP , psttl ) ;
                    {
                    if( POOP )

                    __Z( psttl ) ;
                    //etherC::etRockIF( tinP ).traceF( tinP , psttl ) ;
                    pSControl->readWoLineF( tinP , psttl , TOCK ) ; ___( psttl ) ; //U: csttEstimateP
                    ZE( strokeS* , psttl ) ;
                {
                for(;;)
                boolT bWoth = 1 ;
                ZE( boolT , bChunked ) ;
                ZE( boolT , bLengthSet ) ;
                TN( tChunked , "chunked" ) ;
                TN( tTransferEncoding , "transfer-encoding:" ) ;
                TN( tContentLength , "content-length:" ) ;

                }
                    //etherC::etRockIF( tinP ).traceF( tinP , tRequest ) ;
                    pSControl->writeF( tinP , (osTextT*)tRequest ) ;

                    if( postBodyP ) tRequest += T(postBodyP) ;

                    tRequest += T("\r\n\r\n") ;

                    }
                        if( costBodyP  ) tRequest += T("\r\nContent-Length: ")+TF4(costBodyP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa) ;
                        if( !costBodyP ) costBodyP = thirdC::c_strlenIF( tinP , postBodyP ) ;
                    {
                    if( postBodyP )

                    TN( tRequest , "" ) ; tRequest = T(F(flagsP)&flBOXcgETf_HTTPpOST?"POST /":"GET /")+T(psttName)+T(" HTTP/1.1\r\nHost: ")+T(psttHost) ;
                {

                pSControl->etherF( tinP , *tinP.pEtScratch ) ;
            {
            do
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            countT cTries = cOpenTries ;
            TN( t307 , "307" ) ; //U:: 20190817@1559: EDIT TO FULLY SUPPORT TEMPORARY AND PERMANENT REDIRECTS (SILENTLY FOLLOW REDIRECTS UNLESS CALLER TELLS ME NOT TO)
            TN( t200 , "200" ) ;

            __NZ( &etSave != &ether ) ;
            etherC& etSave = pSControl->etherF( tinP ) ;

            SCOOPS
        {
        IFsCRATCH
        boolT bNoQuitEarly = !cOpenTries ;

        }
            if( psttName->idAdam ) { __( psttName[ CSpREFIX ].idAdam == ' ' ) ; } //U: GOAL IS TO ENSURE THAT THERE ARE NO BLANKS ANYWHERE IN psttName
            //20190818@1037: COMMENTED OUT WITHOUT ANALYSIS: __( !psttName->idAdam ) ;
        {
        if( psttName )
        __( cbP ) ;
    {
    else if( !ether.strCompareF( tinP , psttType , T("http") ) && pSControl )
    }
        else         ether.delF( tinP , pbP ) ;
        if( !POOP ) cbP = cbFile ;
        DEL( pso ) ;
        verifyReplyF( tinP , 0xe2 ) ; // 226

        }
            }
                pso->readF( tinP , pbP , cbFile ) ;
                pbP[ cbFile ] = 0 ;
                ether.newF( tinP , LF , pbP , cbFile + 1 ) ; ___( pbP ) ;
            {
            if( cbFile ) //THIS WILL HANG FOREVER IF THE REMOTE HOST FAILS TO SEND ENOUGH BYTES
        {
        if( !POOP )

        verifyReplyF( tinP , 0x96 ) ; // 150
        __Z( pso ) ;
        __( bRefuse ) ;
        sData.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ;
        ZE( boolT , bRefuse ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        ZE( socketC* , pso ) ;

        { textC txt = T("retr ")+T(psttName)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }

        verifyReplyF( tinP , 200 ) ;
        ether.delF( tinP , pstthp ) ;
        { textC txt = T("port ")+T(pstthp)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }
        ether.strFromIdPortNicNameF( tinP , pstthp , idPort , nicName ) ; ___( pstthp ) ;
        ZE( strokeS* , pstthp ) ;
        { nicNameC nicNamenu ; sData.myNameF( tinP , idPort , nicNamenu ) ; }
        ZE( countT , idPort ) ;
        { ZE( countT , idpnu ) ; pSControl->myNameF( tinP , idpnu , nicName ) ; }
        nicNameC nicName ;
        sData.listenF( tinP ) ;
        sData.bindF( tinP ) ;
        socketC sData( tinP , ether , TAG( TAGiDnULL ) ) ;

        //U: info.fZombie = 0 ;
        }
            __( rc != 213 && rc != 211 ) ;
            ether.delF( tinP , psttReply ) ;
            cbFile = cbFileF( tinP , psttReply ) ;
            countT rc = pSControl->readWoReplyF( tinP , psttReply ) ; ___( psttReply ) ;
            ZE( strokeS* , psttReply ) ;
        {
        if( !POOP )
        ZE( sCountT , cbFile ) ;

        { textC txt = T("stat ")+T(psttName)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }
        __NZ( cbP ) ;

        //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
        infoBoxGetPutS info( tinP , ether , *pSControl ) ;
    {
    else if( !ether.strCompareF( tinP , psttType , T("ftp") ) && pSControl )
    }
        }
            cbP = 0 ;
            ether.delF( tinP , pbP ) ;
        {
        if( POOP )
        //U: info.fZombie = 0 ;

        pSControl->readF( tinP , pbP , cbP ) ;
        ether.newF( tinP , LF , pbP , cbP ) ; ___( pbP ) ;
        cbP = 2 * sizeof( countT ) ;

        //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
        infoBoxGetPutS info( tinP , ether , *pSControl ) ;
    {
    else if( !ether.strCompareF( tinP , psttHost , T(WWWiDEAFARMcOM) ) && !ether.strCompareF( tinP , psttType , T("dispatcher") ) && pSControl )
    }
        }
            cbP = 0 ;
            ether.delF( tinP , pbP ) ;
        {
        if( POOP )
        //U: info.fZombie = 0 ;

        pSControl->readF( tinP , pbP , cbP ) ;
        ether.newF( tinP , LF , pbP , cbP ) ; ___( pbP ) ;
        cbP = sizeof( sCountT ) + sizeof( countT ) ;

        //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
        infoBoxGetPutS info( tinP , ether , *pSControl ) ;
    {
    else if( !ether.strCompareF( tinP , psttHost , T(WWWiDEAFARMcOM) ) && !ether.strCompareF( tinP , psttType , T("time") ) && pSControl )
    }
        }
            }
                cbP = 0 ;
                ether.delF( tinP , pbP ) ;
            {
            if( POOP )

            }
                if( cbP ) pSControl->readF( tinP , pbP , cbP ) ;
                if( pbP ) pbP[ cbP ] = 0 ;
                ether.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
                __( cbAll - sizeof( countT ) - cbP ) ;
                pSControl->readF( tinP , (byteT*)&cbP , sizeof cbP ) ;
            {
            else
            }
                pSControl->readF( tinP , pbP , cbP ) ;
                ether.newF( tinP , LF , pbP , cbP ) ; ___( pbP ) ;
                cbP = cbAll ;
            {
            if( !!ether.strIdF( tinP , idf , sttq , S1C(' ') , psttName ) )
        {
        if( !POOP )
        }
            __1
            if( !( F(ether.flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) ) ether.etherPutLogF( tinP , psttName ) ;
        {
        if( !cbAll )
        //U: info.fZombie = 0 ;
        pSControl->readF( tinP , (byteT*)&cbAll , sizeof cbAll ) ;
        ZE( countT , cbAll ) ;
        { textC txt = T(psttName)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;

        //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
        infoBoxGetPutS info( tinP , ether , *pSControl ) ;
    {
    if( !ether.strCompareF( tinP , psttType , T("box.server") ) || !ether.strCompareF( tinP , psttType , T("box.server.adam") ) || !ether.strCompareF( tinP , psttType , T("box.server.deputy") ) && pSControl )
    // GET THE BACKING FILE BYTES
    _IO_

    }
        if( POOP ) return ;
        //U::FV( flBOXcgET , flagsP ) ;
        __Z( psttName ) ;
        __Z( psttType ) ;
        __Z( psttHost ) ;
        __NZ( pbP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
    SCOOP
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
{
/*1*/voidT boxC::getF( tinS& tinP , byteT*& pbP , countT& cbP , const flagsT flagsP , const osTextT* const postBodyP , countT costBodyP )/*1*/

/**/
*/
 cbP
 pbP
arguments
pbP and cbP must be ze, except where noted otherwise
 /napkin: get bytes from a napkin
 /napkin.make: get bytes from a napkin
  assumption:  messages are small enough to fit entirely within an internal buffer
 /tap/name: gets a message from a tap
  assumption:  messages are small enough to fit entirely within an internal buffer
 /hose/name: gets a message from a hose
 //name: gets the bytes of a local file
 host/news: retrieves the mail item whose id is specified in cbP (which must be nonze)
 host/pop: retrieves the mail item whose id is specified in cbP (which must be nonze)
 host/http: gets the remote file's bytes
 host/ftp: gets the remote file's bytes
  the time is returned in an timeS structure
 www.ideafarm.com/time: gets reference time from city center
gets all bytes contained in this box
  \<A HREF=\"5.6120104.1.1.0.html\"\>6120104:  WAKEsHOW( "example.simplest.func.1090005.boxC.getF" )\</A\>
 simplest
examples
\<A HREF=\"5.1090005.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$getF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

