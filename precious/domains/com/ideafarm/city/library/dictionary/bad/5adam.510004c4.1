
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.strokeF( tinP , tc ) ;
for( off = 0 ; off < oOut ; off ++ ) etThread.strokeF( tinP , tb+TF1(pbOut[off]) ) ;
etThread.strokeF( tinP , T("heard:") ) ;

hearF( tinP , pbOut , sizeof pbOut , oOut , pcConnection , oConnection ) ;
thirdC::c_memsetIF( tinP , pbOut , sizeof pbOut ) ;
byteT pbOut[ 0x60 ] ;
ZE( countT , oOut ) ;

etThread.strokeF( tinP , tc ) ;
for( off = 0 ; off < oConnection ; off ++ ) etThread.strokeF( tinP , tb+TF1(pcConnection[off]) ) ;
etThread.strokeF( tinP , T("code:") ) ;

talkF( tinP , pcConnection , sizeof pcConnection / sizeof pcConnection[ 0 ] , oConnection , pbIn , sizeof pbIn ) ;
ZE( countT , oConnection ) ;
thirdC::c_memsetIF( tinP , (byteT*)pcConnection , sizeof pcConnection ) ;
countT pcConnection[ 0x100 ] ;

etThread.strokeF( tinP , tc ) ;
for( off = 0 ; off < sizeof pbIn ; off ++ ) etThread.strokeF( tinP , tb+TF1(pbIn[off]) ) ;
etThread.strokeF( tinP , T("said:") ) ;
TN( tc , "\r\n" ) ;
TN( tb , " " ) ;

for( countT off = 0 ; off < sizeof pbIn ; off ++ ) pbIn[ off ] = (byteT)( off % 2 + 1 ) ;
byteT pbIn[ 0x40 ] ;

TODO

}
        decodeF( tinP , pbOutP , cbOutP , oOutP , pcConnectionP , ccConnectionP , oIn , pbRemember , sizeof pbRemember , oWindow , pbAppend ) ;
    while( oIn < ccConnectionP )
    ZE( countT , oIn ) ;
    
    ZE( countT , oWindow ) ;
    thirdC::c_memsetIF( tinP , pbAppend   , sizeof pbAppend   ) ;
    thirdC::c_memsetIF( tinP , pbRemember , sizeof pbRemember ) ;
    byteT pbAppend[ CBwINDOW - 1 ] ; //MUST FOLLOW pbRemember CONTIGUOUSLY
    byteT pbRemember[ CBrEMEMBER ] ;
{
voidT hearF( tinS& tinP , byteT* const pbOutP , const countT cbOutP , countT& oOutP , countT* const pcConnectionP , const countT ccConnectionP )

}
        encodeF( tinP , pcConnectionP , ccConnectionP , oConnectionP , pbInP , cbInP , oIn , pbRemember , sizeof pbRemember , oWindow , pbAppend ) ;
    while( oIn < cbInP )
    ZE( countT , oOut ) ;
    ZE( countT , oIn ) ;
    
    ZE( countT , oWindow ) ;
    thirdC::c_memsetIF( tinP , pbAppend   , sizeof pbAppend   ) ;
    thirdC::c_memsetIF( tinP , pbRemember , sizeof pbRemember ) ;
    byteT pbAppend[ CBwINDOW - 1 ] ; //MUST FOLLOW pbRemember CONTIGUOUSLY
    byteT pbRemember[ CBrEMEMBER ] ;
{
voidT talkF( tinS& tinP , countT* const pcConnectionP , const countT ccConnectionP , countT& oConnectionP , const byteT* const pbInP , const countT cbInP )

}
    if( cbOutP && ccConnectionP ) ;

    }
        }
            if( oWindowP == cbRememberP ) oWindowP = 0 ;
            pbRememberP[ oWindowP ++ ] = pbOutP[ oOutP ++ ] ;
        {
        while( cbHit -- ) //U::THIS CAN BE DONE FASTER WITH WO OR OO MEMCPY CALLS

        thirdC::c_memcpyIF( tinP , pbOutP + oOutP , pbRememberP + oWindowP + code - 0x100 , cbHit ) ;
    {
    else
    }
        if( oWindowP == cbRememberP ) oWindowP = 0 ;
        pbRememberP[ oWindowP ++ ] = (byteT)code ;

        pbOutP[ oOutP ++ ] = (byteT)code ;
        if( cbHit != 1 ) BLAMMO ;
    {
    if( code < 0x100 )

    if( !cbHit ) BLAMMO ;
    countT code  = pcConnectionP[ oInP ++ ] ;
    countT cbHit = pcConnectionP[ oInP ++ ] ;

    if( oWindowP + CBwINDOW > cbRememberP ) thirdC::c_memcpyIF( tinP , pbAppendP , pbRememberP , CBwINDOW - ( cbRememberP - oWindowP ) ) ; //U::O: DO THIS ONLY IF I HAVEN'T DONE IT SINCE WRITING THE SOURCE BYTES
{
voidT decodeF( tinS& tinP , byteT* const pbOutP , const countT cbOutP , countT& oOutP , const countT* const pcConnectionP , const countT ccConnectionP , countT& oInP , byteT* const pbRememberP , const countT cbRememberP , countT& oWindowP , byteT* const pbAppendP )

}
    if( ccOutP && cbInP ) ;

    }
        if( oWindowP == cbRememberP ) oWindowP = 0 ;
        pbRememberP[ oWindowP ++ ] = pbInP[ oInP ++ ] ;
    {
    while( cbHit -- )

    }
        cbHit = 1 ;
        pcOutP[ oOutP ++ ] = pbInP[ oInP ] ;
        pcOutP[ oOutP ++ ] = 1 ;
    {
    else
    }
        pcOutP[ oOutP ++ ] = oHit + 0x100 ;
        pcOutP[ oOutP ++ ] = cbHit ;
    {
    if( cbHit )

    findF( oHit , cbHit , pbRememberP + oWindowP , CBwINDOW , pbInP + oInP , cbInP - oInP ) ;
    ZE( countT , cbHit ) ;
    ZE( countT , oHit ) ;

    if( oWindowP + CBwINDOW > cbRememberP ) thirdC::c_memcpyIF( tinP , pbAppendP , pbRememberP , CBwINDOW - ( cbRememberP - oWindowP ) ) ; //U::O: DO THIS ONLY IF I HAVEN'T DONE IT SINCE WRITING THE SOURCE BYTES
{
voidT encodeF( tinS& tinP , countT* const pcOutP , const countT ccOutP , countT& oOutP , const byteT* const pbInP , const countT cbInP , countT& oInP , byteT* const pbRememberP , const countT cbRememberP , countT& oWindowP , byteT* const pbAppendP )

}
    }
        }
            cbHitP = oIn ;
            oHitP  = oWindow ;
        {
        if( cbHitP < oIn )

        // oIn NOW CONTAINS THE LENGTH OF THE HIT
        }
            if( pbWindowP[ oWindow + oIn ] != pbInP[ oIn ] ) break ;
        {
        for( countT oIn = 1 ; oIn < cbInP && oIn < cbWindowP ; oIn ++ )

        //IF GET HERE THEN I HAVE A HIT OF AT LEAST WO BYTE
        if( pbWindowP[ oWindow ] != pbInP[ 0 ] ) continue ;
    {
    for( countT oWindow = 0 ; oWindow < cbWindowP ; oWindow ++ )
    oHitP = cbHitP = 0 ;
{
voidT findF( countT& oHitP , countT& cbHitP , const byteT* const pbWindowP , const countT cbWindowP , const byteT* const pbInP , const countT cbInP )
/*I FIND THE OFFSET AND LENGTH OF THE MAX LEN HIT*/

#define CBwINDOW   0x4
#define CBrEMEMBER 0x20

//U::NEXT: DECODE THE RESULTING TRANSMISSION STRING

/*1*/WAKEhIDE( "doodle.secret" )/*1*/
/**/
*/
 for simplicity of code, pbAppend is maintained on every call in which the window extends into it
 in the code, the CBwINDOW bytes at oRemember are used to encode the next input subblock
  else these values are raw byteT values and must be preceeded by "get 1 bytes from..."
  if the offset values are >= 001 then these values are true offset values (after removing 001)
  "get a bytes from offset b; get c bytes from offset d; get e bytes from offset f"
 example: a b c d e f g
interpretation of the output code countT values
  for efficiency, the code copies the lookup bytes at offset 0 to extra mem allocated at the end of the lookup buffer as needed when the encoding window is there
  the encoding window will therefore be [001,ff1]
  cursor happens to be at offset 001
  encoding window size is 001
  memory horizon contains 00001 bytes
 example
 only the early portion of the buffer is used for encoding
 the lookup buffer is large, extending from the most recent byte transmitted to the memory horizon
internal specs
 secrecy comes from using an "old" version of the lookup buffer, as it looked M bytes ago
 the code for a subblock is simply the offset + 001 and length where it occurs in the lookup buffer
 this is done immediately after the subblock that contains it has been encoded
 each byteT of the input is written to the circular cursor in pbRemember as it is processed
  a block of incoming text is encoded at a time
 this is block mode forward encoding 
recipe
the inspiration for this is the idea that a long married couple can communicate with a glance; the other knows exactly what is meant
ideally, the eavesdropper would need to know every byte that was ever communicated
the basic idea is that an eavesdropper would need to record -all- communication for a long time in order to be able to decipher what was being said
this is called the "marriage model" encryption
it demonstrates the approach that i have in mind for secured communications between ifc relays
this adam appears to work, although it has not been vigorously tested
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

