
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    }
        etThread.osSleepF( tinP , TOCK * 0x20 , TOCK , flSLEEP_TALK ) ;
        ep.strokeF( tinP , T("\r" BLANK79 "\r") ) ;

        }
            ep.delF( tinP , pstt1m ) ;
            }
                ep.delF( tinP , psttEmail ) ;
                }
                    ep.strokeF( tinP , T("statement mailed to \"")+T(psttEmail)+T("\"\r\n") ) ;
                    ep.delF( tinP , postr ) ;

                    }
                        sOut.writeMsgF( tinP , T(postr) ) ;
                        sOut.writeMsgF( tinP , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+tTo ) ;
                        etThread.strokeF( tinP , T("\"")+tTo+T("\"\r\n") ) ;
                        textC tTo = T(psttEmail)+T("/" ifcEMAIL_OLDfROM "") ;
                        sOut.connectF( tinP , ifcPORToLD1oUTGOINGmAILBOX , 0x01010102 ) ;
                        socketC sOut( tinP , ether , TAG( TAGiDnULL ) ) ;
                    {

                    { ZE( strokeS* , psttnu ) ; ep.boxPutUniqueF( tinP , psttnu , T("///ideafarm/ephemeral/domains/com/ideafarm/5f30104/email") , postr , costr ) ; ep.delF( tinP , psttnu ) ; }

                    ep.delF( tinP , psttr1 ) ;
                    countT costr = ep.strMakeF( tinP , postr , psttr1 ) ; ___( postr ) ;
                    ZE( osTextT* , postr ) ;

                    }
                        ) ; ___( psttr1 ) ;

                            "Statements are mailed daily.\r\n")
                            "\r\n"
                            "\r\n"
                            "the Ambassador for details.\r\n"
                            "up to the full amount that you owe, with no questions asked.  Contact\r\n"
                            "policy of IdeaFarm " "(tm) City to credit your account on request for any amount\r\n"
                            "make payments as needed to keep your account in good standing.  It is the\r\n"
                            "to you of any amount up to your balance.  If your balance is negative, please\r\n"
                            "If your balance is positive, you can request a payout from IdeaFarm " "(tm) City\r\n"
                            "\r\n"
                            "Your shares are $$ ")+TF4(mShare  ,flFORMAT_EXPONENT,2,6)+T("    ( ")+TF4(cCentsS,0,0,0xa)+T(" cents )\r\n"
                            "\r\n"
                            "Your balance is $  ")+TF4(mBalance,flFORMAT_EXPONENT,2,6)+T("    ( ")+TF4(cCentsB,0,0,0xa)+T(" cents )\r\n"
                            "\r\n"
                            "\r\n"
                            "IdeaFarm " "(tm) City / Citizen ")+TF1(idcHirer)+T(" Statement of Account\r\n"
                            "\r\n"
                            "\r\n"
                            ifcEMAIL_WEBsITEcONTACT " or see http://www.ideafarm.com .  Thank you.\r\n"
                            "is strongly opposed to spam.  If you received this in error, please contact\r\n"
                            "obtained citizenship in IdeaFarm (tm) City for your email address.  IdeaFarm " "(tm) City\r\n"
                            "You are receiving this report because you, or an impostxr who claimed to be you,\r\n"
                            T("Subject: Statement ")+( mBalance > - 20.0 ? T("(FYI)") : T("(Please Pay)") )+T("\r\n\r\n"

                        ep.strMakeF( tinP , psttr1 ,
                    {
                    ZE( strokeS* , psttr1 ) ;

                    const sCountT cCentsS = mShare   * 100.0 ;
                    const sCountT cCentsB = mBalance * 100.0 ;
                {
                if( psttEmail )

                ep.strokeF( tinP , T("  mBalance =")+TF4(mBalance,flFORMAT_EXPONENT,2,6)+T("\r\n") ) ;

                }
                    ep.delF( tinP , pstt1m2 ) ;
                    }
                        mShare += *(measureT*)&c2b.c2 ; // ASSUME: sizeof( measureT ) == sizeof( countT )
                        __( idcHirer - c2b.c1 ) ;
                        ep.delF( tinP , pbi ) ;
                        ep.memCopyF( tinP , (byteT*)&c2b , pbi , cbi ) ;
                        __( cbi - sizeof c2b ) ;
                        ep.boxGetShadowF( tinP , pbi , cbi , psttc2 ) ; ___( pbi ) ;
                        ZE( countT , cbi ) ;
                        ZE( byteT* , pbi ) ;
                        count2S c2b ;
                    {
                    FORsTRINGSiN2( pstt1m2 )
                    ep.boxMenuF( tinP , soul1m2 , T(psttc1)+T("/share.*") ) ; ___( pstt1m2 ) ;
                    ZE( strokeS* , pstt1m2 ) ;
                {
                ZE( measureT , mShare ) ;

                }
                    ep.delF( tinP , pstt1m2 ) ;
                    }
                        mBalance += *(measureT*)&c2b.c2 ; // ASSUME: sizeof( measureT ) == sizeof( countT )
                        __( idcHirer - c2b.c1 ) ;
                        ep.delF( tinP , pbi ) ;
                        ep.memCopyF( tinP , (byteT*)&c2b , pbi , cbi ) ;
                        __( cbi - sizeof c2b ) ;
                        ep.boxGetShadowF( tinP , pbi , cbi , psttc3 ) ; ___( pbi ) ;
                        ZE( countT , cbi ) ;
                        ZE( byteT* , pbi ) ;
                        count2S c2b ;
                    {
                    FORsTRINGSiN3( pstt1m2 )
                    ep.boxMenuF( tinP , soul1m2 , T(psttc1)+T("/payin.*") ) ; ___( pstt1m2 ) ;

                    ep.delF( tinP , pstt1m2 ) ;
                    }
                        mBalance -= *(measureT*)&c2b.c2 ; // ASSUME: sizeof( measureT ) == sizeof( countT )
                        __( idcHirer - c2b.c1 ) ;
                        ep.delF( tinP , pbi ) ;
                        ep.memCopyF( tinP , (byteT*)&c2b , pbi , cbi ) ;
                        __( cbi - sizeof c2b ) ;
                        ep.boxGetShadowF( tinP , pbi , cbi , psttc2 ) ; ___( pbi ) ;
                        ZE( countT , cbi ) ;
                        ZE( byteT* , pbi ) ;
                        count2S c2b ;
                    {
                    FORsTRINGSiN2( pstt1m2 )
                    ep.boxMenuF( tinP , soul1m2 , T(psttc1)+T("/debit.*") ) ; ___( pstt1m2 ) ;
                    ZE( strokeS* , pstt1m2 ) ;
                {
                ZE( measureT , mBalance ) ;

                if( !psttEmail ) { ep.ifcExternalEmailFromIdCitizenF( tinP , psttEmail , 1 ) ; }
                if( idcHirer ) { ep.ifcExternalEmailFromIdCitizenF( tinP , psttEmail , idcHirer ) ; ___( psttEmail ) ; }
                ZE( strokeS* , psttEmail ) ;
                ep.delF( tinP , psttw ) ;
                countT idcHirer = ep.strDigitsToSCountF( tinP , psttw ) ;
                ep.strWordF( tinP , psttw , psttc1 , sttq , S1C('/') , - 1 ) ; ___( psttw ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttw ) ;
            {
            FORsTRINGSiN1( pstt1m )
            ep.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/1350007/transactions/" "*") ) ; ___( pstt1m ) ;
            ZE( strokeS* , pstt1m ) ;
        {
        if( bNewDay )

        time2last = time2 ;
        time1last = time1 ;

        const boolT bNewDayEnd    = bNewHour && offHOUR( time1 ) == 0x5 ;
        const boolT bNewStrongEnd = bNewDay && ( offDAY( time2 ) == 0x6 || offDAY( time2 ) == 0xe ) ;

        const boolT bNewTick      = bNewHour   || offTICK(   time1 ) != offTICK(   time1last ) ;
        const boolT bNewHour      = bNewDay    || offHOUR(   time1 ) != offHOUR(   time1last ) ;
        const boolT bNewDay       = bNewStrong || offDAY(    time2 ) != offDAY(    time2last ) ;
        const boolT bNewStrong    = bNewQtr    || offSTRONG( time2 ) != offSTRONG( time2last ) ;
        const boolT bNewQtr       = bNewDuck   || offQTR(    time2 ) != offQTR(    time2last ) ;
        const boolT bNewDuck      =               offDUCK(   time2 ) != offDUCK(   time2last ) ;

        ep.osTimeNowF( tinP , time1 , time2 ) ;
        ZE( sCountT , time2 ) ;
        ZE( countT , time1 ) ;
        idCycle ++ ;

        etherC ep( tinP , TAG( TAGiDnULL ) , etThread.os_cAllKidThreadsI_IF( tinP ) ) ;
    {
    while( !ether )
    ZE( countT , idCycle ) ;

    etThread.osTimeNowF( tinP , time1last , time2last ) ;
    ZE( sCountT , time2last ) ;
    ZE( countT , time1last ) ;
    ZE( strokeS* , psttw ) ;

    etThread.strokeF( tinP , T("IdeaFarm " "(tm) City Revenue Collector\r\ni periodically (daily) send a statement to each citizen to collect revenue\r\n") ) ;
{
else
}
    etThread.strokeF( tinP , T("Another ")+textIdFileC( tinP , DDNAME )+T(" appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tinP , TAG( TAGiDnULL ) , T("5f30104") ) ;

TODO

/*1*/WAKEhIDE( "city.revenue.collector" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

