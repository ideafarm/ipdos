
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idPort ;
    }
        if( !POOP ) idPort = tinP.brcRaw ;
        BOSdOnOTtEST( WHATgbo , ntohs( info.sin_port ) )
        BOSpOOP
        BOSS( WHATsir , BOSfAIL , getsockname( handleP.osF( ifcIDtYPEhANDLE_SOCKET ) , (sockaddr*)&info , &cbInfo ) )
        sCountT cbInfo = sizeof info ;
        c_memsetIF( tinP , (byteT* const)&info , sizeof info ) ;
    {
    if( !POOP )
    ZE( countT , idPort ) ;

    }
        __1 ;
        __( idPortP ) ;
    {
    if( bFail )

    }
        while( !*this && ( bNoQuit || ( bNoQuitEarly && !thPrimeIF( tinP ) ) || ( cTriesP && -- cTriesP ) ) ) ;
        }
            }
                break ;
                bFail = 0 ;
                //LOGrAW5( "adam " , processGlobal1I.idAdamRoot , " bind() to port " , idPortP , " aok\r\n" ) ;
            {
            else
            }
                ++ s ; dosSleepIF( tinP , TUCK * 0x40 ) ;

                //LOGrAW7( "adam " , processGlobal1I.idAdamRoot , " bind() to port " , idPortP , " failed, with WSABASEERR relative error code " , rc , "\r\n" ) ;
                //rc -= WSABASEERR ;
                //countT rc = tinP.brcRaw ;
                //BOSdOnOTtEST( WHATgbo , WSAGetLastError() )
                //U:: TO CATCH A BUG
            {
            if( tinP.bosFail )
            BOSS( WHATgbo , BOSfAIL , bind( handleP.osF( ifcIDtYPEhANDLE_SOCKET ) , (sockaddr*)&info , sizeof info ) )
        {
        do
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    boolT bFail = 1 ;
    boolT bNoQuitEarly = !cTriesP ;
    boolT bNoQuit = cTriesP == - 1 ;

    info.sin_addr.s_addr = tinP.brcRaw ; //U: SUPPORTS ONLY IPV4 (NOT IPV6)
    BOSdOnOTtEST( WHATgbo , htonl( *(const countT*)nicNameP ) )
    info.sin_port = (count01T)tinP.brcRaw ;
    BOSdOnOTtEST( WHATgbo , htons( (count01T)( idPortP ? idPortP : INADDR_ANY ) ) )
    info.sin_family = AF_INET ;
    c_memsetIF( tinP , (byteT* const)&info , sizeof info ) ;
    sockaddr_in info ;
    _IO_

    }
        if( POOP ) return 0 ;
        __Z( handleP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL    
    SCOOP
{
/*1*/countT thirdC::s_bindF( tinS& tinP , const handleC& handleP , const countT idPortP , const nicNameC nicNameP , countT cTriesP )/*1*/

/**/
*/
  if - 1 then will retry forever even if thPrimeIF( tinP ) is impotent
  if not 0 then will try cTriesP times (even if thPrimeIF( tinP ) is impotent)
  if 0 then will retry forever unless thPrimeIF( tinP ) is impotent
  can be 0
 cTriesP
   if the host has more than one LAN adapter card, the nicName assignment might be deferred
  can be 0, in which case an nicName assignment to this socket might be deferred until someone connects to it
 nicNameP
  can be 0, in which case an idPort will be assigned
 idPortP
  must not be 0
 handleP
arguments
 windows nt: can fail
on some operating systems, this call can fail if cTriesP == 1 and it is made immediately after another process closes a socket that was bound to the requested port
 this will always be idPortP except when idPortP is 0
returns the idPort actually bound to the socket
  \<A HREF=\"5.6e00104.1.1.0.html\"\>6e00104:  WAKEsHOW( "example.simplest.func.1020038.thirdC.s_bindF" )\</A\>
 simplest
examples
\<A HREF=\"5.1020038.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$s_bindF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

