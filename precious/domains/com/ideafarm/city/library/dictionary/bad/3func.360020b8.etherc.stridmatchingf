
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    return idHit ;

    }
        }
            }
                default : { idHit = strIdF( tinP , idFirstP , sttQuoteP , psttBigP[ CSpREFIX - 2 + idFirstP ] , psttBigP ) ; break ; }
                }
                    break ;
                    delF( tinP , pstta ) ;_WQ
    
                    }
                        if( cOpen ) idHit = 0 ;_WQ
    
                        else if( psttBigP[ CSpREFIX - 1 + idHit ] == stt2 ) cOpen -- ;
                        else if( psttBigP[ CSpREFIX - 1 + idHit ] == stt1 ) cOpen ++ ;
                        if( !idHit ) ;
    
                        if( idHit && idFirstP > idHit + 1 ) idFirstP = idHit + 1 ; // IF WE FIND E.G. "()((()))()()()", WE WANT TO PROCESS EACH ONE, NOT JUMP TO THE END OF THIS STRING OF PARENS
                        idHit = strIdAnyF( tinP , 0 , flSTRmATCH_null , idFirstP , sttQuoteP , pstta , psttBigP ) ;_WQ
                    {
                    while( idFirstP && !POOP && cOpen )
                    countT cOpen = 1 ;_WQ
                    ZE( boolT , bFound ) ;_WQ
    
                    strFuseF( tinP , pstta , stt2     ) ; ___( pstta ) ;_WQ
                    strFuseF( tinP , pstta , stt1 , 1 ) ; ___( pstta ) ;_WQ
                    ZE( strokeS* , pstta ) ;_WQ
                    else if( stt1 == S1C('<') ) stt2 = S1C('>') ;
                    else if( stt1 == S1C('{') ) stt2 = S1C('}') ;
                    else if( stt1 == S1C('[') ) stt2 = S1C(']') ;
                         if( stt1 == S1C('(') ) stt2 = S1C(')') ;
                    strokeS stt2 ;_WQ
                {
                case '<' :
                case '{' :
                case '[' :
                case '(' :
            {
            switch( stt1 )
            idFirstP ++ ;_WQ
            strokeS stt1 = psttBigP[ CSpREFIX - 1 + idFirstP ] ;_WQ
        {
        if( idFirstP < psttBigP->idAdam )
    {
    STRiDrECURSE( strIdMatchingF( tinP , idf , sttQuoteP , psttBigP , 1 ) )
    _IO_

    }
        if( POOP ) return 0 ;
        __Z( idP ) ;_WQ
        __Z( psttBigP ) ;_WQ
        __Z( idFirstP ) ;_WQ
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/**//*1*/countT etherC::strIdMatchingF( tinS& tinP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* const psttBigP , sCountT idP )/*1*/
*/
  must not be 0
 psttBigP
 sttQuoteP
  must not be 0
 idFirstP
arguments
behavior when matching the double quote stroke is undefined and subject to change
sets idFirstP to the id of the stroke after the match found
  '/' will match with '/'
  'I' will match with 'I'
  'i' will match with 'i'
  '}' will match with '{'
  '[' will match with ']'
 examples
 other strokes are matched to their next occurance
  '<' and '>'
  '{' and '}'
  '[' and ']'
  '(' and ')'
 special matching pairs
matching rules
 it cannot be used to match a ')' with its preceding '('
this is forward looking
returns the id of the next stroke that matches the stroke at idFirstP
  \<A HREF=\"5.6b10104.1.1.0.html\"\>6b10104:  WAKEsHOW( "example.simplest.func.10300d2.etherC.strIdMatchingF" )\</A\>
 simplest
examples
\<A HREF=\"5.10300d2.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strIdMatchingF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

