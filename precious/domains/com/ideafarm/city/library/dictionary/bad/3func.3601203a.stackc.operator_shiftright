
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return *this ;
    _OUTbATONsTACKc_

    }
        default : __1
        }
            break ;

            third.delF( tinP , pbi ) ;
            }
                soulP.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_byteTptr , pbi , cbi ) ;

                }
                    ppci = F(flags) & flSTACKc_FIFO ? ppci->ppD : ppci->ppU ;

                    }
                        }
                            pbc += cbc ;
                            third.c_memcpyIF( tinP , pbc , pbs , cbc ) ;
                            __( pbe < pbc + cbc ) ;
                            countT cbc = 3 * sizeof( countT ) + ((countT*)pbs)[ 2 ] ;
                        {
                        if( !third )
                        __( pbe <= pbc ) ;
                        __Z( pbs ) ;
                        const byteT* pbs = *pso ;
                    {
                    if( pso )
                    __Z( pso ) ;
                    soulC* pso = (soulC*)PLATE_countT_REF( ppci ) ;
                {
                while( ppci )
                plateS* ppci = F(flags) & flSTACKc_FIFO ? ppTop : ppBottom ;

                *(flagsT*)pbc = flagsState   ; pbc += sizeof( flagsT ) ;
                *(countT*)pbc = cbData       ; pbc += sizeof( countT ) ;
                *(countT*)pbc = idType       ; pbc += sizeof( countT ) ;
                *(countT*)pbc = cPlates      ; pbc += sizeof( countT ) ;
                *(flagsT*)pbc = flags        ; pbc += sizeof( flagsT ) ;
                byteT* pbc = pbi ;

                byteT* const pbe = pbi + cbi ;
            {
            if( pbi )
            third.newF( tinP , LF , pbi , cbi ) ; ___BITScT( pbi , 0xe0d ) ;
            ZE( byteT* , pbi ) ;
            }
                }
                    ppci = F(flags) & flSTACKc_FIFO ? ppci->ppD : ppci->ppU ;

                    }
                        }
                            cbi += 3 * sizeof( countT ) + ((countT*)pbs)[ 2 ] ;
                            __( ((countT*)pbs)[ 1 ] - 1                 ) ;
                            __( getNegAM( ((countT*)pbs)[ 0 ] ) - FINGERnEG_SOULc ) ;
                        {
                        if( pbs )
                        
                        __Z( pbs ) ;
                        const byteT* pbs = *pso ;
                    {
                    if( pso )
                    __Z( pso ) ;
                    soulC* pso = (soulC*)PLATE_countT_REF( ppci ) ;
                {
                while( ppci )
                plateS* ppci = F(flags) & flSTACKc_FIFO ? ppTop : ppBottom ;
            {
            countT cbi = 2 * sizeof( flagsT ) + 3 * sizeof( countT ) ;

            }
                countT foo = 2 ;
            {
            if( idIn == 2 )
            countT idIn = 1 + incv02AM( idInLath ) ;
            static countT idInLath ;
            //U::
        {
        case ifcSTACKtYPE_PTR_soulC :
        }
            break ;

            }
                (*pEther)( tinP , psEnv ) ;
                }
                    soulP << *psEnv ;

                    }
                        ppci = F(flags) & flSTACKc_FIFO ? ppci->ppD : ppci->ppU ;

                        if( psttw ) *psEnv << psttw ; //LOADS *psEnv WITH EXPORTABLE RENDERING OF psttw
                        __Z( psttw ) ;
                        strokeS* psttw = (strokeS*)PLATE_countT_REF( ppci ) ;
                    {
                    while( ppci )
                    plateS* ppci = F(flags) & flSTACKc_FIFO ? ppTop : ppBottom ;
                {
                if( psEnv )
                (*pEther)( tinP , psEnv , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psEnv ) ;
            {
            if( pEther )
            __Z( pEther ) ;
            etherC* pEther = third.third_pEtherContainsMe_F() ;
        {
        case ifcSTACKtYPE_PTR_strokeS :
        }
            break ;

            }
                (*pEther)( tinP , psEnv ) ;
                }
                    soulP << *psEnv ;

                    }
                        ppci = F(flags) & flSTACKc_FIFO ? ppci->ppD : ppci->ppU ;
                        if( pCap ) *pCap >> *psEnv ; //NOTE THAT INFO IS LOST WHEN PLATE IS NULL; WHEN SHIFTING LEFT, WILL NOT KNOW TO CREATE A NULL PLATE
                        plateC* pCap = (plateC*)PLATE_countT_REF( ppci ) ;
                    {
                    while( ppci )
                    plateS* ppci = F(flags) & flSTACKc_FIFO ? ppTop : ppBottom ;
                {
                if( psEnv )
                (*pEther)( tinP , psEnv , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psEnv ) ;
            {
            if( pEther )
            __Z( pEther ) ;
            etherC* pEther = third.third_pEtherContainsMe_F() ;
        {
        case ifcSTACKtYPE_PTR_plateC :
        }
            break ;

            third.delF( tinP , pbi ) ;
            }
                soulP.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_byteTptr , pbi , cbi ) ;

                }
                    }
                        ppi = F(flags) & flSTACKc_FIFO ? ppi->ppD : ppi->ppU ;
                        else __1
                        }
                            }
                                }
                                    off += sizeof( countT ) ;
                                    *(countT*)( pbi + off ) = pcv[ off2 ] ;
                                {
                                for( countT off2 = 0 ; off2 < ccToDo ; off2 ++ )
                                countT* pcv = idType == ifcSTACKtYPE_nicNameC || idType == ifcSTACKtYPE_timeS ? (countT*)PLATE_byteT_PTR( ppi ) : (countT*)PLATE_countT_REF( ppi ) ;

                                }
                                    default                           : ccToDo = idType + 2 - ifcSTACKtYPE_PTR_count2S ;
                                    case    ifcSTACKtYPE_timeS        : ccToDo = sizeof( timeS ) / sizeof( countT ) ;
                                    case    ifcSTACKtYPE_PTR_nicNameC : ccToDo = processGlobal1I.cb_nicNameC_ / sizeof( countT ) ;
                                    case    ifcSTACKtYPE_nicNameC     :
                                {
                                switch( idType )
                                ZE( countT , ccToDo ) ;
                            {
                            if( PLATE_countT_REF( ppi ) || idType == ifcSTACKtYPE_nicNameC || idType == ifcSTACKtYPE_timeS )

                            if( idType != ifcSTACKtYPE_nicNameC && idType != ifcSTACKtYPE_timeS ) { __( !PLATE_countT_REF( ppi ) ) ; }
                        {
                        else if( idType == ifcSTACKtYPE_PTR_nicNameC || idType == ifcSTACKtYPE_nicNameC || idType == ifcSTACKtYPE_timeS || ( idType >= ifcSTACKtYPE_PTR_count2S && idType <= ifcSTACKtYPE_PTR_count8S ) ) //ASSUME: nicNameC AND timeS AND count2S count3S count4S count5S count6S count7S count8S MEMORY IMAGE IS A SEQUENCE OF countT OBJECTS
                        }
                            }
                                off += cbPlateData ;
                                thirdC::c_memcpyIF( tinP , (byteT*)( pbi + off ) , PLATE_byteT_PTR( ppi ) , cbPlateData ) ;
                                countT cbPlateData = sizeof( countT ) + PLATE_countT_REF( ppi ) ;
                            {
                            else
                            }
                                off += cbData ;
                                thirdC::c_memcpyIF( tinP , (byteT*)( pbi + off ) , PLATE_byteT_PTR( ppi ) , cbData ) ;
                            {
                            if( cbData )
                        {
                        else if( idType == ifcSTACKtYPE_BLOB )
                        }
                            off += sizeof( countT ) ;
                            *(countT*)( pbi + off ) = PLATE_countT_REF( ppi ) ;
                        {
                        if( idType == ifcSTACKtYPE_countT || idType == ifcSTACKtYPE_sCountT || idType == ifcSTACKtYPE_measureT )
                    {
                    if( !third )
                    __( off >= cbi ) ;
                {
                while( ppi )
                plateS* ppi = F(flags) & flSTACKc_FIFO ? ppTop : ppBottom ;

                *( countT* )( pbi + off ) = flagsState   ; off += sizeof( countT ) ; //ASSUME: sizeof( flagsT ) == sizeof( countT )
                *( countT* )( pbi + off ) = cbData       ; off += sizeof( countT ) ;
                *( countT* )( pbi + off ) = idType       ; off += sizeof( countT ) ;
                *( countT* )( pbi + off ) = cPlates      ; off += sizeof( countT ) ;
                *( countT* )( pbi + off ) = flags        ; off += sizeof( countT ) ; //ASSUME: sizeof( flagsT ) == sizeof( countT )
                ZE( countT , off ) ;
            {
            if( pbi )

            third.newF( tinP , LF , pbi , cbi ) ; ___BITScT( pbi , 0xe0f ) ;
            else __1
            else if( idType >= ifcSTACKtYPE_PTR_count2S  && idType <= ifcSTACKtYPE_PTR_count8S                                     ) cbi += cPlates * sizeof( countT ) * ( idType + 2 - ifcSTACKtYPE_PTR_count2S ) ;
            }
                }
                    }
                        ppi = ppi->ppD ;
                        cbi += sizeof( countT ) + PLATE_countT_REF( ppi ) ;
                    {
                    while( ppi )
                    plateS* ppi = ppTop ;
                {
                else
                if( cbData ) cbi += cPlates * cbData ;
            {
            else if( idType == ifcSTACKtYPE_BLOB )
            else if( idType == ifcSTACKtYPE_timeS                                                                                  ) cbi += cPlates * sizeof( timeS ) ;
            else if( idType == ifcSTACKtYPE_nicNameC     || idType == ifcSTACKtYPE_PTR_nicNameC                                    ) cbi += cPlates * processGlobal1I.cb_nicNameC_ ;
                 if( idType == ifcSTACKtYPE_countT       || idType == ifcSTACKtYPE_sCountT      || idType == ifcSTACKtYPE_measureT ) cbi += cPlates * sizeof( countT ) ;
            countT cbi = 5 * sizeof( countT ) ; //ASSUME: sizeof( flagsT ) == sizeof( countT )
            ZE( byteT* , pbi ) ;
        {
        case ifcSTACKtYPE_PTR_count8S  :
        case ifcSTACKtYPE_PTR_count7S  :
        case ifcSTACKtYPE_PTR_count6S  :
        case ifcSTACKtYPE_PTR_count5S  :
        case ifcSTACKtYPE_PTR_count4S  :
        case ifcSTACKtYPE_PTR_count3S  :
        case ifcSTACKtYPE_PTR_count2S  :
        case ifcSTACKtYPE_PTR_nicNameC :
        case ifcSTACKtYPE_BLOB         :
        case ifcSTACKtYPE_timeS        :
        case ifcSTACKtYPE_nicNameC     :
        case ifcSTACKtYPE_measureT     :
        case ifcSTACKtYPE_sCountT      :
        case ifcSTACKtYPE_countT       :
    {
    switch( idType )

    _INbATONsTACKc_

    }
        if( third ) return *this ;
    {
    IFbEcAREFUL

    SCOOP
    TINSL
{
/*1*/baseSoilXxxxC& stackC::operator >>( soulC& soulP )/*1*/

/**/
*/
 to achieve the normal function (removal of plates), call me and then call purgeF
 it is named this in order to correspond to <<( soulC& soulP ), which adds plates
 in this sense this overload is inappropriate since all of the other overloads of >> remove a plate
no plates are removed
\<A HREF=\"5.115003d.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

