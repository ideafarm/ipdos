
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    etThread.diskWaitDirF( tinP , hDirChange , ether , tInDir , flWAITdIR_FILEnAME ) ;

    etThread.delF( tinP , pstt1m ) ;
    }
        etThread.delF( tinP , psttNameShort ) ;
        }
            etThread.boxPutF( tinP , tDesk+tReadMe     , tRead  , tRead.csF( tinP ) ) ;
            etThread.boxPutF( tinP , tDesk+tHelloWorld , tHello , tHello.csF(  tinP ) ) ;
            etThread.delF( tinP , psttrm ) ;
            tRead = T(psttrm) ;
            etThread.strReverseF( tinP , psttrm , tRead , T("\r\n") ) ; ___( psttrm ) ;
            ZE( strokeS* , psttrm ) ;
            TN( tRead  , POSTlITrEADmE ) ;
            TN( tHello , ".soixlOld .tm IdeaFarm .version 1 . \"Hello, world!\" POPUP" ) ;

            etThread.delF( tinP , psttw ) ;
            }
                }
                    idDup ++ ;
                    *tinP.zEtScratch = 0 ;
                {
                else
                if( !*tinP.zEtScratch ) break ;
                tinP.zEtScratch->diskMoveFileOrDirF( tinP , tDesk+T("soixlOld.reject.")+(idDup?TF1(idDup)+T("."):T(""))+T(psttNameShort) , psttc1 ) ;
            {
            while( !ether && idDup < 0x10000 )
            ZE( countT , idDup ) ;
            etThread.strReplaceF( tinP , psttw , psttc1 , tInDir , tDesk , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttw ) ;
            ZE( strokeS* , psttw ) ;
        {
        else
        }
            }
                else            break ;
                if( *tinP.zEtScratch ) { *tinP.zEtScratch = 0 ; ether.osSleepF( tinP , TUCK * 0x40 ) ; }
                tinP.zEtScratch->boxZapF( tinP , psttc1 ) ;
            {
            while( !ether )
            etThread.osThreadF( tinP , countTC() , tmWorkF , 0 , flTHREADlAUNCH_null , 0 , (countT)psttSoixlOld ) ;
        {
        if( psttSoixlOld )

        }
            }
                }
                    etThread.delF( tinP , psttSoixlOld ) ;
                    POPUPsOIXLoLD( T("A file object containing text that did not begin with the words \".soixlOld .tm IdeaFarm .version\" (reading from the bottom up) was dropped into the depository.  It will be moved to the desktop.")+TiNTRO ) ;
                {
                if( cOk < 4 )

                etThread.delF( tinP , pstt1w ) ;
                }
                    if( bBreak ) break ;

                    }
                        case 3 : { if( !etThread.strCompareF( tinP , psttc1 , T(".version") ) ) cOk ++ ; else bBreak = 1 ; break ; }
                        case 2 : { if( !etThread.strCompareF( tinP , psttc1 , T("IdeaFarm") ) ) cOk ++ ; else bBreak = 1 ; break ; }
                        case 1 : { if( !etThread.strCompareF( tinP , psttc1 , T(".tm"     ) ) ) cOk ++ ; else bBreak = 1 ; break ; }
                        case 0 : { if( !etThread.strCompareF( tinP , psttc1 , T(".soixlOld"   ) ) ) cOk ++ ; else bBreak = 1 ; break ; }
                    {
                    switch( cOk )
                    ZE( countT , bBreak ) ;

                    if( !psttc1->idAdam ) continue ;
                {
                FORsTRINGSiN1( pstt1w )
                etThread.strWordsOldF( tinP , pstt1w , psttSoixlOld , sttq , 0 ) ; ___( pstt1w ) ;
                strokeS sttq ;
                ZE( strokeS* , pstt1w ) ;
                ZE( countT , cOk ) ;

                etThread.strReverseF( tinP , psttSoixlOld , 0 , T("\r\n") ) ; ___( psttSoixlOld ) ;
                etThread.delF( tinP , postSoixlOld ) ;
                etThread.strMakeF( tinP , psttSoixlOld , T(postSoixlOld) ) ; ___( psttSoixlOld ) ;
            {
            else
            }
                POPUPsOIXLoLD( "I was not able to read a file object that was just dropped into the depository.  I will move it to the desktop when I can." ) ;
                *tinP.zEtScratch = 0 ;
            {
            if( *tinP.zEtScratch )
            tinP.zEtScratch->boxGetShadowF( tinP , postSoixlOld , costSoixlOld , psttc1 ) ; ___( postSoixlOld ) ;
            ZE( countT   , costSoixlOld ) ;
            ZE( osTextT* , postSoixlOld ) ;
        {
        else
        if( 1 != etThread.strIdF( tinP , T("soixlOld.") , psttNameShort ) ) { POPUPsOIXLoLD( T("A file object whose name does not begin with \"soixlOld.\" was dropped into the depository.  I will move it to the desktop.")+TiNTRO ) ; }
        TN( tReadMe , "soixlOld.readMe.txt" ) ;
        TN( tHelloWorld , "soixlOld.helloWorld.txt" ) ;
        ZE( strokeS* , psttSoixlOld ) ;

        etThread.strConvertToLowerCaseF( tinP , psttNameShort ) ;
        etThread.strWordF( tinP , psttNameShort , psttc1 , sttq , S1C('/') , - 1 ) ; ___( psttNameShort ) ;
        strokeS sttq ;
        ZE( strokeS* , psttNameShort ) ;

        *tinP.zEtScratch = 0 ;
    {
    FORsTRINGSiN1( pstt1m )
    etThread.boxMenuF( tinP , soul , tInDir+T("*") ) ; ___( pstt1m ) ;
    ZE( strokeS* , pstt1m ) ;
{
while( !ether )
handleC hDirChange( tinP , TAG( TAGiDnULL ) ) ;

    T("\" on your desk.  If you are new to IdeaFarm " "(tm) City, welcome.")
    tReadMe+                                                                                    \
    T("\" and \"")+                                                                             \
    tHelloWorld+                                                                                \
    T("  I will also put \"")+                                                                  \
#define TiNTRO                                                                                  \

etThread.strokeF( tinP , tDesk+T("\r\n") ) ;
}
    etThread.diskMakeDirIfNeededF( tinP , tInDir ) ;
    tInDir = tDesk + T("IdeaFarm " "(tm) SOIL (tm) Depository - To begin, paste a COPY of a blank text file here!/") ;
    
    tDesk = T(iff) ;
    etThread.delF( tinP , psttw ) ;
    ifFileNameC iff( tinP , etThread , T(psttw)+T("\\Desktop\\") ) ;
    etThread.osEnvironmentVariableF( tinP , psttw , T("ALLUSERSPROFILE") ) ; ___( psttw ) ;
    ZE( strokeS* , psttw ) ;
{
TN( tDesk , "" ) ;
TN( tInDir , "" ) ;

TODO

DONE( tmWorkF )
}
    etThread.delF( tinP , psttSoixlOldP ) ;
    workF( tinP , etThread , psttSoixlOldP ) ;

    strokeS* psttSoixlOldP = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmWorkF )

}
    }
        DEL( pVar ) ;
        baseSoilXxxxC*& pVar = *(baseSoilXxxxC**)&(countT&)sw_var ;
        etThread.strokeF( tinP , T("deleting var object named \"")+T(psttl_var)+T("\"\r\n") ) ;
        psttl_var = (strokeS*)sw_var.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    cFlavors = sw_var.cFlavorsF( tinP ) ;
    
    }
        DEL( pSoul ) ;
        soulC*& pSoul = *(soulC**)&(countT&)sw_soulC ;
        etThread.strokeF( tinP , T("deleting soulC object named \"")+T(psttl_soulC)+T("\"\r\n") ) ;
        psttl_soulC = (strokeS*)sw_soulC.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = sw_soulC.cFlavorsF( tinP ) ;
    
    etThread.delF( tinP , psttTemp ) ;
    etThread.delF( tinP , pstt1w ) ;
    }
        }
            }
                }
                    }
                        //U::if( !etThread.strCompareF( tinP , psttc1 , t_if ) ) *pslActive << (countT)ifcIDcMDbASE_REFERENCE << &lex ;

                        else *pslActive << psttc1 << (countT)ifcIDcMDbASE_CMDdEFAULT << &lex ;
                        }
                            if( pVar ) *pslActive << (countT)ifcIDcMDbASE_CMDdEFAULT << pVar ;
                            baseSoilXxxxC* pVar = (baseSoilXxxxC*)(countT)sw_var ;
                            psttl_var = psttc1 ;
                        {
                        if( sw_var.idSlotOfLeverF( tinP , (countT)psttc1 ) )
                    {
                    else
                    }
                        cDotX -- ;
    
                        }
                            etThread.delF( tinP , psttTemp ) ;
                            }
                                if( pSoul ) *(soulC*)&( *pslActive << *pSoul ) << psttTemp O2(IDcMDwORD_DEFINE,lex) ;
                                soulC* pSoul = (soulC*)(countT)sw_soulC ;
                                psttl_soulC = psttc1 ;
                            {
                            if( sw_soulC.idSlotOfLeverF( tinP , (countT)psttc1 ) )
                        {
                        else
                        if( cDotX == 2 ) psttTemp = psttOldC( tinP , etThread , psttc1 ) ;
                    {
                    else if( cDotX )
                    }
                        cDotN -- ;
    
                        }
                            }
                                if( pVar ) pVar->nameF( tinP , etThread , psttc1 ) ;
                                if( !pVar ) { pVar = (baseSoilXxxxC*)new( 0 , tinP , LF ) etherC( tinP , TAG( TAGiDnULL ) , etThread ) ; ___( pVar ) ; }
                                baseSoilXxxxC*& pVar = *(baseSoilXxxxC**)&(countT&)sw_var ;
                                psttl_var = psttc1 ;
                                bNewEther = 0 ;
                            {
                            if( bNewEther )
    
                            }
                                if( pVar ) pVar->nameF( tinP , etThread , psttc1 ) ;
                                if( !pVar ) { pVar = new( 0 , tinP , LF ) countC ; ___( pVar ) ; }
                                baseSoilXxxxC*& pVar = *(baseSoilXxxxC**)&(countT&)sw_var ;
                                psttl_var = psttc1 ;
                                bNewCount = 0 ;
                            {
                            if( bNewCount )
    
                            }
                                if( pSoul ) pSoul->nameF( tinP , etThread , psttc1 ) ;
                                if( !pslActive ) pslActive = pSoul ;
                                if( !pSoul ) { pSoul = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) , flSOUL_LIFO|flSOUL_LIVE ) ; ___( pSoul ) ; }
                                soulC*& pSoul = *(soulC**)&(countT&)sw_soulC ;
                                psttl_soulC = psttc1 ;
                                bNewStack = 0 ;
                            {
                            if( bNewStack )
    
                            }
                                if( pSoul ) pSoul->nameF( tinP , etThread , psttc1 ) ;
                                if( !pslActive ) pslActive = pSoul ;
                                if( !pSoul ) { pSoul = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( pSoul ) ; }
                                soulC*& pSoul = *(soulC**)&(countT&)sw_soulC ;
                                psttl_soulC = psttc1 ;
                                bNewList = 0 ;
                            {
                            if( bNewList )
                        {
                        else
                        }
                            else if( !etThread.strCompareF( tinP , psttc1 , t_etherC ) ) bNewEther = 1 ;
                            else if( !etThread.strCompareF( tinP , psttc1 , t_count  ) ) bNewCount = 1 ;
                            else if( !etThread.strCompareF( tinP , psttc1 , t_stack  ) ) bNewStack = 1 ;
                                 if( !etThread.strCompareF( tinP , psttc1 , t_list   ) ) bNewList  = 1 ;
                        {
                        if( cDotN == 2 )
                    {
                    else if( cDotN )
                    }
                        cDotAssign -- ;
    
                        }
                            etThread.delF( tinP , psttTemp ) ;
    
                            }
                                if( pVar ) *(countC*)pVar = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
                                baseSoilXxxxC* pVar = (baseSoilXxxxC*)(countT)sw_var ;
                                psttl_var = psttTemp ;
                            {
                            if( sw_var.idSlotOfLeverF( tinP , (countT)psttTemp ) )
                        {
                        else
                        if( cDotAssign == 2 ) psttTemp = psttOldC( tinP , etThread , psttc1 ) ;
                    {
                    else if( cDotAssign )
                    }
                        csttExtra = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
                        bDotPlus = 0 ;
                    {
                    else if( bDotPlus )
                    }
                        etThread.strokeF( tinP , T("comment: \"")+T(psttc1)+T("\"\r\n") ) ;
                        bDotPound = 0 ;
                    {
                    else if( bDotPound )
                    }
                        }
                            if( pSoul ) pslActive = pSoul ;
                            soulC* pSoul = (soulC*)(countT)sw_soulC ;
                            psttl_soulC = psttc1 ;
                        {
                        if( sw_soulC.idSlotOfLeverF( tinP , (countT)psttc1 ) )
                        bDotAt = 0 ;
                    {
                    else if( bDotAt )
                    }
                        }
                            break ;
                            if( !scQuiet ) { POPUPsOIXLoLD( T("I do not know how to interpret version ")+TF1(versionRequested)+T(" SOIL (tm) code.") ) ; }
                        {
                        if( 1 != versionRequested )
                        countT versionRequested = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
                        bDotVersion = 0 ;
                    {
                    else if( bDotVersion )
                    }
                        }
                            break ;
                            if( !scQuiet ) { POPUPsOIXLoLD( T("I do not know how to interpret SOIL (tm) code marked with the \"")+T(psttc1)+T("\" trademark.") ) ; }
                        {
                        if( etThread.strCompareF( tinP , psttc1 , T("IdeaFarm") ) )
                        bDotTm = 0 ;
                    {
                    else if( bDotTm )
                    }
                        *pslActive << (osTextT*)T(psttc1) ;
                        bDotBat = 0 ;
                    {
                    else if( bDotBat )
                    }
                        *pslActive << (countT)etThread.strDigitsToSCountF( tinP , psttc1 ) ;
                        bDotC = 0 ;
                    {
                    if( bDotC )
                {
                else
                }
                    break ;
                    if( !scQuiet ) { POPUPsOIXLoLD( T("Quitting because \"")+tDotQuit+T("\" encountered.  (\"")+tDotQuit+T("\" is intended to be used only during program development.)") ) ; }
                {
                else if( !etThread.strCompareF( tinP , psttc1 , tDotQuit ) )
                else if( !etThread.strCompareF( tinP , psttc1 , tDotVersion ) ) bDotVersion = 1 ;
                else if( !etThread.strCompareF( tinP , psttc1 , tDotTm      ) ) bDotTm = 1 ;
                else if( !etThread.strCompareF( tinP , psttc1 , tDotSoixlOld    ) ) ;
                else if( !etThread.strCompareF( tinP , psttc1 , tDotPlus    ) ) bDotPlus = 1 ;
                else if( !etThread.strCompareF( tinP , psttc1 , tDotAssign  ) ) cDotAssign = 2 ;
                else if( !etThread.strCompareF( tinP , psttc1 , tDotPound   ) ) bDotPound = 1 ;
                else if( !etThread.strCompareF( tinP , psttc1 , tDotAt      ) ) bDotAt = 1 ;
                else if( !etThread.strCompareF( tinP , psttc1 , tDotBat     ) ) bDotBat = 1 ;
                else if( !etThread.strCompareF( tinP , psttc1 , tDotC       ) ) bDotC = 1 ;
                else if( !etThread.strCompareF( tinP , psttc1 , tDotX       ) ) cDotX = 2 ;
                else if( !etThread.strCompareF( tinP , psttc1 , tDotN       ) ) cDotN = 2 ;
                else if( !etThread.strCompareF( tinP , psttc1 , tDotNoQuiet ) ) scQuiet -- ;
                     if( !etThread.strCompareF( tinP , psttc1 , tDotQuiet   ) ) scQuiet ++ ;
            {
            else
            }
                }
                    psttc1[ 2 ].idAdam = save ;
                    *pslActive << psttc1 ; //THIS WORKS BECAUSE soulC::shiftLeftF DOES NOT ACCESS THE CLAIMED EXTRA STROKES
                    psttc1[ 2 ].idAdam = csttExtra ; csttExtra = 0 ;
                    countT save = psttc1[ 2 ].idAdam ;
                {
                else
                if( !csttExtra ) *pslActive << psttc1 ;
                bDot = 0 ;
            {
            if( bDot )
        {
        else
        else if( !bDot && !etThread.strCompareF( tinP , psttc1 , tDot ) ) bDot = 1 ;
        if( scOff ) ;

        else if( !etThread.strCompareF( tinP , psttc1 , tDotOn  ) ) { scOff -- ; if( !scQuiet ) { POPUPsOIXLoLD( T("scOff is now ")+TF1(scOff)+T(" so words other than \"")+tDotOff+T("\" and \"")+tDotOn+T("\" will be ")+T(scOff?"ignored":"obeyed")+T(".  (\"")+tDotOn +T("\" is intended to be used only during program development.)") ) ; } continue ; }
             if( !etThread.strCompareF( tinP , psttc1 , tDotOff ) ) { scOff ++ ; if( !scQuiet ) { POPUPsOIXLoLD( T("scOff is now ")+TF1(scOff)+T(" so words other than \"")+tDotOff+T("\" and \"")+tDotOn+T("\" will be ")+T(scOff?"ignored":"obeyed")+T(".  (\"")+tDotOff+T("\" is intended to be used only during program development.)") ) ; } continue ; }
        etThread.strokeF( tinP , T("word: \"")+T(psttc1)+T("\"\r\n") ) ;
    {
    FORsTRINGSiN1( pstt1w )
    ZE( sCountT , scQuiet ) ;
    ZE( countT , csttExtra ) ;
    ZE( strokeS* , psttTemp ) ;
    ZE( countT , cDotAssign ) ;
    ZE( boolT , bDotVersion ) ;
    ZE( boolT , bDotBat ) ;
    ZE( boolT , bDotC ) ;
    ZE( boolT , bDotPound ) ;
    ZE( boolT , bDotAt ) ;
    ZE( boolT , bNewEther ) ;
    ZE( boolT , bNewCount ) ;
    ZE( boolT , bNewStack ) ;
    ZE( boolT , bNewList ) ;
    ZE( boolT , bDotTm ) ;
    ZE( boolT , bDotPlus ) ;
    ZE( countT , cDotX ) ;
    ZE( countT , cDotN ) ;
    ZE( sCountT , scOff ) ; // IF scOff THEN ALL WORDS OTHER THAN .off AND .on ARE IGNORED
    ZE( boolT , bDot ) ;

    switchC sw_soulC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttl_soulC ) ;
    ZE( strokeS* , psttl_soulC ) ;
    
    switchC sw_var( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttl_var ) ;
    ZE( strokeS* , psttl_var ) ;
    
    etThread.strWordsOldF( tinP , pstt1w , tSoixlOldProlog+T(psttSoixlOldP) , sttq ) ; ___( pstt1w ) ;
    strokeS sttq ;
    ZE( strokeS* , pstt1w ) ;
    
    ZE( soulC* , pslActive ) ;
    lex.nameF( tinP , etThread , T("lexDefault") ) ;
    lexC lex( tinP , etThread , TAG( TAGiDnULL ) ) ;

    TN( tSoixlOldProlog , "\r\n.n stackT stack\r\n" ) ;
    
    TN( t_if , "if" ) ;
    TN( t_etherC , "etherC" ) ;
    TN( t_count , "countT" ) ;
    TN( t_stack , "stackT" ) ;
    TN( t_list , "listT" ) ;
    TN( tDotAssign , ".=" ) ;
    TN( tDotPound , ".#" ) ; //COMMENT
    TN( tDotAt , ".@" ) ;
    TN( tDotM , ".m" ) ; //measureT LITERAL
    TN( tDotC , ".c" ) ; //countT LITERAL
    TN( tDotBat , ".b@" ) ; //byteT* LITERAL
    TN( tDotPlus , ".+" ) ;
    TN( tDotX , ".x" ) ;
    TN( tDotN , ".n" ) ;
    TN( tDotOn  , ".on" ) ;
    TN( tDotOff , ".off" ) ;
    TN( tDotVersion , ".version" ) ;
    TN( tDotTm , ".tm" ) ;
    TN( tDotSoixlOld , ".soixlOld" ) ;
    TN( tDotNoQuiet , ".noquiet" ) ;
    TN( tDotQuiet , ".quiet" ) ;
    TN( tDotQuit , ".quit" ) ;
    TN( tDot , "." ) ;
    TN( tb , " " ) ;
{
voidT workF( tinS& tinP , etherC& etThread , const strokeS* const psttSoixlOldP )

"Introduction to IdeaFarm " "(tm) SOIL (tm) - Sentient Object Interface Language\r\n"
"\r\n"                                                                                              \
"IdeaFarm " "(tm) SOIL (tm) is a general purpose programming language.  If you are\r\n"                     \
"new to IdeaFarm " "(tm) SOIXLoLD, begin by reading this file.  This file is also\r\n"                     \
"a SOIL (tm) program.  SOIL (tm) program files are processed from the bottom up.  So\r\n"                     \
"to read this file, please go now to the bottom line and start reading\r\n"                         \
"upward.\r\n"                                                                                       \
"_______________________________________________________________________________\r\n"               \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"                   .on .? .off\r\n"                                                                \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"dropping this soixlOld.readme.txt file into the Depository.\r\n"                                       \
"Step 6: Obtain IdeaFarm " "(tm) SOIL (tm) reference information.  You can do that right now by\r\n"        \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"attempt to prevent you from \"shooting off your foot\".\r\n"                                       \
"Like C++, SOIL (tm) attempts to give you full access to the power of the CPU; it does not\r\n"          \
"discover that IdeaFarm " "(tm) SOIL (tm) is a suprisingly powerful programming language.\r\n"              \
"Step 5: Study the programming philosophy of IdeaFarm " "(tm) SOIL (tm).  As you play, you will\r\n"        \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"are now ready to begin writing your own IdeaFarm " "(tm) SOIL (tm) programs.\r\n"                          \
"You have just seen that no other tools are needed.  You have everything you need, and\r\n"         \
"IdeaFarm " "(tm) SOIL (tm) programs are interpreted; you do not need to compile and link them.\r\n"        \
"valid SOIL (tm) program, so always deposit COPIES, never ORIGINALS!\r\n"                                \
"by dropping a COPY of such a file onto the Depository.  Note:  The Depository \"eats\" any\r\n"    \
"programs are plain text files that contain a sequence of words.  You run such a program\r\n"       \
"Step 4: Study the concepts demonstrated in soixlOld.helloWorld.txt.  IdeaFarm " "(tm) SOIL (tm)\r\n"           \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"Do that now.  A popup window containing \"Hello, world!\" will appear immediately.\r\n"            \
"\r\n"                                                                                              \
"                   IdeaFarm " "(tm) SOIL (tm) Depository\r\n"                                              \
"\r\n"                                                                                              \
"which is on your desk:\r\n"                                                                        \
"Step 3: Run soi.helloWorld.txt by copying it and pasting it onto this object,\r\n"                 \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"displays that data word to the user (in a \"popup window\").\r\n"                                  \
"pops the data word that it expects to find on the stack of pending words, and\r\n"                 \
"the interpreter tells that object to \"do its thang\".  The POPUP object\r\n"                      \
"POPUP is the name of an object.  When POPUP is encountered in a SOIL (tm) program,\r\n"                 \
"is the last word in the hello program, and the only word that \"does anything\".\r\n"              \
"\r\n"                                                                                              \
"                    POPUP\r\n"                                                                     \
"\r\n"                                                                                              \
"stack, since all of the preceding words were handled by the interpreter.\r\n"                      \
"the word onto a stack of pending words.  It is the first word to be placed on the\r\n"             \
"Since the interpreter has been told that this is a data word, it simply places\r\n"                \
"\r\n"                                                                                              \
"                    \"Hello, world!\"\r\n"                                                         \
"\r\n"                                                                                              \
"SOIXLoLD words refer to live objects that do things.)  The data word is:\r\n"                          \
"This word means \"the word that follows me is just data\".  (By default,\r\n"                      \
"\r\n"                                                                                              \
"                    .\r\n"                                                                         \
"\r\n"                                                                                              \
"The next word is the real beginning of the hello world program:\r\n"                               \
"\r\n"                                                                                              \
"                    1\r\n"                                                                         \
"\r\n"                                                                                              \
"the version number is:\r\n"                                                                        \
"program and that a version number follows.  In the hello, world program\r\n"                       \
"These words declare that the text that follows is an IdeaFarm " "(tm) SOIL (tm)\r\n"                       \
"\r\n"                                                                                              \
"                   .soixlOld .tm IdeaFarm .version\r\n"                                                \
"\r\n"                                                                                              \
"word does.  Every IdeaFarm " "(tm) SOIL (tm) program must begin with the 4 words:\r\n"                     \
"Step 2: Study the hello world program until you understand what each SOIL (tm)\r\n"                     \
"\r\n"                                                                                              \
"\r\n"                                                                                              \
"become familiar with the words and what they do.\r\n"                                              \
"just a sequence of words.  There is no syntax to learn; you just need to\r\n"                      \
"because it is contained within double quote marks.)  SOIL (tm) programs are\r\n"                        \
"contains 8 SOIL (tm) words.  (\"Hello, World!\" counts as a single SOIL (tm) word\r\n"                       \
"sequence of words separated by white space.  This hello world program\r\n"                         \
"IdeaFarm " "(tm) SOIL (tm) program files are plain text files that contain a\r\n"                          \
"Step 1: Find and open this object on your desktop: \"soixlOld.helloWorld\".\r\n"                       \
"\r\n"                                                                                              \
"IdeaFarm " "(tm) SOIL (tm).  For more information, see http://www.ideafarm.com .\r\n"                      \
"This file presents only the information that you will need to start using\r\n"                     \
"\r\n"                                                                                              \
"community.  Welcome!\r\n"                                                                          \
"still reading, you are a potential member of an exceptionally open minded\r\n"                     \
"can read upwards, but closed minded people will refuse to do it!  If you are\r\n"                  \
"you must be willing and able to learn to read upwards.  Everyone who can read\r\n"                 \
"IdeaFarm " "(tm) SOIL (tm) is a general purpose programming language.  To use SOIXLoLD,\r\n"                   \
"\r\n"                                                                                              \
"Introduction to IdeaFarm " "(tm) SOIL (tm) - Sentient Object Interface Language\r\n"                     \
"_______________________________________________________________________________\r\n"               \
"\r\n"                                                                                              \
".off\r\n"                                                                                          \
".quiet\r\n"                                                                                        \
".soixlOld .tm IdeaFarm .version 1\r\n"                                                                 \
                                                                                                    \
#define POSTlITrEADmE                                                                               \

VARIABLE( countC , countT )

/*1*/WAKEhIDE( "kernel.soixlOld.interpreter" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

