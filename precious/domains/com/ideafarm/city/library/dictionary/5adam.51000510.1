
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

THREADmODE1rESTORE ;
}
    }
        DEL( psPayload ) ;
        stRelayOut >> *(countT*)&psPayload ;
        ZE( soulC* , psPayload ) ;
    {
    while( stRelayOut )
    //U::sgnDone_tmOutF.waitF( tinP ) ;
    bQuit = 1 ;
    
    etThread.relayF( tinP , ether , stRelayOut , pcArg , pCioGetF , b_pCioGetF ) ;
    ZE( countT* , pcArg ) ;
    batonC b_pCioGetF( tinP , TAG( TAGiDnULL ) ) ;
    cioGetFT pCioGetF = cioGetF ;
    
    //U:: etThread.osThreadF( tinP , countTC() , tmOutF , &sgnDone_tmOutF , flTHREADlAUNCH_null , 0 , (countT)&etThread , (countT)&bQuit , (countT)&stRelayOut ) ;
    ZE( boolT , bQuit ) ;
    //U:: signC sgnDone_tmOutF( tinP , TAG( TAGiDnULL ) ) ;
    stackC stRelayOut( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO|flSTACKc_GIVEsIGNnEWpLATE ) ;
{
THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;

TODO

}
    if( cArgP && idptOriginP && bQuitP ) ;
    }
        DEL( psPayloadP ) ; //OPTIONAL
        etherP.delF( tinP , pczChannelP ) ; //OPTIONAL
        etherP.strokeF( tinP , T(pczChannelP)+T("| ")+T(psttMsg) ) ;
        *psPayloadP >> psttMsg ;
        ZE( strokeS* , psttMsg ) ;
    {
    if( idPayloadTypeP == ifcIDtYPEgIFT_APPLICATION )
{
voidT cioGetF( tinS& tinP , etherC& etherP , const boolT& bQuitP , const countT idPayloadTypeP , soulC*& psPayloadP , countT*& pczChannelP , countT& cArgP , const idPortTimeC& idptOriginP )

DONE( tmOutF )
}
    }
        ++ s ; etThread.osSleepF( tinP , TUCK * 0x40 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;

        }
            stRelayOutP << (countT)psWrap ;

            /* a-d */ homeS::homeIF().idptRelay >> *psWrap ;
            /* 9 */ *psWrap << sGift ;
            /* 8 */ *psWrap << flags ;
            /* 7 */ *psWrap << sToMediator ;
            /* 6 */ *psWrap << sTo ;
            /* 5 */ *psWrap << (countT*)c8Channel ;
            /* 4 */ *psWrap << (countT)ifcIDtYPEwRAP_GIFT ;
            /* 3 */ *psWrap << (countT)1 ; // idVersion
            /* 2 */ *psWrap << (countT)ifcIDpROTOCOL_RELAYwRAP ;
            /* 1 */ *psWrap << (strokeS*)tTM ;

            c8Channel.c4 = 1 + cOut % 8 ;
            sGift << (strokeS*)tMsg ;
            TN( tMsg , "" ) ; tMsg = T("how now brown cow! ")+TF1(++cOut)+T("\r\n") ;
            static countT cOut ;
            soulC sGift( tinP , TAG( TAGiDnULL ) ) ;
            flagsT flags = flCIOpUT_null ;
            soulC sToMediator( tinP , TAG( TAGiDnULL ) ) ;
            soulC sTo( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( psWrap )
        soulC* psWrap = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrap ) ;
    {
    while( !bQuitP && !stRelayOutP.third && !etThread )

    }
        }
            stRelayOutP << (countT)psEnvelope ;

            *psEnvelope << (countT)4 ; // ccFilter
            psEnvelope->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_countTptr , (countT*)c8Filter , 4 ) ; // pcFilter
            *psEnvelope << (countT)0 ; // ccTestMax ;
            *psEnvelope << (countT*)c8Channel ;
            *psEnvelope << (countT)ifcIDtYPEwRAP_CHANNELeXCLUDEpUSH ;
            *psEnvelope << (countT)1 ; // idVersion
            *psEnvelope << (countT)ifcIDpROTOCOL_RELAYwRAP ;
            *psEnvelope << (strokeS*)tTM ;

            count8S c8Filter( 0 , 0 , 0 , -4 ) ;
            c8Channel.c4 = 4 ; //MUST BE NONZE; MATCHES CHANNELS THAT HAVE SAME LOW 2 BITS
        {
        if( psEnvelope )
        soulC* psEnvelope = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psEnvelope ) ;
    {
    //SET AN EXCLUSION FILTER THAT SELECTS CHANNELS THAT ARE MODULO 4 (4 8 c 01 ...)

    }
        }
            stRelayOutP << (countT)psEnvelope ;

            *psEnvelope << (countT)4 ; // ccFilter
            psEnvelope->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_countTptr , (countT*)c8Filter , 4 ) ; // pcFilter
            *psEnvelope << (countT)0 ; // ccTestMax ;
            *psEnvelope << (countT*)c8Channel ;
            *psEnvelope << (countT)ifcIDtYPEwRAP_CHANNELiNCLUDEpUSH ;
            *psEnvelope << (countT)1 ; // idVersion
            *psEnvelope << (countT)ifcIDpROTOCOL_RELAYwRAP ;
            *psEnvelope << (strokeS*)tTM ;

            count8S c8Filter( 0 , 0 , 0 , -2 ) ;
            c8Channel.c4 = 2 ; //MUST BE NONZE; SPECIFY ANY EVEN VALUE TO GET EVEN CHANNELS; ANY ODD VALUE TO GET ODD CHANNELS
        {
        if( psEnvelope )
        soulC* psEnvelope = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psEnvelope ) ;
    {
    //SET A FILTER THAT SELECTS CHANNELS THAT ARE EVEN

    //}
    //    }
    //        stRelayOutP << (countT)psEnvelope ;
    //
    //        *psEnvelope << (countT)0 ; // ccFilter
    //        psEnvelope->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_countTptr , (countT*)0 ) ; // pcFilter
    //        *psEnvelope << (countT)4 ; // ccTestMax ;
    //        *psEnvelope << (countT*)c8Channel ;
    //        *psEnvelope << (countT)ifcIDtYPEwRAP_CHANNELiNCLUDEpUSH ;
    //        *psEnvelope << (countT)1 ; // idVersion
    //        *psEnvelope << (countT)ifcIDpROTOCOL_RELAYwRAP ;
    //        *psEnvelope << (strokeS*)tTM ;
    //
    //        c8Channel.c4 = idChannel ;
    //    {
    //    if( psEnvelope )
    //    soulC* psEnvelope = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
    //{
    //for( countT idChannel = 3 ; idChannel <= 4 ; idChannel ++ )
    //SET A FILTER TO REQUEST CHANNELS 3 AND 4

    count8S c8Channel( 1 , 2 , 3 , 4 ) ;
    TN( tTM , "IdeaFarm " "(tm)" ) ;

    stackC& stRelayOutP  = *(stackC*)pTaskP->c3 ;
    boolT&  bQuitP       =  *(boolT*)pTaskP->c2 ;
    etherC& etThreadMain = *(etherC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmOutF )

/*1*/WAKEhIDE( "example.other.func.10301c8.etherC.relayF" )/*1*/
/**/
*/
applications should use the etherC::cio* api calls
applications should not call relayF
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

