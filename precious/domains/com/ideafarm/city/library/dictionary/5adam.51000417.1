
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.strokeF( tinP , T("ok\r\n") ) ;
writeTimeNowTableF( tinP , etThread ) ;
writeValidFlagsTableF( tinP , etThread , swValidFlags , idGroupFlags ) ;

etThread.delF( tinP , postx ) ;

etThread.boxPutF( tinP , tFileOut2d , postSplitAt , costx - cost1 ) ;
etThread.boxPutF( tinP , tFileOut2c , postSplitAt , costx - cost1 ) ;
etThread.boxPutF( tinP , tFileOut2b , postSplitAt , costx - cost1 ) ;
etThread.boxPutF( tinP , tFileOut2a , postSplitAt , costx - cost1 ) ;
//etThread.boxPutF( tinP , tFileOut2  , postSplitAt , costx - cost1 ) ;

etThread.boxPutF( tinP , tFileOut1d , postx , cost1 ) ;
etThread.boxPutF( tinP , tFileOut1c , postx , cost1 ) ;
etThread.boxPutF( tinP , tFileOut1b , postx , cost1 ) ;
etThread.boxPutF( tinP , tFileOut1a , postx , cost1 ) ;
//etThread.boxPutF( tinP , tFileOut1  , postx , cost1 ) ;

countT cost1 = postSplitAt - postx ;

postSplitAt += 5 ;
if( !postSplitAt ) { BLAMMO ; }
osTextT* postSplitAt = thirdC::c_strstrIF( tinP , postx + costx / 2 , "END\r\n//SOURCE:" ) ; // SPLIT THE IMAGE INTO OO IMAGES TO AVOID CAUSING COMPILER (wpp386) TO CRAP AND DIE

TN( tFileOut2d , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.adam.hide.third.2.h" ) ;
TN( tFileOut2c , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.adam.show.third.2.h" ) ;
TN( tFileOut2b , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.base.hide.third.2.h" ) ;
TN( tFileOut2a , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.base.show.third.2.h" ) ;

TN( tFileOut1d , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.adam.hide.third.1.h" ) ;
TN( tFileOut1c , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.adam.show.third.1.h" ) ;
TN( tFileOut1b , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.base.hide.third.1.h" ) ;
TN( tFileOut1a , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.base.show.third.1.h" ) ;

// ALL FI FILES IN EACH OF THE OO SETS MUST REMAIN IDENTICAL ; ANY MANUAL MODIFICATIONS TO ipdos.h MUST BE PROPOGATED TO THESE FO FILES BY COPYING AND SPLITTING ipdos.h
// THESE FILES ARE IDENTICAL COPIES OF tFileOut.  IT IS A KLUDGE THAT IS DONE SO THAT PRECOMPILED HEADERS CAN BE FULLY EXPLOITED TO SPEED UP BUILDS

//TN( tFileOut2 , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.2.h" ) ;
//TN( tFileOut1 , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.1.h" ) ;

etThread.boxPutF( tinP , tFileOutAll , postx , costx ) ;
TN( tFileOutAll , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.h" ) ;

// 
// SUMMARY: THE FILE ipdos.h ONLY EXISTS FOR USE WITH THE hc.bat BATCH FILE TO PROPOGATE HEADER CHANGES DURING CRAFTWORK, I.E. BETWEEN "DOaLL" BUILDS
// 
// DURING STEP 7, THE FILE ipdos.h WILL BE OVERWRITTEN BY ADAM ifcIDaDAM_HEADER.  (THE MANUAL EDITS ARE NO LONGER NEEDED.)
//
// 7. Elves IS BUILT AND RUN (e.bat)
// 6. THE ephemeral\domains DIRECTORY IS DELETED
// 5. THE "#define DOaLL" LINE IN ADAM 621 IS ENABLED
// 4. OTHER CODE IS EDITED TO USE THAT NEW SYMBOLIC CONSTANT
// 3. THE hc.bat BATCH FILE IS RUN, TO PROPOGATE THE ipdos.h IMAGE TO THE FILES THAT ARE ACTUALLY INCLUDED BY THE SOURCE CODE
// 2. A COPY OF THE #define LINE IS PASTED AT THE TOP (ANYWHERE, BUT THE TOP IS EASIEST) OF FILE ipdos.h
// 1. THE CODE CRAFTSMAN CREATES A NEW DICTIONARY FILE CONTAINING THE #define LINE
// 
// EXAMPLE SCENARIO:  DURING CODE CRAFTWORK, A NEW SYMBOLIC CONSTANT IS NEEDED
// 
// FILE ipdos.h EXISTS FOR THE CONVENIENCE OF HUMAN EDITORS
// THE SOURCE CODE DOES NOT REFER TO, OR INCLUDE, ipdos.h
// 
// USAGE NOTES

etThread.delF( tinP , pstto ) ;
countT costx = etThread.strMakeF( tinP , LF , postx , pstto ) ; ___( postx ) ;
ZE( osTextT* , postx ) ;

__( idLath > 0xdfffffff ) ;
etThread.strokeF( tinP , TF2(idf,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
}
    etThread.delF( tinP , psttw ) ;
    }
        }
            break ;
            __1
            __( idsTag ) ;
        {
        default :
        //}
        //    break ;
        //    etThread.strFuseF( tinP , pstto , T("0x")+TF3(idLath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
        //    etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
        //    bNewGroup = 0 ;
        //    __Z( bIn3block ) ;
        //{
        //case  :
        //}
        //    break ;
        //    etThread.strFuseF( tinP , pstto , T("0x")+TF3(idLath+1,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
        //    etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
        //    bNewGroup = 0 ;
        //    __Z( bIn3block ) ;
        //{
        //case  :
        //}
        //    break ;
        //    etThread.strFuseF( tinP , pstto , T("0x")+TF3(++idbLast,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,2) ) ; ___( pstto ) ;
        //    etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
        //    bNewGroup = 0 ;
        //    __Z( bIn3block ) ;
        //{
        //case  :
        }
            break ;
            groupLath = idbLath ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(idbLath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ idbLath ;
            }
                groupWoth = ++idbLath ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 0x11 :
        }
            break ;
            groupLath = idaLath ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(idaLath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ idaLath ;
            }
                groupWoth = ++idaLath ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 0x10 :
        }
            break ;
            etThread.delF( tinP , psttLathWord ) ;
            }
                etThread.strFuseF( tinP , pstto , tLeft+T("_max     0x")+TF3(idr01Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                TN( tLeft , "\r\n#define " ) ; tLeft += T(psttLathWord) ;
            {
            if( psttLathWord && psttLathWord->idAdam )

            idr01Lath += 0x10 - 1 ; //THIS RESERVES THE REMAINING f VALUES
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(++idr01Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;

            etThread.strWordF( tinP , psttLathWord , psttw , sttq , S1C(' ') , - 2 ) ; ___( psttLathWord ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , psttLathWord ) ;

            __NZ( bIn3block ) ;
        {
        case 0xf :
        }
            break ;
            groupLath = id9Lath ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(id9Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ id9Lath ;
            }
                groupWoth = ++id9Lath ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 0xe :
        }
            break ;
            groupLath = id8Lath ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(id8Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ id8Lath ;
            }
                groupWoth = ++id8Lath ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 0xd :
        }
            break ;
            groupLath = id7Lath ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(id7Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ id7Lath ;
            }
                groupWoth = ++id7Lath ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 0xc :
        }
            break ;
            groupLath = id5Lath ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(id6Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ id6Lath ;
            }
                groupWoth = ++id6Lath ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 0xb :
        }
            break ;
            groupLath = id5Lath ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(id5Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ id5Lath ;
            }
                groupWoth = ++id5Lath ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 0xa :
        }
            break ;
            groupLath = id4Lath ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(id4Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ id4Lath ;
            }
                groupWoth = ++id4Lath ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 9 :
        }
            break ;
            groupLath = id3Lath ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(id3Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ id3Lath ;
            }
                groupWoth = ++id3Lath ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 8 :
        }
            break ;
            groupLath = id2Lath ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(id2Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ id2Lath ;
            }
                groupWoth = ++id2Lath ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 7 :
        }
            break ;
            groupLath = id1Lath ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(id1Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ id1Lath ;
            }
                groupWoth = ++id1Lath ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 6 :
        }
            break ;
            groupLath = idwmLast ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(idwmLast,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ idwmLast ;
            }
                groupWoth = ++idwmLast ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 5 :
        }
            break ;
            groupLath = fiLast ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(fiLast,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ fiLast ;
            }
                groupWoth = ++fiLast ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            __Z( bIn3block ) ;
        {
        case 4 :
        }
            break ;
            flNext <<= 1 ;
            (countT&)swValidFlags |= vv ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(vv,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;

            //LOGrAW3( "[vv]          :    " , vv                             , "\r\n" ) ; //U:: TO FIND A BUG
            //LOGrAW3( "[markFlags]   :    " , markFlags                      , "\r\n" ) ; //U:: TO FIND A BUG
            //LOGrAW3( "[flNext]      :    " , flNext                         , "\r\n" ) ; //U:: TO FIND A BUG
            //LOGrAW3( "[cFlavors]    :    " , swValidFlags.cFlavorsF( tinP ) , "\r\n" ) ; //U:: TO FIND A BUG
            //LOGrAW3( "[idGroupFlags]:    " , idGroupFlags                   , "\r\n" ) ; //U:: TO FIND A BUG

            flagsT vv = flNext | markFlags ;
            __( !( F(flNext) ) ) ;

            }
                flNext = 1 << offbFlags ;

                markFlags = idGroupFlags | 0xe << offbIdType ;

                if( !idGroupFlags ) idGroupFlags ++ ;
                idGroupFlags &= 0xff ;
                //20141121@1005: DISABLED THIS BECAUSE NOW HAVE MORE THAN A TUCK OF FLAGS GROUPS: __( idGroupFlags > 0xff ) ; //THIS CAN BE REMOVED IF HAVE MORE THAN ff GROUPS.  THEN THE idGroup VALUES WILL NOT BE UNIQUE. THEY WILL STILL SERVE TO HELP DETECT CODING ERRORS
                idGroupFlags ++ ;

                b_fl = 1 ;

                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )

            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;

            __Z( bIn3block ) ;

            //}
            //    etThread.delF( tinP , posto ) ;
            //    etThread.boxPutF( tinP , T("///d/tmp/goo.ttt") , posto , costo ) ;
            //    costo = etThread.strMakeF( tinP , LF , posto , psttw ) ; ___( posto ) ;
            //
            //    etThread.delF( tinP , posto ) ;
            //    etThread.boxPutF( tinP , T("///d/tmp/foo.ttt") , posto , costo ) ;
            //    countT costo = etThread.strMakeF( tinP , LF , posto , pstto ) ; ___( posto ) ;
            //    ZE( osTextT* , posto ) ;
            //{
            //if( !bIn3block ) //U:: TO FIND A BUG
        {
        case 3 :
        }
            break ;
            groupLath = idLath ;
            etThread.strFuseF( tinP , pstto , T("0x")+TF3(idLath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
            else ++ idLath ;
            }
                groupWoth = ++idLath ;
                prefixF( tinP , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                bNewGroup = 0 ;
            {
            if( bNewGroup )
            }
                __Z( bIn3block ) ;
                etThread.strokeF( tinP , T("ERROR: NOT DELIMITED BY \"/*3*/\": \"\r\n")+T(psttw)+T("\r\n\"\r\n") ) ;
            {
            if( !bIn3block )
        {
        case 2 :
        }
            break ;
            }
                    etThread.delF( tinP , psttGroup ) ;
                    b_fl = 0 ;
                    bNewGroup = 0 ;
            {
            else
            if( bIn3block ) bNewGroup = 1 ;

            }
                etThread.strFuseF( tinP , pstto , tLeft+T("_min     0x")+TF3(groupWoth,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tLeft+T("_max     0x")+TF3(groupLath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                TN( tLeft , "\r\n#define " ) ; tLeft += T(psttGroup) ;
            {
            else if( !bIn3block && psttGroup && psttGroup->idAdam )
            if( b_fl ) { etThread.strFuseF( tinP , pstto , T("\r\n#define ")+T(psttGroup)+T("_null    0x")+TF3(markFlags,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ; }
            bIn3block = !bIn3block ;
            etThread.strFuseF( tinP , pstto , t3 ) ; ___( pstto ) ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
        {
        case 1 :
        }
            break ;
            etThread.strFuseF( tinP , pstto , psttw ) ; ___( pstto ) ;
        {
        case 0 :
    {
    switch( idsTag )

    etThread.strSubstringF( tinP , psttw , idf , sttq , stTag , idsTag , tIn ) ; ___( psttw ) ;
    idsTag = 0 ;
    ZE( strokeS* , psttw ) ;
    if( !( idf % TUCK ) ) etThread.strokeF( tinP , TF2(idf,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r") ) ;
{
while( !ether && !etThread && idf )
switchC swValidFlags( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idGroupFlags ) ;
ZE( boolT , b_fl ) ;
ZE( strokeS* , psttGroup ) ;
etThread.strokeF( tinP , T("editing (cursor position)\r\n") ) ;
ZE( countT , groupLath ) ;
ZE( countT , groupWoth ) ;
ZE( flagsT , markFlags ) ;
ZE( boolT , bNewGroup ) ;
ZE( countT , idGroupFlags ) ;
ZE( boolT , bIn3block ) ;
ZE( countT , flNext ) ;
ZE( countT , idbLast ) ;
countT idwmLast = 0x000003ff ; //ASSUME: WM_USER == 0x400 FOR ALL OPERATING SYSTEMS SUPPORTED
countT fiLast   = 0xcccc0000 ; // THE HIGH ORDER "cccc" INDICATES FINGERPRINT
//OLD: countT fiLast   = 0xc1a732b8 ; // THE HIGH ORDER "c" INDICATES FINGERPRINT; THE REMAINING NIBBLES ARE INTENDED TO BE UNLIKELY TO OCCUR IN DATA
countT idbLath   = 0xdddd4000 ; // ifcIDmODEaCCOUNT
countT idaLath   = 0xdddd5000 ; // LISTnAMEaDAM
countT idr01Lath = 0xdddd6000 ; // ID'S FOR RESERVED BLOCKS (TAGS OF FORM /*idr.01*/
countT id9Lath   = 0xdddd7000 ; // LISTnAME
countT id8Lath   = 0xdddd8000 ; // ID'S FOR ifcIDtYPEsOULiTEM ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
countT id7Lath   = 0xdddd9000 ; // ID'S FOR ifcIDtYPEdISPLAY ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
countT id6Lath   = 0xdddda000 ; // ID'S FOR ifcIDtYPEtREEwALKcb ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
countT id5Lath   = 0xddddb000 ; // ID'S FOR ifcIDcMDsPOUSE_PILLnAME ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
countT id4Lath   = 0xddddc000 ; // ID'S FOR ifcOLDiDtYPEwRAP ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
countT id3Lath   = 0xddddd000 ; // ID'S FOR ifcIDpROTOCOL ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
countT id2Lath   = 0xdddde000 ; // ID'S FOR strokeC IDaDAM ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
countT id1Lath   = 0xddddf000 ; // ID'S FOR strokeC CASTE ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE

//0xdddd0000: TWEAK idLath INITIAL VALUE TO VERIFY PERSISTENT STORES (E.G. KT FILES) AREN'T BROKEN
countT idLath   = 0xdddd0000 ; // ID'S ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE

//sttq = ze ;
idf = 1 ;

) , tIn.csF( tinP ) + csTags ) ; ___( pstto ) ;

    "\r\n"

#endif

    "#define SIZEOF_windowOldC       0x")+TF2(sizeof( windowOldC       ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_switchStackC  0x")+TF2(sizeof( switchStackC  ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_switchC       0x")+TF2(sizeof( switchC       ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_stackC        0x")+TF2(sizeof( stackC        ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_soulC         0x")+TF2(sizeof( soulC         ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_sexC          0x")+TF2(sizeof( sexC          ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_rootWordC     0x")+TF2(sizeof( rootWordC     ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_renderStateOldS  0x")+TF2(sizeof( renderStateOldS  ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_pulpOldC         0x")+TF2(sizeof( pulpOldC         ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_poolC         0x")+TF2(sizeof( poolC         ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_napkinC       0x")+TF2(sizeof( napkinC       ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_lexC          0x")+TF2(sizeof( lexC          ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_handleC       0x")+TF2(sizeof( handleC       ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_grabMemorySpaceC 0x")+TF2(sizeof( grabMemorySpaceC ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_fileC         0x")+TF2(sizeof( fileC         ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_etherC        0x")+TF2(sizeof( etherC        ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_bookC         0x")+TF2(sizeof( bookC         ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_batonC        0x")+TF2(sizeof( batonC        ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
    "#define SIZEOF_baseSoilXxxxC     0x")+TF2(sizeof( baseSoilXxxxC     ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"

#else

    "#define SIZEOF_windowOldC      ( sizeof( windowOldC          ) )\r\n"
    "#define SIZEOF_switchStackC    ( sizeof( switchStackC        ) )\r\n"
    "#define SIZEOF_switchC         ( sizeof( switchC             ) )\r\n"
    "#define SIZEOF_stackC          ( sizeof( stackC              ) )\r\n"
    "#define SIZEOF_soulC           ( sizeof( soulC               ) )\r\n"
    "#define SIZEOF_sexC            ( sizeof( sexC                ) )\r\n"
    "#define SIZEOF_rootWordC       ( sizeof( rootWordC           ) )\r\n"
    "#define SIZEOF_renderStateOldS ( sizeof( renderStateOldS     ) )\r\n"
    "#define SIZEOF_pulpOldC        ( sizeof( pulpOldC            ) )\r\n"
    "#define SIZEOF_poolC           ( sizeof( poolC               ) )\r\n"
    "#define SIZEOF_napkinC         ( sizeof( napkinC             ) )\r\n"
    "#define SIZEOF_lexC            ( sizeof( lexC                ) )\r\n"
    "#define SIZEOF_handleC         ( sizeof( handleC             ) )\r\n"
    "#define SIZEOF_grabMemorySpaceC   ( sizeof( grabMemorySpaceC       ) )\r\n"
    "#define SIZEOF_fileC           ( sizeof( fileC               ) )\r\n"
    "#define SIZEOF_etherC          ( sizeof( etherC              ) )\r\n"
    "#define SIZEOF_bookC           ( sizeof( bookC               ) )\r\n"
    "#define SIZEOF_batonC          ( 0x1b4                         )\r\n"
    "#define SIZEOF_baseSoilXxxxC   ( sizeof( baseSoilXxxxC       ) )\r\n"

#if !defined( NEVERdEFINED )
//U::DEBUG USE OF OOTH SET OF DEFS (REVERSING SENSE OF NEXT LINE)
//20180127@1709: sizeof( batonC ) IS HARDCODED SO CAN BE USED WITHIN CLASS DEF OF napkinC
//SO WE NORMALLY USE THE OOTH SNIP
//BUT USING THE WOTH SNIP WILL RESULT IN LOTS OF IRRITATING WARNING CHATTER FROM THE COMPILER
//USING THE WOTH SNIP IS NEEDED WHENEVER THE SIZE OF ANY OF THE LISTED CLASSES CHANGES

    "\r\n"
    "#pragma disable_message ( 549 , 656 , 657 , 665 , 666 , 726 ) ;\r\n"
    "\r\n"
    "// SIZEOF_[class] CONSTANTS ARE DEFINED HERE TO AVOID HAVING A USELESS COMPILER ERROR\r\n"
    "\r\n"
    "// For build environment info, see file \"\\ideafarm.work\\backed.up.never\\txt\\readme.first.ipdos.build.environment.txt\"\r\n"
    "\r\n"
    "// IPDOS (tm) <> IdeaFarm " "(tm) Piggyback Distributed Operating System\r\n"
    "\r\n"

etThread.strMakeF( tinP , LF , pstto , T(
ZE( strokeS* , pstto ) ;

// Warning! W726: col(1) no reference to formal parameter 'tinP'

}
    offbIdType = idMax ;
    offbFlags = idMin - 1 ;
    __( cGaps ) ;
    maskExtentF( tinP , etThread , idMin , idMax , cGaps , FL_maskFlags ) ;
    ZE( countT , cGaps ) ;
    ZE( countT , idMax ) ;
    ZE( countT , idMin ) ;
{
ZE( countT , offbIdType ) ;
ZE( countT , offbFlags ) ;
//U: USE THIS INFO TO CALCULATE THE FLAGS VALUES USING CODE THAT DOES NOT ASSUME 02 BITS PER flagsT OBJECT

}
    }
        }
            }
                break ;
                __1
                __( idsTag ) ;
            {
            default :
            //case    : { csTags += sw_cTag *   0x0 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            //case    : { csTags += sw_cTag *   0x0 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            //case    : { csTags -= sw_cTag *   0x3 ; break ; } // TAG REMOVED; 2 DIGITS; "0x"
            case 0x11 : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case 0x10 : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case 0xf  : { csTags += sw_cTag *   0x0 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case 0xe  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case 0xd  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case 0xc  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case 0xb  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case 0xa  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case   9  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case   8  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case   7  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case   6  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case   5  : { csTags += sw_cTag *   0x2 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case   4  : { csTags += sw_cTag *   0x4 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case   3  : { csTags += sw_cTag *   0x4 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case   2  : { csTags += sw_cTag *   0x4 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
            case   1  : { csTags += sw_cTag * 0x100 ; break ; } // NO EDITS, BUT ALLOCATE 0x100 BYTES FOR GENERATED DEFINITION LINES FOR EACH GROUP
        {
        switch( idsTag )
        idsTag = sw_cTag.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = sw_cTag.cFlavorsF( tinP ) ;
{
ZE( countT , csTags ) ;

//etThread.strokeF( tinP , TF2(idf,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
}
    else                                                              break ;
    if( etThread.strIdF( tinP , idf , sttq , stTag , idsTag , tIn ) ) ( (countT&)sw_cTag ) ++ ;
    idsTag = 0 ;
    /*if( idf && !( idf % TUCK ) )*/ etThread.strokeF( tinP , TF2(idf,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r") ) ;
{
while( !ether && !etThread && idf )
strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
countT idf = 1 ;
etThread.strokeF( tinP , T("counting tags (cursor position)\r\n") ) ;

switchC sw_cTag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idsTag ) ;
ZE( countT , idsTag ) ;

//U:stTag << psttOldC( tinP , etThread , T("/*idLath*/") ) ; //
//U:stTag << psttOldC( tinP , etThread , T("/*idNext*/") ) ; //
psttv = psttOldC( tinP , etThread , T("/*idb*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 11
psttv = psttOldC( tinP , etThread , T("/*ida*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 01
psttv = psttOldC( tinP , etThread , T("/*idr.01*/" ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // f
psttv = psttOldC( tinP , etThread , T("/*id9*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // e
psttv = psttOldC( tinP , etThread , T("/*id8*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // d
psttv = psttOldC( tinP , etThread , T("/*id7*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // c
psttv = psttOldC( tinP , etThread , T("/*id6*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // b
psttv = psttOldC( tinP , etThread , T("/*id5*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // a
psttv = psttOldC( tinP , etThread , T("/*id4*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 9
psttv = psttOldC( tinP , etThread , T("/*id3*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 8
psttv = psttOldC( tinP , etThread , T("/*id2*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 7
psttv = psttOldC( tinP , etThread , T("/*id1*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 6
psttv = psttOldC( tinP , etThread , T("/*idwm*/"   ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 5
psttv = psttOldC( tinP , etThread , T("/*fi*/"     ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 4
psttv = psttOldC( tinP , etThread , T("/*fl*/"     ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 3
psttv = psttOldC( tinP , etThread , T("/*id*/"     ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 2
psttv = psttOldC( tinP , etThread , t3               ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; // 1
ZE( strokeS* , psttv ) ;
//FOR BEST SPEED, IT IS VERY IMPORTANT THAT THE MOST FREQUENT TAGS BE LISTED WOTH
//THESE LINES CORRESPOND TO THE HARDCODED CASE VALUES

TN( t3 , "/*" "3*/" ) ;

stackC stTag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;

}
    etThread.delF( tinP , posti ) ;
    tIn = T(posti) ;
    etThread.boxGetShadowF( tinP , posti , countTC() , tFileIn ) ; ___( posti ) ;
    ZE( osTextT* , posti ) ;
{
TN( tIn , "" ) ;

TN( tFileIn  , "///ideafarm/ephemeral/domains/com/ideafarm/city/workshop/tmp/ipdos.h.draft2" ) ;

CONoUTrAW( "HEADER FILE\r\n" ) ;

*/
/*

TODO

}
    etThread.delF( tinP , psttw ) ;
    }
        }
            if( idw < cWords - 1 ) { etThread.strFuseF( tinP , psttP , tUnder ) ; ___( psttP ) ; }
            etThread.delF( tinP , psttn ) ;
            etThread.strFuseF( tinP , psttP , psttn ) ; ___( psttP ) ;
            etThread.strWordF( tinP , psttn , psttw , sttq , sttUnder , idw ) ; ___( psttn ) ;
            ZE( strokeS* , psttn ) ;
            //sttq = ze ;
        {
        for( countT idw = 1 ; idw < cWords ; idw ++ )
        strokeS sttUnder('_') ;
        etThread.strFuseF( tinP , psttP , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ psttw->idAdam ) ; ___( psttP ) ;
        sCountT cWords = etThread.strCLinesF( tinP , psttw , tUnder ) ;
        TN( tUnder , "_" ) ;
    {
    if( psttw )
    etThread.strWordF( tinP , psttw , psttFromP , sttq , S1C(' ') , 2 ) ; ___( psttw ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , psttw ) ;

    //IT IS BAD CODE STYLE TO USE UNDERSCORES WITHIN PREFIXES, BUT I WILL HANDLE IT IF NECESSARY
    //psttP IS SET TO "PREFIX1_PREFIX2_..._PREFIXN"
    //ASSUME: psttFromP IS OF THE FORM "#define PREFIX1_PREFIX2_..._PREFIXN_SUFFIX"
{
voidT prefixF( tinS& tinP , etherC& etThread , strokeS*& psttP , const strokeS* const psttFromP )

}
    cGapsP = cZe - cBitsOut ;
    countT cBitsOut = cBitsAll - cBitsIn ;
    countT cBitsIn = idMaxP - idMinP + 1 ;
    countT cBitsAll = sizeof( flagsT ) * SB ;

    }
        idc ++ ;
        mski <<= 1 ;

        else                          cZe ++ ;
        if(            maskP & mski ) idMaxP = idc ;
        if( !idMinP && maskP & mski ) idMinP = idc ;
    {
    while( mski )
    ZE( countT , cZe ) ;
    countT idc = 1 ;
    countT mski = 1 ;

    }
        if( etThread ) return ;
        __( cGapsP ) ;
        __( idMaxP ) ;
        __( idMinP ) ;
        if( etThread ) return ;
    {
    IFbEcAREFUL
{
voidT maskExtentF( tinS& tinP , etherC& etThread , countT& idMinP , countT& idMaxP , countT& cGapsP , const flagsT maskP )

}
    etThread.delF( tinP , postx ) ;
    etThread.boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/city/workshop/snip/1snip.1900000b.genValidFlags.h") , postx , costx ) ;
    etThread.delF( tinP , pstto ) ;
    countT costx = etThread.strMakeF( tinP , LF , postx , pstto ) ; ___( postx ) ;
    ZE( osTextT* , postx ) ;

    }
        etThread.strFuseF( tinP , pstto , T("0x")+TF3(vv,flFORMAT_UNSIGNED|flFORMAT_FOREIGN,8)+(idf<cFlavors?T(" ,\r\n"):T("\r\n")) ) ;
        //LOGrAW7( "write [idf,leverP,vv]    :    " , idf , "    " , leverP , "    " , vv , "\r\n" ) ; //U:: TO FIND A BUG
        flagsT vv = swP ;
        leverP = swP.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    etThread.strMakeF( tinP , LF , pstto , tLine , cFlavors * tLine.csF( tinP ) ) ; ___( pstto ) ;
    TN( tLine , "0x00000000 ,\r\n" ) ;
    ZE( strokeS* , pstto ) ;

    //LOGrAW3( "write [cFlavors]    :    " , cFlavors , "\r\n" ) ; //U:: TO FIND A BUG

    countT cFlavors = swP.cFlavorsF( tinP ) ;
{
voidT writeValidFlagsTableF( tinS& tinP , etherC& etThread , switchC& swP , countT& leverP )

}
    etThread.boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/city/workshop/snip/1snip.1900000c.genTimeNow.h") , (osTextT*)tt , tt.csF( tinP ) ) ;
    TN( tt , "" ) ; tt = T("0x")+TF3(timeN1,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(" ,\r\n0x")+TF3(timeN2,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T("\r\n") ;

    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT  , timeN1 ) ;
{
voidT writeTimeNowTableF( tinS& tinP , etherC& etThread )

// "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.h"
// "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\ipdos.h"

//  THE REASON FOR THIS IS THAT I MUST BE ABLE TO RUN CORRECTLY USING THE "OLD" VALUES IN EFFECT WHEN I WAS COMPILED
// IT IS ILLEGAL TO REFER TO ANY SYMBOLS WHOSE VALUES I CALCULATE

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_HEADER" )/*1*/
/**/
*/
generates snip.0050025.genMake.h snip file by inserting generated values
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

