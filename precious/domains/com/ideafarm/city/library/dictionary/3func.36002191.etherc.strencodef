
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cbUsed ;

    }
        }
            if( bIsIdJot ) DELzOMBIE( pPageOut ) ;

            __( *(countT*)pbe != ( FINGERnEG_STReNCODEf + 1 ) &&  *(countT*)pbe != ( FINGERnEGoLD_strEncodeF + 1 ) ) ; //TO CATCH OVERWRITE

            //}
            //    delF( tinP , psttdCodes ) ;
            //    LOGrAW( td ) ;
            //    TN( td , "" ) ; td = T("to codes    : ")+T(psttdCodes)+T("\r\n") ;
            //    strDumpIF( tinP , psttdCodes , pbOut , ((countT*)pbOut)[ 1 ] + 2 * sizeof( countT ) ) ; ___( psttdCodes ) ;
            //    ZE( strokeS* , psttdCodes ) ;
            //{
            //if( tinP.pc Utility[ 0 ] )
            //COMMENT OUT IN PRODUCTION
            
            //}
            //    delF( tinP , psttdStrokes ) ;
            //    LOGrAW( td ) ;
            //    TN( td , "" ) ; td = T("\r\nfrom strokes: ")+T(psttdStrokes)+T("\r\n") ;
            //    strDumpIF( tinP , psttdStrokes , (byteT*)psttP , ( CSpREFIX + psttP->idAdam ) * sizeof( strokeS ) ) ; ___( psttdStrokes ) ;
            //    ZE( strokeS* , psttdStrokes ) ;
            //{
            //if( tinP.pc Utility[ 0 ] )
            //COMMENT OUT IN PRODUCTION

            }
                //tinP.pDropNoteNewest->cbRequested  = tinP.pDropNoteNewest->cbUsedReally = cbUsed ;
            {
            if( !pbeP )
            ((countT*)pbOut)[ 1 ] = cbUsed - 2 * sizeof( countT ) ;
            cbUsed = ( SB - 1 + offbo ) / SB ;

            }
                }
                    offs  += csImage - 1 ;
                    offbo += cbImage * SB ;

                    //delF( tinP , psttd ) ;
                    //LOGrAW( "\r\n" ) ;
                    //strokeF( tinP , psttd ) ;
                    //LOGrAW3( "encoded this soul image at bit offset " , offbo , "\r\n" ) ;
                    //strDumpIF( tinP , psttd , (byteT*)&psttP[ offs ] , cbImage ) ;
                    //ZE( strokeS* , psttd ) ;

                    /*WCBC(C):8*cbImage*/ thirdC::c_memcpyIF( tinP , pbOut + offbo / SB , (byteT*)&psttP[ offs ] , cbImage ) ;
                    countT cbImage = csImage * sizeof( strokeS ) ;

                    /*WCBC(C):7*/ { count2S c2t = valueF( offbo , offboa , 0 , ( SB - offbo ) % SB ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }

                    if( offs == offse ) break ;
                    offs ++ ;
                    countT csImage = sttc.idAdam ;
                {
                if( sttc.idCaste == sc_cADAMeXPORT )

                //CONoUTrAW3( "bytes remaining: " , pbe - ( pbOut + offbo / SB ) , "\r\n" ) ; //U::
                /*WCBC(B):02*/ if( cBitsNote   ) { count2S c2t = valueF( offbo , offboa , sttc.cNote           , cBitsNote            ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
                /*WCBC(B):c */ if( !bAlphabet1 ) { count2S c2t = valueF( offbo , offboa , sttc.idCaste & 0xfff , 0xc                  ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
                /*WCBC(B):02*/                   { count2S c2t = valueF( offbo , offboa , sttc.idAdam          , bAdamTiny ? 8 : 0x20 ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
                /*WCBC(B):3 */                   { count2S c2t = valueF( offbo , offboa , cBytesNote           , 3                    ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
                /*WCBC(B):1 */                   { count2S c2t = valueF( offbo , offboa , bAlphabet1           , 1                    ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
                /*WCBC(B):1 */                   { count2S c2t = valueF( offbo , offboa , bAdamTiny            , 1                    ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
                countT cBitsNote = cBytesNote * SB ;
                ;
                                : 4
                                ? 3
                            : sttc.cNote < 0x1000000
                            ? 2
                        : sttc.cNote < 0x10000
                        ? 1
                    : sttc.cNote < 0x100
                    ? 0
                countT cBytesNote = !sttc.cNote
                boolT bAlphabet1 = sttc.idCaste == sc_cALPHABET1 ;
                boolT bAdamTiny  = sttc.idAdam < 0x100 ;

                const strokeS& sttc = psttP[ offs ] ;
            {
            for( countT offs = 0 ; offs < offse ; offs ++ )
            const countT offse = CSpREFIX + psttP->idAdam ;

            /*WCBC(A):02*/ { count2S c2t = valueF( offbo , offboa , 0xffffffff           , SB * sizeof( countT ) ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; } //OVERWRITTEN LATER
            /*WCBC(A):02*/ { count2S c2t = valueF( offbo , offboa , FINGERnEG_STReNCODEf , SB * sizeof( countT ) ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
            ZE( countT , offboa ) ;
            ZE( countT , offbo ) ; //BIT OFFSET OF NEXT WRITE

            pbOut += cbHeadP ;

            if( pbHeadP ) memCopyF( tinP , pbOut , pbHeadP , cbHeadP ) ;

            *(countT*)pbe = FINGERnEG_STReNCODEf + 1 ; //TO CATCH OVERWRITE ; U:: BUG: THIS SHOULD BE A UNIQUE FINGER_ VALUE THAT IS NOT USED ANYWHERE ELSE
            memSetF( tinP , pbOut , cba ) ; //ALL OF THE WRITES THAT FOLLOW ARE DONE BY OR'ING INTO THIS RANGE

            const byteT* const pbe = pbOut + cba ;

            ;
                : (byteT*)(const byteT*)*pPageOut
                ? pbP
            byteT* pbOut = !bIsIdJot

            ;
                : new( 0 , tinP , pb_pageOut , sizeof pb_pageOut ) pageC( jotC::readIF( tinP , (countT)pbP ) ) ;
                ? 0
            pageC* pPageOut = !bIsIdJot
            byteT pb_pageOut[ sizeof pageC ] ;

            boolT bIsIdJot = !ISrAWpOINTER( pbP ) ;
        {
        if( !POOP )

        }
            __NZ( ISnULLjpOINTER( pbP ) ) ;
            newF( tinP , LF , pbP , cba + sizeof( countT ) ) ; ___( pbP ) ;
        {
        if( ISnULLjpOINTER( pbP ) )

        }
            __Z( pbP + cba + sizeof( countT ) <= pbeP ) ;
        {
        if( ISrAWpOINTER( pbP ) && pbP )

        countT cba = cbHeadP + 2 * sizeof( countT ) + sizeof( strokeS ) * ( CSpREFIX + psttP->idAdam ) ; //ALLOWS FOR WHOLE STRING TO BE A SOUL IMAGE

        //  IF NO IMAGES: 04 + 15 * cStrokes
        //
        // TOTAL WORST CASE
        //
        // (C) SOUL IMAGE: 7 + csImage * 06
        // (B) EACH STROKE EXCLUDING SOUL IMAGE: 15
        // (A) PREFIX: 04 BITS
        // SUMMARY
        //WCBC: WORST CASE BIT CONSUMPTION IS INDICATED AT EACH CONSUMING CODE LINE

        // IF CASTE IS sc_cADAMeXPORT THEN THIS IS FOLLOWED BY THE IMAGE, BYTE ALIGNED, WITH LEADING PAD BITS SET TO 0
        //  ENCODED cNote
        //  ENCODED idCaste
        //  ENCODED idAdam
        //  FLAG BITS
        // FOR EACH STROKE
        // 02-f3 cbBytes FOLLOWING
        // 0 -f1 fingerprint
        //HEADER LAYOUT

        //CONoUTrAW( T("encoding \"")+T(psttP)+T("\"\r\n") ) ; //TO FIND SLOWNESS
    {
    if( psttP )
    ZE( countT , cbUsed ) ;

    }
        if( POOP ) return 0 ;

        __( psttP && psttP->idCaste != sc_PREFIXlENGTH ) ;

        }
            }
                __Z( pbP <= pbeP ) ;
                __Z( pbeP ) ;
            {
            else
            }
                __NZ( pbeP ) ;
            {
            if( !pbP )
        {
        else
        }
            __NZ( pbeP ) ;        // END MUST NOT BE SPECIFIED
        {
        if( !ISrAWpOINTER( pbP ) )

        if( POOP ) return 0 ;
        __Z( ISvALIDjpOINTER( pbP ) ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/countT etherC::strEncodeF( tinS& tinP , byteT*& pbP , const strokeS* const psttP , const byteT* const pbeP , const countT cbHeadP , const byteT* pbHeadP )/*1*/

/**/
*/
  if not 0 then must point to cbHeadP bytes, which will be copied to pbP
  may be 0
 pbHeadP
   will be initialized to 0
  extra bytes to allocate at beginning
 cbHeadP
   must point to the woth byte that is not available
  if pbP then must not be 0, and must indicate the end of the bytes available at pbP
  if !pbP then must be 0
 pbeP
   see SETpREFIX
  if not 0 then must point to a string prefix
  if 0 then i do nothing
  may be 0
 psttP
  U:: can also be a value initialized by ZEJ() to specify that the drop is to be allocated within the specified jotC instance rather than in PUSE
  if not 0 then must contain enough bytes to receive the worst case length encoding
  can be 0
 pbP
 tinP
arguments
 pbP + myReturnValue is the pbEnd of the encoding
i evaluate to the number of bytes actually used in the encoding
i encode strings of strokeS values to reduce the required space
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

