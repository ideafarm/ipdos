
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    while( idl -- ) { strFuseF( tinP , psttP , tNull+S2(0,scOld_POPcOLOR) ) ; ___( psttP ) ; }
    countT idl = idLathI ;
    }
        case 1 : { strFuseF( tinP , psttP , tNull+S2(0xffff00,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn1,idrIn1)+OLDlINEtO(idcOut1,idrOut1) ) ; ___( psttP ) ; if( idFirst == 1 ) break ; }
        case 2 : { strFuseF( tinP , psttP , tNull+S2(0xbfff00,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn2,idrIn2)+OLDlINEtO(idcOut2,idrOut2) ) ; ___( psttP ) ; if( idFirst == 2 ) break ; }
        case 3 : { strFuseF( tinP , psttP , tNull+S2(0x7fff00,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn3,idrIn3)+OLDlINEtO(idcOut3,idrOut3) ) ; ___( psttP ) ; if( idFirst == 3 ) break ; }
        case 4 : { strFuseF( tinP , psttP , tNull+S2(0x3fff00,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn4,idrIn4)+OLDlINEtO(idcOut4,idrOut4) ) ; ___( psttP ) ; if( idFirst == 4 ) break ; }
        case 5 : { strFuseF( tinP , psttP , tNull+S2(0x00ffff,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn5,idrIn5)+OLDlINEtO(idcOut5,idrOut5) ) ; ___( psttP ) ; if( idFirst == 5 ) break ; }
        case 6 : { strFuseF( tinP , psttP , tNull+S2(0x00ffbf,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn6,idrIn6)+OLDlINEtO(idcOut6,idrOut6) ) ; ___( psttP ) ; if( idFirst == 6 ) break ; }
        case 7 : { strFuseF( tinP , psttP , tNull+S2(0x00ff7f,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn7,idrIn7)+OLDlINEtO(idcOut7,idrOut7) ) ; ___( psttP ) ; if( idFirst == 7 ) break ; }
        case 8 : { strFuseF( tinP , psttP , tNull+S2(0x00ff3f,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn8,idrIn8)+OLDlINEtO(idcOut8,idrOut8) ) ; ___( psttP ) ; if( idFirst == 8 ) break ; }
    {
    switch( idLathI )
    //HANDS

    strFuseF( tinP , psttP , tNull+S2(0x0000ff,scOld_cPUSHcOLOR)+OLDmOVEtO(idcIn1death,idrIn1death)+OLDlINEtO(idcOut1death,idrOut1death)+S2(0,scOld_POPcOLOR) ) ; ___( psttP ) ;
    strFuseF( tinP , psttP , tNull+S2(0x00ff00,scOld_cPUSHcOLOR)+OLDmOVEtO(idcIn1born,idrIn1born)+OLDlINEtO(idcOut1born,idrOut1born)+S2(0,scOld_POPcOLOR) ) ; ___( psttP ) ;

    ) ; ___( psttP ) ;

        S2(0,scOld_POPcOLOR)

        OLDlINEtO( mIdco + 0.5 , mIdro-mCr*4/8 + 0.5 ) +
        OLDmOVEtO( mIdco + 0.5 , mIdro         + 0.5 ) +   // TICKS

        tNull +

    strFuseF( tinP , psttP ,

    }
        ) ;
    
            OLDlINEtO( mIdco - mCc/2 * mHand + 0.5 , mIdro - mCr/2 * mHand + 0.5 )
            OLDlINEtO( mIdco + mCc/2 * mHand + 0.5 , mIdro - mCr/2 * mHand + 0.5 ) +
            OLDlINEtO( mIdco + mCc/2 * mHand + 0.5 , mIdro + mCr/2 * mHand + 0.5 ) +
            OLDlINEtO( mIdco - mCc/2 * mHand + 0.5 , mIdro + mCr/2 * mHand + 0.5 ) +
            OLDmOVEtO( mIdco - mCc/2 * mHand + 0.5 , mIdro - mCr/2 * mHand + 0.5 ) +   // COSMETIC RECTANGLE
    
            tNull +
    
        strFuseF( tinP , psttP ,
        measureT mHand = (measureT)idHand / (measureT)cHand ;
    {
    for( countT idHand = 2 ; idHand < cHand ; idHand +=2 )

    ) ; ___( psttP ) ;

        tNull

        T(psttNoteP) +
        OLDmOVEtO( mIdco-mCc*4/8 + 1.5 , (sCountT)mIdro-mCr*4/8 + 1.5 ) +

        OLDlINEtO( mIdco-mCc*4/8+0.5 , mIdro-mCr*4/8+0.5 ) +
        OLDlINEtO( mIdco+mCc*4/8+0.5 , mIdro-mCr*4/8+0.5 ) +
        OLDlINEtO( mIdco+mCc*4/8+0.5 , mIdro+mCr*4/8+0.5 ) +
        OLDlINEtO( mIdco-mCc*4/8+0.5 , mIdro+mCr*4/8+0.5 ) +
        OLDmOVEtO( mIdco-mCc*4/8+0.5 , mIdro-mCr*4/8+0.5 ) +   // PERIMETER RECTANGLE
        S2(0x808080,scOld_cPUSHcOLOR) +

        tNull +

    strFuseF( tinP , psttP ,

    POSTPONEtEST( psttP ) ;
    strMakeF( tinP , psttP , tNull , 0x200 ) ; // CALLER MUST TAG ___( psttP ) . GENEROUS
    TN( tNull , "" ) ;
    ORIGIN

    }
        case 1 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x1c , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 2 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x18 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 3 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x14 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 4 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x10 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 5 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x0c , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 6 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x08 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 7 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x04 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 8 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x00 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
    {
    switch( idLathI )
    }
        case 1 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x1c , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 2 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x18 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 3 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x14 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 4 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x10 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 5 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x0c , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 6 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x08 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 7 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x04 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 8 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x00 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
    {
    switch( idLathI )
    }
        case 1 : { endsF( tinP , *this , idcIn1 , idrIn1 , idcOut1 , idrOut1 , cP << 0x1c , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 1 ) break ; }
        case 2 : { endsF( tinP , *this , idcIn2 , idrIn2 , idcOut2 , idrOut2 , cP << 0x18 , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 2 ) break ; }
        case 3 : { endsF( tinP , *this , idcIn3 , idrIn3 , idcOut3 , idrOut3 , cP << 0x14 , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 3 ) break ; }
        case 4 : { endsF( tinP , *this , idcIn4 , idrIn4 , idcOut4 , idrOut4 , cP << 0x10 , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 4 ) break ; }
        case 5 : { endsF( tinP , *this , idcIn5 , idrIn5 , idcOut5 , idrOut5 , cP << 0x0c , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 5 ) break ; }
        case 6 : { endsF( tinP , *this , idcIn6 , idrIn6 , idcOut6 , idrOut6 , cP << 0x08 , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 6 ) break ; }
        case 7 : { endsF( tinP , *this , idcIn7 , idrIn7 , idcOut7 , idrOut7 , cP << 0x04 , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 7 ) break ; }
        case 8 : { endsF( tinP , *this , idcIn8 , idrIn8 , idcOut8 , idrOut8 , cP << 0x00 , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 8 ) break ; }
    {
    switch( idLathI )
    ZE( countT , idHandLast ) ;
    const countT cHand = idLathI - idFirst + 1 ;
    const countT idLathI  = idLastP  ? idLastP  : 8 ;
    const countT idFirst = idFirstP ? idFirstP : 1 ;
    ZE( countT , idrOut8 ) ;
    ZE( countT , idcOut8 ) ;
    ZE( countT , idrIn8 ) ;
    ZE( countT , idcIn8 ) ;
    ZE( countT , idrOut7 ) ;
    ZE( countT , idcOut7 ) ;
    ZE( countT , idrIn7 ) ;
    ZE( countT , idcIn7 ) ;
    ZE( countT , idrOut6 ) ;
    ZE( countT , idcOut6 ) ;
    ZE( countT , idrIn6 ) ;
    ZE( countT , idcIn6 ) ;
    ZE( countT , idrOut5 ) ;
    ZE( countT , idcOut5 ) ;
    ZE( countT , idrIn5 ) ;
    ZE( countT , idcIn5 ) ;
    ZE( countT , idrOut4 ) ;
    ZE( countT , idcOut4 ) ;
    ZE( countT , idrIn4 ) ;
    ZE( countT , idcIn4 ) ;
    ZE( countT , idrOut3 ) ;
    ZE( countT , idcOut3 ) ;
    ZE( countT , idrIn3 ) ;
    ZE( countT , idcIn3 ) ;
    ZE( countT , idrOut2 ) ;
    ZE( countT , idcOut2 ) ;
    ZE( countT , idrIn2 ) ;
    ZE( countT , idcIn2 ) ;
    ZE( countT , idrOut1 ) ;
    ZE( countT , idcOut1 ) ;
    ZE( countT , idrIn1 ) ;
    ZE( countT , idcIn1 ) ;
    ZE( countT , idrOut1death ) ;
    ZE( countT , idcOut1death ) ;
    ZE( countT , idrIn1death ) ;
    ZE( countT , idcIn1death ) ;
    ZE( countT , idrOut1born ) ;
    ZE( countT , idcOut1born ) ;
    ZE( countT , idrIn1born ) ;
    ZE( countT , idcIn1born ) ;

    }
        timeDeath = timeB1 >> 0x10 | ( timeB2 << 0x10 ) ;
        osTimeFromOldTimeF( tinP , timeB1 , timeB2 , 2036 , 9 , 7 ) ;
        timeB1 = timeB2 = 0 ;
        timeBorn = timeB1 >> 0x10 | ( timeB2 << 0x10 ) ;
        osTimeFromOldTimeF( tinP , timeB1 , timeB2 , 1953 , 9 , 7 ) ;
        ZE( sCountT , timeB2 ) ;
        ZE( countT , timeB1 ) ;
    {
    ZE( countT , timeDeath ) ;
    ZE( countT , timeBorn ) ;

    _IO_

    }
        if( POOP ) return ;
        __( idStyleP - 1 ) ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::strClockF( tinS& tinP , strokeS*& psttP , countT cP , const countT idColP , const countT idRowP , const countT cColP , const countT cRowP , const countT idStyleP , const countT idFirstP , const countT idLastP , const strokeS* const psttNoteP )/*1*/

/**/
*/
\<A HREF=\"5.103019d.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strClockF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

