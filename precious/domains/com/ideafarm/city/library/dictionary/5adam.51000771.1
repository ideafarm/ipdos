
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tinP , T("ok") ) ;

}
    }
        ++ s ; etThread.osSleepF( tinP , TOCK ) ;
    {
    while( ws.cWorkers )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    etThread.traceF( tinP , T("waiting for worker") ) ;

    }
        etThread.traceF( tinP , T("napped") ) ;
        ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        etThread.traceF( tinP , T("napping") ) ;

        if( bQuit ) break ;

        THREADmODE1rESTORE
        }
            }
                }
                    }
                        ++ s ; etThread.osSleepF( tinP , TOCK >> 3 ) ;
                        etThread.traceF( tinP , T("waiting for queue to shrink [cPending]:    ")+TF2(ws.st_pPageEvent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    while( ws.st_pPageEvent > TUCK )
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( ws.st_pPageEvent > ( TUCK << 1 ) )                // THE QUEUE LENGTH MUST BE SMALL SO THAT IT IS IMPOSSIBLE FOR A QUEUED ITEM TO BE IN A BOOK OTHER THAN THE BOOK IMMEDIATELY PRECEDING THE BOOK BEING READ, ASSUMING THAT I ONLY KEEP WO INACTIVE BOOK

                //if( bPrefix ) bQuit2 = 1 ; //U:: TO FIND A BUG

                bPrefix = !bPrefix ;

                else          pbi = 0 ;
                if( bDelete ) PUSE( tinP , *(byteT**)&pbi ) ;

                ;
                    : sizeof( countT )
                    ? *(countT*)pbi
                cbi = bPrefix

                }
                    if( ws.idIn < TUCK || !( ws.idIn % TUCK ) ) etThread.traceF( tinP , T("[ws.idIn,cOutputFlavors]:    ")+TF2(ws.idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ws.swBooksByByte.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    ++ ws.idIn ;
                    ws.st_pPageEvent << *(countT*)&pPageEvent ;

                    __( (countT)*pPageEvent - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;

                        THREADmODE3rESTORE
                        DEL( pPageEvent ) ;
                        THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                    {
                    if( !(const byteT*)*pPageEvent )        //SHOULD BE IMPOSSIBLE SINCE "ALL OR NONE" USED FOR WRITING BOOKTOGETHER AND I'VE ALREADY READ THE PREFIX

                    THREADmODE3rESTORE
                    bksAccessEvents.readF( tinP , *pPageEvent , hRead , flBOOKScrEAD_null , &bQuit ) ;
                    pPageEvent = new( 0 , tinP , LF ) pageC( tinP , bksAccessEvents , cbi ) ; ___( pPageEvent ) ;
                    THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                    ZE( pageC* , pPageEvent ) ;
                {
                else
                }
                    __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;
                    {
                    if( !pbi )
                    bDelete = bksAccessEvents.readF( tinP , pbi , cbi , hRead , flBOOKScrEAD_null , &bQuit ) ;
                {
                if( bPrefix )
                ZE( boolT , bDelete ) ;

                HANDLEaPPnOTEScOUNTcLASS ch = hRead ;

                handleC hReadSave = hRead ;
                countT cbiSave = cbi ;
            {
            while( !bQuit && !bQuit2 && !POOP )
            boolT bPrefix = 1 ;
            countT cbi = sizeof( countT ) ;
            ZE( const byteT* , pbi ) ;

            // *****************************************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
            // ********                    *************************************************************************************************************************************************************************************************************************
            // ********  EAT BOOK ENTRIES  *************************************************************************************************************************************************************************************************************************
            // ********                    *************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
        {
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    {
    while( !bQuit && !bQuit2 && !POOP )
    ZE( boolT , bQuit2 ) ;
    handleC hRead( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
    etThread.traceF( tinP , T("ACCESSeVENTS3bOOKfOReACHuRI / enering loop to read events") ) ;

    }
        etThread.osThreadF( tinP , countTC() , tmWorkerF , 0 , flTHREADlAUNCH_INHERITjOTrEGISTRATIONS , TOCK , (countT)&ws , (countT)&bksAccessEvents ) ;
        inc02AM( ws.cWorkers ) ;
    {
    while( cDo -- )
    countT cDo = 0x40 ;
    etThread.traceF( tinP , T("ACCESSeVENTS3bOOKfOReACHuRI / launching workers") ) ;

    workS ws( tinP , etThread ) ;
    etThread.traceF( tinP , T("ACCESSeVENTS3bOOKfOReACHuRI / ct ws") ) ;

    TN( tb4 , "    " ) ;
    booksC bksAccessEvents( tinP , TAG( TAGiDnULL ) , "bksAccessEvents.1.raw" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_null , 0 , 1 , 0 , 0 , 0 , 0 , &bQuit ) ;
    etThread.traceF( tinP , T("ACCESSeVENTS3bOOKfOReACHuRI / ct bksAccessEvents") ) ;

    const boolT& bQuit = *(const boolT*)&(const countT&)ether ;
{

TODO

DONE( tmWorkerF )
}
    dec02AM( wsP.cWorkers ) ;

    }
        }
            THREADmODE1rESTORE
            }
                wsP.st_pPageEvent.ungrabF( tinP ) ;
                }
                    wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    }
                        THREADmODE3rESTORE
                        DEL( pPageEvent ) ;
                        THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )

                        #endif

                        }
                            etThread.delF( tinP , psttBrowser ) ;
                            etThread.delF( tinP , psttProtocol ) ;
                            etThread.delF( tinP , psttQuery ) ;
                            etThread.delF( tinP , psttUri ) ;
                            etThread.delF( tinP , psttContainer ) ;
                            etThread.delF( tinP , psttLogBucket ) ;
                            etThread.delF( tinP , psttMethod ) ;

                            }

                                wsP.swBooksByByte.ungrabF( tinP ) ;

                                booksOut.writeF( tinP , (byteT*)&cbo , sizeof cbo , WS( sBookEntryOut ) , flBOOKScwRITE_ALLOWoDDlENGTH | flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ELSEfILLtOeND , 0 ) ;
                                countT cbo = sBookEntryOut.cbF( tinP ) ;

                                booksC& booksOut = *(booksC*)&(countT&)wsP.swBooksByByte ;

                                }
                                    }
                                        booksC* pBooks = new( 0 , tinP , pba , sizeof( booksC ) ) booksC( tinP , TAG( TAGiDnULL ) , tBooksOut , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER , TOCK << 4 ) ; ___( pBooks ) ;
                                        TN( tBooksOut , "" ) ; tBooksOut = T("bksAccessEvents.2.hash1.")+TF3(wsP.lever_cByte,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,2)+T(".accessEvents") ;
                                    {
                                    if( !POOP )

                                    __Z( pba ) ;
                                    byteT* pba = (byteT*)&(countT&)wsP.swBooksByByte ;
                                {
                                if( !wsP.swBooksByByte.idSlotOfLeverF( tinP , wsP.lever_cByte ) )
                                wsP.lever_cByte = hashUri & 0xff ;
                                wsP.swBooksByByte.grabF( tinP , TAG( TAGiDnULL ) ) ;

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                        *********************************************************************************************************************************************************************************************************************
                                // ********  BOOK THE EVENT soulC  *********************************************************************************************************************************************************************************************************************
                                // ********                        *********************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************


                                sBookEntryOut << pidj[ 5 ] ;                        // BROWSER
                                sBookEntryOut << cbReply ;                          // CB REPLY BODY
                                sBookEntryOut << code ;                             // HTTP RESPONSE CODE
                                sBookEntryOut << pidj[ 4 ] ;                        // PROTOCOL
                                sBookEntryOut << pidj[ 3 ] ;                        // QUERY
                                sBookEntryOut << psttUri ;                          // URI           (STRING)
                                sBookEntryOut << hashUri ;                          // THIS IS REDUNDANT AND IS AN OPTIMIZATION TO AVOID MULTIPLE CALCULATIONS AS PROCESSING PROCEEDS THROUGH SORTING TO FINAL OUTPUT
                                sBookEntryOut << pidj[ 2 ] ;                        // CONTAINER
                                sBookEntryOut << pidj[ 1 ] ;                        // BUCKET
                                sBookEntryOut << pidj[ 0 ] ;                        // METHOD
                                sBookEntryOut << nnHe ;
                                sBookEntryOut << *(countT*)&timeW2 ;
                                sBookEntryOut << timeW1 ;
                                sBookEntryOut << (countT)1 ;
                                sBookEntryOut << finger ;       finger = 0 ;

                                soulC sBookEntryOut( tinP , TAG( TAGiDnULL ) ) ;

                                putNegAM( finger, FINGERnEG_ACCESSeVENTiDjOTfORmOstsTRINGS ) ;
                                ZE( countT , finger ) ;
                                const countT hashUri = hashF( (byteT*)psttUri , sizeof( strokeS ) * ( CSpREFIX + psttUri->idAdam ) , 0 ) ;

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // ********  CONSTRUCT EVENT soulC  ********************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************

                                }
                                    if( !pidj[ offi ] ) { BLAMMO ; }

                                    ppjhs[ offi ]->ungrabF( tinP ) ;
                                    //if( offi == 3 ) etThread.traceF( tinP , T("serialized processing ---- for offi==3 [hash]:    ")+TF2(ph[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    }
                                        etThread.traceF( tinP , T("stored  [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[ offi ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                        }
                                            wsP.sws_idJotContainerByHash.ungrabF( tinP ) ;
                                            wsP.sws_idJotContainerByHash.sinkF( tinP , countTC() , pidj[ offi ] , flSTACKsINK_UNIQUE ) ;
                                            wsP.leverHashContainer = ph[ offi ] ;
                                            wsP.sws_idJotContainerByHash.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                        {
                                        if( offi == 2 )
                                        pidj[ offi ] = (countT)pbEncoded ;
                                        etThread.strEncodeF( tinP , pbEncoded , psttzv , 0 , sizeof( countT ) , (const byteT*)&ph[ offi ] ) ; ___( pbEncoded ) ;
                                        ZEJ( byteT* , pbEncoded , *ppjhs[ offi ] ) ;
                                        //etThread.traceF( tinP , T("storing [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[ offi ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                        _IO_
                                    {
                                    if( !pidj[ offi ] )

                                    }
                                        }
                                            }
                                                etThread.delF( tinP , psttHe ) ;
                                                }
                                                    //etThread.traceF( tinP , T("found   [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                                    pidj[ offi ] = ppjhs[ offi ]->idLathReadF() ;
                                                {
                                                if( !etThread.strCompareF( tinP , psttzv , psttHe ) )
                                                //etThread.traceF( tinP , T("comparing [offi,psttzv,psttHe]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv)+tb4+T(psttHe) ) ;
                                                etThread.strDecodeF( tinP , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                                                ZE( strokeS* , psttHe ) ;
                                            {
                                            else if( *(countT*)pbEncodedHe == ph[ offi ] )
                                            if( !pbEncodedHe || !cbEncodedHe ) break ;

                                            countT       cbEncodedHe = pageHe ;
                                            const byteT* pbEncodedHe = pageHe ;

                                            pageC pageHe = *ppjhs[ offi ] ;
                                            //CS:PSEUDOdUPLICATE this this
                                        {
                                        while( !pidj[ offi ] )
                                        ppjhs[ offi ]->resetLathReadF() ;
                                        _IO_
                                    {
                                    else   // SEARCH JOT SEQUENTIALLY
                                    }
                                        wsP.sws_idJotContainerByHash.ungrabF( tinP ) ;

                                        }
                                            while( !etThread && ~hWalk ) ;
                                            }
                                                }
                                                    etThread.delF( tinP , psttHe ) ;
                                                    }
                                                        break ;
                                                        etThread.delF( tinP , psttHe ) ;
                                                        pidj[ offi ] = idJot ;
                                                    {
                                                    if( !etThread.strCompareF( tinP , psttzv , psttHe ) )
                                                    etThread.strDecodeF( tinP , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                                                    ZE( strokeS* , psttHe ) ;

                                                    }
                                                        continue ;
                                                        etThread.traceF( tinP , T("error: unexpected hash [offi,idJot,actualHash,expectedHash]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(*(countT*)pbEncodedHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ph[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    {
                                                    if( *(countT*)pbEncodedHe != ph[ offi ] )
                                                {
                                                if( pbEncodedHe && cbEncodedHe )

                                                countT       cbEncodedHe = pageHe ;
                                                const byteT* pbEncodedHe = pageHe ;

                                                pageC pageHe = jotUse[ idJot ] ;
                                                //CS:PSEUDOdUPLICATE this this

                                                jotC& jotUse = *ppjhs[ offi ] ;

                                                countT idJot = wsP.sws_idJotContainerByHash.downF( tinP , hWalk ) ;
                                            {
                                            do
                                            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        if( wsP.sws_idJotContainerByHash )

                                        wsP.leverHashContainer = ph[ offi ] ;
                                        wsP.sws_idJotContainerByHash.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                    {
                                    if( offi == 2 )    // LOOK UP idJotContainer

                                    ppjhs[ offi ]->grabF( tinP , TAG( TAGiDnULL ) ) ;

                                    ph[ offi ] = hashF( (byteT*)psttzv , sizeof( strokeS ) * ( CSpREFIX + psttzv->idAdam ) , 0 ) ;

                                    strokeS* psttzv = ppsttzValue[ offi ] ;

                                    _IO_
                                {
                                for( countT offi = 0 ; offi < sizeof ppsttzValue / sizeof ppsttzValue[ 0 ] ; offi ++ )
                        
                                countT   ph[]          = { 0             , 0             , 0             , 0             , 0             , 0               } ; // "ph":"pHash"                                    CS:CODEsYNC: this this this this
                                countT   pidj[]        = { 0             , 0             , 0             , 0             , 0             , 0               } ; // "pidj":"pIdJot"                                 CS:CODEsYNC: this this this this
                                strokeS* ppsttzValue[] = { psttMethod    , psttLogBucket , psttContainer , psttQuery     , psttProtocol  , psttBrowser     } ; // STROKE STRING                                   CS:CODEsYNC: this this this this
                                jotC*    ppjhs[]       = { &wsP.jhsOther , &wsP.jhsOther , &wsP.jhsOther , &wsP.jhsQuery , &wsP.jhsOther , &wsP.jhsBrowser } ; // "ppjhs":"ppJotHashStrings"                      CS:CODEsYNC: this this this this

                                // THE OUTPUT EVENT WILL THEN BE WRITTEN TO THE booksC INSTANCE DEDICATED TO THE VALUE OF THE LOW ORDER BYTE OF THE URI HASH
                                // ALL STRINGS OTHER THAN URI ARE REPLACED BY IDJOT VALUES IN THE OUTPUT EVENT

                                //A:ASSUME: THE URI STRING IS THE ONLY STRING THAT CAN HAVE UNBOUNDEDLY MANY VALUES.  ALL OTHER STRING FIELDS ARE ASSUMED TO HAVE "ONLY A FEW" POSSIBLE VALUES, SO THAT STORING THE IDjOT VALUES ASSOCIATED WITH EACH HASH VALUE WILL NOT REQUIRE A LARGE MEMORY FOOTPRINT

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                             ****************************************************************************************************************************************************************************************************************
                                // ********  GET IDjOT VALUES , HASHES  ****************************************************************************************************************************************************************************************************************
                                // ********                             ****************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************

                                //}
                                //    etThread.traceF( tinP , T("[nnHe,time,method,bucket,container,uri,query,protocol,code,cb,browser]:    ")+tSay ) ;
                                //
                                //    ;
                                //
                                //        +tb4+tBrowser
                                //        +tb4+TF4(cbReply,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                                //        +tb4+TF4(code,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                                //        +tb4+tProtocol
                                //        +tb4+tQuery
                                //        +tb4+tUri
                                //        +tb4+tContainer
                                //        +tb4+tLogBucket
                                //        +tb4+tMethod
                                //        +tb4+TT(timeW1,timeW2)
                                //        T(nnHe)
                                //
                                //    TN( tSay , "" ) ; tSay =
                                //
                                //    TN( tBrowser   , psttBrowser   ) ;
                                //    TN( tProtocol  , psttProtocol  ) ;
                                //    TN( tQuery     , psttQuery     ) ;
                                //    TN( tUri       , psttUri       ) ;
                                //    TN( tContainer , psttContainer ) ;
                                //    TN( tLogBucket , psttLogBucket ) ;
                                //    TN( tMethod    , psttMethod    ) ;
                                //{

                                // A:ASSUME:  THIS CODE ASSUMES THAT EVENTS ARE UNIQUELY IDENTIFIED BY [hash,idJot,time,nn]; MULTIPLE EVENTS WILL RESULT IN MULTIPLE VALUES FOR THE FIELDS

                                //etThread.traceF( tinP , T(psttUri) ) ;

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // ********  PROCESS WO BOOK ENTRY  ********************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                _IO_
                            {
                            else
                            if( getNegAM( finger ) != FINGERnEG_ACCESSeVENTrAW || idFormat != 1 ) etThread.traceF( tinP , T("unexpected format [finger,idFormat]:    ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            sBookEntryIn >> psttBrowser ;             ___( psttBrowser ) ;
                            sBookEntryIn >> cbReply ;
                            sBookEntryIn >> code ;
                            sBookEntryIn >> psttProtocol ;            ___( psttProtocol ) ;
                            sBookEntryIn >> psttQuery ;               ___( psttQuery ) ;
                            sBookEntryIn >> psttUri ;                 ___( psttUri ) ;
                            sBookEntryIn >> psttContainer ;           ___( psttContainer ) ;
                            sBookEntryIn >> psttLogBucket ;           ___( psttLogBucket ) ;
                            sBookEntryIn >> psttMethod ;              ___( psttMethod ) ;
                            sBookEntryIn >> nnHe ;
                            sBookEntryIn >> *(countT*)&timeW2 ;
                            sBookEntryIn >> timeW1 ;
                            sBookEntryIn >> idFormat ;
                            sBookEntryIn >> finger ;

                            ZE( strokeS* , psttBrowser   ) ;
                            ZE( countT   , cbReply       ) ;
                            ZE( countT   , code          ) ;
                            ZE( strokeS* , psttProtocol  ) ;
                            ZE( strokeS* , psttQuery     ) ;
                            ZE( strokeS* , psttUri       ) ;
                            ZE( strokeS* , psttContainer ) ;
                            ZE( strokeS* , psttLogBucket ) ;
                            ZE( strokeS* , psttMethod    ) ;
                            nicNameC       nnHe            ;
                            ZE( sCountT  , timeW2        ) ;
                            ZE( countT   , timeW1        ) ;
                            ZE( countT   , idFormat      ) ;
                            ZE( countT   , finger        ) ;

                            }
                                etThread.delF( tinP , pbPageCopy ) ;
                                }
                                    sBookEntryIn.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbPageCopy , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;

                                    bksAccessEventsP.unlockF( tinP ) ;
                                    etThread.memCopyF( tinP , pbPageCopy , pbzPage , cbzPage ) ;
                                    const byteT* pbzPage = *pPageEvent ;
                                    bksAccessEventsP.lockF( tinP , TAG( TAGiDnULL ) ) ;
                                {
                                if( !POOP )

                                __Z( pbPageCopy ) ;
                                etThread.newF( tinP , LF , pbPageCopy , cbzPage ) ; ___( pbPageCopy ) ;
                                ZE( byteT* , pbPageCopy ) ;

                                countT cbzPage = *pPageEvent ;
                            {
                            soulC sBookEntryIn( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( !ether )

                        #if defined( NEVERdEFINED )

                        //_IO_
                    {
                    if( pPageEvent )

                    wsP.st_pPageEvent.ungrabF( tinP ) ;
                    wsP.st_pPageEvent >> *(countT*)&pPageEvent ;
                    ZE( pageC* , pPageEvent ) ;
                    _IO_
                {
                while( wsP.st_pPageEvent )
                wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;

                _IO_
            {
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            _IO_
        {
        else
        }
            //etThread.traceF( tinP , T("napped") ) ;
            ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //etThread.traceF( tinP , T("napping") ) ;

            if( ether ) break ;
        {
        if( !wsP.st_pPageEvent )
        _IO_
    {
    while( !etThread && !POOP )

    TN( tDot , "." ) ;
    TN( tb4 , "    " ) ;

    booksC& bksAccessEventsP = *(booksC*)pTaskP->c2 ;
    workS&  wsP              =  *(workS*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )

}
{
swBooksByByte(            tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , lever_cByte , 0 , sizeof( booksC ) , ifcIDgRABlAYER_7BASEmISC3 )
lever_cByte( 0 ) ,
sws_idJotContainerByHash( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , leverHashContainer , flSTACKc_null , ifcSTACKtYPE_countT , ifcIDgRABlAYER_7BASEmISC3 ) ,
leverHashContainer( 0 ) ,
idOut( 0 ) ,
idIn( 0 ) ,
cWorkers( 0 ) ,
st_pPageEvent( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_countT ) ,
jhsOther(      tinP , "jotAccessEvents.hash.string.other"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [STRING]; WO JOT PER UNIQUE STRING
jhsBrowser(    tinP , "jotAccessEvents.hash.string.browser" , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsQuery(      tinP , "jotAccessEvents.hash.string.query"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsUri(        tinP , "jotAccessEvents.hash.string.uri"     , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
workS::workS( tinS& tinP , etherC& etherP ) :

}
    swBooksByByte.ungrabF( tinP ) ;

    tinP.pEther->traceF( tinP , T("destroyed  all output books [idOut,cFlavors,heap.cNew-cDel]:    ")+TF2(idOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(processGlobal3S::_processGlobal3I_IF().heap.cNewF()-processGlobal3S::_processGlobal3I_IF().heap.cDelF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    swBooksByByte.freeAllF( tinP ) ;

    }
        //tinP.pEther->traceF( tinP , T("destroying a book [idf,cFlavors]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        //tinP.pc Utility[ 0 ] -- ; //U:: TO FIND A BUG
        DELzOMBIE( pBooks ) ;
        //tinP.pc Utility[ 0 ] ++ ; //U:: TO FIND A BUG
        booksC* pBooks = (booksC*)&(countT&)swBooksByByte ;
        lever_cByte = swBooksByByte.leverF( tinP , idf ) ;
        tinP.pEther->traceF( tinP , T("destroying a book [idf,cFlavors]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )

    tinP.pEther->traceF( tinP , T("destroying all output books [idOut,cFlavors]:    ")+TF2(idOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    countT cFlavors = swBooksByByte.cFlavorsF( tinP ) ;

    swBooksByByte.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT workS::destroyBooksF( tinS& tinP )

}
    destroyBooksF( tinP ) ;
    TINSL
{
workS::~workS( voidT )

;
}
    voidT destroyBooksF( tinS& tinP ) ;
    workS( tinS& tinP , etherC& etherP ) ;
    ~workS( voidT ) ;

    switchC       swBooksByByte ;
    countT        lever_cByte ;

    switchStackC  sws_idJotContainerByHash ;
    countT        leverHashContainer ;

    countT        idOut ;
    countT        idIn ;
    countT        cWorkers ;

    stackC        st_pPageEvent ;

    jotC          jhsOther   ;
    jotC          jhsBrowser ;
    jotC          jhsQuery   ;          //CS:CODEsYNC: 73a 740 (THESE MUST BE CT IN THE SAME ORDER SO THAT THE SAME TAG VALES ARE ASSIGNED
    jotC          jhsUri     ;          // EVERY JOT INSTANCE CONTAINS HASH PREFIXED STRINGS TO KEEP CODE SIMPLE EVEN THOUGH THE HASH IS NOT USEFUL FOR THE STRINGS IN jhsOther
{
struct workS

/*1*/WAKEhIDE( "scratch.7.inactive.tool.gorilla.read.access.events" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
