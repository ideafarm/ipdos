
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        //etThread.delF( tinP , psttnFound ) ;
        //etThread.delF( tinP , pbA ) ;
        //}
        //    while( ~hWalk ) ;
        //    }
        //        }
        //            etThread.delF( tinP , pbB ) ;
        //            }
        //                LOGrAW( T("did not zap (different image): ")+T(psttn)+tcr ) ;
        //            {
        //            else
        //            }
        //                etThread.delF( tinP , psttn ) ;
        //                LOGrAW( T("zapped: ")+T(psttn)+tcr ) ;
        //                etThread.boxZapF( tinP , psttn ) ;
        //                swsName.extractF( 0 , tinP ) ;
        //            {
        //            else if( cbB == cbA && !etThread.memCompareF( tinP , pbA , pbB , cbA ) )
        //            }
        //                }
        //                    LOGrAW( T("did not zap (different hash): ")+T(psttn)+tcr ) ;
        //                {
        //                else
        //                }
        //                    etThread.delF( tinP , psttn ) ;
        //                    LOGrAW( T("zapped (big): ")+T(psttn)+tcr ) ;
        //                    swsName.extractF( 0 , tinP ) ;
        //                    etThread.boxZapF( tinP , psttn ) ;
        //                {
        //                if( hashA == hashB )
        //            {
        //            if( !pbB )
        //
        //            }
        //                etThread.boxGetShadowF( tinP , pbB , cbB , psttn ) ; ___( pbB ) ;
        //            {
        //            else
        //            }
        //                }
        //                    BLAMMO ;
        //                    LOGrAW( T("could not get hash: ")+T(psttn)+tcr ) ;
        //                {
        //                if( !hashB )
        //
        //                PUSE( tinP , pbBuf ) ;
        //                hashB = hashF( pbBuf , TICK , 0 ) ;
        //            
        //                }
        //                    __( TICK - cbr ) ;
        //                    etThread.fileReadF( tinP , pbBuf , cbr , hFile ) ;
        //                    countT cbr = TICK ;
        //
        //                    etThread.fileOpenF( tinP , hFile , countTC() , psttn , ifcOPENaCCESS_R , 0 , flOPENdETAILS_null , ifcOPENhOW_nFeO ) ;
        //                    handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
        //                {
        //                byteT* pbBuf = PUSE.newF( tinP , LF , TICK ) ; ___( pbBuf ) ;
        //            {
        //            if( pcLever[ 2 ] || pcLever[ 3 ] > TICK )
        //            ZE( countT , hashB ) ;
        //            ZE( countT , cbB ) ;
        //            ZE( byteT* , pbB ) ;
        //        {
        //        if( etThread.strCompareF( tinP , psttn , psttnFound ) )
        //
        //        strokeS* psttn = (strokeS*)swsName.downF( tinP , hWalk ) ;
        //    {
        //    do
        //{
        //if( bFound )
        //
        //while( ~hWalk ) ;
        //}
        //    }
        //        break ;
        //        }
        //            etThread.boxGetShadowF( tinP , pbA , cbA , psttn ) ; ___( pbA ) ;
        //        {
        //        else
        //        }
        //            }
        //                BLAMMO ;
        //                LOGrAW( T("could not get hash: ")+T(psttn)+tcr ) ;
        //            {
        //            if( !hashA )
        //
        //            PUSE( tinP , pbBuf ) ;
        //            hashA = hashF( pbBuf , TICK , 0 ) ;
        //
        //            }
        //                __( TICK - cbr ) ;
        //                etThread.fileReadF( tinP , pbBuf , cbr , hFile ) ;
        //                countT cbr = TICK ;
        //
        //                etThread.fileOpenF( tinP , hFile , countTC() , psttn , ifcOPENaCCESS_R , 0 , flOPENdETAILS_null , ifcOPENhOW_nFeO ) ;
        //                handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
        //            {
        //            byteT* pbBuf = PUSE.newF( tinP , LF , TICK ) ; ___( pbBuf ) ;
        //        {
        //        if( pcLever[ 2 ] || pcLever[ 3 ] > TICK )
        //
        //        etThread.strMakeF( tinP , psttnFound , psttn ) ; ___( psttnFound ) ;
        //
        //        }
        //            cbA = hashA = 0 ;
        //            etThread.delF( tinP , pbA ) ;
        //            etThread.delF( tinP , psttnFound ) ;
        //        {
        //        if( psttnFound )
        //
        //        if( !bFound ) bFound = 1 ;
        //    {
        //    if( !psttnFound || psttn->idAdam < psttnFound->idAdam )
        //
        //    strokeS* psttn = (strokeS*)swsName.downF( tinP , hWalk ) ;
        //{
        //if( !bFound ) do                        // FIND THE NAME THAT IS THE SHORTEST





        while( ~hWalk ) ;
        }
            etThread.delF( tinP , pbA ) ;
            while( ~hWalk2 ) ;
            }
                }
                    etThread.delF( tinP , pbB ) ;
                    }
                        hWalk.closeIfF() ;
                        etThread.delF( tinP , psttn2 ) ;
                        LOGrAW( T("zapped big: ")+T(psttn2)+tcr ) ;
                        etThread.boxZapF( tinP , psttn2 ) ;
                        swsName.extractF( 0 , tinP ) ;
                    {
                    else if( hashA == hashB )
                    }
                        hWalk.closeIfF() ;
                        etThread.delF( tinP , psttn2 ) ;
                        LOGrAW( T("zapped: ")+T(psttn2)+tcr ) ;
                        etThread.boxZapF( tinP , psttn2 ) ;
                        swsName.extractF( 0 , tinP ) ;
                    {
                    if( cbA && cbB == cbA && !etThread.memCompareF( tinP , pbA , pbB , cbA ) )

                    }
                        hashB = hashF( pbB , cbB , 0 ) ;
                        etThread.boxGetShadowF( tinP , pbB , cbB , psttn2 ) ; ___( pbB ) ;
                    {
                    else
                    }
                        }
                            BLAMMO ;
                            LOGrAW( T("could not get hash: ")+T(psttn2)+tcr ) ;
                        {
                        if( !hashB )
                
                        PUSE( tinP , pbBuf ) ;
                        hashB = hashF( pbBuf , TICK , 0 ) ;
                
                        }
                            __( TICK - cbr ) ;
                            etThread.fileReadF( tinP , pbBuf , cbr , hFile ) ;
                            countT cbr = TICK ;
                
                            etThread.fileOpenF( tinP , hFile , countTC() , psttn2 , ifcOPENaCCESS_R , 0 , flOPENdETAILS_null , ifcOPENhOW_nFeO ) ;
                            handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                        {
                        byteT* pbBuf = PUSE.newF( tinP , LF , TICK ) ; ___( pbBuf ) ;
                    {
                    if( pcLever[ 2 ] || pcLever[ 3 ] > TICK )
                    ZE( countT , hashB ) ;
                    ZE( countT , cbB ) ;
                    ZE( byteT* , pbB ) ;
                {
                if( etThread.strCompareF( tinP , psttn , psttn2 ) )

                strokeS* psttn2 = (strokeS*)swsName.downF( tinP , hWalk2 ) ;
            {
            do
            handleC hWalk2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

            }
                hashA = hashF( pbA , cbA , 0 ) ;
                etThread.boxGetShadowF( tinP , pbA , cbA , psttn ) ; ___( pbA ) ;
            {
            else
            }
                }
                    BLAMMO ;
                    LOGrAW( T("could not get hash: ")+T(psttn)+tcr ) ;
                {
                if( !hashA )
        
                PUSE( tinP , pbBuf ) ;
                hashA = hashF( pbBuf , TICK , 0 ) ;
        
                }
                    __( TICK - cbr ) ;
                    etThread.fileReadF( tinP , pbBuf , cbr , hFile ) ;
                    countT cbr = TICK ;
        
                    etThread.fileOpenF( tinP , hFile , countTC() , psttn , ifcOPENaCCESS_R , 0 , flOPENdETAILS_null , ifcOPENhOW_nFeO ) ;
                    handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                {
                byteT* pbBuf = PUSE.newF( tinP , LF , TICK ) ; ___( pbBuf ) ;
            {
            if( pcLever[ 2 ] || pcLever[ 3 ] > TICK )
            ZE( countT , hashA ) ;
            ZE( countT , cbA ) ;
            ZE( byteT* , pbA ) ;

            //LOGrAW( T("++++++++ ")+T(psttn)+tcr ) ;

            strokeS* psttn = (strokeS*)swsName.downF( tinP , hWalk ) ;
        {
        do


       
        //while( ~hWalk ) ;
        //}
        //    else etThread.delF( tinP , psttTest ) ;
        //    }
        //        break ;
        //        etThread.delF( tinP , psttTest ) ;
        //        }
        //            etThread.boxGetShadowF( tinP , pbA , cbA , psttn ) ; ___( pbA ) ;
        //        {
        //        else
        //        }
        //            }
        //                BLAMMO ;
        //                LOGrAW( T("could not get hash: ")+T(psttn)+tcr ) ;
        //            {
        //            if( !hashA )
        //
        //            PUSE( tinP , pbBuf ) ;
        //            hashA = hashF( pbBuf , TICK , 0 ) ;
        //
        //            }
        //                __( TICK - cbr ) ;
        //                etThread.fileReadF( tinP , pbBuf , cbr , hFile ) ;
        //                countT cbr = TICK ;
        //
        //                etThread.fileOpenF( tinP , hFile , countTC() , psttn , ifcOPENaCCESS_R , 0 , flOPENdETAILS_null , ifcOPENhOW_nFeO ) ;
        //                handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
        //            {
        //            byteT* pbBuf = PUSE.newF( tinP , LF , TICK ) ; ___( pbBuf ) ;
        //        {
        //        if( pcLever[ 2 ] || pcLever[ 3 ] > TICK )
        //
        //        etThread.strMakeF( tinP , psttnFound , psttn ) ; ___( psttnFound ) ;
        //
        //        bFound = 1 ;
        //    {
        //    if( !etThread.strCompareF( tinP , psttTest , tTest ) )
        //    etThread.strSubstringF( tinP , psttTest , idf , idl , psttn ) ; ___( psttTest ) ;
        //    countT idl = 36 ;
        //    countT idf = 34 ;
        //    ZE( strokeS* , psttTest ) ;
        //
        //    strokeS* psttn = (strokeS*)swsName.downF( tinP , hWalk ) ;
        //{
        //do                                      // FIND A NAME THAT CONTAINS THE TEST VALUE
        //ZE( strokeS* , psttnFound ) ;
        //ZE( countT , hashA ) ;
        //ZE( countT , cbA ) ;
        //ZE( byteT* , pbA ) ;
        //ZE( boolT , bFound ) ;
        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( swsName > 1 )

    //LOGrAW( "----------------------------------------------------------------------------------------------------------------\r\n" ) ;
    CONoUTrAW5( "\r                 \r" , cFlavors , " " , idf , "" ) ;

    etThread.memCopyF( tinP , (byteT*)pcLever , (byteT*)swsName.leverF( tinP , idf ) , sizeof pcLever ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
countT cFlavors = swsName.cFlavorsF( tinP ) ;
TN( tTest , "dsc" ) ;

}
    etThread.delF( tinP , pstt1m ) ;
    }
        }
            PUSE( tinP , *(byteT**)&pInfo ) ;
    
            }
                swsName << psttn ;
                etThread.strMakeF( tinP , psttn , psttc1 ) ; ___( psttn ) ;
                ZE( strokeS* , psttn ) ;
    
                pcLever[ 3 ] = pInfo->cbUsed ;
                pcLever[ 2 ] = pInfo->cbUsedHigh ;
                pcLever[ 1 ] = 0 /*pInfo->timeWritten1*/ ;
                pcLever[ 0 ] = hash /*pInfo->timeWritten2*/ ;

                }
                    PUSE( tinP , pbBuf ) ;
                    hash = hashF( pbBuf , cbHash , 0 ) ;
                    
                    }
                        __( cbHash - cbr ) ;
                        etThread.fileReadF( tinP , pbBuf , cbr , hFile ) ;
                        countT cbr = cbHash ;
                    {
                    byteT* pbBuf = PUSE.newF( tinP , LF , cbHash ) ; ___( pbBuf ) ;
                {
                if( cbHash )

                ;
                    : pInfo->cbUsed
                    ? TICK
                countT cbHash = pInfo->cbUsedHigh || pInfo->cbUsed > TICK
            {
            if( pInfo )
    
            etThread.diskFileQueryF( tinP , pInfo , hFile ) ; ___( pInfo ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        if( ~hFile )
    
        etThread.fileOpenF( tinP , hFile , countTC() , psttc1 , ifcOPENaCCESS_R , 0 , flOPENdETAILS_null , ifcOPENhOW_nFeO ) ;
        handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
        ZE( countT , hash ) ;
    {
    FORsTRINGSiN1( pstt1m )
    
    etThread.boxMenuF( tinP , soul , T("///d/gather.to/*") ) ; ___( pstt1m ) ;
    ZE( strokeS* , pstt1m ) ;
{
switchStackC swsName( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , (byteT*)pcLever , sizeof pcLever , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
countT pcLever[ 4 ] ;
TN( tcr , "\r\n" ) ;

TODO

/*1*/WAKEsHOWtEXT( "tool.migrate.delete.redundant.gathered.files" )/*1*/
/**/
*/
 countT timeWritten1 ;
 sCountT timeWritten2 ;
 countT cbUsedHigh ;
 countT cbUsed ;
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

