
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idHere ;
    _OUT_
    }
        }
            POSTPONEtEST( psttPart2P ) ;
            strSubstringF( tinP , psttPart2P , idf , countTC() , psttBigP , csttExtraP ) ; // CALLER MUST TAG ___( psttPart2P ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = F(flagsP) & flSTRbISECT_PREPENDdELIMITER ? idHere : idfBisect ;
        {
        else
        }
            }
                POSTPONEtEST( psttPart2P ) ;
                strMakeF( tinP , psttPart2P , tDelimiter ) ; //CALLER MUST TAG ___( psttPart2P ) ;
            {
            if( F(flagsP) & flSTRbISECT_PREPENDdELIMITER )
        {
        if( !idfBisect )
        //PART 2

        }
            POSTPONEtEST( psttPart1P ) ;
            strSubstringF( tinP , psttPart1P , idf , idl , psttBigP , csttExtraP ) ; //CALLER MUST TAG ___( psttPart1P ) ;
            ;
                    : idfBisect - 1
                    ? 0
                : !idfBisect 
                ? idHere - 1
            countT idl = !( F(flagsP) & flSTRbISECT_APPENDdELIMITER )
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        else
        }
            if( F(flagsP) & flSTRbISECT_APPENDdELIMITER  ) { strMakeF( tinP , psttPart1P , tDelimiter ) ; ___( psttPart1P ) ; }
        {
        if( idHere == 1 )
        //PART 1
    {
    if( idHere )                // idHere IS THE LOCATION OF THE BISECTOR; idfBisect IS THE LOCATION OF THE TRAILING SUBSTRING, IF ANY

    ;

        : strIdF(    tinP , 0 , flSTRmATCH_null , idfBisect , sttq , tDelimiter , psttBigP , 0 , idP )
        ? strIdAnyF( tinP , 0 , flSTRmATCH_null , idfBisect , sttq , tDelimiter , psttBigP , 0 , idP )
    countT idHere = F(flagsP) & flSTRbISECT_ANY
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    countT idfBisect = 1 ;

    if( psttDelimiterP ) tDelimiter = T(psttDelimiterP) ;
    TN( tDelimiter , "/" ) ;
    _INoLD_

    }
        if( POOP ) return 0 ;
        FV( flSTRbISECT , flagsP ) ;
        __Z( idP ) ;
        __NZ( psttPart2P ) ;
        __NZ( psttPart1P ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/**//*1*/countT etherC::strBisectF( tinS& tinP , strokeS*& psttPart1P , strokeS*& psttPart2P , const strokeS* const psttBigP , const strokeS* const psttDelimiterP , const countT idP , const flagsT flagsP , const countT csttExtraP )/*1*/
*/
  modifies behavior
 flagsP
   - 1: lath occurance
   1: woth occurance
  can be negative
  must not be 0
 idP
  marks the bisection point
 psttDelimiterP
  receives the ooth part
  must be 0
 psttPart2P
  receives the woth part
  must be 0
 psttPart1P
arguments
if i do not find the specified delimiter, i silently do nothing
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

