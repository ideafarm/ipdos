
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbo ;

    grab.ungrabF( tinP ) ;

    }
        pbCursor += sizeof( countT ) + *(countT*)pbCursor ;
        pbo = pbCursor + sizeof( countT ) ;
    {
    if( pbCursor + *(countT*)pbCursor < pbEnd )
    ZE( byteT* , pbo ) ;

    if( !bFrozen ) freezeF( tinP ) ;

    grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    TINSL
{
/*1*/bufferC::operator byteT*( voidT )/*1*/

/**/
*/
 wo'ce i am called, i will not accumulate any more bytes
calling me disables *this (freezes the contents of *this)
   the length is the number of bytes of data
  case: the data is a string of arbitrary bytes
   note that 1 must be subtracted from this length to get the text length (excluding the null terminator)
   the null terminator is part of the data, so is included in the length value
  case: the data is a null terminated string of osTextT
 the length prefix (immediately below the returned address) contains the length of the data bytes at the address
i evaluate to a pointer to bytes that is immediately preceeded by a countT containing its length
\<A HREF=\"5.16b0005.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

