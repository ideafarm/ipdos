
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbo ;

    grab.ungrabF( tinP ) ;

    }
        pbCursor += sizeof( countT ) + *(countT*)pbCursor ;
        pbo = pbCursor + sizeof( countT ) ;
    {
    if( pbCursor + *(countT*)pbCursor < pbEnd )
    ZE( byteT* , pbo ) ;

    if( !bFrozen ) freezeF( tinP ) ;

    grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    TINSL
{
/*1*/bufferC::operator byteT*( voidT )/*1*/

/**/
*/
 wo'ce i am called, i will not accumulate any more bytes
calling me disables *this (freezes the contents of *this)
   the length is the number of bytes of data
  case: the data is a string of arbitrary bytes
   note that 1 must be subtracted from this length to get the text length (excluding the null terminator)
   the null terminator is part of the data, so is included in the length value
  case: the data is a null terminated string of osTextT
 the length prefix (immediately below the returned address) contains the length of the data bytes at the address
i evaluate to a pointer to bytes that is immediately preceeded by a countT containing its length
\<A HREF=\"5.16b0005.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

