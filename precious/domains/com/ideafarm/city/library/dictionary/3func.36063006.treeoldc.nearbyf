
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            }
                }
                    }
                        }
                            ether.delF( tinP , *(countT**)&ppcUp ) ;
                            ether.delF( tinP , *(countT**)&ppcDown ) ;
                            pDadDadDad->pSwsKids->ungrabF( tinP ) ;
                            
                            }
                                }
                                    *(const strokeS**)&branchesP.ppsttzUpGGMoms[ off ] = psttd ;
                                    strokeS* psttd =  *(strokeS**)ppcUp[ off ] ;
                                {
                                for( countT off = 0 ; off <= branchesP.cUpGGMoms ; off ++ )
                                
                                }}
                                    *(const strokeS**)&branchesP.ppsttzDnGGMoms[ off ] = psttd ;
                                    strokeS* psttd =  *(strokeS**)ppcDown[ off ] ;
                                {
                                {for( countT off = 0 ; off <= branchesP.cDnGGMoms ; off ++ )
                            {
                            if( ppcDown )
                            
                            ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzUpGGMoms , 1 + branchesP.cUpGGMoms ) ; ___( branchesP.ppsttzUpGGMoms ) ;
                            ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzDnGGMoms , 1 + branchesP.cDnGGMoms ) ; ___( branchesP.ppsttzDnGGMoms ) ;
                            pDadDadDad->pSwsKids->grabListF( tinP , ppcDown , ppcUp , *(countT*)&branchesP.cDnGGMoms , *(countT*)&branchesP.cUpGGMoms , 1 ) ;
                            ZE( countT** , ppcUp ) ;
                            ZE( countT** , ppcDown ) ;
                        {
                        //----GGMOMS---------------------------------------------------------------------------
        
                
                        }
                            ether.delF( tinP , *(countT**)&ppcUp ) ;
                            ether.delF( tinP , *(countT**)&ppcDown ) ;
                            pDadDadDad->pSwsKids->ungrabF( tinP ) ;

                            }
                                }
                                    *(const strokeS**)&branchesP.ppsttzUpGDads[ off ] = data.psttb ;
                                    branchDataOldS& data = *(branchDataOldS*)(     (branchHeaderOldS*)ppcUp[ off ] + 1     ) ;
                                {
                                for( countT off = 0 ; off <= branchesP.cUpGDads ; off ++ )
                        
                                }}
                                    *(const strokeS**)&branchesP.ppsttzDnGDads[ off ] = data.psttb ;
                                    branchDataOldS& data = *(branchDataOldS*)(     (branchHeaderOldS*)ppcDown[ off ] + 1     ) ;
                                {
                                {for( countT off = 0 ; off <= branchesP.cDnGDads ; off ++ )
                            {
                            if( ppcDown )
                        
                            ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzUpGDads , 1 + branchesP.cUpGDads ) ; ___( branchesP.ppsttzUpGDads ) ;
                            ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzDnGDads , 1 + branchesP.cDnGDads ) ; ___( branchesP.ppsttzDnGDads ) ;
                            pDadDadDad->pSwsKids->grabListF( tinP , ppcDown , ppcUp , *(countT*)&branchesP.cDnGDads , *(countT*)&branchesP.cUpGDads ) ;
                            ZE( countT** , ppcUp ) ;
                            ZE( countT** , ppcDown ) ;
                        {
                        //----GDADS---------------------------------------------------------------------------
                
                        SET_psttLeverKids( pDadDadDad )
                        branchHeaderOldS* pDadDadDad = pCursor->pbrDad->pbrDad->pbrDad ;
                    {
                    else
                    }
                        *(const strokeS**)&branchesP.ppsttzUpGDads[ 0 ] = *(const strokeS**)&branchesP.ppsttzDnGDads[ 0 ] = data.psttb ;
                        branchDataOldS& data = *(branchDataOldS*)(     pRoot + 1     ) ;
                
                        ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzUpGDads , 1 + branchesP.cUpGDads ) ; ___( branchesP.ppsttzUpGDads ) ;
                        ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzDnGDads , 1 + branchesP.cDnGDads ) ; ___( branchesP.ppsttzDnGDads ) ;
                        *(countT*)&branchesP.cUpGDads = 0 ;
                        *(countT*)&branchesP.cDnGDads = 0 ;
                        //----GDAD---------------------------------------------------------------------------
                    {
                    if( pDadDad == pRoot )
                
                    }
                        ether.delF( tinP , *(countT**)&ppcUp ) ;
                        ether.delF( tinP , *(countT**)&ppcDown ) ;
                        pDadDad->pSwsKids->ungrabF( tinP ) ;
                        
                        }
                            }
                                *(const strokeS**)&branchesP.ppsttzUpGMoms[ off ] = psttd ;
                                strokeS* psttd =  *(strokeS**)ppcUp[ off ] ;
                            {
                            for( countT off = 0 ; off <= branchesP.cUpGMoms ; off ++ )
                            
                            }}
                                *(const strokeS**)&branchesP.ppsttzDnGMoms[ off ] = psttd ;
                                strokeS* psttd =  *(strokeS**)ppcDown[ off ] ;
                            {
                            {for( countT off = 0 ; off <= branchesP.cDnGMoms ; off ++ )
                        {
                        if( ppcDown )
                        
                        ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzUpGMoms , 1 + branchesP.cUpGMoms ) ; ___( branchesP.ppsttzUpGMoms ) ;
                        ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzDnGMoms , 1 + branchesP.cDnGMoms ) ; ___( branchesP.ppsttzDnGMoms ) ;
                        pDadDad->pSwsKids->grabListF( tinP , ppcDown , ppcUp , *(countT*)&branchesP.cDnGMoms , *(countT*)&branchesP.cUpGMoms , 1 ) ;
                        ZE( countT** , ppcUp ) ;
                        ZE( countT** , ppcDown ) ;
                    {
                    //----GMOMS---------------------------------------------------------------------------
    
                    }
                        ether.delF( tinP , *(countT**)&ppcUp ) ;
                        ether.delF( tinP , *(countT**)&ppcDown ) ;
                        pDadDad->pSwsKids->ungrabF( tinP ) ;
            
                        }
                            }
                                *(const strokeS**)&branchesP.ppsttzUpDads[ off ] = data.psttb ;
                                branchDataOldS& data = *(branchDataOldS*)(     (branchHeaderOldS*)ppcUp[ off ] + 1     ) ;
                            {
                            for( countT off = 0 ; off <= branchesP.cUpDads ; off ++ )
                    
                            }}
                                *(const strokeS**)&branchesP.ppsttzDnDads[ off ] = data.psttb ;
                                branchDataOldS& data = *(branchDataOldS*)(     (branchHeaderOldS*)ppcDown[ off ] + 1     ) ;
                            {
                            {for( countT off = 0 ; off <= branchesP.cDnDads ; off ++ )
                        {
                        if( ppcDown )
                    
                        ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzUpDads , 1 + branchesP.cUpDads ) ; ___( branchesP.ppsttzUpDads ) ;
                        ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzDnDads , 1 + branchesP.cDnDads ) ; ___( branchesP.ppsttzDnDads ) ;
                        pDadDad->pSwsKids->grabListF( tinP , ppcDown , ppcUp , *(countT*)&branchesP.cDnDads , *(countT*)&branchesP.cUpDads ) ;
                        ZE( countT** , ppcUp ) ;
                        ZE( countT** , ppcDown ) ;
                    {
                    //----DADS---------------------------------------------------------------------------
            
                    SET_psttLeverKids( pDadDad )
                    branchHeaderOldS* pDadDad = pCursor->pbrDad->pbrDad ;
                {
                else
                }
                    *(const strokeS**)&branchesP.ppsttzUpDads[ 0 ] = *(const strokeS**)&branchesP.ppsttzDnDads[ 0 ] = data.psttb ;
                    branchDataOldS& data = *(branchDataOldS*)(     pRoot + 1     ) ;
            
                    ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzUpDads , 1 + branchesP.cUpDads ) ; ___( branchesP.ppsttzUpDads ) ;
                    ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzDnDads , 1 + branchesP.cDnDads ) ; ___( branchesP.ppsttzDnDads ) ;
                    *(countT*)&branchesP.cUpDads = 0 ;
                    *(countT*)&branchesP.cDnDads = 0 ;
                    //----DAD---------------------------------------------------------------------------
                {
                if( pDad == pRoot )
                
                }
                    ether.delF( tinP , *(countT**)&ppcUp ) ;
                    ether.delF( tinP , *(countT**)&ppcDown ) ;
                    pDad->pSwsKids->ungrabF( tinP ) ;
                
                    }
                        }
                            *(const strokeS**)&branchesP.ppsttzUpMoms[ off ] = psttd ;
                            strokeS* psttd =  *(strokeS**)ppcUp[ off ] ;
                        {
                        for( countT off = 0 ; off <= branchesP.cUpMoms ; off ++ )
                    
                        }}
                            *(const strokeS**)&branchesP.ppsttzDnMoms[ off ] = psttd ;
                            strokeS* psttd =  *(strokeS**)ppcDown[ off ] ;
                        {
                        {for( countT off = 0 ; off <= branchesP.cDnMoms ; off ++ )
                    {
                    if( ppcDown )
                
                    ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzUpMoms , 1 + branchesP.cUpMoms ) ; ___( branchesP.ppsttzUpMoms ) ;
                    ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzDnMoms , 1 + branchesP.cDnMoms ) ; ___( branchesP.ppsttzDnMoms ) ;
                    pDad->pSwsKids->grabListF( tinP , ppcDown , ppcUp , *(countT*)&branchesP.cDnMoms , *(countT*)&branchesP.cUpMoms , 1 ) ;
                    ZE( countT** , ppcUp ) ;
                    ZE( countT** , ppcDown ) ;
                {
                //----MOMS---------------------------------------------------------------------------
    
                }
                    ether.delF( tinP , *(countT**)&ppcUp ) ;
                    ether.delF( tinP , *(countT**)&ppcDown ) ;
                    pDad->pSwsKids->ungrabF( tinP ) ;
                
                    }
                        }
                            *(const strokeS**)&branchesP.ppsttzUpBros[ off ] = data.psttb ;
                            branchDataOldS& data = *(branchDataOldS*)(     (branchHeaderOldS*)ppcUp[ off ] + 1     ) ;
                        {
                        for( countT off = 0 ; off <= branchesP.cUpBros ; off ++ )
                    
                        }}
                            *(const strokeS**)&branchesP.ppsttzDnBros[ off ] = data.psttb ;
                            branchDataOldS& data = *(branchDataOldS*)(     (branchHeaderOldS*)ppcDown[ off ] + 1     ) ;
                        {
                        {for( countT off = 0 ; off <= branchesP.cDnBros ; off ++ )
                    {
                    if( ppcDown )
                
                    ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzUpBros , 1 + branchesP.cUpBros ) ; ___( branchesP.ppsttzUpBros ) ;
                    ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzDnBros , 1 + branchesP.cDnBros ) ; ___( branchesP.ppsttzDnBros ) ;
                    pDad->pSwsKids->grabListF( tinP , ppcDown , ppcUp , *(countT*)&branchesP.cDnBros , *(countT*)&branchesP.cUpBros ) ;
                    ZE( countT** , ppcUp ) ;
                    ZE( countT** , ppcDown ) ;
                {
                //----BROS---------------------------------------------------------------------------
    
                SET_psttLeverKids( pDad )
                branchHeaderOldS* pDad = pCursor->pbrDad ;
            {
            else
            }
                *(const strokeS**)&branchesP.ppsttzUpBros[ 0 ] = *(const strokeS**)&branchesP.ppsttzDnBros[ 0 ] = data.psttb ;
                branchDataOldS& data = *(branchDataOldS*)(     pCursor + 1     ) ;
        
                ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzUpBros , 1 + branchesP.cUpBros ) ; ___( branchesP.ppsttzUpBros ) ;
                ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzDnBros , 1 + branchesP.cDnBros ) ; ___( branchesP.ppsttzDnBros ) ;
                *(countT*)&branchesP.cUpBros = 0 ;
                *(countT*)&branchesP.cDnBros = 0 ;
                //----ME---------------------------------------------------------------------------
            {
            if( pCursor == pRoot )
        
            }
                }
                    ether.delF( tinP , *(countT**)&ppcUp ) ;
                    ether.delF( tinP , *(countT**)&ppcDown ) ;
                    pCursor->pSwsKids->ungrabF( tinP ) ; //I RELY ON grab.grabF TO ENSURE THAT THE ZOMBIE POINTERS WILL REMAIN VALID. THIS IS WHY grab DOES NOT ALLOW RECURSION
                
                    }
                        }
                            *(const strokeS**)&branchesP.ppsttzUpWives[ off ] = psttd ;
                            strokeS* psttd =  *(strokeS**)ppcUp[ off ] ;
                        {
                        for( countT off = 0 ; off <= branchesP.cUpWives ; off ++ )
                    
                        }}
                            *(const strokeS**)&branchesP.ppsttzDnWives[ off ] = psttd ;
                            strokeS* psttd =  *(strokeS**)ppcDown[ off ] ;
                        {
                        {for( countT off = 0 ; off <= branchesP.cDnWives ; off ++ )
                    {
                    if( ppcDown )
                
                    ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzUpWives , 1 + branchesP.cUpWives ) ; ___( branchesP.ppsttzUpWives ) ;
                    ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzDnWives , 1 + branchesP.cDnWives ) ; ___( branchesP.ppsttzDnWives ) ;
                    pCursor->pSwsKids->grabListF( tinP , ppcDown , ppcUp , *(countT*)&branchesP.cDnWives , *(countT*)&branchesP.cUpWives , 1 ) ;
                    ZE( countT** , ppcUp ) ;
                    ZE( countT** , ppcDown ) ;
                {
                //----WIVES---------------------------------------------------------------------------
    
                }
                    ether.delF( tinP , *(countT**)&ppcUp ) ;
                    ether.delF( tinP , *(countT**)&ppcDown ) ;
                    pCursor->pSwsKids->ungrabF( tinP ) ;
        
                    }
                        }
                            *(const strokeS**)&branchesP.ppsttzUpKids[ off ] = data.psttb ;
                            branchDataOldS& data = *(branchDataOldS*)(     (branchHeaderOldS*)ppcUp[ off ] + 1     ) ;
                        {
                        for( countT off = 0 ; off <= branchesP.cUpKids ; off ++ )
            
                        }}
                            *(const strokeS**)&branchesP.ppsttzDnKids[ off ] = data.psttb ;
                            branchDataOldS& data = *(branchDataOldS*)(     (branchHeaderOldS*)ppcDown[ off ] + 1     ) ;
                        {
                        {for( countT off = 0 ; off <= branchesP.cDnKids ; off ++ )
                    {
                    if( ppcDown )
            
                    ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzUpKids , 1 + branchesP.cUpKids ) ; ___( branchesP.ppsttzUpKids ) ;
                    ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzDnKids , 1 + branchesP.cDnKids ) ; ___( branchesP.ppsttzDnKids ) ;
                    pCursor->pSwsKids->grabListF( tinP , ppcDown , ppcUp , *(countT*)&branchesP.cDnKids , *(countT*)&branchesP.cUpKids ) ;
                    ZE( countT** , ppcUp ) ;
                    ZE( countT** , ppcDown ) ;
                {
                //----KIDS---------------------------------------------------------------------------
    
                SET_psttLeverKids( pCursor )
    
                }
                    ether.delF( tinP , *(countT**)&ppcUp0 ) ;
                    ether.delF( tinP , *(countT**)&ppcDown0 ) ;
                    pCursor->pSwsKids->ungrabF( tinP ) ;
        
                    }
                        }
                            ether.delF( tinP , *(countT**)&ppcUp ) ;
                            ether.delF( tinP , *(countT**)&ppcDown ) ;
                            pKid->pSwsKids->ungrabF( tinP ) ;

                            }
                                }
                                    *(const strokeS**)&branchesP.ppsttzUpGKids[ off ] = data.psttb ;
                                    branchDataOldS& data = *(branchDataOldS*)(     (branchHeaderOldS*)ppcUp[ off ] + 1 ) ;
                                {
                                for( countT off = 0 ; off <= branchesP.cUpGKids ; off ++ )
                    
                                }}
                                    *(const strokeS**)&branchesP.ppsttzDnGKids[ off ] = data.psttb ;
                                    branchDataOldS& data = *(branchDataOldS*)(     (branchHeaderOldS*)ppcDown[ off ] + 1 ) ;
                                {
                                {for( countT off = 0 ; off <= branchesP.cDnGKids ; off ++ )
                            {
                            if( ppcDown )
                    
                            ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzUpGKids , 1 + branchesP.cUpGKids ) ; ___( branchesP.ppsttzUpGKids ) ;
                            ether.newF( tinP , LF , *(countT**)&branchesP.ppsttzDnGKids , 1 + branchesP.cDnGKids ) ; ___( branchesP.ppsttzDnGKids ) ;
                            pKid->pSwsKids->grabListF( tinP , ppcDown , ppcUp , *(countT*)&branchesP.cDnGKids , *(countT*)&branchesP.cUpGKids ) ;
                            ZE( countT** , ppcUp ) ;
                            ZE( countT** , ppcDown ) ;
        
                            SET_psttLeverKids( pKid )
                        {
                        if( pKid->pSwsKids )
                        branchHeaderOldS* pKid = (branchHeaderOldS*)ppcDown0[ 0 ] ;
                    {
                    if( ppcDown0 )
    
                    pCursor->pSwsKids->grabListF( tinP , ppcDown0 , ppcUp0 , cDnKids0 , cUpKids0 ) ;
                    countT   cUpKids0 = - 1 ;
                    countT   cDnKids0 = - 1 ; //U::USE THE FIELDS IN branchesP
                    ZE( countT** , ppcUp0 ) ;
                    ZE( countT** , ppcDown0 ) ;
                {
                //----GKIDS---------------------------------------------------------------------------
    
                SET_psttLeverKids( pCursor )
            {
            if( pCursor->pSwsKids )
        {
        if( pCursor )
        PcURSOR
    
        branchesP.pTree = this ;
    {
    if( !branchesP.pTree )

    *sw_pCursor.pLeverLathRefF( tinP ) = cLeverCursor ;
    grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
/*1*/voidT treeOldC::nearbyF( tinS& tinP , branchesOldS& branchesP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

