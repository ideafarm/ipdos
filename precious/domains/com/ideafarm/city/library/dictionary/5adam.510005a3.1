
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    etThread.delF( tinP , pbChunk ) ;
    DEL( pInfo ) ;
    }
        CONoUTrAW( postb ) ;
        DEL( pso ) ;
        pso->readWoLineF( tinP , countTC() , postb , sizeof postb ) ;
        osTextT postb[ TUCK ] ;
        
        }
            cbFile -= cbChunk ;
            pso->writeF( tinP , pbChunk , cbChunk ) ;
            etThread.fileReadF( tinP , pbChunk , cbChunk , hFile ) ;
            countT cbChunk = cbFile < CBcHUNK ? cbFile : CBcHUNK ;
        {
        while( cbFile )
    
        pso->writeF( tinP , (byteT*)&cbFile , sizeof cbFile ) ;
        
        CONoUTrAW( "client connection accepted\r\n" ) ;
        sOut.acceptF( tinP , pso , countTC() , nicNameC() , countTC() ) ; ___( pso ) ;
        ZE( socketC* , pso ) ;
        sOut.listenF( tinP ) ;
        etThread.strokeF( tinP , T("listening on port ")+TF2(idPort,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
        countT idPort = sOut.bindF( tinP , 81 ) ;
        socketC sOut( tinP , etThread , TAG( TAGiDnULL ) ) ;
    
        countT cbFile = pInfo->cbUsed ;
    {
    if( pInfo && pbChunk )
    etThread.newF( tinP , LF , pbChunk , CBcHUNK ) ; ___( pbChunk ) ;
    ZE( byteT* , pbChunk ) ;
    etThread.diskFileQueryF( tinP , pInfo , hFile ) ; ___( pInfo ) ;
    ZE( infoFileS* , pInfo ) ;
    etThread.fileOpenF( tinP , hFile , countTC() , T("///d/tmp/blob.out") , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO ) ;
    handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
{
else
}
    etThread.delF( tinP , pbChunk ) ;
    DEL( pInfo ) ;
    }
        CONoUTrAW( postb ) ;
        sOut.readWoLineF( tinP , countTC() , postb , sizeof postb ) ;
        osTextT postb[ TUCK ] ;
        
        }
            cbFile -= cbChunk ;
            sOut.writeF( tinP , pbChunk , cbChunk ) ;
            etThread.fileReadF( tinP , pbChunk , cbChunk , hFile ) ;
            countT cbChunk = cbFile < CBcHUNK ? cbFile : CBcHUNK ;
        {
        while( cbFile )
    
        sOut.writeF( tinP , (byteT*)&cbFile , sizeof cbFile ) ;
        CONoUTrAW( "connected\r\n" ) ;
        sOut.connectF( tinP , 81 , socketC::nicNameIF( tinP , etThread , T("72.167.92.180") ) ) ;
        CONoUTrAW( "connecting\r\n" ) ;
        sOut.bindF( tinP ) ;
        socketC sOut( tinP , etThread , TAG( TAGiDnULL ) ) ;
    
        countT cbFile = pInfo->cbUsed ;
    {
    if( pInfo && pbChunk )
    etThread.newF( tinP , LF , pbChunk , CBcHUNK ) ; ___( pbChunk ) ;
    ZE( byteT* , pbChunk ) ;
    etThread.diskFileQueryF( tinP , pInfo , hFile ) ; ___( pInfo ) ;
    ZE( infoFileS* , pInfo ) ;
    etThread.fileOpenF( tinP , hFile , countTC() , T("///d/tmp/blob.out") , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO ) ;
    handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
{
if( bLaptop )

const boolT bCenter = IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 == etThread.diskIdF( tinP , T("///c") ) ;
const boolT bLaptop = IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0     == etThread.diskIdF( tinP , T("///c") ) ;

TODO

#define CBcHUNK TOCK

/*1*/WAKEsHOWtEXT( "tool.blob.out" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

