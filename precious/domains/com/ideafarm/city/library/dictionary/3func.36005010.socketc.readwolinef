
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return ostEscaped ;
    //pEther->traceF( tinP , T(psttP)+T(" !!!! DONE") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ; //U:: TO FIND A BUG

    dec02AM( cFunctionsPending ) ;
    }
    
        tinP.pAdamGlobal3->_socketC_.grab.ungrabF( tinP ) ;
        pOdometer->cbWrite += tinP.odoSockCbWrite - _odoSockCbWriteOpen ;
        pOdometer->cbRead  += tinP.odoSockCbRead  - _odoSockCbReadOpen  ;
        pOdometer = (sockOdometerS*)&(countT&)*tinP.pAdamGlobal3->_socketC_.pSwOdometer ;
        tinP.pAdamGlobal3->_socketC_.nnLever = nnPeer ;
        tinP.pAdamGlobal3->_socketC_.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        bRead.ungrabF( tinP ) ;
    
        if( idleTimeAllowedRead ) FRESHtIMEaTOMIC( *pEther , timeLathRead.time1 , timeLathRead.time2 )
    
        if( !ostEscaped && !psttP ) { pEther->strMakeF( tinP , psttP , T("") ) ; ___( psttP ) ; }
        }
            }
                //pEther->traceF( tinP , T(psttP) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ; //U:: TO FIND A BUG
                pEther->strFuseF( tinP , psttP , psttIn , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ csttEstimateP ) ; ___( psttP ) ;
                psttIn[ CSpREFIX ] = bIn ;
            {
            else
            }
                break ;
                }
                    readF( tinP , &bIn , 1 ) ;
                {
                if( bIn == '\n' )
                peekF( tinP , &bIn , 1 ) ;
            {
            else if( bIn == '\r' )
            if( bIn == '\n' ) break ;
            //pEther->traceF( tinP , T("readWoLineF / 0") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ; //U:: TO FIND A BUG
    
            }
                if( ostEscaped ) break ;
    
                }
                    }
                        break ;
                        ostEscaped = postEscapeP[ offi - 1 ] ;
                    {
                    if( bIn == postEscapeP[ offi ++ ] )
                {
                while( postEscapeP[ offi ] )
                ZE( countT , offi ) ;
                bLookForEscape = 0 ;
            {
            if( bLookForEscape )

            }
                if( tinP.pcUtility[ 0 ] ) pEther->traceF( tinP , T("readWoLineF / 1") , flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_7 ) ;
                bWoth = 0 ;
            {
            if( bWoth )
    
            if( bWoth && tinP.pcUtility[ 0 ] ) tinP.pcUtility[ 1 ] -- ; //U:: TO FIND A BUG
            readF( tinP , &bIn , 1 ) ;
            if( bWoth && tinP.pcUtility[ 0 ] ) tinP.pcUtility[ 1 ] ++ ; //U:: TO FIND A BUG
    
            if( !psttP[ 2 ].idAdam ) break ; //csttExtra (see s*.GETpREFIX)
            if( bWoth && tinP.pcUtility[ 0 ] ) pEther->traceF( tinP , T("readWoLineF / 2") , flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_7 ) ;
        {
        if( psttP ) while( !*pEther )
        boolT bWoth = 1 ; //U:: TO FIND A BUG
        if( tinP.pcUtility[ 0 ] ) pEther->traceF( tinP , T("readWoLineF / 3") , flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_7 ) ;
        pEther->strMakeF( tinP , psttP , 0 , csttEstimateP ) ; ___( psttP ) ;
        if( tinP.pcUtility[ 0 ] ) pEther->traceF( tinP , T("readWoLineF / 4") , flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_7 ) ;
        boolT bLookForEscape = !!postEscapeP ;
        psttIn[ CSpREFIX ] = 0 ;
        SETpREFIX( psttIn , 1 , 0 ) ;
        strokeS psttIn[ CSpREFIX + 1 ] ;
        ZE( byteT , bIn ) ;
        _IO_
        if( tinP.pcUtility[ 0 ] ) pEther->traceF( tinP , T("readWoLineF / 5") , flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_7 ) ;
        bRead.grabF( tinP , TAG( TAGiDnULL ) ) ;
        if( tinP.pcUtility[ 0 ] ) pEther->traceF( tinP , T("readWoLineF / 6") , flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_7 ) ;
    
        const countT _odoSockCbWriteOpen = tinP.odoSockCbWrite ;
        const countT _odoSockCbReadOpen  = tinP.odoSockCbRead  ;
    
        }
            }
                return 0 ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
            __Z( csttEstimateP ) ;

            }
                return 0 ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL        
        SCOOPP
    {
    ZE( osTextT , ostEscaped ) ;
    inc02AM( cFunctionsPending ) ;
    if( tinP.pcUtility[ 0 ] ) pEther->traceF( tinP , T("readWoLineF / 7") , flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_7 ) ;
{
/*1*/osTextT socketC::readWoLineF( tinS& tinP , strokeS*& psttP , const countT csttEstimateP , const osTextT* const postEscapeP )/*1*/

//U::NOTE I ALLREADY HAVE THE OTHER OVERLOAD
//U::REWRITE TO ELIMINATE csttEstimateP

/**/
*/
  if match then i return the id of the osTextT match immediately and do not set psttP
  if not 0 then must be a null terminated string
  may be 0
 postEscapeP
  if the actual line input is longer than this, a bad coding style error will be generated
  must not be 0
 csttEstimateP
 psttP
arguments
this function is inefficient, so should not be used to read "long" lines
 the delimiting "\r\n" is excluded from the returned string
   this forgiving behavior was inserted after seeing that some html at search.excite.com contained orphan "\r"s
  this allows each line to be delimited by ether "\r\n" or "\r"
  if "\r" is not followed by an "\n", an implicit "\n" is used
 a line is delimited by "\r\n" or "\r" or "\n"
gets one line from the peer socket
  \<A HREF=\"5.c420104.1.1.0.html\"\>c420104:  WAKEsHOW( "example.simplest.func.1070011.socketC.readWoLineF" )\</A\>
 simplest
examples
\<A HREF=\"5.1070011.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$readWoLineF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

