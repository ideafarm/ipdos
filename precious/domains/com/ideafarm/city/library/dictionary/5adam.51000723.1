
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

etThread.diskWalkF( tinP , cDirs , cFiles , T( "///d/archive" /*".dut.20180404@1426.page.titles.and.page.keywords"*/ "/") , bQuit , diskWalkFooCBF , (countT*)pcArg , 0 , 0 ) ;
ZE( boolT , bQuit ) ;
ZE( countT , cFiles ) ;
ZE( countT , cDirs ) ;

countT pcArg[] = { (countT)&tPathLath , (countT)&tDateLath , (countT)&stKeywords , (countT)&tn , (countT)&tSlash , (countT)&tDot , (countT)&tMetaDotCurrentname , (countT)&tAlphaLower , (countT)&tPathOut } ;
TN( tPathOut    , "///d/poured.from.cloud/to.archive/" ) ;
TN( tAlphaLower , "abcdefghijklmnopqrstuvwxyz" ) ;
TN( tMetaDotCurrentname , "meta.currentname" ) ;
TN( tDot , "." ) ;
TN( tSlash , "/" ) ;
TN( tn , "" ) ;
TN( tDateLath , "" ) ;
TN( tPathLath , "" ) ;
stackC stKeywords( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS , ifcIDgRABlAYER_7BASEmISC1 , 0 , 0 , 0 , 0 , 0 ) ;

TODO


}
    return bDoIt ;

    }
        PUSE( tinP , *(byteT**)&psttShort ) ;
        PUSE( tinP , *(byteT**)&psttPath ) ;
        PUSE( tinP , *(byteT**)&psttDate ) ;
        PUSE( tinP , *(byteT**)&psttMetaType ) ;
        PUSE( tinP , *(byteT**)&psttNU ) ;

        }
            PUSE( tinP , *(byteT**)&psttCurrentName ) ;
            PUSE( tinP , *(byteT**)&pstt1Words ) ;

            }
                }
                    if( !ids ) PUSE( tinP , *(byteT**)&psttWord ) ;
                    stKeywordsP.sinkF( tinP , ids , psttWord , flSTACKsINK_UNIQUE , 0 , 0 ) ;
                    ZE( countT , ids ) ;

                    tinP.pEther->strMakeF( tinP , psttWord , psttc1 ) ; ___( psttWord ) ;
                    ZE( strokeS* , psttWord ) ;
                {
                )
                    && tinP.pEther->strCompareF( tinP , psttc1 , T("private"                     ) )                                      // THESE WORDS ARE SUPPRESSED
                    && tinP.pEther->strCompareF( tinP , psttc1 , T("for"                         ) )                                      // THESE WORDS ARE SUPPRESSED
                       tinP.pEther->strCompareF( tinP , psttc1 , T("confidential"                ) )                                      // THESE WORDS ARE SUPPRESSED
                (
                if

                //etherC::etRockIF( tinP ).traceF( tinP , T("keyword [psttc1]: ")+T(psttc1) ) ;
            {
            FORsTRINGSiN1( pstt1Words )

            tinP.pEther->strWordsF( tinP , pstt1Words , tUse2 , sttq , tAlphaLowerP , flSTRwORDS_DELIMITERS | flSTRwORDS_ONLYdELIMITERS , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1Words ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1Words ) ;

            //etherC::etRockIF( tinP ).traceF( tinP , T("[tUse]: ")+tUse2 ) ;

            PUSE( tinP , *(byteT**)&psttPrefix2 ) ;
            TN( tUse2 , psttPrefix2 ? psttPrefix2 : (strokeS*)tUse ) ;
            PUSE( tinP , *(byteT**)&psttSuffix2 ) ;
            tinP.pEther->strBisectF( tinP , psttPrefix2 , psttSuffix2 , tUse , tDotP , -1 , flSTRbISECT_null , 0 ) ;  ___( psttPrefix2 ) ; ___( psttSuffix2 ) ;
            ZE( strokeS* , psttSuffix2 ) ;
            ZE( strokeS* , psttPrefix2 ) ;

            PUSE( tinP , *(byteT**)&psttSuffix ) ;
            TN( tUse , psttSuffix ? psttSuffix : psttCurrentName ) ;
            PUSE( tinP , *(byteT**)&psttPrefix ) ;
            tinP.pEther->strBisectF( tinP , psttPrefix , psttSuffix , psttCurrentName , T(".!.") , -1 , flSTRbISECT_null , 0 ) ;  ___( psttPrefix ) ; ___( psttSuffix ) ;
            ZE( strokeS* , psttSuffix ) ;
            ZE( strokeS* , psttPrefix ) ;

            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.e."  ) , T(".equipment."                 ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.p."  ) , T(".police."                    ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;

            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.5."  ) , T(".unknownaudiocode.5."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.i."  ) , T(".unknownaudiocode.i."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.n."  ) , T(".unknownaudiocode.n."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.s."  ) , T(".unknownaudiocode.s."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.w."  ) , T(".unknownaudiocode.w."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.y."  ) , T(".unknownaudiocode.y."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.j."  ) , T(".unknownaudiocode.j."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.z."  ) , T(".unknownaudiocode.z."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.v."  ) , T(".unknownaudiocode.v."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.l."  ) , T(".unknownaudiocode.l."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.c."  ) , T(".unknownaudiocode.c."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.t."  ) , T(".unknownaudiocode.t."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.d."  ) , T(".unknownaudiocode.d."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.a."  ) , T(".unknownaudiocode.a."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.q."  ) , T(".unknownaudiocode.q."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.m."  ) , T(".unknownaudiocode.m."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.o."  ) , T(".unknownaudiocode.o."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.x."  ) , T(".unknownaudiocode.x."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.f."  ) , T(".unknownaudiocode.f."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.h."  ) , T(".unknownaudiocode.h."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.p.r.") , T(".unknownaudiocode.p.r."      ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.p.c.") , T(".unknownaudiocode.p.c."      ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.p.j.") , T(".unknownaudiocode.p.j."      ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;

            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.p.i.") , T(".police.investigation."      ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;
            tinP.pEther->strReplaceF( tinP , psttCurrentName , 0 , T(".!.audio.p.e.") , T(".police.enforcement."        ) , 0 , flSTRrEPLACE_null ) ; ___( psttCurrentName ) ;

            tinP.pEther->strConvertToLowerCaseF( tinP , psttCurrentName ) ;

            PUSE( tinP , posti ) ;
            tinP.pEther->strMakeFromOsTextF( tinP , psttCurrentName , posti ) ; ___( psttCurrentName ) ;
            ZE( strokeS* , psttCurrentName ) ;

            tinP.pEther->boxGetShadowF( tinP , posti , costi , tName ) ; ___( posti ) ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;
        {
        if( !tinP.pEther->strCompareF( tinP , psttMetaType , tMetaDotCurrentnameP ) )

        //etherC::etRockIF( tinP ).traceF( tinP , T("[psttMetaType]: ")+T(psttMetaType) ) ;
        tinP.pEther->strBisectF( tinP , psttNU , psttMetaType , psttShort , tDotP , -2 , flSTRbISECT_APPENDdELIMITER , 0 ) ;  ___( psttNU ) ; ___( psttMetaType ) ;
        ZE( strokeS* , psttMetaType ) ;
        ZE( strokeS* , psttNU ) ;

        }
            tDateLathP = T(psttDate) ;
            FLUSHkEYWORDS
            //etherC::etRockIF( tinP ).traceF( tinP , T("date has changed [tDateLathP]: ")+tDateLathP ) ;
        {
        if( tinP.pEther->strCompareF( tinP , psttDate , tDateLathP ) )

        //etherC::etRockIF( tinP ).traceF( tinP , T("[psttDate]: ")+T(psttDate) ) ;
        tinP.pEther->strSubstringF( tinP , psttDate , idf , idl , psttShort , 0 ) ; ___( psttDate ) ;
        ZE( strokeS* , psttDate ) ;
        countT idl = 0x28 ;
        countT idf = 0x21 ;

        etherC::etRockIF( tinP ).traceF( tinP , T("[psttShort]: ")+T(psttShort) ) ;

        tPathLathP = T(psttPath) ;
        tinP.pEther->strBisectF( tinP , psttPath , psttShort , tName , tSlashP , -1 , flSTRbISECT_APPENDdELIMITER , 0 ) ;  ___( psttPath ) ; ___( psttShort ) ;
        ZE( strokeS* , psttShort ) ;
        ZE( strokeS* , psttPath ) ;

        TN( tName , ifName ) ;
        ifFileNameC ifName( tinP , *tinP.pEther , postNameP ) ;
    {
    else if( postNameP[ thirdC::c_strlenIF( tinP , postNameP ) - 1 ] != '\\' && tinP.pEther ) // IF NOT A DIRECTORY
    }
        tDateLathP = tnP ;
        FLUSHkEYWORDS
        //etherC::etRockIF( tinP ).traceF( tinP , T("end of file list [tDateLathP]: ")+tDateLathP ) ;
    {
    if( !postNameP )

    ZE( boolT , bDoIt ) ;

    textC&  tPathOutP            =  *(textC*)pcArgP[ 8 ] ;
    textC&  tAlphaLowerP         =  *(textC*)pcArgP[ 7 ] ;
    textC&  tMetaDotCurrentnameP =  *(textC*)pcArgP[ 6 ] ;
    textC&  tDotP                =  *(textC*)pcArgP[ 5 ] ;
    textC&  tSlashP              =  *(textC*)pcArgP[ 4 ] ;
    textC&  tnP                  =  *(textC*)pcArgP[ 3 ] ;
    stackC& stKeywordsP          = *(stackC*)pcArgP[ 2 ] ;
    textC&  tDateLathP           =  *(textC*)pcArgP[ 1 ] ;
    textC&  tPathLathP           =  *(textC*)pcArgP[ 0 ] ;

    _IO_
{
/*1*/boolT diskWalkFooCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloFilesP , const countT* const pModuloDirsP )/*1*/

    }
        PUSE( tinP , *(byteT**)&psttAllWords ) ;                                                                                                          \
                                                                                                                                                            \
        tinP.pEther->boxPutF( tinP , tPathOutP+T("!ideafarm.8.2.00000000.00000001.")+tDateLathP+T("@0000.!.control.page.keywords") , posto , costo ) ;      \
        countT   costo = tAllWords.csF( tinP ) ;                                                                                                            \
        osTextT* posto = tAllWords ;                                                                                                                        \
                                                                                                                                                            \
        /*etherC::etRockIF( tinP ).traceF( tinP , T("[tDateLathP,psttAllWords]:    ")+tDateLathP+T("    ")+tAllWords ) ;*/                                              \
        TN( tAllWords , psttAllWords ) ;                                                                                                                    \
                                                                                                                                                            \
        }                                                                                                                                                   \
            PUSE( tinP , *(byteT**)&psttWord ) ;                                                                                                          \
                                       tinP.pEther->strFuseF( tinP , psttAllWords , psttWord ) ;                                                            \
            if( psttAllWords->idAdam ) tinP.pEther->strFuseF( tinP , psttAllWords , T(" ") ) ;                                                              \
            stKeywordsP >> psttWord ;                                                                                                                       \
            ZE( strokeS* , psttWord ) ;                                                                                                                     \
        {                                                                                                                                                   \
        while( stKeywordsP )                                                                                                                                \
                                                                                                                                                            \
        tinP.pEther->strMakeF( tinP , psttAllWords , 0 , csttNeeded ) ; ___( psttAllWords ) ;                                                               \
        ZE( strokeS* , psttAllWords ) ;                                                                                                                     \
                                                                                                                                                            \
        while( !stKeywordsP.third && ~hWalk ) ;                                                                                                             \
        }                                                                                                                                                   \
            csttNeeded += !!csttNeeded + psttzWord->idAdam ;                                                                                                \
            strokeS* psttzWord = (strokeS*)stKeywordsP.downF( tinP , hWalk ) ;                                                                              \
        {                                                                                                                                                   \
        do                                                                                                                                                  \
        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;                                                                              \
        ZE( countT , csttNeeded ) ;                                                                                                                         \
    {                                                                                                                                                       \
    if( stKeywordsP )                                                                                                                                       \
                                                                                                                                                            \
#define FLUSHkEYWORDS                                                                                                                                       \

// !ideafarm.8.2.00000000.00000001.20070516@0000.!.control.page.keywords
// !ideafarm.8.2.00000000.00000001.20070516@0000.!.control.page.title
// !ideafarm.8.2.00000000.00000001.20070516@1424.20170130@2150.001.e50a9768ca59fcdb1b1998e21bc87200.00000001.data.jpg
// !ideafarm.8.2.00000000.00000001.20070516@1424.20170130@2150.001.e50a9768ca59fcdb1b1998e21bc87200.00000001.meta.currentname
// !ideafarm.8.2.00000000.00000001.20070516@1424.20170130@2150.001.e50a9768ca59fcdb1b1998e21bc87200.00000001.meta.hashedname
// !ideafarm.8.2.00000000.00000001.20070516@1424.20170130@2150.001.e50a9768ca59fcdb1b1998e21bc87200.00000001.meta.raw.jpg
// !ideafarm.8.2.00000000.00000001.20070516@1424.20170130@2150.001.e50a9768ca59fcdb1b1998e21bc87200.00000001.meta.thumb.0600x.jpg
// !ideafarm.8.2.00000000.00000001.20070517@0000.!.control.page.keywords
// !ideafarm.8.2.00000000.00000001.20070517@0000.!.control.page.title
// !ideafarm.8.2.00000000.00000001.20070517@1424.20170130@2150.001.e50a9768ca59fcdb1b1998e21bc87200.00000001.data.jpg
// !ideafarm.8.2.00000000.00000001.20070517@1424.20170130@2150.001.e50a9768ca59fcdb1b1998e21bc87200.00000001.meta.currentname
// !ideafarm.8.2.00000000.00000001.20070517@1424.20170130@2150.001.e50a9768ca59fcdb1b1998e21bc87200.00000001.meta.hashedname
// !ideafarm.8.2.00000000.00000001.20070517@1424.20170130@2150.001.e50a9768ca59fcdb1b1998e21bc87200.00000001.meta.raw.jpg
// !ideafarm.8.2.00000000.00000001.20070517@1424.20170130@2150.001.e50a9768ca59fcdb1b1998e21bc87200.00000001.meta.thumb.0600x.jpg
//
// 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
// 0              1               2               3               4               5               6               7               8
//                                 |      |
//                                 0x21   0x28



/*1*/WAKEsHOWtEXT( "tool.archive.refresh.control.keywords" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
