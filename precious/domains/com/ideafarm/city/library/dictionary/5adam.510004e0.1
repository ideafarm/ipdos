
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        etThread.delF( tinP , pc2pbcb ) ;
        etThread.delF( tinP , *(byteT**)&pc2pbcb->c1 ) ;
    {
    if( pc2pbcb )
    count2S*& pc2pbcb = *(count2S**)&(countT&)swImage ;
    psttLever = (strokeS*)swImage.leverF( tinP , idf ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
countT cFlavors = swImage.cFlavorsF( tinP ) ;

}
    while( cDone < idClient ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
    ZE( countT , ecz ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{

}
    *tinP.zEtScratch = 0 ;
    }
        }
            else           { ZE( countT , tnu ) ; tinP.zEtScratch->osThreadF( tinP , tnu , tmFtpServeF , 0 , flTHREADlAUNCH_null , 0 , (countT)pso , ++ idClient , (countT)&cDone , (countT)&psttLever , (countT)&swImage ) ; }
            if( *tinP.zEtScratch ) { DEL( pso ) ; }
            socket.acceptF( tinP , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            ZE( socketC* , pso ) ;
        {
        while( !cQuit && !*tinP.zEtScratch )

        socket.listenF( tinP ) ;
        __( socket.bindF( tinP , ifcPORToLD2_IFCfTP ) - ifcPORToLD2_IFCfTP ) ;
        socketC socket( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) ) ;
    {
    while( !cQuit && !*tinP.zEtScratch )
{
while( !cQuit )
ZE( countT , cDone ) ;
ZE( countT , idClient ) ;
const countT& cQuit = ether ;
ZE( const countT , cQuitNU ) ;
switchC swImage( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttLever ) ;
ZE( strokeS* , psttLever ) ;

TODO

DONE( tmFtpServeF )

}
    cDone ++ ;

    DEL( pso ) ;
    }
        etThread = 0 ;
        TELL( "cleaning up" )
        }
            ++ s ; etThread.osSleepF( tinP , TUCK * 0x80 ) ; //AS COURTESY
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        //pso->readF( tinP , &bIn , 1 ) ;
        TELL( "cleaning up: waiting for client to write a byteT so that it can disconnect" )
        ZE( byteT , bIn ) ;
    {
    if( !etThread )

    pso->writeF( tinP , sOut ) ;
    sOut.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_byteTptr , pbi , cbi ) ;
    sOut << cbRemaining ;
    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;

    }
        if( !cbi ) pbi = 0 ;
        }
            cbi = cbw ;
            cbRemaining = cbi - cbw ;
        {
        if( cbi > cbw )
        cbi = offw < cbi ? cbi - offw : 0 ;
        pbi = offw < cbi ? pbi + offw : 0 ;
        pbcbF( tinP , etThread , pbi , cbi , tName , psttLever , swImage ) ;
    {
    ZE( countT , cbRemaining ) ;
    ZE( countT , cbi ) ;
    ZE( byteT* , pbi ) ;

    }
        tinP.zEtScratch->delF( tinP , psttw ) ;
        tName = T(psttw) ;
        sIn >> cbw ; // CAN BE 0 (CLIENT WOULD DO THIS TO QUERY FOR FILE SIZE)
        sIn >> offw ;
        sIn >> psttw ;
        ZE( strokeS* , psttw ) ;
        pso->readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    {
    TN( tName , "" ) ;
    ZE( countT , cbw ) ;
    ZE( countT , offw ) ; // "w": "wanted"

    pso->etherF( tinP , *tinP.zEtScratch ) ;

    switchC&  swImage   =  *(switchC*)pTaskP->c5 ;
    strokeS*& psttLever = *(strokeS**)pTaskP->c4 ;
    countT&   cDone     =   *(countT*)pTaskP->c3 ;
    countT    idClient  =             pTaskP->c2 ;
    socketC*  pso       =   (socketC*)pTaskP->c1 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmFtpServeF )

}
    __Z( pbP ) ;
    swImageP.ungrabF( tinP ) ;
    }
        cbP =         pc2pbcb->c2 ;
        pbP = (byteT*)pc2pbcb->c1 ;
    {
    if( pc2pbcb )
    __Z( pc2pbcb ) ;

    }
        }
            *tinP.zEtScratch = 0 ;
            DEL( pInfo ) ;
            }
                ((byteT*)pc2pbcb->c1)[ cba ] = 0 ;
                tinP.zEtScratch->fileReadF( tinP , (byteT*)pc2pbcb->c1 , cba , handle ) ;
                countT cba = pc2pbcb->c2 ;
                etThread.newF( tinP , LF , *(byteT**)&pc2pbcb->c1 , pc2pbcb->c2 + 1 ) ; ___( pbP ) ;
                pc2pbcb->c2 = pInfo->cbUsed ;
            {
            if( pInfo )
            tinP.zEtScratch->diskFileQueryF( tinP , pInfo , handle ) ; ___( pInfo ) ;
            tinP.zEtScratch->fileOpenF( tinP , handle , idr , T(psttNameP) , ifcOPENaCCESS_R , ifcOPENsHARE_WR , flOPENdETAILS_FAIL , ifcOPENhOW_nFeO , flFILEaTTR_null , 0 , 1 ) ;
            ZE( infoFileS* , pInfo ) ;
            ZE( countT , idr ) ;
            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            *tinP.zEtScratch = 0 ;
        {
        if( pc2pbcb )
        etThread.newF( tinP , LF , pc2pbcb ) ; ___( pc2pbcb ) ;
    {
    if( !pc2pbcb )
    count2S*& pc2pbcb = *(count2S**)&(countT&)swImageP ;
    psttLeverP = psttNameP ;
    swImageP.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT pbcbF( tinS& tinP , etherC& etThread , byteT*& pbP , countT& cbP , strokeS* psttNameP , strokeS*& psttLeverP , switchC& swImageP )

/*1*/WAKEhIDE( "tool.server.blob" )/*1*/
/**/
*/
 keep a file cache permanently in memory, using a switch
int specs
  pb
  cb
 outgoing soul
  cbWanted
  offset to begin
  blob name
 incoming soul
protocol
i serve blobs
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

