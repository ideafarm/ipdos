
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cFound ;

    if( !bStringOfStrings ) delF( tinP , pstt1u ) ;

    }
        }
            delF( tinP , psttnu ) ;
            cFound = diskFindFileOrDirF( tinP , psttnu , fnLike.pathF() , &pat ) ; ___( psttnu ) ;
            ZE( strokeS* , psttnu ) ;
            
            patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
            fileNameC fnLike( tinP , *this , psttc1 ) ;
        {
        else
        }
            }
                else cFound = 1 ;
                }
                    if( fileTest.idOpenResultF( tinP ) == ifcOPENrESULT_ERRORsHARINGvIOLATION ) cFound = 1 ;
                    POOPRqUIET
                {
                if( POOP )

                THREADmODE1rESTORE
                fileC fileTest( tinP , psttc1 , ifcOPENaCCESS_R , ifcOPENsHARE_WR , flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_BUMPkEY | flOPENdETAILS_DOnOTmAKEdIRiFnEEDED , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 ) ;
                THREADmODE1oN( flTHREADmODE1_QUIETiMPOTENCE ) ;

                SCOOPS
            {
            IFsCRATCH
        {
        )
            !strIdF( tinP , S1C( '?' ) , psttc1 )
            &&
            !strIdF( tinP , S1C( '*' ) , psttc1 )
        (
        if
    {
    FORsTRINGSiN1( pstt1u )

    else                    pstt1u = (strokeS*)psttLikeP ;
    if( !bStringOfStrings ) { strFuseSeparateF( tinP , pstt1u , psttLikeP ) ; ___( pstt1u ) ; }
    ZE( strokeS* , pstt1u ) ;
    boolT bStringOfStrings = ISsTRINGoFsTRINGS( psttLikeP ) ;

    ZE( countT , cFound ) ;

    _IO_

    }
        if( POOP ) return 0 ;
        __Z( psttLikeP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/**//*1*/countT etherC::diskFileExistsF( tinS& tinP , const strokeS* const psttLikeP )/*1*/
*/
  the result is as if the caller called me repeatedly and accumulated my return value
   for example, wildcards and paths may differ
  the strings need not bear any relationship to each other
  will accumulate over all strings specified
 may also be a string of strings
  example: T("///ideafarm/ephemeral/tmp/10300cc.one.file")
  example: T("///ideafarm/ephemeral/tmp/10300cc.???")
  example: T("///ideafarm/ephemeral/tmp/10300cc*")
  pattern of the names of the files to find
 psttLikeP
arguments
evaluates to the number of files found
  \<A HREF=\"5.5410104.1.1.0.html\"\>5410104:  WAKEsHOW( "example.simplest.func.10300cc.etherc.diskFileExistsF" )\</A\>
 simplest
examples
\<A HREF=\"5.10300cc.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$diskFileExistsF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

