
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbo ;
    _OUT_

    inc02AM( pcTallyOut[ offs ] ) ;

    __Z( pbo ) ;
    byteT* pbo = !ppSex[ offs ] ? 0 : (*ppSex[ offs ])[ offP >> CbITSeXPsLOTS ] ; //A:ASSUME: countT IS 02 BITS

    __( !ppSex[ offs ] ) ;

    }
        pGrabNewElt[ offs ].ungrabF( tinP ) ;
        }
            ppSex[ offs ] = pSexNew ;

                                           pPoolContainsMe->pSexLifoConstructed = pSexNew ;
            pSexNew->pSexLifoConstructed = pPoolContainsMe->pSexLifoConstructed           ;

            //CONoUTrAW( ostoSay ) ;
            //}
            //    pc = pc->pSexLifoConstructed ;
            //    OStEXTC(  ostoSay , pc , 0 ) ;
            //    OStEXTAK( ostoSay , " , " ) ;
            //{
            //while( pc )
            //sexC* pc = pPoolContainsMe->pSexLifoConstructed ;
            //OStEXTC(   ostoSay , pSexNew , 0 ) ;
            //OStEXTAK(  ostoSay , "\r\n+ [pNew,list]: " ) ;
            //OStEXT(    ostoSay , TOCK << 0 ) ;

            THREADmODE1rESTORE
            sexC* pSexNew = new( 0 , tinP , pbza1 + offs * sizeof( sexC ) , sizeof( sexC ) ) sexC( tinP , TAG( TAGiDnULL ) , LF , ostoName , expCbSlot , offs , flagsc , idStateSpace , idMemorySpace , pPoolContainsMe ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            OStEXTCF( ostoName , offs , '0' ) ;
            OStEXTAK( ostoName , ".slotsC.sex." ) ;
            OStEXTA(  ostoName , postName ) ;
            OStEXT(   ostoName , TUCK )

            if( F(flagsCt) & flSLOTSc_NOTES    ) flagsc |= fliSEXc_NOTES    ;
            if( F(flagsCt) & flSLOTSc_READoNLY ) flagsc |= fliSEXc_READoNLY ;
            if( F(flagsCt) & flSLOTSc_BROWSE   ) flagsc |= fliSEXc_BROWSE   ;
            flagsT flagsc = fliSEXc_null ;
        {
        if( !ppSex[ offs ] )
        pGrabNewElt[ offs ].grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !ppSex[ offs ] )

    inc02AM( pcTallyIn[ offs ] ) ;

    countT offs = expSlotsMin + ( offP & ( 1 << CbITSeXPsLOTS ) - 1 ) ;
    if( F(tinP.flagsThreadMode2) & flTHREADmODE2_DISALLOWpUSE ) { BLAMMO ; }
    _INoLD_

    }
        if( POOP ) return 0 ;
        __NZ( offP == - 1 ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL

    TINSL
{
/*1*/byteT* slotsC::operator []( const countT offP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

