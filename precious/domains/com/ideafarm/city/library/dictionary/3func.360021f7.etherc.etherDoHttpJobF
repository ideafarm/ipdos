
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#undef PUSHrEPLY
#undef PUSHsNIP
#undef REPLY
#undef PUSHK
#undef PEEP

}
    //THREADmODE4rESTORE
    }
        //traceF( tinP , T("etherDoHttpJobF / ---- ") ) ;
        //tinP.pAdamGlobal1->pEtThreadMain->etherTestF( tinP ) ; //U:: TO FIND A BUG

        //}
        //    thirdC::osFireIF( tinP ) ;
        //    traceF( tinP , T("calling osFireIF") ) ;
        //{
        //if( bOsFire )

        TELL( "etherDoHttpJobF: cleaning up (part 2)" ) ;
        }
            //LOGrAW( tLog ) ;
            //tLog += T("\r\n") ;
            //TELL( "appending log entry to log file" ) ;
        {
        if( !bDeadman ) //VISITORS CAN CONCEAL THEIR VISIT BY ASKING FOR DEADMAN URL

        { _IO_ (*this)( tinP , pswTally ) ; }
        }
            }
                //else tLog += t2+TF2(*pswTally,flFORMAT_NObIGITvALUES)+t1+T(psttLeverUrlTally)+tcr ;
                bDeadman = 1 ;
                )
                    )
                        !strCompareF( tinP , psttLeverUrlTally , tSlashDeadman2 )
                        ||
                        !strCompareF( tinP , psttLeverUrlTally , tSlashDeadman1 )
                    (
                    &&
                    psttLeverUrlTally
                (
                if
                psttLeverUrlTally = (strokeS*)pswTally->leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = pswTally->cFlavorsF( tinP ) ;
            TN( tcr , "\r\n" ) ;
            TN( t2 , "    " ) ;
            TN( t1 , ": " ) ;
        {
        ZE( boolT , bDeadman ) ;

        ;
        //
        //    +T("\r\n")
        //    +TF2(cHamburgersThisSession,flFORMAT_NObIGITvALUES)
        //    +T(" total:")
        //    +TF2(jobP.nnPeer.pcId[0],flFORMAT_NObIGITvALUES)
        //    +T("| http 05 session peer:")
        //    TT(timeA1,timeA2)
        //
        //TN( tLog , "" ) ; tLog =
        osTimeNowF( tinP , timeA1 , timeA2 ) ;
        ZE( sCountT , timeA2 ) ;
        ZE( countT , timeA1 ) ;
        { _IO_ (*this)( tinP , pswKV ) ; }
        TELL( "etherDoHttpJobF: cleaning up (part 1)" ) ;

        }
            if( idEscaped ) (*pHttpRawCommandServerCBFP)( tinP , *this , bQuitP , cArgAppP , *psoP , time1idleTimeoutReadP , time1idleTimeoutWriteP , jobP.sessions , jobP.nnPeer , idEscaped ) ;
            TELL( "maybe calling raw command server" ) ;

            //LOGrAW( T("------------------------- E N D   O F   S E S S I O N -------------------------------------------------------\r\n") ) ;
            //CONoUTrAW( T("------------------------- E N D   O F   S E S S I O N -------------------------------------------------------\r\n") ) ;
            }
                if( bClose ) break ;

                delF( tinP , postBody    ) ;
                delF( tinP , psttAgent   ) ;
                delF( tinP , psttName    ) ;
                delF( tinP , psttQueryKV ) ;

                //else                         traceF( tinP , T("accumulated time pending [nnPeer,time]:    "        )                   +T(jobP.nnPeer)+tb4+TT(timeTotalPending1,timeTotalPending2)+T(timeTotalPending1>TOCK?"    ********":"") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                if( bDeadman1 || bDeadman2 ) traceF( tinP , T("accumulated time pending [idCycle,nnPeer,time]:    ")+T(psttQueryKV)+tb4+T(jobP.nnPeer)+tb4+TT(timeTotalPending1,timeTotalPending2)+T(timeTotalPending1>TOCK?"    ********":"") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                osTimeAddF(      tinP , timeTotalPending1 , timeTotalPending2 , timeElapsed1 , timeElapsed2 ) ;
                osTimeSubtractF( tinP , timeElapsed1 , timeElapsed2 , timeStart1 , timeStart2 ) ;
                osTimeNowF(      tinP , timeElapsed1 , timeElapsed2 ) ;
                ZE( sCountT , timeElapsed2 ) ;
                ZE( countT  , timeElapsed1 ) ;

                if( idDesireOld ) osThreadSwitchingDesireF( tinP , idDesireOld ) ;
                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 0") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                              //traceF( tinP , T("U:: etherDoHttpJobF / 0") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                }
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 1") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                  //traceF( tinP , T("U:: etherDoHttpJobF / 1") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    }
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 2") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / 2") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    nonfile response has been written") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        delF( tinP , psttKVReport ) ;
                        pswKV->freeNullsF( tinP ) ;
                        TELL( "cleaning up 5" ) ;
                        }
                            delF( tinP , psttv ) ;
                            strokeS*& psttv = *(strokeS**)&(countT&)*pswKV ;
                            psttLeverKV = (strokeS*)pswKV->leverF( tinP , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        countT cFlavors = pswKV->cFlavorsF( tinP ) ;
                        TELL( "cleaning up 4" ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 3") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / 3") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        (*this)( tinP , pStkBodyDynamic ) ;
                        (*this)( tinP , pStkBody ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 4") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / 4") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        }
                            if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 5") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                          //traceF( tinP , T("U:: etherDoHttpJobF / 5") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                            meP.swReply.ungrabF( tinP ) ;
                            ++ *pswTally ;
                            psttLeverUrlTally = psttName ;
                            meP.swReply.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            TELL( "tallying" ) ;
                            if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 6") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                          //traceF( tinP , T("U:: etherDoHttpJobF / 6") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                            else delF( tinP , postsReply ) ;
                            }
                                pzCache->purgeF( tinP , TUCK ) ; //THIS IS SUPPOSED TO RETAIN THE MOST RECENTLY PUSHED ITEMS (U:: INSPECT TRACE TO VERIFY)

                                //traceF( tinP , T("etherDoHttpJobF: cached this reply [maxAge]:    ")+TF2(maxAge,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                                pzCache->pushF( tinP , psttn , postsReply , costo , maxAge , 1 ) ; // "1": "LENGTH PREFIXED, SO NEED TO USE POSTS( pb )"
                                countT maxAge = bDeadman1 || bDeadman2 ? maxAgeDeadman : /*U:: bTalkBody ? maxAgeMsNotFileTalkBody :*/ maxAgeMsNotFileNotTalkBody ;

                                countT costo = COSTS( postsReply ) ;
                                strMakeF( tinP , LF , psttn , tNameCache ) ; ___( psttn ) ;
                                ZE( strokeS* , psttn ) ;
                            {
                            if( pzCache && !bNoCacheStore )
                            if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 7") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                          //traceF( tinP , T("U:: etherDoHttpJobF / 7") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                            }
                                }
                                    bClose = 1 ;
                                    traceF( tinP , T("etherDoHttpJobF: could not write to socket 109 [nnPeer]:    ")+T(jobP.nnPeer) , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                    POOPRqUIET
                                {
                                if( POOP )
                                psoP->writeF( tinP , POSTS( postsReply ) , COSTS( postsReply ) ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            TELL( "writing reply" ) ;
                            if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 8") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                            //traceF( tinP , T("U:: etherDoHttpJobF / 8") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                            //}
                            //    LOGrAW( "\"\r\n" ) ;
                            //    LOGrAW( POSTS( postsReply ) ) ;
                            //    LOGrAW( "postsReply:\r\n\"" ) ;
                            //{
                            //if( bDebugLog )
                            //U::

                            }
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 9") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                              //traceF( tinP , T("U:: etherDoHttpJobF / 9") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                }
                                    pStkBody->extractF( 0 , tinP , 1 ) ;
                                    DELzOMBIE( prPosts ) ;
                                    pbRefC* prPosts = (pbRefC*)&(*pStkBody)[ 1 ] ;
                                {
                                while( !POOP && *pStkBody )
                                TELL( "cleaning up 3" ) ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / a") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                              //traceF( tinP , T("U:: etherDoHttpJobF / a") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                                DEL( prPostsMugShot         ) ;
                                DEL( prPostsBarBrown        ) ;
                                DEL( prPostsBarGreen        ) ;
                                DEL( prPostsBarOrange       ) ;
                                DEL( prPostsBarGray         ) ;
                                DEL( prPostsBarMaroon2      ) ;
                                DEL( prPostsIdSession       ) ;
                                DEL( prPostsIdPort2         ) ;
                                DEL( prPostsIdPort1         ) ;
                                DEL( prPostsPort            ) ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / b") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                              //traceF( tinP , T("U:: etherDoHttpJobF / b") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                                DEL( pRefReply ) ;
                                bOsFire = F(REPLY.flagsHttpReply) & flHTTPrEPLY_OSfIRE ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / c") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                              //traceF( tinP , T("U:: etherDoHttpJobF / c") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                                DEL( prPostsCostBody ) ;
                                DEL( prPostsHttpLocation ) ;
                                }
                                    DEL( prPostsHttp ) ;
                                    }
                                        }
                                            while( !POOP && ~hWalk ) ;
                                            }
                                                memCopyF( tinP , postc , POSTS( rPosts ) , COSTS( rPosts ) ) ; postc += COSTS( rPosts ) ;
                                                pbRefC& rPosts = *(pbRefC*)&pStkBody->downF( tinP , hWalk ) ;
                                            {
                                            do
                                            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        if( *pStkBody )

                                        memCopyF( tinP , postc , "\r\n\r\n" , 4                                                                         ) ; postc += 4                                    ;

                                        if( bClose ) { memCopyF( tinP , postc , postOldConnectionClose , sizeof postOldConnectionClose - 1              ) ; postc += sizeof postOldConnectionClose - 1    ; }

                                        }
                                            }
                                                memCopyF( tinP , postc , tKV , tKV.csF( tinP ) ) ; postc += tKV.csF( tinP ) ;
                                                TN( tKV , "?" ) ; tKV += T(psttQueryKV) ;
                                            {
                                            if( bQuery )

                                            memCopyF( tinP , postc , POSTS( *prPostsHttpLocation ) , COSTS( *prPostsHttpLocation ) ) ; postc += COSTS( *prPostsHttpLocation ) ;
                                            memCopyF( tinP , postc , postLocationKey               , sizeof postLocationKey - 1    ) ; postc += sizeof postLocationKey - 1    ;
                                        {
                                        if( prPostsHttpLocation )

                                        if( prPostsCostBody ) { memCopyF( tinP , postc , POSTS( *prPostsCostBody ) , COSTS( *prPostsCostBody ) ) ; postc += COSTS( *prPostsCostBody ) ; }
                                        if( prPostsHttp     ) { memCopyF( tinP , postc , POSTS( *prPostsHttp     ) , COSTS( *prPostsHttp     ) ) ; postc += COSTS( *prPostsHttp     ) ; }
                                        *(countT*)postc = costReply ; postc += sizeof( countT ) ;
                                        osTextT* postc = postsReply ;
                                    {
                                    if( postsReply )
                                    newF( tinP , LF , postsReply , sizeof( countT ) + costReply + 1 ) ; ___( postsReply ) ;

                                    if( bClose ) costReply += sizeof postOldConnectionClose - 1 ;
                                    if( prPostsHttpLocation ) costReply += sizeof postLocationKey - 1 + COSTS( *prPostsHttpLocation ) + ( bQuery ? 1 + psttQueryKV->idAdam : 0 ) ;

                                    }
                                        strMakeFromOsTextF( tinP , psttQueryKV , "rc=" postREFERRALcHAMPIONiD ) ; ___( psttQueryKV) ;
                                        delF( tinP , psttQueryKV ) ;
                                    {
                                    if( !psttQueryKV || !psttQueryKV->idAdam )

                                    ;
                                        + costBody
                                        + 4
                                        + ( !prPostsCostBody ? 0 : COSTS( *prPostsCostBody ) )
                                          ( !prPostsHttp     ? 0 : COSTS( *prPostsHttp     ) )
                                    countT costReply =

                                    const osTextT postLocationKey[] = { "\r\nLocation: " } ;
                                    const osTextT postOldConnectionClose[] = { "\r\nConnection: close" } ;

                                    meP.getSnipF( tinP , prPostsHttp , REPLY.idSnipHttpPrefix ) ; ___( prPostsHttp ) ;
                                    ZE( pbRefC* , prPostsHttp ) ;
                                {
                                TELL( "building postsReply" ) ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / d") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                              //traceF( tinP , T("U:: etherDoHttpJobF / d") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                                }
                                    strMakeF( tinP , LF , prPostsCostBody , TF4(costBody,flFORMAT_NObASE|flFORMAT_FOREIGN,0,0xa) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsCostBody ) ;

                                    }
                                        while( !POOP && ~hWalk ) ;
                                        }
                                            costBody += COSTS( rPosts ) ;
                                            pbRefC& rPosts = *(pbRefC*)&pStkBody->downF( tinP , hWalk ) ;
                                        {
                                        do
                                        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    if( *pStkBody )
                                {                                                                           
                                ZE( countT , costBody ) ;
                                ZE( pbRefC* , prPostsCostBody ) ;
                                TELL( "getting prPostsCostBody" ) ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / e") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                              //traceF( tinP , T("U:: etherDoHttpJobF / e") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                                }
                                    PUSHK( prPostsHttpLocation ) ;
                                {
                                if( REPLY.idSnipHttpPrefix == ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP && !*pStkBody )

                                }
                                    meP.getSnipF( tinP , prPostsHttpLocation , idSnip ) ; ___( prPostsHttpLocation ) ;
                                    if( !idSnip ) idSnip =  ifcIDsNIPpREDEFINED_HTTPlOCATIONrOOT ;
                                    countT idSnip = REPLY.idSnipHttpLocation ;
                                {
                                if( REPLY.idSnipHttpPrefix == ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP )
                                ZE( pbRefC* , prPostsHttpLocation ) ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / f") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                              //traceF( tinP , T("U:: etherDoHttpJobF / f") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                                }
                                    }
                                        break ;
                                        BLAMMO ;
                                    {
                                    default :
                                    }
                                        break ;

                                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / g") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                      //traceF( tinP , T("U:: etherDoHttpJobF / g") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                        }
                                            }
                                                break ;
                                                BLAMMO ;
                                            {
                                            default :
                                            }
                                                break ;

                                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / h") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                              //traceF( tinP , T("U:: etherDoHttpJobF / h") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                                DEL( prPostsLathPeanut ) ;

                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_FOOT3        ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_FOOTaDlINKS  ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_FOOTiMAGEaDS ) ;
                                                PUSHsNIP( meP , !sessionP.getIdAccountCommissionF( tinP ) ? ifcIDsNIPpREDEFINED_FOOT1 : ifcIDsNIPpREDEFINED_FOOT2 ) ;

                                                }
                                                    pStkBodyDynamic->extractF( (byteT*)&(*pStkBody)[ - 1 ] , tinP , 1 ) ;
                                                    *pStkBody << (byteT*)0 ;
                                                {
                                                while( !POOP && *pStkBodyDynamic )
                                                PUSHrEPLY( prPostBody ) ;

                                                }
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD61         ) ;
                                                    PUSHrEPLY( prPostDescription ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD51         ) ;
                                                    PUSHrEPLY( prPostTitle ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD41         ) ;
                                                {
                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 

                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD31         ) ;

                                                //}
                                                //    ) ;
                                                //            : ifcIDsNIPpREDEFINED_HEADfDlINKSgOOGLE
                                                //            ? ifcIDsNIPpREDEFINED_HEADfDlINKSbLANK
                                                //        F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DOnOTdISPLAYtHIRDpARTYaDS
                                                //    *pStkBody << (countT)meP.getSnipF( tinP ,
                                                //{
                                                //if( bShowAdLinks )
                                                //}
                                                //    ) ;
                                                //            : ifcIDsNIPpREDEFINED_HEADiMAGEaDSgOOGLE
                                                //            ? ifcIDsNIPpREDEFINED_HEADiMAGEaDSbLANK
                                                //        F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DOnOTdISPLAYtHIRDpARTYaDS
                                                //    *pStkBody << (countT)meP.getSnipF( tinP ,
                                                //{
                                                //if( bShowImageAds )
                                                //OBSOLETE: NOT EDITED TO USE pbRefC

                                                if( idBannerAd ) PUSHsNIP( meP , ifcIDsNIPrESERVEDbANNER - 1 + idBannerAd ) ;
                                                PUSHK( prPostsBarBrown  ) ;
                                                PUSHK( prPostsBarGreen  ) ;

                                                }
                                                    if( idBannerAd == 8 ) PUSHK( prPostsBarOrange ) ;
                                                    PUSHK( prPostsBarGray   ) ;
                                                {
                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 

                                                PUSHK( prPostsBarMaroon2 ) ;
                                                }
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD21         ) ;
                                                    PUSHK( prPostsIdSession ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD11         ) ;
                                                    PUSHK( prPostsPort ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD01         ) ;
                                                    PUSHK( prPostsIdPort2 ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADf         ) ;
                                                {
                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 

                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADe         ) ;
                                                PUSHK( prPostsMugShot ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADd         ) ;

                                                }
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD91        ) ;
                                                    PUSHrEPLY( prPostDescription ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD81        ) ;
                                                    PUSHrEPLY( prPostTitle ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD71        ) ;
                                                {
                                                else
                                                }
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADc         ) ;
                                                    PUSHK( prPostsLathPeanut ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADb         ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADa         ) ;
                                                    PUSHrEPLY( prPostUrl ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD9         ) ;
                                                    PUSHK( prPostsIdPort1 ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD8         ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD7         ) ;
                                                    PUSHrEPLY( prPostSlogan ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD6         ) ;
                                                {
                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 

                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD5         ) ;
                                                //reserved: error message goes here
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD4         ) ;
                                                PUSHrEPLY( prPostKeywords ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD3         ) ;
                                                PUSHrEPLY( prPostMetaDescription ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD2         ) ;
                                                PUSHrEPLY( prPostTitle ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD1         ) ;
                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/pushing snips" ) ;

                                                }
                                                    delF( tinP , pczName ) ;

                                                    THREADmODE2rESTORE
                                                    }
                                                        delF( tinP , postLathPeanut ) ;
                                                        if( postLathPeanut ) { strMakeF( tinP , LF , prPostsLathPeanut , T(postLathPeanut) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsLathPeanut ) ; }
                                                        puseC puseWork1( tinP , ifcIDpOOL_ADAMtEMP ) ; //--------------------------------------------------------------------------------------
                                                        //PUSE.list_osTextTstrz_Old 2012F( tinP , postLathPeanut , pczName ) ; //A:ASSUME: ANOTHER THREAD MIGHT REPLACE THIS VALUE WHILE I AM USING THIS POINTER, BUT THIS POINTER WILL REMAIN POINTING TO VALID STORAGE
                                                        puseC pusePeanut( pusePeanutP ) ;
                                                        ZE( osTextT* , postLathPeanut ) ;
                                                    {
                                                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                                                    { countT pczFrom[] = { LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION , idPortMe | BM_HIGH , 0 } ; strStretchIF( tinP , pczName , pczFrom , T(POSTS(*REPLY.prPostUrl)) ) ; ___( pczName ) ; }
                                                    ZE( countT* , pczName ) ;
                                                {
                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                                ZE( pbRefC* , prPostsLathPeanut ) ;
                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/making posts 4" ) ;

                                                //;
                                                //)
                                                //                : "have neither"
                                                //                ? "have green"
                                                //            : prPostsBarGreen
                                                //            ? "have brown"
                                                //        : prPostsBarBrown
                                                //        ? "have both"
                                                //    prPostsBarBrown && prPostsBarGreen
                                                //(
                                                //POPUP

                                                }
                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarBrown ) ;

                                                            "</tr>\r\n"
                                                                "</td>\r\n"
                                                                    "</SPAN>\r\n"
                                                                        "<B>IdeaFarm</B> (tm) <B>Space</B>\r\n"
                                                                    "<SPAN class=spaXXSmall>\r\n"
                                                                "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTbROWN  " ; color=#840\">\r\n"
                                                            "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyBrownF() ;\">\r\n"

                                                    strMakeF( tinP , LF , prPostsBarBrown , T(
                                                {
                                                else
                                                }
                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarGreen ) ;

                                                            "</tr>\r\n"
                                                                "</td>\r\n"
                                                                    "</SPAN>\r\n"
                                                                        " <> <B>Federal Constitutional Protectorate of the United States of America</B>\r\n"
                                                                        "<B>IdeaFarm</B> (tm) <B>City</B>"
                                                                    "<SPAN class=spaXXSmall>\r\n"
                                                                "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ; color=#060\">\r\n"
                                                            "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyGreenF() ;\">\r\n"

                                                    strMakeF( tinP , LF , prPostsBarGreen , T(
                                                {
                                                if( idPortMe == ifcIDpORT_DOOR || idPortMe == ifcIDpORT_PANICdOOR )

                                                }
                                                    }
                                                        ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarOrange ) ;

                                                                "</A>\r\n"
                                                                    "</tr>\r\n"
                                                                        "</td>\r\n"
                                                                            "</SPAN>\r\n"
                                                                                "ALERT: Price Doubling for <B>IdeaFarm</B> (tm) <B>Basic Privileges</B> will occur within 0-64 days.<BR><CENTER><I>Click here or you'll regret it!</I></CENTER>\r\n "
                                                                            "<SPAN class=spaLarge>\r\n"
                                                                        "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaLERT " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL "\">\r\n"
                                                                    "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyOrangeF() ;\">\r\n"
                                                                "<A HREF=\"/header/action/alert.html\">\r\n"

                                                        strMakeF( tinP , LF , prPostsBarOrange , T(
                                                    {
                                                    if( idBannerAd == 8 )

                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarGray ) ;

                                                            "</tr>\r\n"
                                                                "</td>\r\n"
                                                                    "</SPAN>\r\n"
                                                                        "<BR>system status: occasional service interruptions (2 per day), each lasting about 5 minutes\r\n "
                                                                        //"<BR>system status: irregular service interruptions (1 to 3 per hour), each lasting about 1 minute\r\n "
                                                                        //"<BR>system status: frequent service interruptions (8 per hour), each lasting about 1 minute\r\n "
                                                                        "<A HREF=\"/nobot/header/calendar.html\"  onMouseOut=\"swatF() ;\" onMouseOver=\"flyTimeF() ;\">")+TnOWtICK+T("</A>\r\n"
                                                                    "<SPAN class=spaXXSmall>\r\n"
                                                                "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnOTEdIM " ; color=#ccc\">\r\n"
                                                            "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyGrayF() ;\">\r\n"

                                                    strMakeF( tinP , LF , prPostsBarGray , T(
                                                {
                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/making posts 3" ) ;

                                                }
                                                    delF( tinP , psttEmail ) ;
                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarMaroon2 ) ;

                                                            "</tr>\r\n"
                                                                "</td>\r\n"
                                                                    "</SPAN>\r\n"
                                                                        +T("\r\n "
                                                                        + tLinks
                                                                    "<SPAN class=spaXXSmall>\r\n")
                                                                "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTrED   " ; color:" ifcCOLORhTMLwHAT_FOREaCCENTrED    "\">\r\n"
                                                            "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyMaroon2F() ;\">\r\n"

                                                    strMakeF( tinP , LF , prPostsBarMaroon2 , T(

                                                    if( !tLinks.csF( tinP ) ) tLinks += T("Connecting People Wholesomely") ;

                                                    }
                                                        }
                                                            tLinks += tLinkMore ;

                                                            ) ;

                                                                : "verbose\" onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'This page header is abbreviated.  Click here to indicate that you want to see full page headers during this session.' );\">more</A>"
                                                                ? "terse\"   onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'This is the full page header.  Click here to indicate that you want to see brief page headers during this session.' );\">less</A>"

                                                            tLinkMore += T( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE
                                                            TN( tLinkMore , "<A HREF=\"" ) ; tLinkMore += T(POSTS(*REPLY.prPostUrl))+T("?headflavor=") ;
                                                            if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                        {
                                                        if( bAllowBigHead )
                                                    {
                                                    //if( sessionP.getIdAccountF( tinP ) == 1 )
                                                    //BEFORE MAKING THIS VISIBLE, THE ENTIRE "MORE" WEB SITE MUST BE EDITED TO ELIMINATE INACCURACIES (E.G. DISCUSSING FREEBIES WHEN THERE AREN'T ANY YET)
                                                    //THIS ALL WORKS BUT IS HIDDEN TO KEEP THE WEB SITE SIMPLE AND TO LIMIT THE SCOPE OF CUSTOMER SERVICE DURING LAUNCH OF THE MAIN PRODUCT (DIRECTORY)

                                                    }
                                                        tLinks += T("<A HREF=\"http://ideafarm.com/\" onMouseOut=\"swatF() ;\" onMouseOver=\"flyF( 'Click to display the IDEAFARM.COM domain root (home) page.' ) ;\">IDEAFARM.COM</A>\r\n") ;
                                                        if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                    {
                                                    if( !bIsRootPage && !bIsHelpPage )

                                                    }
                                                        }
                                                            tLinks += T("<A HREF=\"/nobot/help/help.html?url=")+T(POSTS(*REPLY.prPostUrl))+T("\"")+T(bIsHelpPage?"":" TARGET=\"_blank\"")+tFlyHelp+T(">")+tHelp+T("</A>\r\n") ;
                                                            if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                        {
                                                        if( psttEmail )

                                                        }
                                                            tLinks += T("<A HREF=\"/header/do.html\"    onMouseOut=\"swatF() ;\" onMouseOver=\"flyF( this , 'Work and play and live in IdeaFarm " "(tm) City!' ) ;\">do</A>\r\n") ;
                                                            if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                        {
                                                        if( psttEmail && idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE )
                                                    {
                                                    if( sessionP.getIdAccountF( tinP ) == 1 )
                                                    //THIS ALL WORKS BUT IS HIDDEN TO KEEP THE WEB SITE SIMPLE AND TO LIMIT THE SCOPE OF CUSTOMER SERVICE DURING LAUNCH OF THE MAIN PRODUCT (DIRECTORY)

                                                    }
                                                        ;

                                                            : T("<A HREF=\"/header/action/login.html\"  onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'Click here to log in.  Anywo with an email address can log in; you do not need to open an account or create a password.  A login link that can only be used wo time will be sent to your email address immediately.' );\">login</A>")
                                                            ? T("<A HREF=\"/header/action/logout.html\" onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'Click here to log out.  This is important if you are using a public computer or if your computer can be accessed by others.');\">logout</A> <> ")+T(psttEmail)

                                                        tLinks += psttEmail

                                                        if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                    {
                                                    if( sessionP.getIdAccountCommissionF( tinP ) || sessionP.getIdAccountF( tinP ) ) // MIGHT HAVE LOGGED IN BY CLICKING AN OLD EMAIL LINK AND HAS NOT SELECTED A RECRUITER

                                                    TN( tSpace , " <> " ) ;
                                                    TN( tLinks , "" ) ;

                                                    sessionP.getEmailF( tinP , psttEmail ) ; ___( psttEmail ) ;
                                                    ZE( strokeS* , psttEmail ) ;
                                                {
                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/making posts 2" ) ;

                                                ) ;

                                                    : " onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'A helpful information page is NOT available for the page that you are viewing, but click here anyway to view the general helpful information page for IdeaFarm " "(tm) City.' );\""
                                                    ? " onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'A helpful information page is available for the page that you are viewing.' );\""

                                                TN( tFlyHelp , bExistHelp

                                                ) ;
                                                        : "help"
                                                        ? "HELP"
                                                    : bExistHelp
                                                    ? "aboutHelp"
                                                TN( tHelp , bIsHelpPage

                                                const boolT bExistHelp  = REPLY.prPostPageHelp && COSTS( REPLY.prPostPageHelp ) ;
                                                const boolT bIsHelpPage = !!strIdF( tinP , T("/nobot/help/") , tUrl ) ;
                                                //const boolT bIsLogoutPage = 1 == strIdF( tinP , T("/header/action/logout.html") , tUrl ) ;

                                                ;
                                                    )
                                                        1 == strIdF( tinP , T("/?") , tUrl )
                                                        !strCompareF( tinP , tSlash , tUrl ) ||
                                                    (
                                                    idPortMe == ifcIDpORT_HTTP                      &&
                                                const boolT bIsRootPage =

                                                TN( tUrl , POSTS( *REPLY.prPostUrl ) ) ;

                                                }
                                                    , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsMugShot ) ;

                                                        : T("<IMG onMouseOut=\"swatF();\" onMouseOver=\"flyF( this , 'The Earth, depicted with the Sun and Moon on a field of stars, is the official symbol for IdeaFarm " "(tm) Associates.  The lower hand, Youth, receives Earth from the upper hand, Elders.   A female breast appears in the place of a continent.  The wise infant does not bite his mother while suckling, and the wise elder never forgets his debt.  Love your Mother!' );\" SRC=\"/blob/ifc.ico\" alt=\"\" border=\"0\">\r\n")
                                                        ? T("<IMG SRC=\"/blob/user.")+TF4(idAccCommission,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(".64x48.jpeg\" alt=\"\" border=\"0\">\r\n")

                                                    strMakeF( tinP , LF , prPostsMugShot , idAccCommission

                                                    idAccCommission      = session.getIdAccountCommissionF( tinP ) ; //MUST BE DONE AFTER DYNAMIC CONTENT CALL HAS BEEN MADE
                                                    sessionC& session = jobP.sessions( tinP , jobP.nnPeer ) ;
                                                    ZE( countT , idAccCommission ) ;
                                                {

                                                }
                                                    strMakeF( tinP , LF , prPostsPort            , T((const strokeS*)*psoP)    , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsPort            ) ;
                                                    strMakeF( tinP , LF , prPostsIdPort2         , TF1(idPortMe)               , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdPort2         ) ;
                                                    strMakeF( tinP , LF , prPostsIdPort1         , TF1(idPortMe)               , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdPort1         ) ;
                                                    strMakeF( tinP , LF , prPostsIdSession       , TF1((countT)sessionP)       , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdSession       ) ;
                                                {
                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/making posts" ) ;

                                                //}
                                                    //}
                                                    //    bShowImageAds = etherC::ranUniI_IF( tinP ) <= mProb ; //"=" IS REDUNDANT BECAUSE ranUniC GUARANTEES RESULT STRICTLY LESS THAN RANGE 
                                                    //    measure04T mProb = !strCompareF( tinP , psttName , tSlash ) ? 1.0 / 8.0 : 1.0 / 4.0 ;
                                                    //{
                                                    //if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_HIDEiMAGEaDS ) )

                                                    //if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_HIDEaDlINKS ) ) bShowAdLinks = 1 ;
                                                //{
                                                //if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                                //ZE( boolT , bShowImageAds ) ;
                                                //ZE( boolT , bShowAdLinks ) ;

                                                else if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) idHeadFlavor = ifcIDhEADfLAVOR_TERSE ;
                                                if( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_FULLhEADER ) bAllowBigHead = 1 ;
                                                ZE( boolT , bAllowBigHead ) ;

                                                }
                                                    (*REPLY.pCBF)( tinP , *this , bQuitP , meP , cArgAppP , REPLY , *pStkBodyDynamic , psttKVReport , *pswKV , psttLeverKV , jobP.sessions , jobP.nnPeer , psttName , psttQueryKV , psttAgent , postBody ) ;
                                                    TELL( T(psttName) ) ;
                                                    _IO_
                                                {
                                                if( REPLY.pCBF )
                                                //DONE EARLY TO GIVE CBF AN EARLY CHANCE TO CHANGE STATE IN WAYS THAT WILL AFFECT BUILDING OF HEADER

                                                }
                                                    }
                                                        traceF( tinP , T("etherDoHttpJobF: could not obtain socket my name 611") , flTRACE_FORCEnOsILENCE ) ;
                                                        POOPRqUIET
                                                    {
                                                    if( POOP )
                                                    psoP->myNameF( tinP , idPortMe , nnMe ) ;
                                                    SCOOPS
                                                {
                                                IFsCRATCH
                                                nicNameC nnMe ;
                                                ZE( countT , idPortMe ) ;
                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/getting nnMe" ) ;
                                                TESTsCRATCH //U::TO FIND A BUG

                                                }

                                                    }
                                                        }
                                                            }
                                                                idBannerAd = 1 + (countT)( mSwitch / mCutSwitch ) ;
                                                                measureT mCutSwitch = (measureT)1.0 / (measureT)cAd ;
                                                                measureT mSwitch = etherC::ranUniI_IF( tinP ) ;
                                                            {
                                                            if( mDo < mCutDo )
                                                            measureT mCutDo = 1.0 / 4.0 ;
                                                            measureT mDo    = etherC::ranUniI_IF( tinP ) ;
                                                        {
                                                        else if( idAd > cAd * 2 )
                                                        else if( idAd <= 4 + cAd ) idBannerAd = idAd - 4 ;
                                                        if( idAd <= 4 ) ;
                                                        const countT cAd = 8 ; //CS:CODEsYNC: 1d20003 0b5000d
                                                        countT idAd = session.dispenseIdF( tinP , 1 ) ;

                                                    {
                                                {
                                                )
                                                    strCompareF( tinP , psttName , T("/header/idea/slideshow.regrets.html") )
                                                    strCompareF( tinP , psttName , T("/header/idea/slideshow.tellin.it.html") )    &&
                                                    strCompareF( tinP , psttName , T("/"                          ) )              &&
                                                    idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE                                            &&
                                                (
                                                if
                                                ZE( countT , idBannerAd ) ;
                                                sessionC& session = jobP.sessions( tinP , jobP.nnPeer ) ;
                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD" ) ;
                                                TESTsCRATCH //U::TO FIND A BUG
                                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / i") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                              //traceF( tinP , T("U:: etherDoHttpJobF / i") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                            {
                                            case ifcIDfORMhTTPrEPLY_BIGhEAD :
                                            case ifcIDfORMhTTPrEPLY_PINhEAD :
                                            }
                                                break ;
                                            {
                                            case ifcIDfORMhTTPrEPLY_DEBUG :
                                            }
                                                break ;

                                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / j") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                              //traceF( tinP , T("U:: etherDoHttpJobF / j") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_FOOT3        ) ;
                                                PUSHsNIP( meP , !sessionP.getIdAccountCommissionF( tinP ) ? ifcIDsNIPpREDEFINED_FOOT1 : ifcIDsNIPpREDEFINED_FOOT2 ) ;
                                                //THESE WERE REMOVED IN 2019. 20200729@1734: ENABLED WITHOUT ANALYSIS

                                                }
                                                    (*REPLY.pCBF)( tinP , *this , bQuitP , meP , cArgAppP , REPLY , *pStkBody , psttKVReport , *pswKV , psttLeverKV , jobP.sessions , jobP.nnPeer , psttName , psttQueryKV , psttAgent , postBody ) ;
                                                    _IO_
                                                {
                                                if( REPLY.pCBF )

                                                PUSHrEPLY( prPostBody ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD4         ) ;
                                                PUSHrEPLY( prPostKeywords ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD3         ) ;
                                                PUSHrEPLY( prPostMetaDescription ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD2         ) ;
                                                PUSHrEPLY( prPostTitle ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD1         ) ;
                                                TELL( "ifcIDfORMhTTPrEPLY_FULLcUSTOM/pushing snips" ) ;

                                                }
                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarBrown ) ;

                                                            "</tr>\r\n"
                                                                "</td>\r\n"
                                                                    "</SPAN>\r\n"
                                                                        "<B>IdeaFarm</B> (tm) <B>Space</B>\r\n"
                                                                    "<SPAN class=spaXXSmall>\r\n"
                                                                "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTbROWN  " ; color=#840\">\r\n"
                                                            "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyBrownF() ;\">\r\n"

                                                    strMakeF( tinP , LF , prPostsBarBrown , T(
                                                {
                                                else
                                                }
                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarGreen ) ;

                                                            "</tr>\r\n"
                                                                "</td>\r\n"
                                                                    "</SPAN>\r\n"
                                                                        " <> <B>Federal Constitutional Protectorate of the United States of America</B>\r\n"
                                                                        "<B>IdeaFarm</B> (tm) <B>City</B>"
                                                                    "<SPAN class=spaXXSmall>\r\n"
                                                                "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ; color=#060\">\r\n"
                                                            "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyGreenF() ;\">\r\n"

                                                    strMakeF( tinP , LF , prPostsBarGreen , T(
                                                {
                                                if( idPortMe == ifcIDpORT_DOOR || idPortMe == ifcIDpORT_PANICdOOR )

                                                ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarGray ) ;

                                                        "</tr>\r\n"
                                                            "</td>\r\n"
                                                                "</SPAN>\r\n"
                                                                    "<>\r\n "
                                                                "<SPAN class=spaXXSmall>\r\n"
                                                            "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnOTEdIM " ; color:" ifcCOLORhTMLwHAT_FOREnOTEbRIGHT "\">\r\n"
                                                        "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyGrayF() ;\">\r\n"

                                                strMakeF( tinP , LF , prPostsBarGray , T(
                                                strMakeF( tinP , LF , prPostsPort            , T((const strokeS*)*psoP)    , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsPort            ) ;
                                                strMakeF( tinP , LF , prPostsIdPort2         , TF1(idPortMe)               , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdPort2         ) ;
                                                strMakeF( tinP , LF , prPostsIdPort1         , TF1(idPortMe)               , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdPort1         ) ;
                                                strMakeF( tinP , LF , prPostsIdSession       , TF1((countT)sessionP)       , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdSession       ) ;
                                                TELL( "ifcIDfORMhTTPrEPLY_FULLcUSTOM/making posts" ) ;

                                                //}
                                                //    bShowImageAds = etherC::ranUniI_IF( tinP ) <= mProb ; //"=" IS REDUNDANT BECAUSE ranUniC GUARANTEES RESULT STRICTLY LESS THAN RANGE 
                                                //    measure04T mProb = !strCompareF( tinP , psttName , tSlash ) ? 1.0 / 8.0 : 1.0 / 4.0 ;
                                                //{
                                                //if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_HIDEiMAGEaDS ) )
                                                //ZE( boolT , bShowImageAds ) ;

                                                //if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_HIDEaDlINKS ) ) bShowAdLinks = 1 ;
                                                //ZE( boolT , bShowAdLinks ) ;

                                                }
                                                    }
                                                        traceF( tinP , T("etherDoHttpJobF: could not obtain socket my name 734") , flTRACE_FORCEnOsILENCE ) ;
                                                        POOPRqUIET
                                                    {
                                                    if( POOP )
                                                    psoP->myNameF( tinP , idPortMe , nnMe ) ;
                                                    SCOOPS
                                                {
                                                IFsCRATCH
                                                nicNameC nnMe ;
                                                ZE( countT , idPortMe ) ;
                                                TELL( "ifcIDfORMhTTPrEPLY_FULLcUSTOM/getting nnMe" ) ;

                                                }

                                                    }
                                                        }
                                                            }
                                                                idBannerAd = 1 + (countT)( mSwitch / mCutSwitch ) ;
                                                                measureT mCutSwitch = (measureT)1.0 / (measureT)cAd ;
                                                                measureT mSwitch = etherC::ranUniI_IF( tinP ) ;
                                                            {
                                                            if( mDo < mCutDo )
                                                            measureT mCutDo = 1.0 / 4.0 ;
                                                            measureT mDo    = etherC::ranUniI_IF( tinP ) ;
                                                        {
                                                        else if( idAd > cAd * 2 )
                                                        else if( idAd <= 4 + cAd ) idBannerAd = idAd - 4 ;
                                                        if( idAd <= 4 ) ;
                                                        const countT cAd = 8 ; //CS:CODEsYNC: 1d20003 0b5000d
                                                        countT idAd = session.dispenseIdF( tinP , 1 ) ;

                                                        sessionC& session = jobP.sessions( tinP , jobP.nnPeer ) ;
                                                    {
                                                {
                                                )
                                                    strCompareF( tinP , psttName , T("/header/idea/slideshow.regrets.html") )
                                                    strCompareF( tinP , psttName , T("/header/idea/slideshow.tellin.it.html") )    &&
                                                    strCompareF( tinP , psttName , T("/"                          ) )              &&
                                                (
                                                if
                                                ZE( countT , idBannerAd ) ;
                                                TELL( "ifcIDfORMhTTPrEPLY_FULLcUSTOM" ) ;
                                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / k") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                              //traceF( tinP , T("U:: etherDoHttpJobF / k") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                            {
                                            case ifcIDfORMhTTPrEPLY_FULLcUSTOM :
                                            }
                                                break ;

                                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / l") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                              //traceF( tinP , T("U:: etherDoHttpJobF / l") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                                }
                                                    (*REPLY.pCBF)( tinP , *this , bQuitP , meP , cArgAppP , REPLY , *pStkBody , psttKVReport , *pswKV , psttLeverKV , jobP.sessions , jobP.nnPeer , psttName , psttQueryKV , psttAgent , postBody ) ;
                                                    _IO_
                                                {
                                                if( REPLY.pCBF )

                                                PUSHrEPLY( prPostBody ) ;

                                                httpReplyS& info = *(httpReplyS*)&(refCounterC&)*pRefReply ;

                                                psoP->myNameF( tinP , idPortMe , nnMe ) ;
                                                nicNameC nnMe ;
                                                ZE( countT , idPortMe ) ;
                                                TELL( "ifcIDfORMhTTPrEPLY_RAW" ) ;
                                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / m") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                              //traceF( tinP , T("U:: etherDoHttpJobF / m") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                            {
                                            case ifcIDfORMhTTPrEPLY_RAW :
                                        {
                                        switch( REPLY.idForm )
                                        TESTsCRATCH //U::TO FIND A BUG
                                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / n") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                      //traceF( tinP , T("U:: etherDoHttpJobF / n") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                    {
                                    case ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP :
                                    case ifcIDsNIPpREDEFINED_HTTPfAILmOVED :
                                    case ifcIDsNIPpREDEFINED_HTTPfAILnOTfOUND :
                                    case ifcIDsNIPpREDEFINED_HTTPoKtEXThTML :
                                    }
                                        break ;
                                        PUSHrEPLY( prPostBody ) ;
                                    {
                                    case ifcIDsNIPpREDEFINED_HTTPoKmP3 :
                                    case ifcIDsNIPpREDEFINED_HTTPoKiMAGEjPEG :
                                    case ifcIDsNIPpREDEFINED_HTTPoKiMAGEgIF :
                                    case ifcIDsNIPpREDEFINED_HTTPoKiMAGEiCON :
                                    }
                                        break ;
                                    {
                                    case ifcIDsNIPpREDEFINED_HTTPcONTINUEwELCOME :
                                {
                                switch( REPLY.idSnipHttpPrefix )
                                TESTsCRATCH //U::TO FIND A BUG
                                ZE( pbRefC* , prPostsMugShot         ) ;
                                ZE( pbRefC* , prPostsBarBrown        ) ;
                                ZE( pbRefC* , prPostsBarGreen        ) ;
                                ZE( pbRefC* , prPostsBarOrange       ) ;
                                ZE( pbRefC* , prPostsBarGray         ) ;
                                ZE( pbRefC* , prPostsBarMaroon2      ) ;
                                ZE( pbRefC* , prPostsIdSession       ) ;
                                ZE( pbRefC* , prPostsIdPort2         ) ;
                                ZE( pbRefC* , prPostsIdPort1         ) ;
                                ZE( pbRefC* , prPostsPort            ) ;

                                //POPUPcOUNT( "idHeadFlavor after: " , idHeadFlavor ) ;
                                ;
                                        : ifcIDhEADfLAVOR_VERBOSE
                                        ? ifcIDhEADfLAVOR_TERSE
                                    : REPLY.idForm == ifcIDfORMhTTPrEPLY_PINhEAD
                                    ? idHeadFlavorOverride
                                countT idHeadFlavor = idHeadFlavorOverride

                                //bDebugLog = REPLY.idSnipHttpPrefix == ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP ; //U::

                                if( !pRefReply ) { BLAMMO ; }

                                TESTsCRATCH //U::TO FIND A BUG
                                }
                                    meP.getReplyF( tinP , pRefReply , T("!nf") ) ; ___( pRefReply ) ;
                                    _IO_
                                {
                                if( !pRefReply )

                                TESTsCRATCH //U::TO FIND A BUG
                                }
                                    meP.getReplyF( tinP , pRefReply , psttName ) ; ___( pRefReply ) ;
                                    _IO_
                                {
                                ZE( httpReplyRefC* , pRefReply ) ;
                                TESTsCRATCH //U::TO FIND A BUG
                            {
                            ZE( osTextT* , postsReply ) ;
                            ZE( boolT , bDebugLog ) ;
                            TELL( "preparing to compile the reply" ) ;
                            TESTsCRATCH //U::TO FIND A BUG
                            if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / o") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                          //traceF( tinP , T("U:: etherDoHttpJobF / o") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        {
                        else
                        }
                            traceF( tinP , T("etherDoHttpJobF / error: recycler failure 2") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                            traceF( tinP , T("etherDoHttpJobF / error: recycler failure 2") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                            traceF( tinP , T("etherDoHttpJobF / error: recycler failure 2") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                            traceF( tinP , T("etherDoHttpJobF / error: recycler failure 2") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                            traceF( tinP , T("etherDoHttpJobF / error: recycler failure 2") , flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_2 ) ;
                        {
                        if( !pStkBody || !pStkBodyDynamic )
                        TESTsCRATCH //U::TO FIND A BUG
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / p") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / p") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        (*this)( tinP , pStkBodyDynamic , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_ALLOWzE | flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , sizeof( pbRefC ) ) ;
                        ZE( stackC* , pStkBodyDynamic ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / q") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / q") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        (*this)( tinP , pStkBody , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_ALLOWzE | flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , sizeof( pbRefC ) ) ;
                        ZE( stackC* , pStkBody ) ; //EVERYTHING AFTER THE HTTP HEADER AND ITS TRAILING "\r\n\r\n"
                        TELL( "getting recycled items" ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / r") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / r") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        (*pHttpEatKeyValuePairsCBFP)( tinP , *this , bQuitP , psttKVReport , 0 /*DISABLED TO PREVENT ATTACK: T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(ifcIDaDAM_ROOTfORMdATAeATER)+T("/in/form") */ , *pswKV , psttLeverKV , jobP.sessions , jobP.nnPeer , psttName , psttQueryKV , psttAgent , postBody ) ;
                        ZE( strokeS* , psttKVReport ) ;
                        TELL( "calling keyvalue eater" ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / s") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / s") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        TESTsCRATCH //U::TO FIND A BUG
                        }
                            session.privilegesF( tinP , flSESSIONpRIVILEGE_HIDEiMAGEaDS | flSESSIONpRIVILEGE_HIDEaDlINKS ) ;
                            )
                                !strCompareF( tinP , psttName , T("/robots.txt") )
                                !strCompareF( tinP , psttName , T("/nobot/noads.html") ) ||
                            (
                            if
                            TELL( "maybe changing privileges to hide ads" ) ;

                            }
                                break ;
                                delF( tinP , postBody ) ;
                                delF( tinP , psttAgent ) ;
                                delF( tinP , psttName ) ;
                            {
                            if( idEscaped || POOP )
                            TELL( "inspecting idEscaped" ) ;

                            }
                                }
                                    }
                                        //if( nnMe != jobP.nnPeer && jobP.nnPeer != nnLocal ) boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/ipdos/attackers/")+T(jobP.nnPeer) ) ; 
                                        //nicNameC nnLocal( NICnAMElOCAL ) ;
                                        //nicNameC nnMe = socketC::nicNameIF( tinP , *this ) ;
                                    {
                                    if( /*U::TO FIND A BUG: cTock &&*/ cTouch / cTock )
                                    countT cTock = timeAge.time1 / TOCK ;
                                {
                                if( cTouch > TUCK && !timeAge.time2 )

                                timeS timeAge = session.ageF( tinP ) ;
                                countT cTouch = session.cTouchF( tinP ) ;
                            {
                            TELL( "inspecting session age" ) ;

                            //POPUPcOUNT( "idHeadFlavorOverride after: " , idHeadFlavorOverride ) ;
                            }
                                }
                                    }
                                        break ;
                                        }
                                            if( idHeadFlavorOverride ) session.setIdHeadFlavorOverrideF( tinP , idHeadFlavorOverride ) ;

                                            else if( !strCompareF( tinP , psttv , T("terse"  ) ) ) idHeadFlavorOverride = ifcIDhEADfLAVOR_TERSE   ;
                                                 if( !strCompareF( tinP , psttv , T("verbose") ) ) idHeadFlavorOverride = ifcIDhEADfLAVOR_VERBOSE ;
                                        {
                                        if( psttv )
                                        strokeS* psttv = *(strokeS**)&(countT&)*pswKV ;
                                    {
                                    if( !strCompareF( tinP , psttLeverKV , tKeyHeadFlavor ) )
                                    psttLeverKV = (strokeS*)pswKV->leverF( tinP , idf ) ;
                                {
                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                countT cFlavors = pswKV->cFlavorsF( tinP ) ;

                                TN( tKeyHeadFlavor , "headflavor" ) ;
                            {

                            //POPUPcOUNT( "idHeadFlavorOverride before: " , idHeadFlavorOverride ) ;
                            idHeadFlavorOverride = session.getIdHeadFlavorOverrideF( tinP ) ;
                            session.touchF( tinP , psttName ) ;    
                            sessionC& session = jobP.sessions( tinP , jobP.nnPeer ) ;
                            TELL( "getting idHeadFlavorOverride" ) ;
                        {
                        ZE( countT , idHeadFlavorOverride ) ;
                        TESTsCRATCH //U::TO FIND A BUG
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / t") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / t") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        //}
                        //    if( tSay.csF( tinP ) ) { POPUP( tSay ) ; }
                        //    }
                        //        tSay += T("[")+T(psttLeverKV)+T("]: \"")+T(zsttv)+T("\"\r\n") ;
                        //
                        //        strokeS*& zsttv = *(strokeS**)&(countT&)*pswKV ;
                        //        psttLeverKV = (strokeS*)pswKV->leverF( tinP , idf ) ;
                        //    {
                        //    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        //    countT cFlavors = pswKV->cFlavorsF( tinP ) ;
                        //
                        //    TN( tSay , "" ) ;
                        //{
                        //COMMENT OUT IN PRODUCTION: USED TO SEE KEYVALUES SUBMITTED USING FORMS

                        //CONoUTrAW( T(DASH127 "\r\n")+T(psttName)+T("\r\n") ) ;

                        //}
                        //    countT foo = 2 ;
                        //{
                        //if( bDebug )
                        //const boolT bDebug = 1 ;
                        //const boolT bDebug = !strCompareF( tinP , psttName , T("/nobot/action/myaccount.html") ) ;

                        //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    preparing nonfile response") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        _IO_
                    {
                    else
                    }
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / u") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / u") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        //if( bClose ) traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    closing connection") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        }
                            DEL( pFW ) ;
                            }
                                }
                                    }
                                        }
                                            }
                                                //U:: LATER, PURGE BY NUMBER OF PLATES, BY AGE, AND/OR BY SIZE

                                                pzCache->pushF( tinP , psttn , pbBlob , cbBlob , maxAgeMsFile , 0 ) ; // "0": "NOT LENGTH PREFIXED"

                                                memCopyF( tinP , pbc , pbw              , cbw  ) ;
                                                memCopyF( tinP , pbc , (osTextT*)tReply , cbDo ) ; pbc += cbDo ;
                                                countT cbDo = cbBlob - cbw ;
                                                byteT* pbc = pbBlob ;
                                            {
                                            if( pbBlob )
                                            newF( tinP , LF , pbBlob , cbBlob ) ; ___( pbBlob ) ;
                                            countT       cbBlob = tReply.csF( tinP ) + cbw ;
                                            ZE( byteT* , pbBlob ) ;

                                            strMakeF( tinP , LF , psttn , tNameCache ) ; ___( psttn ) ;
                                            ZE( strokeS* , psttn ) ;
                                        {
                                        if( pzCache && !bNoCacheStore )

                                        bCacheThis = 0 ;
                                    {
                                    if( bCacheThis )

                                    //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    wrote   file window [cbw]:    ")+TF2(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                                    }
                                        }
                                            bClose = 1 ;
                                            traceF( tinP , T("etherDoHttpJobF: could not write to socket 965") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                            POOPRqUIET
                                        {
                                        if( POOP )
                                        psoP->writeF( tinP , pbw , cbw ) ;
                                        SCOOPS
                                    {
                                    IFsCRATCH

                                    //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    writing file window [cbw]:    ")+TF2(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                {
                                else
                                }
                                    break ;
                                    //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    all file windows have been written") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                {
                                if( !pbw || !cbw )

                                pFW->getF( tinP , pbw , cbw , cbWindow ) ;
                                ZE( countT , cbw ) ;
                                ZE( byteT* , pbw ) ;
                            {
                            while( !POOP )

                            }
                                }
                                    bClose = 1 ;
                                    traceF( tinP , T("etherDoHttpJobF: could not write to socket 980") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                    POOPRqUIET
                                {
                                if( POOP )
                                psoP->writeF( tinP , (osTextT*)tReply , tReply.csF( tinP ) ) ;
                                SCOOPS
                            {
                            IFsCRATCH

                            TN( tReply , "" ) ; tReply = T("HTTP/1.1 200 OK\r\nServer: IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System (tm)\r\nContent-Type: ")+tContentType+T("\r\nContent-Length: ")+TF4(cbBody,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;

                            }
                                delF( tinP , psttLower ) ;

                                else if( psttLower->idAdam - 4 == strIdF( tinP , T(".jpeg") , psttLower , - 1 ) ) tContentType = T("image/jpeg") ;
                                else if( psttLower->idAdam - 3 == strIdF( tinP , T(".jpg" ) , psttLower , - 1 ) ) tContentType = T("image/jpeg") ;
                                else if( psttLower->idAdam - 3 == strIdF( tinP , T(".png" ) , psttLower , - 1 ) ) tContentType = T("image/png" ) ;
                                else if( psttLower->idAdam - 3 == strIdF( tinP , T(".mp3" ) , psttLower , - 1 ) ) tContentType = T("audio/mp3" ) ;
                                else if( psttLower->idAdam - 3 == strIdF( tinP , T(".mp4" ) , psttLower , - 1 ) ) tContentType = T("video/mp4" ) ;
                                     if( psttLower->idAdam - 3 == strIdF( tinP , T(".avi" ) , psttLower , - 1 ) ) tContentType = T("video/avi" ) ;

                                strConvertToLowerCaseF( tinP , psttLower , psttName ) ; ___( psttLower ) ;
                                ZE( strokeS* , psttLower ) ;
                            {
                            TN( tContentType , "" ) ;

                            boolT bCacheThis = !pcLoHi[ 1 ] && pcLoHi[ 0 ] <= cbWindow ;

                            const countT cbWindow = TICK >> 2 ;

                            sCountC cbBody( tinP , *this , pcLoHi , SC << 1 ) ;
                            countT pcLoHi[] = { pFW->cbFileLoF() , pFW->cbFileHiF() } ;
                            //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    serving file [cbFileLo,cbFileHi]:    ")+TF3(pFW->cbFileLoF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pFW->cbFileHiF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9) ) ;
                        {
                        else
                        }
                            }
                                }
                                    traceF( tinP , T("etherDoHttpJobF: could not write to socket 1004") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                    POOPRqUIET
                                {
                                if( POOP )
                                psoP->writeF( tinP , (osTextT*)tReply , tReply.csF( tinP ) ) ;
                                SCOOPS
                            {
                            IFsCRATCH

                            TN( tReply , "" ) ; tReply = T("HTTP/1.1 404 Not Found\r\nServer: IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System (tm)\r\nContent-Type: text")+T("\r\nContent-Length: ")+TF4(tBody.csF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;

                            TN( tBody , "The page (or other resource) that you requested does not exist here.\r\n\r\nIf you think that this is our error, please let us know.\r\n" ) ;

                            }
                                traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    error: could not open file:    ")+*pptFileIn[offf] , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                            {
                            for( countT offf = 0 ; offf < sizeof pptFileIn / sizeof pptFileIn[ 0 ] ; offf ++ )
                        {
                        if( !pFW )
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / v") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / v") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        }
                            }
                                }
                                    DEL( pFW ) ;
                                    POOPRqUIET
                                {
                                else
                                if( !POOP ) break ;
                                //tinP.pc Utility[ 0 ] -- ; //U:: TO FIND A BUG
                                pFW = new( 0 , tinP , LF ) fileWindowsC( tinP , *tinP.pEtScratch , *pptFileIn[ offf ] , flFILEwINDOW_DOnOTvALIDATE | flFILEwINDOW_DOnOTmAKEdIRiFnEEDED , 1 ) ; ___( pFW ) ; //DOnOTvALIDATE IS A WORKAROUND TO PREVENT dosOpenIF FROM USING THE WRONG poopC INSTANCE (THIS IS A CODE DESIGN ERROR: NO IMAGE FUNCTION SHOULD ASSUME A PARTICULAR thirdC OR etherC INSTANCE TO USE WHEN CALLING NONIMAGE FUNCTIONS)
                                //tinP.pc Utility[ 0 ] ++ ; //U:: TO FIND A BUG
                                _IO_
                                SCOOPS
                            {
                            IFsCRATCH
                            //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    attempting to open file:    ")+*pptFileIn[offf] , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        {
                        for( countT offf = 0 ; offf < sizeof pptFileIn / sizeof pptFileIn[ 0 ] ; offf ++ )
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / w") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / w") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        } ;
                            &tFileIn8z ,
                            &tFileIn8y ,
                            &tFileIn8x ,
                            &tFileIn3e ,
                        {
                        textC* pptFileIn[]=

                        TN( tFileIn8z , "" ) ; tFileIn8z = T("////factory8/z/archive")+T(psttName) ;
                        TN( tFileIn8y , "" ) ; tFileIn8y = T("////factory8/y/archive")+T(psttName) ;
                        TN( tFileIn8x , "" ) ; tFileIn8x = T("////factory8/x/archive")+T(psttName) ;
                        TN( tFileIn3e , "" ) ; tFileIn3e = T("////factory3/e/archive")+T(psttName) ;

                        ZE( fileWindowsC* , pFW ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / x") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / x") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        _IO_
                    {
                    else if( bFileArchive )
                    }
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / y") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / y") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        delF( tinP , pbIn ) ;
                        }
                            }
                                bClose = 1 ;
                                //traceF( tinP , T("etherDoHttpJobF: could not write to socket 1118") ) ;
                                POOPRqUIET
                            {
                            if( POOP )
                            psoP->writeF( tinP , pbIn , cbIn ) ;
                            psoP->writeF( tinP , (osTextT*)tReply , tReply.csF( tinP ) ) ;
                            SCOOPS
                        {
                        IFsCRATCH

                        TN( tReply , "" ) ; tReply = T("HTTP/1.1 200 OK\r\nServer: IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System (tm)\r\nContent-Type: text/plain\r\nContent-Length: ")+TF4(cbIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;

                        }
                            }
                                bClose = 1 ;
                                traceF( tinP , T("etherDoHttpJobF: could not get challenge file") ) ;
                                POOPRqUIET
                            {
                            if( POOP )
                            tinP.pEtScratch->boxGetShadowF( tinP , pbIn , cbIn , tFileIn ) ; ___( pbIn ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        ZE( countT , cbIn ) ;
                        ZE( byteT* , pbIn ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / z") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / z") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        TN( tFileIn , "" ) ; tFileIn = T("////" postCRAFTWORKfACTORY "/d/tmp/certbot.challenge")+T(psttName) ;
                        //                               "////" postCRAFTWORKfACTORY "/d/tmp/certbot.challenge/.well-known/acme-challenge
                        _IO_
                    {
                    else if( bFileChallenge )
                    }
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / A") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / A") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        //if( bClose ) traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    closing connection") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        delF( tinP , pbIcon ) ;

                        }
                            }
                                //U:: LATER, PURGE BY NUMBER OF PLATES, BY AGE, AND/OR BY SIZE

                                pzCache->pushF( tinP , psttn , pbBlob , cbBlob , maxAgeMsFileFavIcon , 0 ) ; // "0": "NOT LENGTH PREFIXED"

                                memCopyF( tinP , pbc , pbIcon           , cbIcon ) ;
                                memCopyF( tinP , pbc , (osTextT*)tReply , cbDo   ) ; pbc += cbDo ;
                                countT cbDo = cbBlob - cbIcon ;
                                byteT* pbc = pbBlob ;
                            {
                            if( pbBlob )
                            newF( tinP , LF , pbBlob , cbBlob ) ; ___( pbBlob ) ;
                            countT       cbBlob = tReply.csF( tinP ) + cbIcon ;
                            ZE( byteT* , pbBlob ) ;

                            strMakeF( tinP , LF , psttn , tNameCache ) ; ___( psttn ) ;
                            ZE( strokeS* , psttn ) ;
                            _IO_
                        {
                        if( pzCache && !bNoCacheStore )
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / B") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / B") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        }
                            }
                                bClose = 1 ;
                                traceF( tinP , T("etherDoHttpJobF: could not write to socket 980") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                POOPRqUIET
                            {
                            if( POOP )
                            psoP->writeF( tinP , pbIcon , cbIcon ) ;
                            psoP->writeF( tinP , (osTextT*)tReply , tReply.csF( tinP ) ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / C") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / C") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        TN( tReply , "" ) ; tReply = T("HTTP/1.1 200 OK\r\nServer: IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System (tm)\r\nContent-Type: image/x-icon\r\nContent-Length: ")+TF4(cbIcon,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;

                        boxGetShadowF( tinP , pbIcon , cbIcon , tFileFavIcon ) ; ___( pbIcon ) ;
                        ZE( countT , cbIcon ) ;
                        ZE( byteT* , pbIcon ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / D") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / D") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        _IO_
                    {
                    if( bFavIcon )
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / E") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                  //traceF( tinP , T("U:: etherDoHttpJobF / E") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                    }
                        TESTsCRATCH //U::TO FIND A BUG
                        _IO_
                    {
                    _IO_
                {
                else
                }
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / F") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                  //traceF( tinP , T("U:: etherDoHttpJobF / F") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    }
                        }
                            bClose = 1 ;
                            if( bDeadman1 || bDeadman2 ) traceF( tinP , T("etherDoHttpJobF: could not write to socket 96 [nnPeer]:    ")+T(jobP.nnPeer) , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                            POOPRqUIET
                        {
                        else
                        }
                            //traceF( tinP , T("etherDoHttpJobF: wrote reply from cache") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        {
                        if( !POOP )
                        psoP->writeF( tinP , pbzBlob , cbzBlob ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    TELL( "writing reply" ) ;

                    pzCache->ungrabF( tinP ) ;

                    ;
                        :        bytesBlob
                        ? POSTS( bytesBlob )
                    const byteT* pbzBlob = bPrefixed

                    ;
                        : pzCached->cbBlob
                        ? COSTS( bytesBlob )
                    countT cbzBlob = bPrefixed

                    boolT bPrefixed = pzCached->cArg ;

                    PrEF( bytesC , bytesBlob , ptr_pbBlob ) ;
                    POINTERc ptr_pbBlob = *pzCached->pPtr_pbBlob ;
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / G") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                  //traceF( tinP , T("U:: etherDoHttpJobF / G") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                    traceF( tinP , T("found in cache") ) ;
                    _IO_
                {
                if( pzCached )
                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / H") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                              //traceF( tinP , T("U:: etherDoHttpJobF / H") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                }
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / I") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                  //traceF( tinP , T("U:: etherDoHttpJobF / I") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    }
                        //traceF( tinP , T("NOT found in cache:    ")+tNameCache , bDeadman1 || bDeadman2 ? flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE : flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / J") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / J") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        pzCache->ungrabF( tinP ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / K") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / K") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    {
                    else
                    if( pzCached ) ; // traceF( tinP , T("found in cache:    ")+tNameCache , bDeadman1 || bDeadman2 ? flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE : flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    pzCached = (*pzCache)( tinP , tNameCache ) ;
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / L") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                  //traceF( tinP , T("U:: etherDoHttpJobF / L") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    //tinP.pcUtility[ 0 ] -- ; //U:: TO FIND A BUG
                    pzCache->grabF( tinP , TAG( TAGiDnULL ) ) ;
                    //tinP.pcUtility[ 0 ] ++ ; //U:: TO FIND A BUG
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / M") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                  //traceF( tinP , T("U:: etherDoHttpJobF / M") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                    traceF( tinP , T("querying cache") ) ;
                    _IO_
                {
                if( pzCache && !bNoCacheSearch )
                ZE( cachedS* , pzCached ) ;
                TESTsCRATCH //U::TO FIND A BUG
                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / N") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                              //traceF( tinP , T("U:: etherDoHttpJobF / N") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    request:    \"")+T(psttName)+T("\"")+(psttQueryKV?tb4+T(psttQueryKV):T("")) , bDeadman1 || bDeadman2 ? flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY : flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    request:    \"")+T(psttName)+T("\"")+(psttQueryKV?tb4+T(psttQueryKV):T("")) , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / O    ")+TT(timeElRead1,timeElRead2)+tb4+T(psttName) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                              //traceF( tinP , T("U:: etherDoHttpJobF / O    ")+TT(timeElRead1,timeElRead2)+tb4+T(psttName) , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                //traceF( tinP , T("reading began [timeRead]      :    ")+TTF(timeRead1,timeRead2)                      +tb4+T("reading began") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                //traceF( tinP , T("do job        [timeDoJob]     :    ")+TTF(jobP.timeDoJob1,jobP.timeDoJob2)          +tb4+T("do job")        , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                //traceF( tinP , T("job popped    [timeJobPopped] :    ")+TTF(jobP.timeJobPopped1,jobP.timeJobPopped2)  +tb4+T("job popped")    , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                //traceF( tinP , T("job created   [timeJobCreated]:    ")+TTF(jobP.timeJobCreated1,jobP.timeJobCreated2)+tb4+T("job created")   , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                //traceF( tinP , T("accepted      [timeAccepted]  :    ")+TTF(jobP.timeAccepted1,jobP.timeAccepted2)    +tb4+T("accepted")      , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                ;
                                : ifcIDtRACEdIVERT_7
                                ? ifcIDtRACEdIVERT_6
                            : !bFileArchive && !bFileChallenge
                            ? ifcIDtRACEdIVERT_5
                        : !strCompareF( tinP , psttName , tSlash )
                        ? ifcIDtRACEdIVERT_4
                    : !strCompareF( tinP , psttName , tSlashDeadman2 )
                    ? ifcIDtRACEdIVERT_3
                const countT idTraceDivert = !strCompareF( tinP , psttName , tSlashDeadman1 )
                //CS:CODEsYNC: 360021f7 3600212d

                }
                    bFileArchive   = 1 == strIdF( tinP , tPattern          , psttName ) ;
                    bFileChallenge = 1 == strIdF( tinP , tPatternChallenge , psttName ) ;

                    TN( tPatternChallenge , "/.well-known/acme-challenge/" ) ;
                    // "/.well-known/acme-challenge/ZkmjsTYwqPtrWqTRu-3VunoLb_X656Tg8iILtFL8ZWE"


                    ;

                        +S2(sa_SSSaNDeND,sc_ccSSS)
                            +T("/!ideafarm.")
                                +S2(sa_SSSoReND,sc_ccSSS)
                                    +T("x")                                                 // "x" IS ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
                                    +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
                                +S2(sa_SSSoR,sc_ccSSS)
                            +S3(3,sc_ccSSSrEPEAT,3)
                            +tSlash
                        +S2(sa_SSSaND,sc_ccSSS)
                        T("")

                    TN( tPattern , "" ) ; tPattern =
                    // "2013/!ideafarm."
                    //  yyyy
                    _IO_
                {
                if( !bDeadman1 && !bDeadman2 && psttName->idAdam )
                ZE( boolT , bFileArchive ) ;
                ZE( boolT , bFileChallenge ) ;

                }
                    break ;

                    traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                    traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                    traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                    traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                    traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                    traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_2 ) ;
                    if( bDeadman1 || bDeadman2 ) traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    //CS:CODEsYNC: 3300005b 3600212d

                    //}
                    //    }
                    //        if( POOP ) { POOPRqUIET ; }
                    //        tinP.pEtScratch->boxPutF( tinP , tListBlock , tSay , tSay.csF( tinP ) ) ;
                    //        SCOOPS
                    //    {
                    //    IFsCRATCH
                    //
                    //    TN( tSay , "blocked because readRequestF failed, which is attacker behavior" ) ;
                    //{
                    //if( !bHuman && !bWhite && !bWoMore )    //U::20200804@2120: I'VE SEEN THIS BLOCK FACTORY 3-5, SO THIS IS TOO STRICT; WITH THIS CODE, I AM BLOCKING INNOCENT PEERS
                    //
                    //boolT bWoMore = diskFileExistsF( tinP , tListAllowWoMore ) ;
                    //boolT bWhite  = diskFileExistsF( tinP , tListWhite  ) ;
                    //boolT bHuman  = diskFileExistsF( tinP , tListHuman  ) ;
                    //
                    //tListWhite += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(jobP.nnPeer) ;
                    //tListWhite += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(jobP.nnPeer) ;
                    //tListWhite += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(jobP.nnPeer) ;
                    //TlIST( tListWhite ) ;
                    //
                    //tListBlock += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(jobP.nnPeer) ;
                    //tListBlock += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(jobP.nnPeer) ;
                    //tListBlock += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(jobP.nnPeer) ;
                    //TlIST( tListBlock ) ;
                    //
                    //tListAllowWoMore += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(jobP.nnPeer) ;
                    //tListAllowWoMore += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(jobP.nnPeer) ;
                    //tListAllowWoMore += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(jobP.nnPeer) ;
                    //TlIST( tListAllowWoMore ) ;
                    //
                    //tListHuman += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(jobP.nnPeer) ;
                    //tListHuman += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(jobP.nnPeer) ;
                    //tListHuman += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(jobP.nnPeer) ;
                    //TlIST( tListHuman ) ;
                    _IO_
                {
                if( bFail )
                TESTsCRATCH //U::TO FIND A BUG

                //if( bDeadman1 || bDeadman2 ) traceF( tinP , T(psttName)+T(!bClose?"        connection will be kept open":"        CONNECTION WILL BE CLOSED") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                }
                    else if( timeElA2R1 > ( TICK >> 0xf ) ) traceF( tinP , T("deadman1 accept to reading ****f**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >> 0xe ) ) traceF( tinP , T("deadman1 accept to reading ****e**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >> 0xd ) ) traceF( tinP , T("deadman1 accept to reading ****d**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >> 0xc ) ) traceF( tinP , T("deadman1 accept to reading ****c**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >> 0xb ) ) traceF( tinP , T("deadman1 accept to reading ****b**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >> 0xa ) ) traceF( tinP , T("deadman1 accept to reading ****a**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   9 ) ) traceF( tinP , T("deadman1 accept to reading ****9**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   8 ) ) traceF( tinP , T("deadman1 accept to reading ****8**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   7 ) ) traceF( tinP , T("deadman1 accept to reading ****7**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   6 ) ) traceF( tinP , T("deadman1 accept to reading ****6**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   5 ) ) traceF( tinP , T("deadman1 accept to reading ****5**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   4 ) ) traceF( tinP , T("deadman1 accept to reading ****4**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   3 ) ) traceF( tinP , T("deadman1 accept to reading ****3**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   2 ) ) traceF( tinP , T("deadman1 accept to reading ****2**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   1 ) ) traceF( tinP , T("deadman1 accept to reading ****1**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   0 ) ) traceF( tinP , T("deadman1 accept to reading ****0**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                         if( timeElA2R2                   ) traceF( tinP , T("deadman1 accept to reading ****!**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                    osTimeSubtractF( tinP , timeElA2R1 , timeElA2R2 , jobP.timeAccepted1 , jobP.timeAccepted2 ) ;
                    sCountT timeElA2R2 = timeRead2 ;
                    countT  timeElA2R1 = timeRead1 ;

                    traceF( tinP , T("deadman1 reading began [idCycle,timeRead]      :    ")+T(psttQueryKV)+tb4+TTF(timeRead1,timeRead2)                      +tb4+T("reading began") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    traceF( tinP , T("deadman1 do job        [idCycle,timeDoJob]     :    ")+T(psttQueryKV)+tb4+TTF(jobP.timeDoJob1,jobP.timeDoJob2)          +tb4+T("do job")        , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    traceF( tinP , T("deadman1 job popped    [idCycle,timeJobPopped] :    ")+T(psttQueryKV)+tb4+TTF(jobP.timeJobPopped1,jobP.timeJobPopped2)  +tb4+T("job popped")    , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    traceF( tinP , T("deadman1 job created   [idCycle,timeJobCreated]:    ")+T(psttQueryKV)+tb4+TTF(jobP.timeJobCreated1,jobP.timeJobCreated2)+tb4+T("job created")   , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    traceF( tinP , T("deadman1 accepted      [idCycle,timeAccepted]  :    ")+T(psttQueryKV)+tb4+TTF(jobP.timeAccepted1,jobP.timeAccepted2)    +tb4+T("accepted")      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    _IO_
                {
                if( bDeadman1 )

                osTimeSubtractF( tinP , timeElRead1 , timeElRead2 , timeRead1 , timeRead2 ) ;
                sCountT timeElRead2 = timeStart2 ;
                countT  timeElRead1 = timeStart1 ;

                osTimeNowF( tinP , timeStart1 , timeStart2 ) ;
                ZE( sCountT , timeStart2 ) ;
                ZE( countT  , timeStart1 ) ;

                }
                    }
                        else if( bQuery    ) tNameCache += tQuest+T(psttQueryKV) ;
                        else if( bTalkBody ) tNameCache += bBadgeOk ? tNameCacheTalkBodySuffixPrivate : tNameCacheTalkBodySuffixPublic ;
                        if( bFavIcon ) ;

                        }
                            delF( tinP , psttLower ) ;
                            tNameCache = T(psttLower) ;
                            bFavIcon = !strCompareF( tinP , psttLower , tNameTestFavIcon ) ;
                            strConvertToLowerCaseF( tinP , psttLower , psttName ) ; ___( psttLower ) ;
                            ZE( strokeS* , psttLower ) ;
                        {                                   //CASE IS IGNORED FOR psttName WHEN SETTING tNameCache
                        _IO_
                    {
                    else
                    }
                        bClose = 1 ; //O:OPTIMIZATION
                        else                 idDesireOld = osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZY    ) ;
                        else if( bDeadman2 ) idDesireOld = osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIEST ) ;      // DEADMAN2 TESTS ARE TO DETECT THAT I AM OVERWHELMED
                             if( bDeadman1 ) idDesireOld = osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE    ) ;      // DEADMAN1 TESTS ARE TO DETECT THAT I AM DEAD
                        _IO_
                    {
                    if( bDeadman1 || bDeadman2 )                // DEADMAN QUERY IS SUPPRESSED IN tNameCache BECAUSE ITS ONLY FUNCTION IS TO UNIQUELY IDENTIFY THE DEADMAN REQUEST FOR TRACING / DEBUGGING

                    bTalkBody = !strCompareF( tinP , psttName  , tSlashTalkBody ) ;
                    bDeadman2 = !strCompareF( tinP , psttName  , tSlashDeadman2 ) ;
                    bDeadman1 = !strCompareF( tinP , psttName  , tSlashDeadman1 ) ;
                    _IO_
                {
                TN( tNameCache , psttName ) ;
                ZE( countT , idDesireOld ) ;
                ZE( boolT , bFavIcon ) ;
                ZE( boolT , bTalkBody ) ;
                ZE( boolT , bDeadman2 ) ;
                ZE( boolT , bDeadman1 ) ;
                const boolT bQuery = psttQueryKV && psttQueryKV->idAdam ;

                // LAZY   : CONSTRUCTING AND SERVING NONCACHED RESPONSES
                // NORMAL : GENERAL SERVER WORKLOAD
                // RUSH   : ACCEPTING CONNECTIONS, LAUNCHING MY THREAD, SERVING CACHED RESPONSES
                // RUDE   : SERVING DEADMAN
                // SCHEDULING PRIORITY

                pswKV->ungrabF( tinP ) ;
                }
                    }
                        traceF( tinP , T(bBadgeOk?"badge is ok":"badge is NOT ok") ) ;
                        }
                            bBadgeOk = meP.isBadgeOkF( tinP , badge , jobP.nnPeer ) ;
                            countT badge = strDigitsToSCountF( tinP , psttzv ) ;
                        {
                        else
                        }
                            if( jobP.nnPeer == nnMeP ) bBadgeOk = 1 ;       // ONLY I AM ALLOWED TO FORCE THE BADGE (SUPPRESS BADGE VALIDATION)
                        {
                        if( !strCompareF( tinP , psttzv , tBadgeForce ) )

                        strokeS* psttzv = (strokeS*)(countT&)*pswKV ;
                        psttLeverKV = tBadge ;
                        _IO_
                    {
                    if( pswKV->idSlotOfLeverF( tinP , (countT)(strokeS*)tBadge ) )

                    }
                        }
                            traceF( tinP , T("i have been told to not search the cache") ) ;
                            bNoCacheSearch = 1 ;
                        {
                        if( psttzv && !strCompareF( tinP , psttzv , tNo ) )
                        strokeS* psttzv = (strokeS*)(countT&)*pswKV ;
                        psttLeverKV = tCacheSearch ;
                        _IO_
                    {
                    if( pswKV->idSlotOfLeverF( tinP , (countT)(strokeS*)tCacheSearch ) )
                    _IO_
                {
                if( pswKV->cFlavorsF( tinP ) )
                pswKV->grabF( tinP , TAG( TAGiDnULL ) ) ;
                ZE( boolT , bBadgeOk ) ;
                ZE( boolT , bNoCacheStore  ) ;
                ZE( boolT , bNoCacheSearch ) ;

                //if( ++ cRequests == 0x10 ) bClose = 1 ;     // ATTACK PREVENTION (IN CONJUNCTION WITH CONNECTION RATE LIMIT)
                //U:: COMMENTED OUT TO FIND A BUG

                __NZ( psttName->idCaste - sc_PREFIXlENGTH ) ;  //U::20201021@1217: TO FIND A BUG: NULL CASTE DETECTED WITHIN getReplyF
                __Z(  psttName->idCaste                   ) ;  //U::20201021@1217: TO FIND A BUG: NULL CASTE DETECTED WITHIN getReplyF
                }
                    TESTsCRATCH //U::TO FIND A BUG
                    _IO_
                {

                traceF( tinP , T("U:: [psttQueryKV]:    ")+T(psttQueryKV) ) ;
                traceF( tinP , T("U:: [psttName]:       ")+T(psttName) ) ;

                if( bFail ) break ;

                ___( postBody ) ;
                ___( psttAgent ) ;
                ___( psttLeverKV ) ;
                ___( psttName ) ;
                }
                    idEscaped = meP.readRequestF( tinP , bFail , psttName , psttQueryKV , *pswKV , psttLeverKV , psttAgent , postBody , bClose , psoP , pHttpRawCommandServerCBFP ? "!@" : 0 ) ;
                    _IO_
                {
                //traceF( tinP , T("etherDoHttpJobF / calling readRequestF") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                ZE( boolT , bFail ) ;
                ZE( boolT , bClose ) ;
                ZE( osTextT* , postBody ) ;
                ZE( strokeS* , psttAgent ) ;
                ZE( strokeS* , psttQueryKV ) ;
                ZE( strokeS* , psttName ) ;
                TELL( "reading a request" ) ;
                TESTsCRATCH //U:: TO FIND A BUG

                osTimeNowF( tinP , timeRead1 , timeRead2 ) ;
                ZE( sCountT , timeRead2 ) ;
                ZE( countT  , timeRead1 ) ;
                _IO_
            {
            while( !third && !POOP )
            TESTsCRATCH //U:: TO FIND A BUG
            ZE( countT , cRequests ) ;
            const countT maxAgeMsNotFileNotTalkBody = osTimeToOldTimeMsF( tinP , TICK << 4 ) ;
            const countT maxAgeMsNotFileTalkBody    = osTimeToOldTimeMsF( tinP , TOCK << 2 ) ;
            const countT maxAgeMsFile               = osTimeToOldTimeMsF( tinP , TICK << 4 ) ;
            const countT maxAgeMsFileFavIcon        = osTimeToOldTimeMsF( tinP , - 1       ) ;
            const countT maxAgeDeadman              = osTimeToOldTimeMsF( tinP , - 1       ) ;
            ZE( sCountT , timeTotalPending2 ) ;
            ZE( countT  , timeTotalPending1 ) ;
            TN( tNo                             , "no"             ) ;
            TN( tCacheSearch                    , "cachesearch"    ) ;
            TN( tBadgeForce                     , "force"          ) ;
            TN( tBadge                          , "badge"          ) ;
            TN( tNameCacheTalkBodySuffixPrivate , "(private)"      ) ;
            TN( tNameCacheTalkBodySuffixPublic  , "(public)"       ) ;
            TN( tFileFavIcon                    , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/7reso.71000002.favicon.ico" ) ;
            TN( tNameTestFavIcon                , "/favicon.ico"   ) ;
            TN( tQuest                          , "?"              ) ;
            TN( tSlashTalkBody                  , "/talk.body"     ) ;
            TN( tSlash                          , "/"              ) ;
            ZE( countT , idEscaped ) ;
            //LOGrAW( T("------------------------- B E G I N   S E S S I O N -------------------------------------------------------\r\n") ) ;
            //CONoUTrAW( T("------------------------- B E G I N   S E S S I O N -------------------------------------------------------\r\n") ) ;

            }
                DEL( prPosts ) ;
                if( prPosts && COSTS( *prPosts ) ) psoP->writeF( tinP , POSTS( *prPosts ) , COSTS( *prPosts ) ) ;
                meP.getSnipF( tinP , prPosts , ifcIDsNIPpREDEFINED_HTTPcONTINUEwELCOME ) ; ___( prPosts ) ;
                ZE( pbRefC* , prPosts ) ;
            {
            if( pHttpRawCommandServerCBFP )

            cacheC* pzCache = meP.pzCacheF() ;

            puseC& pusePeanutP = *(puseC*)c8P.c1 ;
            count8S& c8P = *(count8S*)cArgAppP ;
            _IO_
        {
        else
        }
            traceF( tinP , T("etherDoHttpJobF / error: recycler failure") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
            traceF( tinP , T("etherDoHttpJobF / error: recycler failure") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
            traceF( tinP , T("etherDoHttpJobF / error: recycler failure") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
            traceF( tinP , T("etherDoHttpJobF / error: recycler failure") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
            traceF( tinP , T("etherDoHttpJobF / error: recycler failure") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
            traceF( tinP , T("etherDoHttpJobF / error: recycler failure") , flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_2 ) ;
            //CS:CODEsYNC: 3300005b 3600212d
            _IO_
        {
        if( !pswKV || !pswTally )
        TN( tSlashDeadman2    , "/deadman2" ) ;
        TN( tSlashDeadman1    , "/deadman1" ) ;
        TN( tb4 , "    " ) ;

        (*this)( tinP , pswTally , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , psttLeverUrlTally ) ; ___( pswTally ) ;
        ZE( switchC* , pswTally ) ;
        ZE( strokeS* , psttLeverUrlTally ) ;

        (*this)( tinP , pswKV , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , psttLeverKV ) ; ___( pswKV ) ;
        ZE( switchC* , pswKV ) ;
        ZE( strokeS* , psttLeverKV ) ;

        ZE( countT , cHamburgersThisSession ) ;
        ZE( countT , idPortPeer ) ;
        ZE( boolT , bOsFire ) ;

        if( !pHttpEatKeyValuePairsCBFP ) pHttpEatKeyValuePairsCBFP = httpEatKeyValuePairsDefaultCBF ;
        HTTPsYSpARAMS( jobP.cArg )

        //tinP.pAdamGlobal1->pEtThreadMain->etherTestF( tinP ) ; //U:: TO FIND A BUG

        //traceF( tinP , T("etherDoHttpJobF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
        //traceF( tinP , T("etherDoHttpJobF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
        //traceF( tinP , T("etherDoHttpJobF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
        //traceF( tinP , T("etherDoHttpJobF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
        //traceF( tinP , T("etherDoHttpJobF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
        //traceF( tinP , T("etherDoHttpJobF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
        //CS:CODEsYNC: 3300005b 3600212d

        //traceF( tinP , T("etherDoHttpJobF / ++++") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

        }
            TESTsCRATCH //U:: TO FIND A BUG
            _IO_
        {
        _IO_
    {
    if( jobP.cArg )
    //THREADmODE4oN( flTHREADmODE4_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY )

    _IO_
{
/*1*/voidT etherC::etherDoHttpJobF( tinS& tinP , taskDrivenServerJobS& jobP , socketC*& psoP , sessionC& sessionP , countT idPortMeP , nicNameC nnMeP )/*1*/

#define REPLY REF( httpReplyS , *pRefReply )

#define PUSHrEPLY(prPostP) PUSHK( REPLY.##prPostP ) ;

    }
        PUSHD( prPosts ) ;                                                                          \
        (meP).getSnipF( tinP , prPosts , (idSnipP) ) ; ___( prPosts ) ;                             \
        ZE( pbRefC* , prPosts ) ;                                                                   \
    {                                                                                               \
                                                                                                    \
#define PUSHsNIP(meP,idSnipP)                                                                       \

    }
        DEL( prDoomed )                                                                             \
        pbRefC* prDoomed = (prPostsP) ;                                                             \
        new( 0 , tinP , (byteT*)&(*pStkBody)[ - 1 ] , sizeof( pbRefC ) ) pbRefC( *prPostsP ) ;      \
        *pStkBody << (byteT*)0 ;                                                                    \
    {                                                                                               \
    if( prPostsP )                                                                                  \
                                                                                                    \
#define PUSHD(prPostsP)                                                                             \
//'D': "DELETE"

    }
        new( 0 , tinP , (byteT*)&(*pStkBody)[ - 1 ] , sizeof( pbRefC ) ) pbRefC( *prPostsP ) ;      \
        *pStkBody << (byteT*)0 ;                                                                    \
    {                                                                                               \
    if( prPostsP )                                                                                  \
                                                                                                    \
#define PUSHK(prPostsP)                                                                             \
//'K': "KEEP"

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

