
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bExisted ;

    }
        }
            delF( tinP , postShorter ) ;

            }
                __( bFail ) ;   // BOSpOOP IS NOT USED BECAUSE THE traceF CALLS RESET ERROR INFO

                }
                    TELL( postP ) ;
                    if( tinP.pEther ) tinP.pEther->traceF( tinP , T("dosCreateDirF / UNK FAIL: [postShorter,brcQuery]:    ")+T(postShorter)+T("    ")+TF2(tinP.brcQuery,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U::
                    bFail = 1 ;
                {
                else
                }
                    TELL( postP ) ;

                    BLAMMOiD( 0x11772299 ) ;
                    etRock.traceF( tinP , T("dosCreateDirF: traced  pool tallies; now calling BLAMMO") ) ;
                    etRock.tracePoolTalliesF( tinP ) ;
                    etRock.traceF( tinP , T("dosCreateDirF: tracing pool tallies") ) ;
                    etherC& etRock = etherC::etRockIF( tinP ) ;

                    if( tinP.pEther ) tinP.pEther->traceF( tinP , T("dosCreateDirF / ERROR_NOT_ENOUGH_MEMORY FAIL: [postShorter,brcQuery]:    ")+T(postShorter)+T("    ")+TF2(tinP.brcQuery,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U::
                    bFail = 1 ;
                {
                else if( tinP.brcQuery == ERROR_NOT_ENOUGH_MEMORY )
                }
                    if( tinP.pEther ) tinP.pEther->traceF( tinP , T("dosCreateDirF / ERROR_LOGON_FAILURE: [postShorter]:    ")+T(postShorter) ) ; //U::
                    bFail = 1 ;
                {
                else if( tinP.brcQuery == ERROR_LOGON_FAILURE )
                }
                    //if( tinP.pEther ) tinP.pEther->traceF( tinP , T("dosCreateDirF / EXISTED: [postShorter]:    ")+T(postShorter) ) ; //U::
                    bExisted = 1 ;
                {
                else if( tinP.brcQuery == ERROR_ALREADY_EXISTS )
                }
                    }
                        dosFindFileOrDirF( tinP , pInfoFile , handle , postShorter ) ; ___( pInfoFile ) ;
                        DEL( pInfoFile ) ;
                        }
                            tinP.bosFail = 0 ;
                            fFirst = 0 ;
                        {
                        if( fFirst )
                    {
                    while( pInfoFile )
                    dosFindFileOrDirF( tinP , pInfoFile , handle , postShorter ) ; ___( pInfoFile ) ;
                    boolT fFirst = 1 ;
                    handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                    //if( tinP.pEther ) tinP.pEther->traceF( tinP , T("dosCreateDirF / ACCESS DENIED: [postShorter]:    ")+T(postShorter) ) ;
                {
                if( tinP.brcQuery == ERROR_ACCESS_DENIED )
                ZE( boolT , bFail ) ;
            {
            if( tinP.bosFail )

            #endif
                }
                    BOS( WHATgbo , BOSoK , CreateDirectory( postShorter , &sa ) )
                    BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                    SECURITYaTTRIBUTE_saUNRESTRICTED( 0 ) ;
                {
            #elif defined( __NT__ )
                rc = tinP.brcRaw ;
                BOS( WHATsfw , BOSfAIL , DosCreateDir( postShorter , 0 ) )
            #ifdef __OS2__

            //if( tinP.pEther ) tinP.pEther->traceF( tinP , T("dosCreateDirF: [postShorter]:    ")+T(postShorter) ) ; //U::

            postShorter[ costP - 1 ] = 0 ;
            c_memcpyIF( tinP , postShorter , postP , costP - 1 ) ;
            newF( tinP , LF , postShorter , costP ) ; ___( postShorter ) ;
            ZE( osTextT* , postShorter ) ;
        {
        else
        }
            DEL( pInfo ) ;
            }
                __1 ;
                __( postP[ 0 ] ) ;
            {
            if( !bExisted )
            bExisted = !!pInfo ;
            //THIS ERROR DETECTION CODE IS NOW HARMLESS BUT OBSOLETED BY THE 20121001 EDIT OF dosQueryFSInfoF

            dosQueryFSInfoF( tinP , pInfo , ifFileNameC( tinP , *this , postP ) ) ; ___( pInfo ) ;
            ZE( infoDisk1S* , pInfo ) ;
        {
        if( postP[ 1 ] == ':' && !postP[ 3 ] )
    {
    ZE( boolT , bExisted ) ;
    _IO_

    }
        if( POOP ) return 0 ;
        __( postP[ costP - 1 ] - '\\' ) ;
        //__( postP[ 1 ] - ':' ) ;
        if( POOP ) return 0 ;
        __( costP < cMin ) ;
        countT cMin = postP[ 1 ] == ':' ? 3 : 2 ;
        if( POOP ) return 0 ;
        __( costP < 2 ) ;
        __Z( postP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP

    const countT costP = postP ? c_strlenIF( tinP , postP ) : 0 ;
{
/*1*/boolT thirdC::dosCreateDirF( tinS& tinP , const osTextT* const postP )/*1*/

/**/
*/
  "?:\\" (special case: i will verify that drive x exists
  example: "\\fooey\"
  enforces the ifc convention that requires each directory name to end with the delimiter character
 postP
arguments
  \<A HREF=\"5.8d00104.1.1.0.html\"\>8d00104:  WAKEsHOW( "example.simplest.func.102001b.thirdC.dosCreateDirF" )\</A\>
 simplest
examples
\<A HREF=\"5.102001b.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosCreateDirF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

