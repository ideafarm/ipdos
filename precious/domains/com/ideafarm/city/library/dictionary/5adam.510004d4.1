
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.strokeF( tinP , T("time per record in: ")+TT(timeB1,timeB2)+T("\r\n") ) ;
timeB1 /= c2i.c2 ;
etThread.strokeF( tinP , T("time per ")+TF1(c2i.c2)+T(" records in: ")+TT(timeB1,timeB2)+T("\r\n") ) ;
etThread.osTimeSubtractF( tinP , timeB1 , timeB2 , timeA1 , timeA2 ) ;
etThread.osTimeNowF( tinP , timeB1 , timeB2 ) ;
ZE( sCountT , timeB2 ) ;
ZE( countT , timeB1 ) ;

}
    ph->cbRead += cbThis ;

    if( pbc == pbEnd ) pbc = pbBegin ;
    pbc += cbThis ;

    }
        }
            }
                etThread.strokeF( tinP , T("in: ")+TF1(c2i.c2)+T("\r\n") ) ;
                pbic = pbi ;
            {
            if( pbic == pbie )
            *( pbic ++ ) = *( pbc2 ++ ) ;
        {
        while( pbc2 < pbc2e )
        const byteT* pbc2e = pbc + cbThis ;
        const byteT* pbc2  = pbc ;
    {

    countT cbThis = (sCountT)cbOver >= 0 ? cbNew - cbOver : cbNew ;
    countT cbOver = pbc + cbNew - pbEnd ;
    countT cbNew  = ph->cbWritten - ph->cbRead ;

    while( ph->cbWritten == ph->cbRead && !ether ) OSsLEEPf( 0x0 ) ;
{
while( !ether /* && c2i.c2 < 0x1000 */ )
const byteT* pbc = pbBegin ;

etThread.osTimeNowF( tinP , timeA1 , timeA2 ) ;
ZE( sCountT , timeA2 ) ;
ZE( countT , timeA1 ) ;

count2S& c2i = *(count2S*)pbi ;
byteT* pbic = pbi ;
byteT* pbie = pbi + sizeof pbi ;
byteT pbi[ sizeof( count2S ) ] ;

byteT* pbEnd   = pbBegin + CBmONITORbUFFER ;
byteT* pbBegin = (byteT*)ph + sizeof( napMonitorHeaderS ) ;
else if( napMonitor != cbMonitor ) { BLAMMO ; }
}
    napMonitor.formattingIsDoneF( tinP ) ;
    etThread.memSetF( tinP , (byteT*)ph , sizeof( napMonitorHeaderS ) ) ;
{
else if( !( F(napMonitor.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
if( !ph ) { BLAMMO ; }
napMonitorHeaderS* ph = (napMonitorHeaderS*)(byteT*)napMonitor ;
napkinC napMonitor( tinP , LF , (byteT*)bits , "napMonitor" , 0 , cbMonitor ) ;
bitsC bits( tinP , CbITSlIFI , 0 , 1 ) ;
const countT cbMonitor = sizeof( napMonitorHeaderS ) + CBmONITORbUFFER ;
BLAMMO ; //U:: FOR DEBUGGING, TO VERIFY THAT NO WO ACCESSES napMonitorG

TODO

/*1*/WAKEhIDE( "craft.monitor.read" )/*1*/
/**/
*/
i read the napkin written by 8d4
obsoleted by ad40104
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

