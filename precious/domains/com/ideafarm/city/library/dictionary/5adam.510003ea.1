
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    b_idBus.ungrabF( tinP ) ;
    }
        etThread.delF( tinP , pbv ) ;
        byteT* pbv = (byteT*)(countT)swValue ;
        idBus = swValue.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    cFlavors = swValue.cFlavorsF( tinP ) ;
    b_idBus.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        etThread.delF( tinP , pc6z ) ;
        stZombie >> pc6z ;
        ZE( count6S* , pc6z ) ;
    {
    while( !etThread && stZombie )

    while( !etThread && etThread.os_cAllKidThreadsI_IF( tinP ) ) etThread.osSleepF( tinP , TOCK ) ;

    b_idBus.ungrabF( tinP ) ;
    }
        }
            etThread.delF( tinP , pc5s ) ;
            if( pc5s ) { DEL( (nicNameC*&)pc5s->c2 ) ; }
            swsSub >> pc5s ;
            ZE( count5S* , pc5s ) ;
        {
        while( !etThread && swsSub )

        idBus = swsSub.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swsSub.cFlavorsF( tinP ) ;
    b_idBus.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        if( etThread ) etThread = 0 ;
        }
            DEL( pso ) ;
            if( !ether && !etThread && pso ) serveF( tinP , etThread , *pso , idBus , b_idBus , swsSub , stZombie , swValue ) ;
            socket.acceptF( tinP , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            ZE( socketC* , pso ) ;
        {
        while( !ether && !etThread )
        socket.listenF( tinP ) ;
        socket.bindF( tinP , ifcPORToLD1bUSsERVER ) ;
        socketC socket( tinP , etThread , TAG( TAGiDnULL ) ) ;
    {
    while( !ether && !etThread )

    switchC swValue( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idBus ) ;
    stackC stZombie( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count6S ) ;
    switchStackC swsSub( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idBus , flSTACKc_null , ifcSTACKtYPE_PTR_count5S ) ; // "SUBSCRIBER"
    batonC b_idBus( tinP , TAG( TAGiDnULL ) ) ;
    ZE( countT , idBus ) ;

    etThread.strokeF( tinP , T("IdeaFarm " "(tm) City Bus Server\r\ni synchronize fast memory across hosts\r\n") ) ;
{
else
}
    etThread.strokeF( tinP , T("Another ")+textIdFileC(tinP,DDNAME)+T(" appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tinP , TAG( TAGiDnULL ) , T("ce30104") ) ;

TODO

}
    b_idBusP.ungrabF( tinP ) ;
    }
        }
            break ;

            broadcastF( tinP , etThread , stZombieP , swsSubP , idBusP , 2 * sizeof( countT ) + cbv , pbv ) ;

            swValueP = (countT)pbv ;
            }
                if( cbv ) sockP.readF( tinP , pbv + 2 * sizeof( countT ) , cbv ) ;
                ((countT*)pbv)[ 1 ] = cbv ;
                ((countT*)pbv)[ 0 ] = idCmd ;
            {
            if( pbv )
            etThread.newF( tinP , LF , pbv , 2 * sizeof cbv + cbv ) ; ___( pbv ) ;

            sockP.readF( tinP , (byteT*)&cbv , sizeof cbv ) ;
            ZE( countT , cbv ) ;

            etThread.delF( tinP , pbv ) ;
            swValueP = 0 ;
            byteT* pbv = (byteT*)(countT)swValueP ;
        {
        case idCMDbUS_WRITE :
        }
            break ;

            broadcastF( tinP , etThread , stZombieP , swsSubP , idBusP , sizeof c2o , (byteT*)&c2o ) ;
            count2S c2o( idCMDbUS_GOODbYE , swsSubP ) ;
        {
        case idCMDbUS_GOODbYE :
        }
            break ;

            broadcastF( tinP , etThread , stZombieP , swsSubP , idBusP , sizeof c2o , (byteT*)&c2o ) ;
            count2S c2o( idCMDbUS_HELLO , swsSubP ) ;

            }
                if( pbv ) sockP.writeF( tinP , pbv , 2 * sizeof( countT ) + ((countT*)pbv)[ 1 ] ) ;
                __Z( pbv ) ;

                }
                    swValueP = (countT)pbv ;

                    }
                        ((countT*)pbv)[ 1 ] = 0 ;
                        ((countT*)pbv)[ 0 ] = 0 ;
                    {
                    if( pbv )
                    etThread.newF( tinP , LF , pbv , 2 * sizeof cbv ) ; ___( pbv ) ;
                    ZE( countT , cbv ) ;
                {
                if( !pbv )
                byteT* pbv = (byteT*)(countT)swValueP ;

                }
                    swsSubP.sinkF( tinP , idSlot , pc5s ) ;
                    ZE( countT , idSlot ) ;

                    if( pNicName ) *pNicName = nicNameC( nicName ) ;
                    etThread.newF( tinP , LF , pNicName ) ; ___( pNicName ) ;
                    pNicName = 0 ;
                    nicNameC*& pNicName = (nicNameC*&)pc5s->c2 ;
                    pc5s->c1 = idPort ;
                {
                if( pc5s )
                etThread.newF( tinP , LF , pc5s ) ; ___( pc5s ) ;
                ZE( count5S* , pc5s ) ;

                sockP.readF( tinP , (byteT*)&idPort , sizeof idPort ) ;
                sockP.peerNameF( tinP , idPort , nicName ) ;
                nicNameC nicName ;
                ZE( countT , idPort ) ;
            {
        {
        case idCMDbUS_SUBSCRIBE :
    {
    switch( idCmd )

    sockP.readF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;
    ZE( countT , idCmd ) ;

    sockP.readF( tinP , (byteT*)&idBusP , sizeof idBusP ) ;
    b_idBusP.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT serveF( tinS& tinP , etherC& etThread , socketC& sockP , countT& idBusP , batonC& b_idBusP , switchStackC& swsSubP , stackC& stZombieP , switchC& swValueP )

}
    }
        while( !etThread && handle ) ;
        }
            }
                }
                    { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmCastF , 0 , flTHREADlAUNCH_null , 0 , (countT)&stZombieP , pc5s->c1 , (countT)pNicName , idBusP , cbP , (countT)pbo ) ; }
                    *pNicName = *(nicNameC*&)pc5s->c2 ;
                {
                if( pNicName )
                etThread.newF( tinP , LF , pNicName ) ; ___( pNicName ) ;
                ZE( nicNameC* , pNicName ) ;

                etThread.memCopyF( tinP , pbo , pbP , cbP ) ;
                etThread.newF( tinP , LF , pbo , cbP ) ;
                ZE( byteT* , pbo ) ;
            {
            if( pc5s && pc5s->c1 && pc5s->c2 )
            count5S* pc5s = (count5S*)swsSubP.downF( tinP , handle ) ;
        {
        do
        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( swsSubP )

    removeZombiesF( tinP , etThread , swsSubP , idBusP , stZombieP ) ;
{
voidT broadcastF( tinS& tinP , etherC& etThread , stackC& stZombieP , switchStackC& swsSubP , countT& idBusP , const countT cbP , const byteT* const pbP )

}
    idBusP = idBusSave ;

    }
        }
            socko.writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;
            countT idCmd = idCMDbUS_GOODbYE ;

            socko.writeF( tinP , (byteT*)&idBusP , sizeof idBusP ) ;

            socko.connectF( tinP , ifcPORToLD1bUSsERVER ) ;
            socketC socko( tinP , etThread , TAG( TAGiDnULL ) ) ;
        {
        if( sw_cZombies )
        idBusP = sw_cZombies.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = sw_cZombies.cFlavorsF( tinP ) ;

    }
        }
            etThread.delF( tinP , pc6z ) ;
            }
                etThread.delF( tinP , pc5s ) ;
                if( pc5s ) { DEL( (nicNameC*&)pc5s->c2 ) ; }
                count5S* pc5s = (count5S*)swsSubP.extractF( tinP , idSlot ) ;
                ( (countT&)sw_cZombies ) ++ ;
            {
            if( idSlot )
            countT idSlot = swsSubP( c5s ) ;
            count5S c5s( pc6z->c2 , pc6z->c3 , pc6z->c4 , pc6z->c5 , pc6z->c6 ) ;
            idBusP  = pc6z->c1 ;
        {
        if( pc6z )

        __Z( pc6z ) ;
        stZombieP >> pc6z ;
        ZE( count6S* , pc6z ) ;
    {
    while( !etThread && stZombieP )
    switchC sw_cZombies( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idBusP ) ;

    countT idBusSave = idBusP ;
{
voidT removeZombiesF( tinS& tinP , etherC& etThread , switchStackC& swsSubP , countT& idBusP , stackC& stZombieP )

DONE( tmCastF )

}
    }
        }
            }
                __Z( idSlot ) ;
                stZombie.sinkF( tinP , idSlot , pc6z ) ;
                ZE( countT , idSlot ) ;

                *(nicNameC*)&pc6z->c3 = *pNicName ;
                pc6z->c2 = idPort ;
                pc6z->c1 = idBus ;
            {
            if( pc6z )
            etThread.newF( tinP , LF , pc6z ) ;
            ZE( count6S* , pc6z ) ;

            etThread.delF( tinP , psttl ) ;
            etThread.etherGetLogF( tinP , psttl ) ; ___( psttl ) ;
            ZE( strokeS* , psttl ) ;

            etThread = 0 ;
        {
        if( etThread )

        }
            etThread.delF( tinP , pbo ) ;
            socko.writeF( tinP , pbo , cbo ) ;
            socko.connectF( tinP , idPort , *pNicName ) ;
            socketC socko( tinP , etThread , TAG( TAGiDnULL ) ) ;
        {
    {
    if( !ether && !etThread )

    __Z( pbo ) ;
    __Z( cbo ) ;
    __Z( idBus ) ;
    __Z( idPort ) ;

    byteT*   pbo      = (byteT*)  pTaskP->c6 ;
    countT   cbo      =           pTaskP->c5 ;
    countT   idBus    =           pTaskP->c4 ;
    nicNameC* pNicName  = (nicNameC*)pTaskP->c3 ;
    countT   idPort   =           pTaskP->c2 ;
    stackC&  stZombie = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )

TASK( tmCastF )

/*1*/WAKEhIDE( "city.bus.server" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

