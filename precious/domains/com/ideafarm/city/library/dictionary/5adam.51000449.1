
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

CELL( jobFillCourseF , jobHearOrderF , 0 )

}
    if( ether && *tinP.zEtScratch && cArgP && c8argP.c1 && sDataP && sNotesTextP && sNotesDataP && idChatSessionP ) ;

    }
        }
            break ;

            }
                }
                    break ;
                    etThread.delF( tinP , psttJobType ) ;

                    else __1
                    }
                        etThread.delF( tinP , psttTitle ) ;
                        etThread.delF( tinP , psttFrom ) ;

                        }
                            etThread.boxPutF( tinP ,  T("ideafarm.com//smtp/")+T(DDNUMB)+T("/")+T(psttFrom) , tm , tm.csF( tinP ) ) ;

                            tm += T("sd:   ")+TF2(sd,flFORMAT_EXPONENT)+T("\r\n\r\n") ;
                            tm += T("mean: ")+TF2(mean,flFORMAT_EXPONENT)+T("\r\n\r\n") ;
                            tm += T("max:  ")+TF2(max,flFORMAT_EXPONENT)+T("\r\n\r\n\r\n\r\n") ;
                            tm += T("oc8:  ")+TF2(oc8,flFORMAT_EXPONENT)+T("\r\n\r\n") ;
                            tm += T("oc7:  ")+TF2(oc7,flFORMAT_EXPONENT)+T("\r\n\r\n") ;
                            tm += T("oc6:  ")+TF2(oc6,flFORMAT_EXPONENT)+T("\r\n\r\n") ;
                            tm += T("oc5:  ")+TF2(oc5,flFORMAT_EXPONENT)+T("\r\n\r\n") ;
                            tm += T("oc4:  ")+TF2(oc4,flFORMAT_EXPONENT)+T("\r\n\r\n") ;
                            tm += T("oc3:  ")+TF2(oc3,flFORMAT_EXPONENT)+T("\r\n\r\n") ;
                            tm += T("oc2:  ")+TF2(oc2,flFORMAT_EXPONENT)+T("\r\n\r\n") ;
                            tm += T("oc1:  ")+TF2(oc1,flFORMAT_EXPONENT)+T("\r\n\r\n") ;
                            tm += T("min:  ")+TF2(min,flFORMAT_EXPONENT)+T("\r\n\r\n") ;
                            tm += T("cObs: ")+TF1((countT)stObs)+T("\r\n\r\n\r\n\r\n") ;

                            tm += T("batch title: \"")+T(psttTitle)+T("\"\r\n\r\n") ;
                        {
                        if( bMail )

                        ;

                            "\r\n")
                            T("subject: [ifc] univariate statistician's report: ")+T(psttTitle)+T("\r\n"

                           //================================================================================================================================

                        if( bMail ) tm =
                        TN( tm , "" ) ;

                        const boolT bMail = !stJobTo ;

                        measureT sd   = ((thirdC&)etThread).c_sqrtF( tinP , bmSumSq / cObs ) ;
                        measureT mean = bmSum / cObs ;

                        measureT oc8  = cObs >= 1 ? stObs[ 8 * cObs / 8 ] : 0 ;
                        measureT oc7  = cObs >= 2 ? stObs[ 7 * cObs / 8 ] : 0 ;
                        measureT oc6  = cObs >= 2 ? stObs[ 6 * cObs / 8 ] : 0 ;
                        measureT oc5  = cObs >= 2 ? stObs[ 5 * cObs / 8 ] : 0 ;
                        measureT oc4  = cObs >= 2 ? stObs[ 4 * cObs / 8 ] : 0 ;
                        measureT oc3  = cObs >= 3 ? stObs[ 3 * cObs / 8 ] : 0 ;
                        measureT oc2  = cObs >= 4 ? stObs[ 2 * cObs / 8 ] : 0 ;
                        measureT oc1  = cObs >= 8 ? stObs[ 1 * cObs / 8 ] : 0 ; //ON EACH LINE, THE CONDITION ON cObs ENSURES THAT THE [] ARGUMENT IS NOT 0

                        measureT max  = cObs ? stObs[ - 1 ] : 0 ;
                        measureT min  = cObs ? stObs[   1 ] : 0 ;
                        countT   cObs = stObs ;

                        }
                            }
                                bmSumSq += bmi * bmi ;
                                bmSum   += bmi ;
                                stObs.sinkF( tinP , countTC() , (countT)bmi ) ; //U: SINK THE MEASURE VALUE (WHEN stackC SUPPORTS THIS)
                                sOrderP >> bmi ;
                                ZE( measure04T , bmi ) ;
                            {
                            while( cObs -- )
                            sOrderP >> cObs ;
                            ZE( countT , cObs ) ;
                        {
                        stackC stObs( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null /*U:: , ifcSTACKtYPE_measureT */ ) ;
                        ZE( measure04T , bmSumSq ) ;
                        ZE( measure04T , bmSum   ) ;

                        while( etThread.strConcatenateF( tinP , psttTitle , 0 , tBlank ) ) ;
                        TN( tBlank , " " ) ;
                        sOrderP >> psttTitle ; ___( psttTitle ) ;
                        ZE( strokeS* , psttTitle ) ;

                        sOrderP >> psttFrom ; ___( psttFrom ) ;
                        ZE( strokeS* , psttFrom ) ;

                        }
                            }
                                stJobTo << idAdamJobTo ;
                                __Z( idAdamJobTo ) ;
                                sOrderP >> idAdamJobTo ;
                                ZE( countT , idAdamJobTo ) ;
                            {
                            while( cJobTo -- )
                            sOrderP >> cJobTo ;
                            ZE( countT , cJobTo ) ;
                        {
                        stackC stJobTo( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;

                        __( idVersion - 1 ) ;
                        sOrderP >> idVersion ;
                        ZE( countT , idVersion ) ;
                    {
                    if( !etThread.strCompareF( tinP , psttJobType , T("!batchOfUnivariate") ) )

                    sOrderP >> psttJobType ; ___( psttJobType ) ;
                    ZE( strokeS* , psttJobType )
                {
                case ifcIDcMDjOBoRDER_NAMED :
                }
                    break ;

                    etThread.delF( tinP , psttBody ) ;
                    etThread.delF( tinP , psttFrom ) ;

                    }
                        etThread.delF( tinP , postBody ) ;
                        etThread.delF( tinP , psttu ) ;
                        etThread.boxPutUniqueF( tinP , psttu , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(DDNUMB)+T("/in/ignored/in") , postBody , costBody ) ;
                        ZE( strokeS* , psttu ) ;

                        countT costBody = etThread.strMakeF( tinP , LF , postBody , psttBody ) ; ___( postBody ) ;
                        ZE( osTextT* , postBody ) ;
                    {

                    sOrderP >> psttBody ; ___( psttBody ) ;
                    ZE( strokeS* , psttBody ) ;

                    __( idAdamTo - DDNUMB ) ;
                    __Z(  idAdamTo ) ;
                    sOrderP >> idAdamTo ;
                    ZE( countT , idAdamTo ) ;

                    __(  psttFrom && !psttFrom->idAdam ) ;
                    __Z( psttFrom ) ;
                    sOrderP >> psttFrom ; ___( psttFrom ) ;
                    ZE( strokeS* , psttFrom ) ;
                {
                case ifcIDcMDjOBoRDER_MAIL :
            {
            switch( idJobType )

            sOrderP >> idJobType ;
            ZE( countT , idJobType ) ;
        {
        case 1 :
    {
    switch( idCourseP )

    __( idAdamP - DDNUMB ) ;
{
voidT jobFillCourseF( tinS& tinP , etherC& ether , etherC& etThread , soulC& sDataP , soulC& sNotesTextP , soulC& sNotesDataP , const countT idCourseP , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

}
    if( cArgP && c8argP.c1 && sOrderP && ether && *tinP.zEtScratch && idChatSessionP ) ;

    __( idAdamP - DDNUMB ) ;
{
voidT jobHearOrderF( tinS& tinP , etherC& ether , etherC& etThread , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

/*1*/WAKEhIDE( "sentient.statistician.univariate" )/*1*/
/**/
*/
\<A HREF=\"5.c440104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

