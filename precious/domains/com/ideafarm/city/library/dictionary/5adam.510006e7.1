
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    etThread.traceF( tinP , T("song duration [seconds]: ")+TF4((countT)((measureT)cFrames/27.8),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;

    }
        DEL( pInfo ) ;
        }
            cFrames = cbNet / cbFrame ;
            countT cbNet = pInfo->cbUsed - cbFileTag ;
        {
        if( pInfo )
        etThread.diskFileQueryF( tinP , pInfo , fi ) ; ___( pInfo ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    ZE( countT , cFrames ) ;

    }
        }
            }
                else if( pbTock[ 0 ] == 0xff ) bArmed = 1 ;
                }
                    }
                        }
                            break ;
                            cbFrame = cbRead - 2 ;
                        {
                        if( cSyncFound == 2 )

                        __( cSyncFound == 1 && cbRead > 2 ) ;
                        cSyncFound ++ ;
                    {
                    if( pbTock[ 0 ] & 0xe0 == 0xe0 )

                    bArmed = 0 ;
                {
                if( bArmed )

                etThread.fileReadF( tinP , pbTock , cbr , fi , 0 ) ; cbRead ++ ;
            {
            while( !POOP )
            ZE( countT , cSyncFound ) ;
            boolT bArmed = 1 ;  // I KNOW THAT THE CURRENT BYTE IS 0xff AND THAT IT MUST BE A SYNC BYTE
            countT cbRead = 1 ;
            cbr = 1 ;
        {

        //RULE: THE SYNC VALUE IS 11 CONSECUTIVE BITS SET TO 1, BEGINNING AT A BYTE BOUNDARY
        //DETERMINE FRAME SIZE BY LOOKING FOR SYNC VALUES
    {
    if( !POOP )
    ZE( countT , cbFrame ) ;

    __( pbTock[ 0 ] != 0xff ) ;

    }
        etThread.fileReadF( tinP , pbTock , cbr , fi , 0 ) ; // LOAD THE WOTH BYTE OF THE WOTH SYNC
        cbr = 1 ;

        }
            }
                }
                    cbToDo -= cbWo ;
                    etThread.fileReadF( tinP , pbTock , cbr , fi , 0 ) ;
                    cbr = cbWo ;

                    ;
                        : cbToDo
                        ? sizeof pbTock
                    countT cbWo = cbToDo > sizeof pbTock
                {
                while( cbToDo )
                countT cbToDo = cbId3 ;
            {
            else
            }
                etThread.fileReadF( tinP , pbTock , cbr , fi , 0 ) ;
                cbr = cbId3 ;
            {
            if( cbId3 <= sizeof pbTock )
        {
        if( !POOP )

        cbFileTag += cbId3 ;
        }
            __Z( cbId3 ) ;

            cbId3 |= size4 << 0x15 ;
            cbId3 |= size3 << 0xe ;
            cbId3 |= size2 << 0x7 ;
            cbId3 |= size1 ;

            countT size1 = pbTock[ 9 ] ;
            countT size2 = pbTock[ 8 ] ;
            countT size3 = pbTock[ 7 ] ;
            countT size4 = pbTock[ 6 ] ;
        {
        if( !POOP )
        ZE( countT , cbId3 ) ;

        __Z( cbr == 0x9 && pbTock[ 0 ] == 'I' && pbTock[ 1 ] == 'D' && pbTock[ 2 ] == '3' ) ;

        cbFileTag += cbr ;
        etThread.fileReadF( tinP , pbTock + 1 , cbr , fi , 0 ) ;
        cbr = 0x9 ;
        cbFileTag = 1 ;
    {
    if( pbTock[ 0 ] != 0xff ) // IF NOT A SYNC BYTE
    ZE( countT , cbFileTag ) ;

    etThread.fileReadF( tinP , pbTock , cbr , fi , 0 ) ;
    countT cbr = 1 ;

    byteT pbTock[ TOCK ] ;

    fileC fi( tinP , (strokeS*)T("///d/tmp/x/test2.mp3") , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 0 ) ;
{

TODO

;
}
    countT idSync            : 11 ;
    countT idVersion         : 2  ;
    countT idLayer           : 2  ;
    countT bNoCRC            : 1  ;
    // 2-3: NET-MSB

    countT idBitRate         : 4  ;
    countT idSamplingRate    : 2  ;
    countT bPadded           : 1  ;
    countT bPrivate          : 1  ;
    // 1

    countT idChannelMode     : 2  ;
    countT idModeExtension   : 2  ;
    countT bCopyright        : 1  ;
    countT bOriginal         : 1  ;
    countT idEmphasis        : 2  ;
    // 0: NET-LSB
{
struct frameHeadS

/*1*/WAKEsHOWtEXT( "doodle.mp3" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

