
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            }
                }
                    }
                        default      : { __1 break ; }
                        case _CT1_0f : { nicNameC* pvv = (nicNameC*)pbcP ; newObjectF( tinP , *pvv ) ; pbcP += processGlobal1I.cb_nicNameC_ ; break ; }
                        case _CT1_0e : { count8S* pvv = (count8S*)pbcP ; newObjectF( tinP , *pvv ) ; pbcP += sizeof( count8S ) ; break ; }
                        case _CT1_0d : { count7S* pvv = (count7S*)pbcP ; newObjectF( tinP , *pvv ) ; pbcP += sizeof( count7S ) ; break ; }
                        case _CT1_0c : { count6S* pvv = (count6S*)pbcP ; newObjectF( tinP , *pvv ) ; pbcP += sizeof( count6S ) ; break ; }
                        case _CT1_0b : { count5S* pvv = (count5S*)pbcP ; newObjectF( tinP , *pvv ) ; pbcP += sizeof( count5S ) ; break ; }
                        case _CT1_0a : { count4S* pvv = (count4S*)pbcP ; newObjectF( tinP , *pvv ) ; pbcP += sizeof( count4S ) ; break ; }
                        case _CT1_09 : { count3S* pvv = (count3S*)pbcP ; newObjectF( tinP , *pvv ) ; pbcP += sizeof( count3S ) ; break ; }
                        case _CT1_08 : { count2S* pvv = (count2S*)pbcP ; newObjectF( tinP , *pvv ) ; pbcP += sizeof( count2S ) ; break ; }
                        case _CT1_06 : { ZE( measureT , vv ) ; GET( vv ) ; newObjectF( tinP , vv ) ; break ; }
                        case _CT1_05 : { ZE( sCountT , vv )  ; GET( vv ) ; newObjectF( tinP , vv ) ; break ; }
                        case _CT1_04 : { ZE( countT , vv )   ; GET( vv ) ; newObjectF( tinP , vv ) ; break ; }
                        }
                            break ;
                            }
                                ptbl->readF( tinP , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , pbcP , pbeP ) ;
                                ZE( byteT* , pbToDelete ) ;
                                newObjectF( tinP , *ptbl ) ;
                            {
                            if( ptbl )
                            stTablesToDeleteP << (countT)ptbl ;
                            tableC* ptbl = new( 0 , tinP , LF ) tableC( tinP , ether ) ; ___( ptbl ) ; //U: READ tableC CONSTRUCTION ARGUMENTS FROM THE FILE
                        {
                        case _CT1_01 :

                    {
                    switch( idType )
                {
                else
                }
                    }
                        /*default      :*/ { __1 /*break ;*/ }
                    {
                    //switch( idType )
                    idType &= ~_CT2_2 ;
                {
                else if( idType & _CT2_2 )
                }
                    }
                        default      : { __1 break ; }
                        case _CT1_07 : { strokeS* pstti = (strokeS*)pbcP ; newObjectF( tinP , pstti ) ; pbcP += ( CSpREFIX + pstti->idAdam ) * sizeof( strokeS ) ; break ; }
                    {
                    switch( idType )
                    idType &= ~_CT2_1 ;
                {
                else if( idType & _CT2_1 )
                }
                    }
                        }
                            }
                                }
                                    default      : { __1 break ; }

                                    case _CT1_0f : { nicNameC* pvv = new( 0 , tinP , LF ) nicNameC ; if( pvv ) { GETNN( *pvv ) ; *pstk << pvv           ; } break ; }
                                    case _CT1_0e : { count8S* pvv = new count8S ; if( pvv ) { GET( *pvv ) ; *pstk << pvv           ; } break ; }
                                    case _CT1_0d : { count7S* pvv = new count7S ; if( pvv ) { GET( *pvv ) ; *pstk << pvv           ; } break ; }
                                    case _CT1_0c : { count6S* pvv = new count6S ; if( pvv ) { GET( *pvv ) ; *pstk << pvv           ; } break ; }
                                    case _CT1_0b : { count5S* pvv = new count5S ; if( pvv ) { GET( *pvv ) ; *pstk << pvv           ; } break ; }
                                    case _CT1_0a : { count4S* pvv = new count4S ; if( pvv ) { GET( *pvv ) ; *pstk << pvv           ; } break ; }
                                    case _CT1_09 : { count3S* pvv = new count3S ; if( pvv ) { GET( *pvv ) ; *pstk << pvv           ; } break ; }
                                    case _CT1_08 : { count2S* pvv = new count2S ; if( pvv ) { GET( *pvv ) ; *pstk << pvv           ; } break ; }
                                    case _CT1_06 : { ZE( measureT , vv )                  ; GET( vv   ) ; *pstk << *(countT*)&vv ;   break ; }
                                    case _CT1_05 : { ZE( sCountT , vv )                   ; GET( vv   ) ; *pstk << *(countT*)&vv ;   break ; }
                                    case _CT1_04 : { ZE( countT , vv )                    ; GET( vv   ) ; *pstk << vv            ;   break ; }
                                    }
                                        break ;
                                        }
                                            ptbl->readF( tinP , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , pbcP , pbeP ) ;
                                            ZE( byteT* , pbToDelete ) ;
                                            newObjectF( tinP , *ptbl ) ;
                                        {
                                        if( ptbl )
                                        stTablesToDeleteP << (countT)ptbl ;
                                        tableC* ptbl = new( 0 , tinP , LF ) tableC( tinP , ether ) ; ___( ptbl ) ; //U: READ tableC CONSTRUCTION ARGUMENTS FROM THE FILE
                                    {
                                    case _CT1_01 :
                                {
                                switch( idType )
                            {
                            else
                            }
                                }
                                    /*default      :*/ { __1 /*break ;*/ }
                                {
                                //switch( idType )
                                idType &= ~_CT2_2 ;
                            {
                            else if( idType & _CT2_2 )
                            }
                                }
                                    default      : { __1 break ; }
                                    case _CT1_07 : { strokeS* pstti = (strokeS*)pbcP ; newObjectF( tinP , pstti ) ; pbcP += ( CSpREFIX + pstti->idAdam ) * sizeof( strokeS ) ; break ; }
                                {
                                switch( idType )
                                idType &= ~_CT2_1 ;
                            {
                            if( idType & _CT2_1 )
                        {
                        while( cPlates -- )

                        newObjectF( tinP , *pstk ) ;
                    {    
                    if( pstk )
                    stStacksToDeleteP << (countT)pstk ;
                    stackC* pstk = new( 0 , tinP , LF ) stackC( tinP , ether , TAG( TAGiDnULL ) , flagsStk , idTypeStk ) ; ___( pstk ) ;

                    GET( cPlates ) ;
                    GET( idTypeStk ) ;
                    GET( flagsStk ) ;
                    ZE( countT , cPlates ) ;
                    ZE( countT , idTypeStk ) ;
                    ZE( flagsT , flagsStk ) ;

                    idType &= ~_CT2_3 ;
                {
                if( idType & _CT2_3 )

                GET( idType ) ;
                ZE( countT , idType ) ;
            {
            for( countT idc = 1 ; idc <= cCols ; idc ++ )

            newEventF( tinP ) ;
        {
        for( countT idr = 1 ; idr <= cRowsNew ; idr ++ )
    {
    if( !ether )

    }
        __( cColsNew - cCols ) ;
        }
            cCols = stNames ;
            while( cTries -- ) newColF( tinP ) ;
            countT cTries = cColsNew ;
        {
        if( !stNames )

        GET( cColsNew ) ;
        ZE( countT , cColsNew ) ;
    {
    ZE( countT , cCols ) ;

    GET( cRowsNew ) ;
    ZE( countT , cRowsNew ) ;

    _IO_

    }
        if( POOP ) return ;
        __( pbeP - pbcP < 2 * sizeof( countT ) ) ;
        __( pbcP >= pbeP ) ;
        __Z( pbeP ) ;
        __Z( pbcP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT tableC::readF( tinS& tinP , stackC& stStringsOfBytesToDeleteP , stackC& stTablesToDeleteP , stackC& stStacksToDeleteP , const byteT*& pbcP , const byteT* const pbeP )/*1*/

#define GETNN(argP) { __( pbcP + processGlobal1I.cb_nicNameC_ > pbeP ) ; ether.memCopyF( tinP , (byteT*)&argP , pbcP , processGlobal1I.cb_nicNameC_ ) ; pbcP += processGlobal1I.cb_nicNameC_ ; }
#define GET(argP)   { __( pbcP + sizeof argP > pbeP ) ; ether.memCopyF( tinP , (byteT*)&argP , pbcP , sizeof argP ) ; pbcP += sizeof argP ; }

/**/
*/
  this function will become impotent if it attempts to read an address at or above pbeP
  this address is exclusive
  must be at least than pbP + 2 * sizeof( countT )
  an address in the poolOld marking an upper bound to read operations in the poolOld for this table
 pbeP
   after evaluation, pbcP will point to the byte immediately following the last byte used to load this table
  this "cursor" address will be advanced by this function
  an address in the poolOld from which to input cells into this table object
 pbcP
  the caller is responsible for deleting these stacks
  pointers to stacks created by me will be put onto this stack
 stStacksToDeleteP
  the caller is responsible for deleting these tableC objects
  pointers to tableC objects created by me will be put onto this stack
 stTablesToDeleteP
  the caller is responsible for deleting these strings
  pointers to strings of byteT objects created by me will be put onto this stack
 stStringsOfBytesToDeleteP
 tinP
arguments
i can either contain no rows or already contain rows
i must be set up and ready to accept new rows
 no information about the table, other than the number of rows and columns, is read
 loads each set of coinstantiated objects in the file into me
  if one or more columns are already declared for the table, this function will become impotent if the number of columns does not equal that indicated in the file
  if there are not yet any columns in the table, columns with default names will be created, one for each column in the file
 will become impotent if i already have declared columns and the number of columns does not match my cCols
 the numbers of rows and of columns are read
reads data into me from the specified range of bytes in the poolOld
  \<A HREF=\"5.b620104.1.1.0.html\"\>b620104:  WAKEsHOW( "example.simplest.func.1320034.tableC.readF" )\</A\>
 simplest
examples
\<A HREF=\"5.1320034.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$readF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

