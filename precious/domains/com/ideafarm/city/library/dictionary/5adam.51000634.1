
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

bOk = tinP.brcRaw ;
BOSpOOP
BOS( WHATgbo , BOSoK , UnregisterClass( postClass , oshInstance ) )

BOSpOOP
BOS( WHATgbo , BOSoK , DestroyWindow( oshw ) )

}
    BOSdOnOTtEST( WHATgbo , DispatchMessage( &info ) )

    if( POOP || !tinP.brcRaw ) break ;
    BOSpOOP
    BOS( WHATgbo , BOSfAILiFmINUS1 , GetMessage( &info , oshw , 0 , 0 ) )
    MSG info ;
{
for(;;)

etThread.osThreadF( TaRG1( tmDrawF ) ) ;

boolT bOk = tinP.brcRaw ;
BOSdOnOTtEST( WHATgbo , ShowWindow( oshw , SW_SHOW ) )

oshw = (HWND)tinP.brcRaw ;
BOSpOOP
BOS( WHATgbo , BOSoK , CreateWindowEx( 0 , postClass , "ifcDoodle" , 0x06cf0000 , 0x0 , 0x20 , 0x400 , 0x200 , 0 , 0 , oshInstance , 0 ) )

}
    if( atomClass ) ;
    ATOM atomClass = (ATOM)tinP.brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , RegisterClass( &info ) )

    info.lpszClassName = postClass ;
    info.lpszMenuName  = 0 ;
    info.hbrBackground = 0 ;
    info.hCursor       = (HCURSOR)tinP.brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , LoadCursor( 0 , IDC_CROSS ) )
    info.hIcon         = 0 ;
    info.hInstance     = oshInstance ;
    info.cbWndExtra    = 0 ;
    info.cbClsExtra    = 0 ;
    info.lpfnWndProc   = winMessageHandlerFooF ;
    info.style         = CS_HREDRAW | CS_VREDRAW | CS_OWNDC | CS_BYTEALIGNCLIENT ;
    WNDCLASS info;
{
osTextT* postClass = "doodleClass" ;
HINSTANCE oshInstance = (HINSTANCE)processGlobal3S::_processGlobal3I_IF()._thirdC_hWindowingClient.osF( ifcIDtYPEhANDLE_WINDOWINGcLIENT ) ;

pTin = &tinP ;

TODO

DONE( tmDrawF )
}
    BOSpOOP
    BOS( WHATgbo , BOSoK , TextOut( oshdc , 0x100 , 0x100 , bOk ? "done" : "fail" , 4 ) )

    #endif

        #endif
            LOGrAW9( "SMALL SIMPLE  [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;
        #else
            LOGrAW9( "SMALL COMPLEX [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;
        #if defined( COMPLEX )

    #else

        #endif
            LOGrAW9( "BIG   SIMPLE  [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;
        #else
            LOGrAW9( "BIG   COMPLEX [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;
        #if defined( COMPLEX )

    #if defined( BIG )

    const countT cLines = ( cSize - 1 ) * cGlyph ;
    
    //Beep( TUCK << 2 , TUCK ) ;
    
    tinP.pEther->osTimeSubtractF( tinP , timeE1 , timeE2 , timeS1 , timeS2 ) ;
    tinP.pEther->osTimeNowF( tinP , timeE1 , timeE2 ) ;
    ZE( sCountT , timeE2 ) ;
    ZE( countT , timeE1 ) ;

    boolT bOk = tinP.brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , PolyPolyline( oshdc , ppt , (DWORD*)pcSize , cGlyph ) )
    
    tinP.pEther->osTimeNowF( tinP , timeS1 , timeS2 ) ;
    ZE( sCountT , timeS2 ) ;
    ZE( countT , timeS1 ) ;

    //Beep( TUCK << 1 , TUCK ) ;

    BOSpOOP
    BOS( WHATgbo , BOSoK , SetROP2( oshdc , R2_XORPEN ) )

    BOSpOOP
    BOS( WHATgbo , BOSoK , Rectangle( oshdc , info.left , info.top , info.right , info.bottom ) )

    BOSdOnOTtEST( WHATgbo , SelectObject( oshdc , oshp ) )
    BOSdOnOTtEST( WHATgbo , SelectObject( oshdc , oshb ) )

    oshp = (HPEN)tinP.brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , CreatePen( PS_SOLID , 1 , 0xffffff ) )
    oshb = (HBRUSH)tinP.brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , CreateSolidBrush( 0 ) )

    }
        }

            #endif

                case 0 : { ppt[ offp ].x = ppt[ offp - 1 ].x ; ppt[ offp ].y = ppt[ offp - 1 ].y + 1 ; break ; }
                case 3 : { ppt[ offp ].x = 0x10              ; ppt[ offp ].y = ppt[ offp - 1 ].y     ; break ; }
                case 2 : { ppt[ offp ].x = ppt[ offp - 1 ].x ; ppt[ offp ].y = ppt[ offp - 1 ].y + 1 ; break ; }
                case 1 : { ppt[ offp ].x = 0x20              ; ppt[ offp ].y = ppt[ offp - 1 ].y     ; break ; }

            #else

                case 0 : { ppt[ offp ].x = ppt[ offp - 1 ].x ; ppt[ offp ].y = ppt[ offp - 1 ].y + 1 ; break ; }
                case 3 : { ppt[ offp ].x = 0x10              ; ppt[ offp ].y = ppt[ offp - 1 ].y     ; break ; }
                case 2 : { ppt[ offp ].x = ppt[ offp - 1 ].x ; ppt[ offp ].y = ppt[ offp - 1 ].y + 1 ; break ; }
                case 1 : { ppt[ offp ].x = 0x410             ; ppt[ offp ].y = ppt[ offp - 1 ].y     ; break ; }

            #if defined( BIG )
        {
        else switch( offp % 4 )
        }
            ppt[ offp ].y = 0x10 ;
            ppt[ offp ].x = 0x10 ;
        {
        if( !( offp % cSize ) )
    {
    for( countT offp = 0 ; offp < sizeof ppt / sizeof ppt[ 0 ] ; offp ++ )

    for( countT offs = 0 ; offs < cGlyph ; offs ++ ) pcSize[ offs ] = cSize ;

    BOSpOOP
    BOS( WHATgbo , BOSoK , GetClientRect( oshw , &info ) )

    while( !oshdc ) OSsLEEPf( 50 ) ;
{
if( pTaskP )
TASK( tmDrawF )

const countT cSize = cpt / cGlyph ;
const countT cpt = sizeof ppt / sizeof ppt[ 0 ] ;
countT pcSize[ cGlyph ] ;

#endif

    POINT        ppt[ cGlyph << 4 ] ;
    const countT cGlyph = 0x4e200 ;

#else

    POINT        ppt[ cGlyph << 8 ] ;
    const countT cGlyph = 0x4e20 ;

#if defined( COMPLEX )
//LIMIT IS 0x4e200 WITH "<< 4"; LIMIT IS 0x4e20 WITH "<< 8"

//#define COMPLEX
#define BIG

HPEN   oshp ;
HBRUSH oshb ;

}
    return rc ;

    }
        }
            break ;
            rc = tinP.brcRaw ;
            BOSdOnOTtEST( WHATgbo , DefWindowProc( oshWindowP , idCmdP , p1P , p2P ) )
        {
        default :
        }
            break ;
            BOSpOOP
            BOS( WHATgbo , BOSoK , PostMessage( oshWindowP , WM_QUIT , 0 , 0 ) )
        {
        case WM_CLOSE :
        }
            break ;
            oshdc = oshdcTmp ;
            BOSdOnOTtEST( WHATgbo , EndPaint( oshWindowP , &info ) )
            HDC oshdcTmp = (HDC)tinP.brcRaw ;
            BOSpOOP
            BOS( WHATgbo , BOSoK , BeginPaint( oshWindowP , &info ) )
            PAINTSTRUCT info ;
        {
        case WM_PAINT :
    {
    switch( idCmdP )
    ZE( LRESULT , rc ) ;

    tinS& tinP = *pTin ;
{
extern "C" LRESULT OSF winMessageHandlerFooF( HWND oshWindowP , UINT idCmdP , WPARAM p1P , LPARAM p2P )

RECT  info ;
HDC   oshdc ;
HWND  oshw ;
tinS* pTin ;

/*1*/WAKEsHOW( "tool.benchmark.glyph.drawing.speed" )/*1*/
/**/
*/
 | 
 | BIG   COMPLEX [cSize,cLines,timeE1,cLines/timeE1]: 001 0e1dd4 a477d 5
 | BIG   SIMPLE  [cSize,cLines,timeE1,cLines/timeE1]: 01 00e394 eb2ec 5
 | SMALL COMPLEX [cSize,cLines,timeE1,cLines/timeE1]: 001 0e1dd4 aa154 21
 | SMALL SIMPLE  [cSize,cLines,timeE1,cLines/timeE1]: 01 00e394 b5d24 11
 | 
output
when the lines are long, they take 3x time to draw
i use "raw" win32 calls, and can draw 11 (17_9) short lines per time (per 1/50,000 sec)
i have oo modes, selected by defining or leaving undefined BIG COMPLEX
i can be used to measure the speed of drawing lines in a glyph
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

