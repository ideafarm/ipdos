
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        //RaiseException( idExceptionP , 0 , ccArgsP , (ULONG const *)pcArgsP ) ;
        //20170210@1026: OBSERVED THIS TO FAIL OBSCURELY

        *pBlammo = 0x28493a17 ; // ARBITRARY VALUE THAT CAN BE SEEN IN DEBUGGER AND IN EXCEPTION REPORT
        countT* pBlammo = 0 ;
        LOGrAW( "\r\ndosRaiseExceptionIF: &tinP is 0, or am debugging, so am just executing an intentional write to address 0\r\n" ) ;
    {
    else
    }
        BOSnOvALUE( WHATgbo , RaiseException( idExceptionP , 0 , ccArgsP , (ULONG const *)pcArgsP ) )
        _IO_
    
        }
            //if( POOP ) return ;
        {
        IFbEcAREFUL
    {
    if( pTin && !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DEBUG ) ) // CALLING RaiseException IS INCONVENIENT WHEN RUNNING AS A CHILD OF A DEBUGGER PROCESS BECAUSE THE CALL STACK BECOMES INVISIBLE, SO WHEN BEING DEBUGGED, I JUST DO AN INTENTIONAL BLAMMO

    countT brcLathSave = tinP.brcLath ;

    tinS* pTin = &tinP ;
{
/*1*/voidT thirdC::dosRaiseExceptionIF( tinS& tinP , const countT idExceptionP , const countT* const pcArgsP , const countT ccArgsP )/*1*/

/**/
*/
 ccArgsP
 pcArgsP
 idExceptionP
 tinP
arguments
\<A HREF=\"5.1020169.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosRaiseExceptionIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

