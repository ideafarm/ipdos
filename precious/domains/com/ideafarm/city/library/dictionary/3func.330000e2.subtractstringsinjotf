
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return -sgn ;

    }
        ((etherC*)pEther)->delF( tinP , pbCopy1 ) ;

        sgn = ((etherC*)pEther)->strCompareEncodedF( tinP , pbCopy1 , pbz2 ) ;
        const byteT* const pbz2 = jotP[ c2P ] ;

        }
            thirdC::c_memcpyIF( tinP , pbCopy1 , pbz1 , cba1 ) ;
            ((etherC*)pEther)->newF( tinP , LF , pbCopy1 , cba1 ) ; ___( pbCopy1 ) ;

            countT cba1 = CBeNCODINGrEF( pbz1 ) + 2 * sizeof( countT ) ; // STRING 1 IS COPIED RATHER THAN STRING 2 BECAUSE 1 WILL BE MORE CORRELATED (LONG RUNS OF THE SAME VALUE) SO PERHAPS NEW/DEL WILL BE LESS COSTLY THAN IF 2 WAS COPIED

            const byteT* const pbz1 = jotP[ c1P ] ;
        {
        ZE( byteT* , pbCopy1 ) ;
    {
    else
    }
        sgn = ((etherC*)pEther)->strCompareEncodedF( tinP , pbz1 , pbz2 ) ;

        const byteT* pbz2 = jotP[ c2P ] ;
        const byteT* pbz1 = jotP[ c1P ] ;
    {
    if( idBook1 == idBook2 )
    ZE( sCountT , sgn ) ;

    countT idBook2 = jotP.peekIdBookF( tinP , c2P ) ;
    countT idBook1 = jotP.peekIdBookF( tinP , c1P ) ;

    jotC&   jotP   = *(jotC*)c3P ;
    etherC& etherP = *(etherC*)pEther ;
{
/*1*/countT _export subtractStringsInJotF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

