
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

REST

}
    }
        etThread.delF( tinP , pstt1m ) ;

        }
            etThread.strokeF( tinP , T("aok") ) ;
            etThread.ifcJobF( tinP , stCourses , ifcIDaDAMoLD_MAILcLERK , sOrder , stOrders , TF1(DDNUMB)+T("/sentient.central.banker.reporter/\"report account balance to account holder\"") ) ;
            stOrders << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
            stackC stOrders(  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
            stackC stCourses( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;

            sOrder << (strokeS*)tNote ;
            sOrder << (strokeS*)T(psttEmail) ;
            sOrder << (countT)1 ;
            sOrder << (countT)DDNUMB ;
            sOrder << (strokeS*)T("!mailOut") ;
            soulC sOrder( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDjOBoRDER_NAMED ) ;

            //etThread.ifcSayF( tinP , tNote , flSAY_APPEND | flSAY_LOG ) ;

            ;

                T("balance: ")+TT5(total1,total2,0,0,S1C('$'))+T(" unix")+tCRLF
                T("account: \"")+T(psttEmail)+T("\"\r\n")+
                T("subject: [ifc] account balance\r\n\r\n")+
                T("from: Tafofozewozefo'o Ideafarm <")+TF1(DDNUMB)+T(ifcEMAIL_MXsUFFIX ">\r\n")+
                T("to: ")+T(psttEmail)+tCRLF+

            TN( tNote , "" ) ; tNote =

            sCountT& total2 = (sCountT&)(countT&)swUnix2 ;
            countT&  total1 =                    swUnix1 ;
            psttEmail = (strokeS*)swUnix1.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swUnix1.cFlavorsF( tinP ) ;
        __( swUnix2.cFlavorsF( tinP ) - swUnix1.cFlavorsF( tinP ) ) ;

        }
            etThread.delF( tinP , pbs ) ;
            }
                etThread.delF( tinP , psttEmail ) ;
                }
                    //etThread.ifcSayF( tinP , tLog , flSAY_APPEND | flSAY_LOG ) ;

                    ;

                        T("\r\n")
                        T(psttEmail)+tBlank+
                        TT(total1,total2)+tBlank+
                        TT(unixDelta1,unixDelta2)+tBlank+

                    TN( tLog , "" ) ; tLog =

                    etThread.osTimeAddF( tinP , total1 , total2 , unixDelta1 , unixDelta2 ) ;

                    sCountT& total2 = (sCountT&)(countT&)swUnix2 ;
                    countT&  total1 =                    swUnix1 ;

                    souIn >> (countT&)unixDelta2 ;
                    souIn >> unixDelta1 ;

                    souIn >> psttEmail ; ___( psttEmail ) ;

                    __( idVersion - 1 ) ;
                    souIn >> idVersion ;

                    __( idType - 2 ) ;
                    souIn >> idType ;

                    __( idAdam - ifcIDaDAMoLD_CENTRALbANKcOMPACTOR ) ;
                    souIn >> idAdam ;
                {
                ZE( sCountT , unixDelta2 ) ;
                ZE( countT , unixDelta1 ) ;
                ZE( countT , idVersion ) ;
                ZE( countT , idType ) ;
                ZE( countT , idAdam ) ;

                souIn.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbs , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                soulC souIn( tinP , TAG( TAGiDnULL ) ) ;

                __( cbs - sizeof( countT ) - *(countT*)pbs ) ;
            {
            if( pbs )
            etThread.boxGetShadowF( tinP , pbs , cbs , psttc1 ) ; ___( pbs ) ;
            ZE( countT , cbs ) ;
            ZE( byteT* , pbs ) ;
        {
        FORsTRINGSiN1( pstt1m )
        switchC swUnix2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttEmail ) ;
        switchC swUnix1( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttEmail ) ;
        ZE( strokeS* , psttEmail ) ;

        etThread.strokeF( tinP , T("cycle ")+TF1(++idCycle)+T(": ")+TF1(cToDo)+T(" files\r\n") ) ;
        const countT cToDo = etThread.boxMenuF( tinP , soul1m , tLikeIn ) ; ___( pstt1m ) ;
        ZE( strokeS* , pstt1m ) ;

        }
            timeL2 = timeN2 ;
            timeL1 = timeN1 ;

            }
                continue ;
                etThread.osSleepF( tinP , TOCK ) ;
            {
            if( offTickL == offTickN )

            countT offTickN = timeN1 >> 24 ;
            countT offTickL = timeL1 >> 24 ; //U: WO PER TICK -> WO PER DAY -> WO PER STRONG

            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
        {
    {
    while( !ether && !etThread )
    ZE( countT , idCycle ) ;
    etThread.osTimeNowF( tinP , timeL1 , timeL2 ) ; // ASSUME: REPORTS WERE ALREADY GENERATED AT THE BEGINNING OF THE CURRENT REPORTING PERIOD
    ZE( sCountT , timeL2 ) ;
    ZE( countT , timeL1 ) ; // "L": "last time reports were generated"
    TN( tQuote , "\"" ) ;
    TN( tBlank , " " ) ;
    TN( tDot  , "." ) ;
    TN( tCRLF , "\r\n" ) ;
    TN( tLikeIn , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/6440104/1.delta/*" ) ;

    etThread.ifcChatF( tinP , 0 , DDNUMB , jobFillCourseF , jobHearOrderF ) ;
    stateS state( tinP , etThread ) ;
{

TODO

STATE0

}
    if( ether && *tinP.zEtScratch && cArgP && c8argP.c1 && sDataP && sNotesTextP && sNotesDataP && idChatSessionP ) ;

    }
        }
            break ;

            }
                }
                    break ;
                    etThread.delF( tinP , psttJobType ) ;

                    else __1
                    }
                    {
                    if( !etThread.strCompareF( tinP , psttJobType , T("!fooey") ) )

                    sOrderP >> psttJobType ; ___( psttJobType ) ;
                    ZE( strokeS* , psttJobType )
                {
                case ifcIDcMDjOBoRDER_NAMED :
                }
                    break ;

                    etThread.delF( tinP , psttBody ) ;
                    etThread.delF( tinP , psttFrom ) ;

                    }
                        etThread.delF( tinP , postBody ) ;
                        etThread.delF( tinP , psttu ) ;
                        etThread.boxPutUniqueF( tinP , psttu , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(DDNUMB)+T("/in/ignored/in") , postBody , costBody ) ;
                        ZE( strokeS* , psttu ) ;

                        countT costBody = etThread.strMakeF( tinP , LF , postBody , psttBody ) ; ___( postBody ) ;
                        ZE( osTextT* , postBody ) ;
                    {

                    sOrderP >> psttBody ; ___( psttBody ) ;
                    ZE( strokeS* , psttBody ) ;

                    __( idAdamTo - DDNUMB ) ;
                    __Z(  idAdamTo ) ;
                    sOrderP >> idAdamTo ;
                    ZE( countT , idAdamTo ) ;

                    __(  psttFrom && !psttFrom->idAdam ) ;
                    __Z( psttFrom ) ;
                    sOrderP >> psttFrom ; ___( psttFrom ) ;
                    ZE( strokeS* , psttFrom ) ;
                {
                case ifcIDcMDjOBoRDER_MAIL :
            {
            switch( idJobType )

            sOrderP >> idJobType ;
            ZE( countT , idJobType ) ;
        {
        case 1 :
    {
    switch( idCourseP )

    __( idAdamP - DDNUMB ) ;
{
voidT jobFillCourseF( tinS& tinP , etherC& ether , etherC& etThread , soulC& sDataP , soulC& sNotesTextP , soulC& sNotesDataP , const countT idCourseP , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

}
    if( cArgP && c8argP.c1 && sOrderP && ether && *tinP.zEtScratch && idChatSessionP ) ;

    __( idAdamP - DDNUMB ) ;
{
voidT jobHearOrderF( tinS& tinP , etherC& ether , etherC& etThread , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

/*1*/WAKEhIDE( "sentient.central.banker.reporter" )/*1*/
/**/
*/
 this is because i do a file move; both directories must be in the same home directory
i must be hired on the same host that 3440104 is hired
\<A HREF=\"5.8440104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

