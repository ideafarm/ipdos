
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            }
                pOffElder = &( (countT*)( pbTls + *pOffElder ) )[ TLSeNTRYoFF_offElder ] ;
    
                }
                    break ;
                    offNextInGroup = 0 ;
                {
                if( offNextInGroup == offMe )
        
                }
                    bFoundElder = 1 ;
                    offNextObject = 0 ;
                    offTopEntry = *pOffElder ;
                    if( offNextObject != offMe ) { BLAMMO ; }
                {
                if( !bFoundElder )
        
                countT& offNextInGroup = ( (countT*)( pbTls + *pOffElder ) )[ TLSeNTRYoFF_offNextInGroup ] ;
                countT& offNextObject  = ( (countT*)( pbTls + *pOffElder ) )[ TLSeNTRYoFF_offNextObject  ] ;
            {
            else while( *pOffElder )
            if( !*pOffElder ) offTopEntry = 0 ;
            countT* pOffElder = &( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_offElder ] ;
            ZE( boolT , bFoundElder ) ;
    
            }
                thirdC::c_memsetIF( tinP , (byteT*)pbData , cbData ) ;
                const countT cbData  = pbEntry + sizeof( countT ) + cbEntry - pbData ;    
                byteT*       pbEntry = pbTls + offMe ;
            {
            if( costaName )
    
            //if( tinP.pc Utility[ 0 ] ) tinP.pc Utility[ 1 ] -- ;
            //if( tinP.pc Utility[ 0 ] && postInGroup   ) { CONoUTrAW( postInGroup ) ; CONoUTrAW( "\r\n" ) ; }
            //if( tinP.pc Utility[ 0 ] && postName      ) { CONoUTrAW( postName    ) ; CONoUTrAW( "\r\n" ) ; }
            //if( tinP.pc Utility[ 0 ]                  ) { CONoUTrAW3( "tinS::newF/entry erased at    " , (countT)( pbTls + offMe ) , "\r\n" ) ; }
            const osTextT* const postInGroup  = !costaInGroup ? 0 : (byteT*)&costaInGroup + sizeof( countT ) + costaName ;
            const osTextT* const postName     = !costaName    ? 0 : (byteT*)&costaInGroup + sizeof( countT ) ;

            const byteT* const   pbData       = (byteT*)&costaInGroup + sizeof( countT ) + costaName + costaInGroup ;
            countT&              costaInGroup = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_costaInGroup ] ;
            countT&              costaName    = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_costaName    ] ;
            countT&              cbEntry      = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_cbEntry      ] ;
    
            //U::if( offMe != offTopEntry ) { BLAMMO ; } //ENFORCES LIFO delF CALLS

            }
                *pcBlammo = 0x12345678 ;
                countT* pcBlammo = (countT*)0x88776655 ;
                LOGcALLnEST( "tlsDelF: not lifo" )
            {
            if( offMe != offTopEntry )  //U:: TO FIND A BUG (HOPEFULLY WDW WILL GIVE ME CALL STACK)

            cTls -- ;
        {
        if( !( -- cRef ) )
        __Z( cRef ) ;
        countT& cRef    = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_cRef ] ;
        pbMeP = 0 ;
        if( !offMe ) { BLAMMO ; } //IF I DIDN'T FIND AN ENTRY
    
        }
            __1

            }
                offMe = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_offElder ] ;
    
                LOGrAW( ostoBuf ) ;
                OStEXTAK( ostoBuf , "\r\n" ) ;
                }
                    }
                        OStEXTAK( ostoBuf , "\"" ) ;
                        OStEXTA( ostoBuf , postInGroup ) ;
                        OStEXTAK( ostoBuf , " group=\"" ) ;
                    {
                    else
                    if( !postInGroup ) { OStEXTAK( ostoBuf , " (not in group)" ) ; }
                    OStEXTAK( ostoBuf , "\"" ) ;
                    OStEXTA( ostoBuf , postName ) ;
                    OStEXTAK( ostoBuf , " name=\"" ) ;
                {
                else
                if( !postName ) { OStEXTAK( ostoBuf , " (nameless)" ) ; }
                OStEXTC( ostoBuf , (countT)pbData , 0 ) ;
                OStEXTAK( ostoBuf , ", rejected data at " ) ;
                OStEXTC( ostoBuf , (countT)pbMeP , 0 ) ;
                OStEXTAK( ostoBuf , "while looking for data at " ) ;
                OStEXT( ostoBuf , 0x200 ) ;
        
                if( !pbMeP || pbData == pbMeP ) break ;
        
                const osTextT* const postInGroup  = !costaInGroup ? 0 : (byteT*)&costaInGroup + sizeof( countT ) + costaName ;
                const osTextT* const postName     = !costaName    ? 0 : (byteT*)&costaInGroup + sizeof( countT ) ;
                const byteT* const   pbData       = (byteT*)&costaInGroup + sizeof( countT ) + costaName + costaInGroup ;
                countT&              costaInGroup = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_costaInGroup ] ;
                countT&              costaName    = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_costaName    ] ;
            {
            while( offMe )
            offMe = offTopEntry ;
        {
        if( !offMe )
    
        }
            offMe = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_offElder ] ;
    
            if( !pbMeP || pbData == pbMeP ) break ;
    
            const byteT* const   pbData       = (byteT*)&costaInGroup + sizeof( countT ) + costaName + costaInGroup ;
            countT&              costaInGroup = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_costaInGroup ] ;
            countT&              costaName    = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_costaName    ] ;
        {
        while( offMe )
        countT offMe = offTopEntry ;
        countT& offTopEntry = *(countT*)pbTls ;
    {
    POOPIES

    _IO_
    tinS& tinP = *this ;

    //}
    //    LOGrAWtID2( "tinS::delF [pb]: " , pbMeP ) //U:: TO FIND A BUG: REMOVE IN PRODUCTION FOR SPEED
    //    tinS& tinP = *this ;
    //{
{
/*1*/voidT tinS::tlsDelF( byteT*& pbMeP )/*1*/

// THE pbMeP PARAMETER IS USED TO ENFORCE THIS
// TLS ENTRIES MUST BE CT/DT IN LIFO ORDER

//
//    postInGroup
//    postName
//    costaInGroup (includes null terminator; if 0 then class is unnamed)
//    costaName (includes null terminator; if 0 then object is unnamed)
//    offNextInGroup (set to 0 by constructing entry)
//    offNextObject (set to 0 by constructing entry; if null then terminates the tls stack
//    offElder (address of entry immediately below me) (0 indicates that i am the bottommost entry)
//    cRef (number of instances including the constructing instance; is never 0)
//    cbEntry (exclusive prefix)
//   tls entry
//    offTopEntry (address of lath entry constructed); this is redundant; it is for speed and to detect corruption
//   tls header
//
// TLS LAYOUT

/**/
*/
  applications that have no convenient place to storage place will specify 0
  specify a nonze value whenever it is not inconvenient to retain the value
  used to verify lifo referencing and dereferencing
  if not 0 then must be the topmost item
  may be 0
 pbMeP
parameters
the topmost item will be dereferenced, and d eleted if there are no more references
caller must d elete tls pointers lifo
if named and i am the only reference then i reset all data bytes
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

