
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

CONoUTrAW( "i've been fired\r\n" ) ;
ether.loafIF( tinP ) ;

}
    ++ s ; ether.osSleepF( tinP , TOCK * 4 ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    etThread.delF( tinP , psttr ) ;
    etThread.strokeF( tinP , psttr ) ;
    }
        }
            }
                }
                    }
                        etThread.delF( tinP , pbTin ) ;
                        }
                            }
                                }
                                    }
                                        etThread.delF( tinP , pbGrab ) ;
                                        }
                                            etThread.strFuseF( tinP , psttr , tcr ) ;
    
                                            ) ;
                    
                                                tb+TF2(grabc.idiFileGrabberNote,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+top+TF2(grabc.idLineGrabberNote,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcp
                    
                                            if( grabc.idiFileGrabberNote ) etThread.strFuseF( tinP , psttr ,
    
                                            ) ;
                    
                                                +tb+TF2(grabc.idiFileGrabber,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+top+TF2(grabc.idLineGrabber,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcp
                                                TP("",0x29)+TF2(grabc.idiFileCt,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+top+TF2(grabc.idLineCt,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcp
                    
                                            etThread.strFuseF( tinP , psttr ,
                                            grabS& grabc = *(grabS*)pbGrab ;
                                        {
                                        if( pbGrab )
                                        image_grabS_F( tinP , etThread , pbGrab , sockm , tinc.ppGrabbed[ off ] , osPid ) ;
                                        ZE( byteT* , pbGrab ) ;
                                    {
                                    if( tinc.ppGrabbed[ off ] )
                                {
                                for( countT off = 0 ; off < sizeof tinc.ppGrabbed / sizeof tinc.ppGrabbed[ 0 ] ; off ++ )

                                }
                                    etThread.delF( tinP , pbGrab ) ;
                                    }
                                        etThread.strFuseF( tinP , psttr , tcr ) ;

                                        ) ;
                
                                            tb+TF2(grabc.idiFileGrabberNote,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+top+TF2(grabc.idLineGrabberNote,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcp
                
                                        if( grabc.idiFileGrabberNote ) etThread.strFuseF( tinP , psttr ,

                                        ) ;
                
                                            +tb+TF2(grabc.idiFileGrabber,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+top+TF2(grabc.idLineGrabber,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcp
                                            TF2(grabc.idiFileCt,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+top+TF2(grabc.idLineCt,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcp
                
                                        etThread.strFuseF( tinP , psttr ,
                                        grabS& grabc = *(grabS*)pbGrab ;
                                    {
                                    if( pbGrab )
                                    image_grabS_F( tinP , etThread , pbGrab , sockm , tinc.pGrabbing , osPid ) ;
                                    ZE( byteT* , pbGrab ) ;
                                {

                                ) ;

                                    TF3(tinc.idThread,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TP(tinc.postThreadName,0x20)

                                etThread.strFuseF( tinP , psttr ,
                            {
                            if( tinc.pGrabbing )
                            //CONoUTrAW( T("[osPid,bIda,ip]:")+tb+TF2(osPid,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb+TF2(bIda,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb+TF2(ip,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcr ) ;
        
                            tinS& tinc = *(tinS*)pbTin ;
                        {
                        if( pbTin && cbTin == sizeof( tinS ) )
                        sIn2.shiftRightF( tinP , pbTin , cbTin , ifcIDtYPEsOULiTEM_byteTptr ) ; ___( pbTin ) ;
                        ZE( countT , cbTin ) ;
                        ZE( byteT* , pbTin ) ;
                    {
                    if( bOk )
                    
                    sIn2 >> bOk ;
                    ZE( countT , bOk ) ;
    
                    __( idReply - ifcIDrEPLYmONITOR_IMAGE ) ;
                    sIn2 >> idReply ;
                    ZE( countT , idReply ) ;
                    
                    sockm.readF( tinP , sIn2 ) ;
                    soulC sIn2( tinP , TAG( TAGiDnULL ) ) ;
                    
                    sockm.writeF( tinP , sOut2 ) ;
                    sOut2 << sizeof( tinS ) ;
                    sOut2 << ip ;
                    sOut2 << osPid ;
                    sOut2 << (countT)ifcIDcMDmONITOR_IMAGE ;
                    soulC sOut2( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( !bIda )

                sIn >> ip ;
                ZE( countT , ip ) ;

                sIn >> bIda ;
                ZE( boolT , bIda ) ;

                sIn >> osPid ;
                ZE( countT , osPid ) ;
            {
            while( cTin -- )
            sIn >> cTin ;
            ZE( countT , cTin ) ;
    
            etThread.strFuseF( tinP , psttr , T("memory space: ")+TF2(idMemorySpace,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcr ) ;
            sIn >> idMemorySpace ;
            ZE( countT , idMemorySpace ) ;
        {
        while( cFlavorsMemory -- )
    
        sIn >> cFlavorsMemory ;
        ZE( countT , cFlavorsMemory ) ;
    {
    while( sIn )
    
    __( idReply - ifcIDrEPLYmONITOR_tinS ) ;
    sIn >> idReply ;
    ZE( countT , idReply ) ;
    
    sockm.readF( tinP , sIn ) ;
    soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
    sockm.writeF( tinP , sOut ) ;
    sOut << (countT)ifcIDcMDmONITOR_tinS ;
    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;

    etThread.strMakeF( tinP , psttr , T("\fIPDOS (tm) <> IdeaFarm " "(tm) Piggyback Distributed Operating System\r\nPerformance Monitor\r\ncycle: ")+TF2(++idCycle,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcr , TOCK ) ; ___( psttr ) ;
    ZE( strokeS* , psttr ) ;
{
while( !ether && !etThread )
ZE( countT , idCycle ) ;
TN( tcp  , ")" ) ;
TN( top  , "(" ) ;
TN( tb   , " " ) ;
TN( tcr  , "\r\n" ) ;

//sockm.connectF( tinP , 0x40c , socketC::nicNameIF( tinP , etThread , T("ideafarm.com") ) ) ;
sockm.connectF( tinP , home.idPortKernelMonitor , socketC::nicNameIF( tinP , etThread , T("10.1.1.1") ) ) ;
socketC sockm( tinP , etThread , TAG( TAGiDnULL ) ) ;

homeS& home = homeS::homeIF() ;

TODO

}
    }
        if( cbGrab != sizeof( grabS ) || ((grabS*)pbGrabP)->fingerprint != FINGERnEG_grabS ) etherP.delF( tinP , pbGrabP ) ;
        sIn3.shiftRightF( tinP , pbGrabP , cbGrab , ifcIDtYPEsOULiTEM_byteTptr ) ; ___( pbGrabP ) ;
        ZE( countT , cbGrab ) ;
    {
    if( bOk )
                                    
    sIn3 >> bOk ;
    ZE( countT , bOk ) ;
                    
    __( idReply - ifcIDrEPLYmONITOR_IMAGE ) ;
    sIn3 >> idReply ;
    ZE( countT , idReply ) ;
                                    
    sockP.readF( tinP , sIn3 ) ;
    soulC sIn3( tinP , TAG( TAGiDnULL ) ) ;
                                    
    sockP.writeF( tinP , sOut3 ) ;
    sOut3 << sizeof( grabS ) ;
    sOut3 << (countT)pForeignGrabP ;
    sOut3 << osPidP ;
    sOut3 << (countT)ifcIDcMDmONITOR_IMAGE ;
    soulC sOut3( tinP , TAG( TAGiDnULL ) ) ;
{
voidT image_grabS_F( tinS& tinP , etherC& etherP , byteT*& pbGrabP , socketC& sockP , grabS* pForeignGrabP , countT osPidP )

//THIS ADAM IS OBSOLETED BY FUNCTIONALITY BUILT INTO obeyF IN 0850104

/*1*/WAKEsHOWtEXT( "tool.performance.monitor.query" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

