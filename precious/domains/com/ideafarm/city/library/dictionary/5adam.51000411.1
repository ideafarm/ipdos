
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    etThread.faceStkNotifyAdamF( tinP ) ;
    //U::sgnDone_tmDisplay.waitF( tinP ) ;
    //U::TELL( "cleaning up: waiting for sgnDone_tmDisplay" )
    }
        while( !etThread && ba.cMonitors ) { ++ s ; thirdC::dosSleepRawIF( tinP , 250 ) ; }
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    TELL( "cleaning up: waiting for !ba.cMonitors" )
    //DUPLICATED CODE

    sgnDone_tmRegisterPort.waitF( tinP ) ;
    TELL( "cleaning up: waiting for sgnDone_tmRegisterPort" )
    fireMonitoredProcessesF( tinP , etThread , ba ) ;
    TELL( "cleaning up: firing monitored processes" )
    etThread.ifcDrivenServerF( tinP , i1 , i2 ) ;
    serverInfo2S i2( 0 , flSOCKETc_null , TF2(thirdC::third_idAdamRootI_IF( tinP ),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , 0 , (countT)&ba , 0 , - 1 , 1 , sizeof( stateS ) , translateStateF , T("monitored") ) ;
    serverInfo1S i1( &ba.pbdVarying , ba.b_pbdVarying , ba.bHandedOff , sgnIdPortReplaced , tmcF , idPort , ether ) ;
    TELL( "serving my chat port" )

    //ASSUME: tmRegisterPortF WILL NOT DO ANYTHING UNTIL AFTER STATE HAS BEEN HANDED OFF TO ME (WITHIN ifcDrivenServerF)
    etThread.osThreadF( tinP , countTC() , tmRegisterPortF , &sgnDone_tmRegisterPort , flTHREADlAUNCH_null , 0 , (countT)&sgnIdPortReplaced , (countT)&idPort , (countT)&ba ) ;
    signC sgnDone_tmRegisterPort( tinP , TAG( TAGiDnULL ) ) ;
    signC sgnIdPortReplaced( tinP , TAG( TAGiDnULL ) ) ;
    ZE( countT , idPort ) ;

    if( thirdC::c_strlenIF( tinP , (>>>>(p oolC&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<Thread).postName ) <= CSpOSTpOOLoLDmONITORmAX ) OStEXTA( poolOld Side.postPoolMonitor  , (>>>>(p oolC&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<Thread).postName ) ;
    poolOld SideS& poolOld Side = (poolOld SideS&)poolC::poolOldRootIF( tinP ) ;

    etherC::etTextIF( tinP ).winSetTitleF( tinP , textC( tinP , TAG( TAGiDnULL ) , "IdeaFarm Cell Monitor") ) ;
{
else
}
    etThread.faceStkNotifyAdamF( tinP ) ;
    //U::sgnDone_tmDisplay.waitF( tinP ) ;
    //U::TELL( "cleaning up: waiting for sgnDone_tmDisplay" )
    }
        while( !etThread && ba.cMonitors ) { ++ s ; thirdC::dosSleepRawIF( tinP , 250 ) ; }
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    TELL( "cleaning up: waiting for !ba.cMonitors" )
    //DUPLICATED CODE

    TELL( "cleaning up" )
    U:: NO LONGER SUPPORTED: thirdC::thirdMonitoredEventHandlerF( tinP ) ;

    }
        fireMonitoredProcessesF( tinP , etThread , ba ) ;
        TELL( "cleaning up: firing monitored processes" )
        while( !etThread && !ether && ba.cMonitors ) ether.osSleepF( tinP , TOCK * 8 , TUCK * 0x40 ) ;
        TELL( "waiting for all monitors to end" )
        //U:etThread.osThreadF( tinP , countTC() , tmCatchCommandF ) ;
        sgnHired.waitF( tinP ) ;
        TELL( "waiting for sgnHired for 314m" )
    {
    if( !etThread )

    etThread.osThreadF( tinP , countTC() , tmMonitorF , 0 , flTHREADlAUNCH_null , 0 , (countT)&ba , (countT)&ptm2 ) ;
    if( !etThread ) ba.cMonitors ++ ;
    params_tmMonitorF_2S ptm2( sgnHired , 1 , tArgs , flHIRE_DISPLAYaUTO ) ;
    TN( tArgs , "" ) ; tArgs = TF3(DDNUMB,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T(" !postHandoffOld monitored !minimized !poolOldRootNoClientRights !ignoreFireByOperator") ;
    signC sgnHired( tinP , TAG( TAGiDnULL ) ) ;
    TELL( "setting up: hiring another instance of myself" )

    U:: NO LONGER SUPPORTED: //U::c :thirdC::thirdMonitoredEventHandlerF( tinP , monitoredEventHandlerF , (countT)&bw ) ;
    //U::c :etThread.strMakeF( tinP , bw.worker.psttDisplay , T("unknown")              ) ; ___( bw.worker.psttDisplay ) ;
    //U::c :etThread.strMakeF( tinP , bw.worker.psttTitle   , T(MYtITLE ".unmonitored") ) ; ___( bw.worker.psttTitle ) ;
    //U::c :bw.worker.idAdam = DDNUMB ;
    //U::c :bookWoS bw( tinP , etThread , TAG( TAGiDnULL ) , ba , ptm2Dummy , stateBlank ) ;
    //U::c :params_tmMonitorF_2S ptm2Dummy( sgnHiredDummy ) ;
    //U::c :signC sgnHiredDummy( tinP , TAG( TAGiDnULL ) ) ;
    //U::c :TELL( "setting up: handling early notifications" )

    etThread.delF( tinP , psttl ) ;
    etThread.strokeF( tinP , psttl ) ;
    etThread.strIfcLogoF( tinP , psttl ) ; ___( psttl ) ;
    ZE( strokeS* , psttl ) ;
    TELL( "setting up: displaying logo" )

    ba.b_pbdVarying.ungrabF( tinP ) ;
    ba.pbdVarying = state.pbdVarying ;
    ba.b_pbdVarying.grabF( tinP , TAG( TAGiDnULL ) ) ;
    stateC state( tinP , etThread , ba.bHandedOff , 0 , sizeof( stateS ) , translateStateF , (countT)&ba ) ;
    TELL( "obtaining my state handoffOld" )

    etherC::etTextIF( tinP ).winSetTitleF( tinP , textC( tinP , TAG( TAGiDnULL ) , "IdeaFarm Operating System Monitor") ) ;
{
if( !ba.bMonitored )

//U::etThread.osThreadF( tinP , countTC() , tmDisplayF , &sgnDone_tmDisplay , flTHREADlAUNCH_null , 0 , (countT)&ba ) ;
//U::signC sgnDone_tmDisplay( tinP , TAG( TAGiDnULL ) ) ;
etThread.faceStkNotifyAdamF( tinP , keyTaskNoticeHandlerF , (countT)&ba ) ;
bookAllS ba( tinP , etThread ) ;
TELL( "setting up" )

TODO

}
    return 0 ;
    //ungrabF( tinP , grabeh ) ;

    }
        //U::j:hanSayF( tinP , bw , info ) ;
        info.osSay_cost = (count01T)thirdC::c_strlenIF( tinP , postP ) ;
        info.osSay_post = (osTextT*)postP ;
        info.osPid = tinP.osPid ;
        info.osTid = tinP.osTid ;
        ifcMonitorEventS info( tinP , bw.ether ) ;
    {
 
    bw.pTinEvent = &tinP ;
    bookWoS& bw = *(bookWoS*)cP ;

    //grabF( tinP , grabeh ) ;
{
boolT monitoredEventHandlerF( tinS& tinP , const osTextT* const postP , countT cP )
//grabOldS grabeh( thirdC::third_tinMainG_IF() , TAG( TAGiDnULL ) ) ; //IS NOT LOCAL BECAUSE WATCOM WOULD NOT EXECUTE THE CONSTRUCTOR UNTIL THE CONSTRUCTION LINE IS ENCOUNTERED IN THE EXECUTION SEQUENCE

}
    __( baP.cMonitors ) ;

    }
        etThread.osSleepF( tinP , TUCK * 0x40 , TUCK * 0x40 ) ;
        baP.bLeverOsPid.ungrabF( tinP ) ;
        }
            }
                ((thirdC&)etThread).dosWriteProcessMemoryIF( tinP , bOk , pv_bFired , baP.leverOsPid , (byteT*)&bFired , sizeof bFired ) ;
                ZE( boolT , bOk ) ;
                boolT bFired = 1 ;
                voidT* pv_bFired = (voidT*)(countT&)worker.p_bFired ;
            {
            if( !etThread && worker.p_bFired )
            workerS& worker = *(workerS*)&(countT&)baP.swWorker ;
            baP.leverOsPid = baP.swWorker.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = baP.swWorker.cFlavorsF( tinP ) ;
        baP.bLeverOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    while( !etThread && !baP.swWorker.third && baP.cMonitors )
{
voidT fireMonitoredProcessesF( tinS& tinP , etherC& etThread , bookAllS& baP )

}
    }
        }
            }
                etThread.delF( tinP , psttOneP ) ;
                ba.idDisplayRequest = psttOneP[ CSpREFIX ].idAdam - minc + min ;
                bookAllS& ba = *(bookAllS*)infoP ;
            {
            if( iddr <= IDdISPLAYmAX )
            countT iddr = psttOneP[ CSpREFIX ].idAdam - minc + min ;
        {
        if( min )

        else if( psttOneP[ CSpREFIX ].idAdam >= 'A' && psttOneP[ CSpREFIX ].idAdam <= 'Z' ) min = 0x24 , minc = 'A' ;
        else if( psttOneP[ CSpREFIX ].idAdam >= 'a' && psttOneP[ CSpREFIX ].idAdam <= 'z' ) min =  0xa , minc = 'a' ;
             if( psttOneP[ CSpREFIX ].idAdam >= '1' && psttOneP[ CSpREFIX ].idAdam <= '9' ) min =    1 , minc = '1' ;
        ZE( countT , minc ) ;
        ZE( countT , min ) ;
    {
    if( psttOneP && infoP )
{
voidT keyTaskNoticeHandlerF( tinS& tinP , etherC& etThread , strokeS*& psttOneP , const countT infoP )

DONE( tmCatchCommandF )

}
    }
        }
            }
                tinP.zEtScratch->osSleepF( tinP , TUCK * 0x40 ) ;
                sockc.writeF( tinP , idPort , nicName , "ifcraok" , 8 ) ;
            {
            while( cTries -- )
            cTries = 8 ;

            tinP.zEtScratch->osFireF( tinP ) ;

            }
                tinP.zEtScratch->osSleepF( tinP , TUCK * 0x40 ) ;
                sockc.writeF( tinP , idPort , nicName , "ifcr" , 5 ) ;
            {
            while( cTries -- )
            countT cTries = 8 ;
        {
        if( !*tinP.zEtScratch && pbIn && cbIn >= 2 * sizeof( countT ) && ((countT*)pbIn)[ 0 ] == 1 && ((countT*)pbIn)[ 1 ] == ifcPASSCODE_OSfIRE ) //U: HARDCODED IDcMD AND PASSCODE.  SUPPORT CONFIGURATION FILE TO OVERRIDE THIS PASSCODE VALUE

        sockc.readF( tinP , pbIn , cbIn , idPort , nicName ) ;
        nicNameC nicName ;
        ZE( countT , idPort ) ;
        ZE( countT , cbIn ) ;
        ZE( byteT* , pbIn ) ;
    {
    while( !ether && !etThread && !*tinP.zEtScratch )

    sockc.bindF( tinP , ifcPORToLD2_CONTROL ) ;
    socketC sockc( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
{
while( !ether )
TASK( tmCatchCommandF )

DONE( tmDisplayF )
}
    TELL( "cleaning up" )
    }
        TELL( "at the end of my loop" )
        }
            idDisplayLast = baP.idDisplay ;
            tinP.zEtScratch->delF( tinP , psttr ) ;
            tinP.zEtScratch->strokeF( tinP , T(psttr) , bKt ? flPAPERtALK_MOVEhERE : 0/*ifcIDtYPE wUP_NORMAL*/ ) ;
            }
                WINDOWrEFERENCEeND( thirdC::pWinRootIF() ) ;
                }
                    ungrabF( tinP , pw->grab_pczKtHere ) ;
                    tinP.zEtScratch->strKtHereAddressF( tinP , psttr , pw->pczKtHere ? pw->pczKtHere : (const countT* const)count3S( 0 , 1 ) ) ; //U: MAKE A COPY OF pcz SO CAN UNGRAB EARLIER
                    grabF( tinP , pw->grab_pczKtHere ) ;
                {
                if( pw && idDisplayLast == baP.idDisplay )
                windowOldC* pw = thirdC::pWinRootIF() ;
                WINDOWrEFERENCEbEGIN( tinP , thirdC::pWinRootIF() ) ;
            {
            if( bKt )

            TELL( "after switch" )
            }
                // WHEN ADDING A CASE VALUE (HERE), EDIT THE VALUE OF SYMBOL IDdISPLAYmAX
                }
                    break ;

                    #endif
                    tinP.zEtScratch->strFuseF( tinP , psttr , T("\fU:this display is under construction (conj: it causes deadlock)") ) ; ___( psttr ) ;
                    #else

                    baP.swWatch.ungrabF( tinP ) ;
                    }
                        tinP.zEtScratch->strFuseF( tinP , psttr , tc ) ; ___( psttr ) ;
                        tinP.zEtScratch->delF( tinP , pbCopy ) ;

                        else tinP.zEtScratch->strFuseF( tinP , psttr , T("(could not read)") ) ;
                        }
                            }
                                }
                                    break ;
                                    }
                                        tinP.zEtScratch->strFuseF( tinP , psttr , TF1(*(pcc++))+(cElt?T("/"):T("")) ) ;
                                    {
                                    while( cElt -- )
                                    countT* pcc = (countT*)pbCopy ;
                                    countT cElt = watch.cbAll / watch.cbElt ;
                                {
                                case 1 : // countT
                            {
                            switch( watch.idType )
                        {
                        if( bOk )
                        ((thirdC&)etScratch).dosReadProcessMemoryIF( tinP , pbCopy , watch.cbAll , bOk , (byteT*)watch.idaOrRawAddr , watch.osPid ) ;
                        ZE( boolT , bOk ) ;

                        tinP.zEtScratch->newF( tinP , LF , pbCopy , watch.cbAll ) ; ___( pbCopy ) ;
                        ZE( byteT* , pbCopy ) ;
                        tinP.zEtScratch->strFuseF( tinP , psttr , TF3(watch.idaOrRawAddr,flFORMAT_UNSIGNED,9)+TF3(watch.cbAll,flFORMAT_UNSIGNED,3)+TF3(watch.cbElt,flFORMAT_UNSIGNED,3)+TPS(baP.psttWatch,0x20,sDot)+T(" ") ) ; ___( psttr ) ;
                        watchS& watch = *(watchS*)&(countT&)baP.swWatch ;
                        baP.psttWatch = (strokeS*)baP.swWatch.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !baP.idDisplayRequest ; idf ++ )
                    tinP.zEtScratch->strFuseF( tinP , psttr , T("\fidDisplay:")+TF1(baP.idDisplay)+T(" [1,")+TF1(IDdISPLAYmAX)+T("]")+T("    ")+TT(timeN1,timeN2)+T("    these memory locations are registered for watching\r\n \r\n") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ cFlavors * 0x100 ) ; ___( psttr ) ;
                    countT cFlavors = baP.swWatch.cFlavorsF( tinP ) ;
                    baP.swWatch.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    strokeS sDot('.') ;

                    #if defined( NEVERdEFINED )
                    //U:
                {
                case 0 :
                }
                    break ;

                    }
                        tinP.monitor.idStep ++ ;
                        grabOldS grab( tinP , TAG( TAGiDnULL ) , flGRABs_DISABLED ) ;
                        tinP.monitor.idStep ++ ;
                    {
                    while( !baP.idDisplayRequest )
                {
                case 0xc :
                }
                    break ;
                    baP.stThread.ungrabF( tinP ) ;
                    }
                        while( !ether && !*tinP.zEtScratch && !baP.stThread.third && ~hDown && !baP.idDisplayRequest ) ;
                        }
                            ) ;
    
                                T(thread.postThreadName)+tc
                                TF3(thread.idProcessOld,flFORMAT_UNSIGNED,9)+
                                TF3(thread.idThread,flFORMAT_UNSIGNED,9)+
                                TF3(thread.idAdamRoot,flFORMAT_UNSIGNED,9)+
                                TF3(thread.osPid,flFORMAT_UNSIGNED,9)+
                                TF3(thread.osTid,flFORMAT_UNSIGNED,9)+
                                TT(thread.timeDel.time1,thread.timeDel.time2)+tb+
                                TT(thread.timeUnreg.time1,thread.timeUnreg.time2)+tb+
                                TT(thread.timeReg.time1,thread.timeReg.time2)+tb+
                                TT(thread.timeNew.time1,thread.timeNew.time2)+tb+
    
                            tinP.zEtScratch->strFuseF( tinP , psttr , 
                            threadS& thread = (threadS&)(countT&)baP.stThread.downF( tinP , hDown ) ;
                        {
                        do
                        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( baP.stThread )

                    , baP.stThread * 0x100 ) ; ___( psttr ) ;

                        TPS("name",0x20,sttd)+tc+tb+tc
                        TPS("idProcessOld",8,sttd)+tb+
                        TPS("idThread",8,sttd)+tb+
                        TPS("idAdamPO",8,sttd)+tb+
                        TPS("osPid",8,sttd)+tb+
                        TPS("osTid",8,sttd)+tb+
                        TPS("timeDel",0x11,sttd)+tb+
                        TPS("timeUnreg",0x11,sttd)+tb+
                        TPS("timeReg",0x11,sttd)+tb+
                        TPS("timeNew",0x11,sttd)+tb+
                        T("\fidDisplay:")+TF1(baP.idDisplay)+T(" [1,")+TF1(IDdISPLAYmAX)+T("]")+T("    ")+TT(timeN1,timeN2)+T("    these ")+TF1(baP.stThread)+T(" threads formerly existed in ifc processes but have ended\r\n \r\n")+

                    tinP.zEtScratch->strFuseF( tinP , psttr , 
                    baP.stThread.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    strokeS sttd( '-' ) ;
                    TN( tc , "\r\n" ) ;
                    TN( tb , " " ) ;
                {
                case 0xa :
                }
                    break ;
                    baP.swThread.ungrabF( tinP ) ;
                    }
                        ) ;

                            T(thread.postThreadName)+tc
                            TF3(thread.idProcessOld,flFORMAT_UNSIGNED,9)+
                            TF3(thread.idThread,flFORMAT_UNSIGNED,9)+
                            TF3(thread.idAdamRoot,flFORMAT_UNSIGNED,9)+
                            TF3(thread.osPid,flFORMAT_UNSIGNED,9)+
                            TF3(thread.osTid,flFORMAT_UNSIGNED,9)+
                            TT(thread.timeDel.time1,thread.timeDel.time2)+tb+
                            TT(thread.timeUnreg.time1,thread.timeUnreg.time2)+tb+
                            TT(thread.timeReg.time1,thread.timeReg.time2)+tb+
                            TT(thread.timeNew.time1,thread.timeNew.time2)+tb+

                        tinP.zEtScratch->strFuseF( tinP , psttr , 

                        threadS& thread = (threadS&)(countT&)baP.swThread ;
                        baP.leverOsTid = baP.swThread.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !baP.idDisplayRequest ; idf ++ )

                    , cFlavors * 0x100 ) ; ___( psttr ) ;

                        TPS("name",0x20,sttd)+tc+tb+tc
                        TPS("idProcessOld",8,sttd)+tb+
                        TPS("idThread",8,sttd)+tb+
                        TPS("idAdamPO",8,sttd)+tb+
                        TPS("osPid",8,sttd)+tb+
                        TPS("osTid",8,sttd)+tb+
                        TPS("timeDel",0x11,sttd)+tb+
                        TPS("timeUnreg",0x11,sttd)+tb+
                        TPS("timeReg",0x11,sttd)+tb+
                        TPS("timeNew",0x11,sttd)+tb+
                        T("\fidDisplay:")+TF1(baP.idDisplay)+T(" [1,")+TF1(IDdISPLAYmAX)+T("]")+T("    ")+TT(timeN1,timeN2)+T("    these ")+TF1(cFlavors)+T(" threads currently exist in ifc processes\r\n \r\n")+

                    tinP.zEtScratch->strFuseF( tinP , psttr , 
                    countT cFlavors = baP.swThread.cFlavorsF( tinP ) ;
                    baP.swThread.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    strokeS sttd( '-' ) ;
                    TN( tc , "\r\n" ) ;
                    TN( tb , " " ) ;
                {
                case 9 :
                }
                    break ;

                    baP.swTallySayGrabCt.ungrabF( tinP ) ;

                    ) ; ___( psttr ) ;

                        TPS("pt in primary poolOld (distinct ct lines)",0x40,sttd)+tb+(cFlavors?TF1((0x100*cFlavorsIda)/cFlavors):T(""))+tc
                        TPS("elsewhere (distinct ct lines)",0x40,sttd)+tb+TF1(cFlavorsRaw)+tc+
                        TPS("in primary poolOld (distinct ct lines)",0x40,sttd)+tb+TF1(cFlavorsIda)+tc+
                        TPS("pt in primary poolOld",0x40,sttd)+tb+(cAll?TF1((0x100*cIda)/cAll):T(""))+tc+tb+tc+
                        TPS("elsewhere",0x40,sttd)+tb+TF1(cRaw)+tc+
                        TPS("in primary poolOld",0x40,sttd)+tb+TF1(cIda)+tc+
                        T("\fidDisplay:")+TF1(baP.idDisplay)+T(" [1,")+TF1(IDdISPLAYmAX)+T("]")+T("    ")+TT(timeN1,timeN2)+T("    ")+TF1(cAll)+T(" grabOldS objects have been constructed\r\n \r\n")+

                    tinP.zEtScratch->strFuseF( tinP , psttr , 
                    strokeS sttd( '.' ) ;
                    countT cAll = cIda + cRaw ;

                    }
                        cRaw += baP.swTallySayGrabCtRaw ;
                        baP.pczLineFileCt = (countT*)baP.swTallySayGrabCtRaw.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavorsRaw ; idf ++ )
                    ZE( countT , cRaw ) ;

                    }
                        cIda += baP.swTallySayGrabCtIda ;
                        baP.pczLineFileCt = (countT*)baP.swTallySayGrabCtIda.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavorsIda ; idf ++ )
                    ZE( countT , cIda ) ;

                    countT cFlavorsRaw = baP.swTallySayGrabCtRaw.cFlavorsF( tinP ) ;
                    countT cFlavorsIda = baP.swTallySayGrabCtIda.cFlavorsF( tinP ) ;
                    countT cFlavors = baP.swTallySayGrabCt.cFlavorsF( tinP ) ;
                    baP.swTallySayGrabCt.grabF( tinP , TAG( TAGiDnULL ) ) ; //U: EDIT TO BE AS QUICK AS POSSIBLE SINCE THIS WILL BLOCK MONITORED PROCESSES THAT ARE SAYING SOMETHING
                    TN( tb , " " ) ;
                    TN( tc , "\r\n" ) ;
                    strokeS sDot('.') ;
                {
                case 8 :
                }
                    break ;

                    baP.swTallySay.ungrabF( tinP ) ;
                    }
                        tinP.zEtScratch->strFuseF( tinP , psttr , TF3(baP.swTallySay,flFORMAT_UNSIGNED,9)+TF3(baP.idTypeSay,flFORMAT_UNSIGNED,9)+tc ) ; ___( psttr ) ;
                        baP.idTypeSay = baP.swTallySay.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !baP.idDisplayRequest ; idf ++ )
                    tinP.zEtScratch->strFuseF( tinP , psttr , T("\fidDisplay:")+TF1(baP.idDisplay)+T(" [1,")+TF1(IDdISPLAYmAX)+T("]")+T("    ")+TT(timeN1,timeN2)+T("    i have heard these ")+TF1(tallyAll)+T(" sayings\r\n \r\n") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ cFlavors * 0x100 ) ; ___( psttr ) ;

                    }
                        tallyAll +=  baP.swTallySay ;
                        baP.idTypeSay = baP.swTallySay.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !baP.idDisplayRequest ; idf ++ )
                    ZE( countT , tallyAll ) ;

                    countT cFlavors = baP.swTallySay.cFlavorsF( tinP ) ;
                    baP.swTallySay.grabF( tinP , TAG( TAGiDnULL ) ) ; //U: EDIT TO BE AS QUICK AS POSSIBLE SINCE THIS WILL BLOCK MONITORED PROCESSES THAT ARE SAYING SOMETHING
                    strokeS sDot('.') ;

                {
                case 7 :
                }
                    break ;

                    baP.swTallyEvent.ungrabF( tinP ) ;

                    }
                        tinP.zEtScratch->strFuseF( tinP , psttr , TF3(baP.swTallyEvent,flFORMAT_UNSIGNED,9)+TF3(baP.idEvent,flFORMAT_UNSIGNED,9)+T(postTitle)+tc ) ; ___( psttr ) ;

                        }
                            break ;
                            postTitle = idTitle[ offi ].post ;
                            if( idTitle[ offi ].id != baP.idEvent ) continue ;
                        {
                        for( countT offi = 0 ; offi < sizeof idTitle / sizeof idTitle[ 0 ] ; offi ++ )
                        ZE( osTextT* , postTitle ) ;

                        baP.idEvent = baP.swTallyEvent.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !baP.idDisplayRequest ; idf ++ )

                    tinP.zEtScratch->strFuseF( tinP , psttr , T("\fidDisplay:")+TF1(baP.idDisplay)+T(" [1,")+TF1(IDdISPLAYmAX)+T("]")+T("    ")+TT(timeN1,timeN2)+T("    i have been notified of these ")+TF1(tallyAll)+T(" events\r\n \r\n") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ cFlavors * 0x100 ) ; ___( psttr ) ;

                    }
                        tallyAll += baP.swTallyEvent ;
                        baP.idEvent = baP.swTallyEvent.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !baP.idDisplayRequest ; idf ++ )
                    ZE( countT , tallyAll ) ;

                    countT cFlavors = baP.swTallyEvent.cFlavorsF( tinP ) ;
                    baP.swTallyEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    strokeS sDot('.') ;

                    } ;
                        ifcIDeVENTmONITORED_RIP             , "rip" ,
                        ifcIDeVENTmONITORED_SAY             , "say" ,
                        ifcIDeVENTmONITORED_UNLOADdLL       , "unloadDll" ,
                        ifcIDeVENTmONITORED_LOADdLL         , "loadDll" ,
                        ifcIDeVENTmONITORED_EXITpROCESS     , "exitProcess" ,
                        ifcIDeVENTmONITORED_EXITtHREAD      , "exitThread" ,
                        ifcIDeVENTmONITORED_CREATEpROCESS   , "createProcess" ,
                        ifcIDeVENTmONITORED_CREATEtHREAD    , "createThread" ,
                        ifcIDeVENTmONITORED_EXCEPTION       , "exception" ,
                    {
                    idTitle[] =
                    }
                        osTextT* post ;
                        countT   id ;
                    {
                    static struct
                    //CODE SYNCH: 0010144 6a40104

                {
                case 6 :
                }
                    break ;

                    }
                        ) ;
                            T("no entries yet")
                            S2(saOLD_KTaTTACHuP,scOld_KTaTTACH)+S2(1,scOld_KTfORMAT)+S2(flKTsCRATCH_WMHhERE,scOld_KTfLAGSsCRATCH)+
                        tinP.zEtScratch->strFuseF( tinP , psttr , T("")+
                    {
                    if( !cEntries )

                    baP.swPoolHistory.ungrabF( tinP ) ;
                    }
                        }
                            stSnap.ungrabF( tinP ) ;
                            }
                                if( idf < cFlavors ) tinP.zEtScratch->strFuseF( tinP , psttr , T("")+S2(saOLD_KTaTTACHdOWN,scOld_KTaTTACH) ) ;

                                tinP.zEtScratch->delF( tinP , psttGraph4 ) ;
                                tinP.zEtScratch->delF( tinP , psttGraph3 ) ;
                                tinP.zEtScratch->delF( tinP , psttGraph2 ) ;
                                tinP.zEtScratch->delF( tinP , psttGraph1 ) ;
                                }
                                    ) ;

                                        T(psttGraph4)
                                        S2(saOLD_KTaTTACHuP,scOld_KTaTTACH)+S2(1,scOld_KTfORMAT)+S2(flKTsCRATCH_null,scOld_KTfLAGSsCRATCH)+
                                        T("cAccesses cCollisions")+
                                        S2(saOLD_KTaTTACHdOWN,scOld_KTaTTACH)+S2(1,scOld_KTfORMAT)+S2(flKTsCRATCH_null,scOld_KTfLAGSsCRATCH)+

                                        T(psttGraph3)+
                                        S2(saOLD_KTaTTACHuP,scOld_KTaTTACH)+S2(1,scOld_KTfORMAT)+S2(flKTsCRATCH_null,scOld_KTfLAGSsCRATCH)+
                                        T("cbPool cdUsed")+
                                        S2(saOLD_KTaTTACHdOWN,scOld_KTaTTACH)+S2(1,scOld_KTfORMAT)+S2(flKTsCRATCH_null,scOld_KTfLAGSsCRATCH)+

                                        T(psttGraph2)+
                                        S2(saOLD_KTaTTACHuP,scOld_KTaTTACH)+S2(1,scOld_KTfORMAT)+S2(flKTsCRATCH_null,scOld_KTfLAGSsCRATCH)+
                                        T("cDropNewed cDropDeleted")+
                                        S2(saOLD_KTaTTACHdOWN,scOld_KTaTTACH)+S2(1,scOld_KTfORMAT)+S2(flKTsCRATCH_null,scOld_KTfLAGSsCRATCH)+

                                        T(psttGraph1)+
                                        S2(saOLD_KTaTTACHuP,scOld_KTaTTACH)+S2(1,scOld_KTfORMAT)+S2(flKTsCRATCH_null,scOld_KTfLAGSsCRATCH)+
                                        T("cdUsed")+
                                        S2(saOLD_KTaTTACHuP,scOld_KTaTTACH)+S2(1,scOld_KTfORMAT)+S2(flKTsCRATCH_null,scOld_KTfLAGSsCRATCH)+

                                    tinP.zEtScratch->strFuseF( tinP , psttr , T("")+
                                {
                                if( !baP.idDisplayRequest )

                                }
                                    if( !baP.idDisplayRequest )tinP.zEtScratch->strGraphF( tinP , psttGraph4 , lever , bLever , swsX , swsY , swColor , swMarker , 0x100 , 0x100 , ifcIDsTYLEsTRgRAPH_STYLE1 , flSTRgRAPH_ORIGINyiSzE , T("cAccesses cCollisions") , count3S( 6 , 7 ) ) ;
                                    if( !baP.idDisplayRequest )tinP.zEtScratch->strGraphF( tinP , psttGraph3 , lever , bLever , swsX , swsY , swColor , swMarker , 0x100 , 0x100 , ifcIDsTYLEsTRgRAPH_STYLE1 , flSTRgRAPH_ORIGINyiSzE , T("cbPool cdUsed") , count3S( 4 , 5 ) ) ;
                                    if( !baP.idDisplayRequest )tinP.zEtScratch->strGraphF( tinP , psttGraph2 , lever , bLever , swsX , swsY , swColor , swMarker , 0x100 , 0x100 , ifcIDsTYLEsTRgRAPH_STYLE1 , flSTRgRAPH_ORIGINyiSzE , T("cDropNewed cDropDeleted") , count3S( 2 , 3 ) ) ;
                                    if( !baP.idDisplayRequest )tinP.zEtScratch->strGraphF( tinP , psttGraph1 , lever , bLever , swsX , swsY , swColor , swMarker , 0x100 , 0x100 , ifcIDsTYLEsTRgRAPH_STYLE1 , flSTRgRAPH_ORIGINyiSzE , T("cdUsed") , count2S( 1 ) ) ;
    
                                    while( !stSnap.third && ~hDown && !baP.idDisplayRequest ) ;
                                    }
                                        if( !hDown ) snapLath = snap ;
                                        }
                                            snapWoth = snap ;
                                            bWoth = 0 ;
                                        {
                                        if( bWoth )

                                        swsY << (measureT)snap.cCollisions ;
                                        swsX << (measureT)( *(countT*)(byteT*)&snap.time1o + 2 ) ;
                                        lever = 7 ;
    
                                        swsY << (measureT)snap.cAccesses ;
                                        swsX << (measureT)( *(countT*)(byteT*)&snap.time1o + 2 ) ;
                                        lever = 6 ;
    
                                        swsY << (measureT)snap.cdUsed ;
                                        swsX << (measureT)( *(countT*)(byteT*)&snap.time1o + 2 ) ;
                                        lever = 5 ;
    
                                        swsY << (measureT)snap.cbPool ;
                                        swsX << (measureT)( *(countT*)(byteT*)&snap.time1o + 2 ) ;
                                        lever = 4 ;
    
                                        swsY << (measureT)snap.cDropDeleted ;
                                        swsX << (measureT)( *(countT*)(byteT*)&snap.time1o + 2 ) ;
                                        lever = 3 ;
    
                                        swsY << (measureT)snap.cDropNewed ;
                                        swsX << (measureT)( *(countT*)(byteT*)&snap.time1o + 2 ) ;
                                        lever = 2 ;
    
                                        swsY << (measureT)snap.cdUsed ;
                                        swsX << (measureT)( *(countT*)(byteT*)&snap.time1o + 2 ) ;
                                        lever = 1 ;
    
                                        poolOldSnapS& snap = *(poolOldSnapS*)&stSnap.downF( tinP , hDown ) ;
                                    {
                                    do
                                    boolT bWoth = 1 ;
                                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                ZE( strokeS* , psttGraph4 ) ;
                                ZE( strokeS* , psttGraph3 ) ;
                                ZE( strokeS* , psttGraph2 ) ;
                                ZE( strokeS* , psttGraph1 ) ;
                                poolOldSnapS snapLath( tinP , *tinP.zEtScratch ) ;
                                poolOldSnapS snapWoth( tinP , *tinP.zEtScratch ) ;
                                lever = 7 ; swColor = 0x0000ff ;
                                lever = 6 ; swColor = 0x00ff00 ;
                                lever = 5 ; swColor = 0x00ff00 ;
                                lever = 4 ; swColor = 0xff0000 ;
                                lever = 3 ; swColor = 0x0000ff ;
                                lever = 2 ; swColor = 0x00ff00 ;
                                lever = 1 ; swColor = 0xff0000 ;
                                switchC swMarker( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO , lever ) ;
                                switchC swColor( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO , lever ) ;
                                switchStackC swsY( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO , lever , flSTACKc_FIFO , ifcSTACKtYPE_measureT ) ;
                                switchStackC swsX( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO , lever , flSTACKc_FIFO , ifcSTACKtYPE_measureT ) ;
                                batonC bLever( tinP , TAG( TAGiDnULL ) ) ;
                                ZE( countT , lever ) ;
                            {
                            else
                            }
                                ) ;
                                    T("please wait while i make my woth oo observations of this poolOld")
                                    S2(saOLD_KTaTTACHuP,scOld_KTaTTACH)+S2(1,scOld_KTfORMAT)+S2(flKTsCRATCH_null,scOld_KTfLAGSsCRATCH)+
                                tinP.zEtScratch->strFuseF( tinP , psttr , T("")+
                            {
                            if( !stSnap )
                            stSnap.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            stackC& stSnap = *history.pStkSnap ;
                        {
                        else
                        }
                            ) ;
                                T("please wait while i set up")
                                S2(saOLD_KTaTTACHuP,scOld_KTaTTACH)+S2(1,scOld_KTfORMAT)+S2(flKTsCRATCH_null,scOld_KTfLAGSsCRATCH)+
                            tinP.zEtScratch->strFuseF( tinP , psttr , T("")+
                        {
                        if( !history.pStkSnap )

                        if( bWoth ) bWoth = 0 ;
                        ) ;
                            TF3(history.cRef,flFORMAT_UNSIGNED,3)+T(baP.psttPoolName)
                            S2(bWoth?saOLD_KTaTTACHuP:saOLD_KTaTTACHdOWN,scOld_KTaTTACH)+S2(1,scOld_KTfORMAT)+S2(bWoth?flKTsCRATCH_WMHhERE:flKTsCRATCH_null,scOld_KTfLAGSsCRATCH)+
                        tinP.zEtScratch->strFuseF( tinP , psttr , T("")+
                        cEntries ++ ;

                        __( !history.cRef ) ;
                        __( !history.pStkSnap ) ;
                        poolOldHistoryS& history = *(poolOldHistoryS*)&(countT&)baP.swPoolHistory ;
                        baP.psttPoolName = (strokeS*)baP.swPoolHistory.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !baP.idDisplayRequest ; idf ++ )
                    boolT bWoth = 1 ;
                    ZE( countT , cEntries ) ;

                    , 0x100 + cFlavors * 0x100000 ) ; ___( psttr ) ; //WHAT IS A REASONABLE ALOCATION FOR THE REPORT ON A SINGLE POOLoLD?
                        T("idDisplay:")+TF1(baP.idDisplay)+T(" [1,")+TF1(IDdISPLAYmAX)+T("]")+T("    ")+TT(timeN1,timeN2)+T("    ")+TF1(cFlavors)+T(" shared memory poolOlds are attached")
                        S2(1,scOld_KTfORMAT)+S2(flKTsCRATCH_null,scOld_KTfLAGSsCRATCH)+
                    tinP.zEtScratch->strFuseF( tinP , psttr , T("\f")+

                    countT cFlavors = baP.swPoolHistory.cFlavorsF( tinP ) ;
                    baP.swPoolHistory.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    strokeS sDot('.') ;
                    bKt = 1 ;
                {
                case 5 :
                }
                    break ;

                    }
                        }
                            while( !stGrabImage.third && ~hDown && !baP.idDisplayRequest ) ;
                            }
                                if( bTinWantCopied ) { DEL( pTinWant ) ; }
                                if( bTinHaveCopied ) { DEL( pTinHave ) ; }
            
                                tinP.zEtScratch->strFuseF( tinP , psttr , T("\r\n") ) ;
    
                                }
                                    ) ;
                                        sb+sttStar+TF1(pTinWant->idAdamRoot)+sb+T(pTinWant->postThreadName)
                                    tinP.zEtScratch->strFuseF( tinP , psttr , T("")+
                                    strokeS sttStar( baP.osPid == pTinWant->osPid ? '*' : ' ' ) ;
                                {
                                if( pTinWant )
    
                                else if( pTinWant ) tinP.zEtScratch->strFuseF( tinP , psttr , T("  ")+TPS("",0x18,sDot) ) ;
                                }
                                    ) ;
                                        sb+sttStar+TF3(pTinHave->idAdamRoot,flFORMAT_UNSIGNED,8)+TP(pTinHave->postThreadName,0x10)
                                    tinP.zEtScratch->strFuseF( tinP , psttr , T("")+
                                    strokeS sttStar( baP.osPid == pTinHave->osPid ? '*' : ' ' ) ;
                                {
                                if( pTinHave )
    
                                ) ;
                                    TF3(grab.idLineCt,flFORMAT_UNSIGNED,9)+TF3(grab.idiFileCt,flFORMAT_UNSIGNED,9)+TF3(grab.osTidHave,flFORMAT_UNSIGNED,9)+TF3(grab.osPidHave,flFORMAT_UNSIGNED,9)+TF3(grab.osTidWant,flFORMAT_UNSIGNED,9)+TF3(grab.osPidWant,flFORMAT_UNSIGNED,9)+TF3(grab.cAccesses,flFORMAT_UNSIGNED,9)+TF3(grab.cCollisions,flFORMAT_UNSIGNED,9)+sttBS
                                tinP.zEtScratch->strFuseF( tinP , psttr , T("")+
                                *tinP.zEtScratch = 0 ;

                                ;
                                        : S1C( 'g' )
                                        ? S1C( 'p' )
                                    : F(grab.flags) & flGRABs_PSEUDO
                                        : S1C( 'b' ) // ASSUME: IF ANNOTATED AND NOT CT AS signC THEN CT AS batonC. THIS IS DONE FOR SPEED
                                        ? S1C( 's' )
                                    ? F( ((grabAnnotatedS&)grab).grabNotes.flags ) & flGRABnOTES_CTaSsIGNc
                                sttBS = F(grab.flags) & flGRABs_ANNOTATED
                                strokeS sttBS( ' ' ) ;
    
                                if( grab.osTidWant && grab.osPidWant ) pTinF( tinP , *tinP.zEtScratch , pTinWant , bTinWantCopied , grab.osTidWant , grab.osPidWant , baP , 1 ) ;
                                ZE( boolT , bTinWantCopied ) ;
                                ZE( tinS* , pTinWant ) ;
                                *tinP.zEtScratch = 0 ;
    
                                if( grab.osTidHave && grab.osPidHave ) pTinF( tinP , *tinP.zEtScratch , pTinHave , bTinHaveCopied , grab.osTidHave , grab.osPidHave , baP , 1 ) ;
                                ZE( boolT , bTinHaveCopied ) ;
                                ZE( tinS* , pTinHave ) ;
                                *tinP.zEtScratch = 0 ;
    
                                grabOldS& grab = *(grabOldS*)&stGrabImage.downF( tinP , hDown ) ;
                            {
                            do
                            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        {
                        if( stGrabImage && !baP.idDisplayRequest )
    
                        }
                            case '*' : { sStarT.idAdam = '-' ; break ; }
                            case '-' : { sStarT.idAdam = '*' ; break ; }
                        {
                        switch( sStarT.idAdam )
                        }
                            case 'p' : { sBST.idAdam = '-' ; break ; }
                            case 'g' : { sBST.idAdam = 'p' ; break ; }
                            case 'b' : { sBST.idAdam = 'g' ; break ; }
                            case 's' : { sBST.idAdam = 'b' ; break ; }
                            case '-' : { sBST.idAdam = 's' ; break ; }
                        {
                        switch( sBST.idAdam )
                        }
                            , 0x100 + stGrabImage * 0x100 ) ; ___( psttr ) ;
                                TPS("idLineCt",8,sd)+sb+TPS("idiFileC",8,sd)+sb+TPS("osTidHav",8,sd)+sb+TPS("osPidHav",8,sd)+sb+TPS("osTidWan",8,sd)+sb+TPS("osPidWan",8,sd)+sb+TPS("cAccesse",8,sd)+sb+TPS("cCollisi",8,sd)+sb+sBST+sb+sStarT+TPS("idAdamH",7,sd)+sb+TPS("threadHave",0x10,sd)+sb+sStarT+TPS("idAdamW",7,sd)+sb+TPS("threadWant",0x10,sd)+tc2
                                T("idDisplay:")+TF1(baP.idDisplay)+T(" [1,")+TF1(IDdISPLAYmAX)+T("]")+T("    ")+TT(timeN1,timeN2)+T("    i am monitoring ")+TF1(cInspected)+T(" grabOldS object images constructed by ")+TF1(swIdProcess.cFlavorsF(tinP))+T(" processes, watching for deadlocks\r\n \r\nnote on shared memory: if a grabOldS object is visible to 3 processes, each \"view\" is an \"image\".  i monitor images\r\neach such image is counted separately in all of my displays\r\nthis display reports all items that are grabbed\r\nit is sorted by cCollisions\r\n \r\n")+
                            tinP.zEtScratch->strFuseF( tinP , psttr , T("\f")+
                        {
                        if( !baP.idDisplayRequest )
                    {
                    else
                    }
                        }
                            }
                                tinP.zEtScratch->strFuseF( tinP , psttr , tc ) ;
                                if( bRing ) tinP.zEtScratch->strFuseF( tinP , psttr , T(" RING ") ) ;
                                }
                                    tinP.zEtScratch->strFuseF( tinP , psttr , tb+TF1(idWant) ) ;
                                    st_idWant >> idWant ;
                                    ZE( countT , idWant ) ;
                                {
                                while( st_idWant )
                                tinP.zEtScratch->strFuseF( tinP , psttr , TF1(idHave)+T(":") ) ;

                                boolT bRing = idWantF( tinP , st_idWant , stGrabImage , idHave , baP ) ;
                                stackC st_idWant( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;
                            {
                            for( countT idHave = 1 ; idHave <= stGrabImage ; idHave ++ )
                        {
                        if( stGrabImage && !baP.idDisplayRequest )
    
                        }
                            , 0x100 + stGrabImage * 0x100 ) ; ___( psttr ) ;
                                TPS("idLineCt",8,sd)+sb+TPS("idiFileC",8,sd)+sb+TPS("osTidHav",8,sd)+sb+TPS("osPidHav",8,sd)+sb+TPS("osTidWan",8,sd)+sb+TPS("osPidWan",8,sd)+sb+TPS("cAccesse",8,sd)+sb+TPS("cCollisi",8,sd)+sb+sBST+sb+sStarT+TPS("idAdamH",7,sd)+sb+TPS("threadHave",0x10,sd)+sb+sStarT+TPS("idAdamW",7,sd)+sb+TPS("threadWant",0x10,sd)+tc2
                                T("idDisplay:")+TF1(baP.idDisplay)+T(" [1,")+TF1(IDdISPLAYmAX)+T("]")+T("    ")+TT(timeN1,timeN2)+T("    i am monitoring ")+TF1(cInspected)+T(" grabOldS object images constructed by ")+TF1(swIdProcess.cFlavorsF(tinP))+T(" processes, displaying deadlock rings\r\n \r\nnote on shared memory: if a grabOldS object is visible to 3 processes, each \"view\" is an \"image\".  i monitor images\r\neach such image is counted separately in all of my displays\r\nthis display reports all items that are grabbed\r\nit is sorted by cCollisions\r\n \r\n")+
                            tinP.zEtScratch->strFuseF( tinP , psttr , T("\f")+
                        {
                        if( !baP.idDisplayRequest )
                    {
                    if( baP.idDisplay == 3 )
                    static strokeS sStarT( '-' ) ;
                    static strokeS sBST( '-' ) ;
                    strokeS sDot( '.' ) ;
                    strokeS sb( ' ' ) ;
                    strokeS sd( '-' ) ;
                    TN( tc2 , "\r\n \r\n" ) ;
                    TN( tc  , "\r\n" ) ;
                    TN( tb  , " " ) ;

                    }
                        baP.bLeverOsPid.ungrabF( tinP ) ;
    
                        baP.sws_pGrab.ungrabF( tinP ) ;
                        }
                            }
                                while( !baP.sws_pGrab.third && ~hDown && !baP.idDisplayRequest ) ;
                                }
                                    }
                                        }
                                            }
                                                ((countT&)swIdProcess) ++ ;
                                                ((thirdC&)etScratch).dosWriteProcessMemoryIF( tinP , bOk , pbRaw + offm , baP.leverOsPid , (byteT*)&grab.cAccessesSeenByMonitor , 2 * sizeof( countT ) ) ;
                                                bOk = 0 ;
                                                countT offm = (byteT*)&grab.cAccessesSeenByMonitor - (byteT*)&grab ;
                                                grab.cCollisionsSeenByMonitor = grab.cCollisions ;
                                                grab.cAccessesSeenByMonitor   = grab.cAccesses   ;
                                                stGrabImage.sinkF( tinP , countTC() , pbGA , flSTACKsINK_null , subtractGrabImageBlobsF ) ;
                                            {
                                            if( bOk )
    
                                            }
                                                ((thirdC&)etScratch).dosReadProcessMemoryIF( tinP , pbGA + sizeof( grabOldS ) , sizeof( grabAnnotatedS ) - sizeof( grabOldS ) , bOk , pbRaw + sizeof( grabOldS ) , baP.leverOsPid ) ;
                                                bOk = 0 ;
                                            {
                                            if( F(grab.flags) & flGRABs_ANNOTATED )
                                        {
                                        if( grab.scGrab > 0 )
                                        grabOldS& grab = *(grabOldS*)pbGA ;
                                    {
                                    if( bOk )
                                    ((thirdC&)etScratch).dosReadProcessMemoryIF( tinP , pbGA , sizeof( grabOldS ) , bOk , pbRaw , baP.leverOsPid ) ;
                                    byteT* const pbRaw = (byteT*)baP.sws_pGrab.downF( tinP , hDown ) ;
                                    ZE( boolT , bOk ) ;
                                    byteT pbGA[ sizeof( grabAnnotatedS ) ] ;
                                {
                                do
                                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                cInspected += baP.sws_pGrab ;
                            {
                            if( baP.sws_pGrab )
                            baP.leverOsPid = baP.sws_pGrab.leverF( tinP , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cFlavors && !baP.idDisplayRequest ; idf ++ )
                        cFlavors = baP.sws_pGrab.cFlavorsF( tinP ) ;
                        baP.sws_pGrab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
                        baP.swsIdaGrab.ungrabF( tinP ) ;
                        }
                            }
                                while( !baP.swsIdaGrab.third && ~hDown && !baP.idDisplayRequest ) ;
                                }
                                    }
                                        ((countT&)swIdProcess) ++ ;
                                        pGrab->cCollisionsSeenByMonitor = pGrab->cCollisions ;
                                        pGrab->cAccessesSeenByMonitor   = pGrab->cAccesses   ;
                                        stGrabImage.sinkF( tinP , countTC() , (byteT*)pGrab , flSTACKsINK_null , subtractGrabImageBlobsF ) ;
                                    {
                                    if( pGrab && pGrab->scGrab > 0 )
                                    grabOldS* pGrab = (grabOldS*)(byteT*)ap_artmentOldC( tinP , baP.swsIdaGrab.downF( tinP , hDown ) ) ;
                                {
                                do
                                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                cInspected += baP.swsIdaGrab ;
                            {
                            if( baP.swsIdaGrab )
                            baP.leverOsPid = baP.swsIdaGrab.leverF( tinP , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cFlavors && !baP.idDisplayRequest ; idf ++ )
                        countT cFlavors = baP.swsIdaGrab.cFlavorsF( tinP ) ;
                        baP.swsIdaGrab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
                        baP.bLeverOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    ZE( countT , cInspected ) ;
                    switchC swIdProcess( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , flSTACKc_null , baP.leverOsPid ) ;
                    stackC stGrabImage( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( grabAnnotatedS ) , 0 , cbGrabImageF ) ;
                {
                case 4 :
                case 3 :
                }
                    break ;
                    baP.swThread.ungrabF( tinP ) ;
                    }
                        ) ;

                            T(thread.postYell)+tc
                            TP(thread.postThreadName,0x10)+tb+
                            TF3(thread.osTid,flFORMAT_UNSIGNED,9)+

                        tinP.zEtScratch->strFuseF( tinP , psttr , 

                        threadS& thread = (threadS&)(countT&)baP.swThread ;
                        baP.leverOsTid = baP.swThread.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !baP.idDisplayRequest ; idf ++ )

                    , cFlavors * 0x100 ) ; ___( psttr ) ;

                        TPS("yell",COSTmAXtELL,sttd)+tc+tb+tc
                        TPS("name",0x10,sttd)+tb+
                        TPS("osTid",8,sttd)+tb+
                        T("\fidDisplay:")+TF1(baP.idDisplay)+T(" [1,")+TF1(IDdISPLAYmAX)+T("]")+T("    ")+TT(timeN1,timeN2)+T("    these ")+TF1(cFlavors)+T(" threads currently exist in ifc processes\r\n \r\n")+

                    tinP.zEtScratch->strFuseF( tinP , psttr , 
                    countT cFlavors = baP.swThread.cFlavorsF( tinP ) ;
                    baP.swThread.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    strokeS sttd( '-' ) ;
                    TN( tc , "\r\n" ) ;
                    TN( tb , " " ) ;
                {
                case 2 :
                }
                    break ;
                    }
                        }
                            DEL( pTinCopy ) ;
                            }
                                tinP.zEtScratch->strFuseF( tinP , psttr , tc ) ; ___( psttr ) ;
                                }
                                    }
                                        break ;
                                        __1
                                        __( baP.idDisplay ) ;
                                    {
                                    default :
                                    }
                                        break ;
                                        else                     { tinP.zEtScratch->strFuseF( tinP , psttr , TP(ppostWhere[idWhere2],0x18)+T(" ")+T(pTinCopy->postTellWait) ) ; ___( psttr ) ; }




                                        //U::if( baP.idDisplay == 1 ) { tinP.zEtScratch->strFuseF( tinP , psttr , TP(ppostWhere[idWhere2],0x18)+T(" ")+T(pTinCopy->postTell    ) ) ; ___( psttr ) ; }

                                        if( baP.idDisplay == 1 ) { tinP.zEtScratch->strFuseF( tinP , psttr , TP(ppostWhere[idWhere2],0x18)+T(" ")+TF1(pTinCopy->pcReserved[0xf])+T(" ")+TF1(pTinCopy->pcReserved[0xc])+T(" ")+TF1(pTinCopy->pcReserved[0xd])+T(" ")+TF1(pTinCopy->pcReserved[0xe])+T(" ")+T(pTinCopy->postTell) ) ; ___( psttr ) ; } //U::




                                        countT idWhere2 = pTinCopy->idWhere - ifcIDwHERE_IFC + 1 < sizeof ppostWhere / sizeof ppostWhere[ 0 ] ? pTinCopy->idWhere - ifcIDwHERE_IFC + 1 : 0 ;
                                    {
                                    case 3 :
                                    case 1 :
                                {
                                switch( baP.idDisplay )




                                //U::tinP.zEtScratch->strFuseF( tinP , psttr , TF3(pTinCopy->monitor.mStepsPerTuck,flFORMAT_EXPONENT,0xd)+sttStar+TF3(pTinCopy->idAdamRoot,flFORMAT_UNSIGNED,8)+TF3(pTinCopy->osTid,flFORMAT_UNSIGNED,9)+TF3(pTinCopy->osPid,flFORMAT_UNSIGNED,9)+TP(pTinCopy->postThreadName,0x20)+T(" ") ) ; ___( psttr ) ;

                                //tinP.zEtScratch->strFuseF( tinP , psttr , TF3(pTinCopy->idAdam,flFORMAT_UNSIGNED,8)+TF3(pTinCopy->osTid,flFORMAT_UNSIGNED,9)+TF3(pTinCopy->osPid,flFORMAT_UNSIGNED,9)+TP(pTinCopy->postThreadName,0x10)+T(" ") ) ; ___( psttr ) ; //U::
                                tinP.zEtScratch->strFuseF( tinP , psttr , TF3(pTinCopy->idAdamRoot,flFORMAT_UNSIGNED,8)+TF3(pTinCopy->osTid,flFORMAT_UNSIGNED,9)+TF3(pTinCopy->osPid,flFORMAT_UNSIGNED,9)+TP(pTinCopy->postThreadName,0x10)+T(" ") ) ; ___( psttr ) ; //U::




                                strokeS sttStar( baP.osPid == pTinCopy->osPid ? '*' : ' ' ) ;
                            {
                            if( !baP.idDisplayRequest )
                            st_pTinCopy >> (countT&)pTinCopy ;
                            ZE( tinS* , pTinCopy ) ;
                        {
                        while( !*tinP.zEtScratch && st_pTinCopy )
                    {
                    if( st_pTinCopy )
        
                    } ;
                        "OSwAITgRAB" ,
                        "OSoTHER" ,
                        "OSmONITOR" ,
                        "OSwAITiNTERNETaCCEPT" ,
                        "OSwAITiNTERNETwRITE" ,
                        "OSwAITiNTERNETrEAD" ,
                        "OSwAITfILEwRITE" ,
                        "OSwAITfILErEAD" ,
                        "OSwAITwINDOW" ,
                        "OSwAITmONITORING" ,
                        "OSwAITsIGN" ,
                        "OSwAITbATON" ,
                        "OSwAITnAP" ,
                        "IFC" ,
                        "<invalid value>" ,
                    {
                    static osTextT* ppostWhere[] = // 0010*.ifcIDwHERE AND func.12f0007.tinS.strFuseF AND adam.c740104 MUST BE KEPT IN SYNC
                    //U: THIS REALLY MUST GO INTO A SNIPPET FILE

                    else                     { tinP.zEtScratch->strFuseF( tinP , psttr , TPS("where",0x18,sttd)+sttb+TPS("tellWait",COSTmAXtELL,sttd)+tc+sttb+tc ) ; ___( psttr ) ; }
                    if( baP.idDisplay == 1 ) { tinP.zEtScratch->strFuseF( tinP , psttr , TPS("where",0x18,sttd)+sttb+TPS("tell"    ,COSTmAXtELL,sttd)+tc+sttb+tc ) ; ___( psttr ) ; }

                    }
                        case '*' : { sStarT.idAdam = '-' ; break ; }
                        case '-' : { sStarT.idAdam = '*' ; break ; }
                    {
                    switch( sStarT.idAdam )
                    , 0x100 + st_pTinCopy * 0x100 ) ; ___( psttr ) ;

                        TPS("speed",0xc,sttd)+sttb+sStarT+TPS("idAdamPO",7,sttd)+sttb+TPS("osTid",8,sttd)+sttb+TPS("osPid",8,sttd)+sttb+TPS("thread",0x20,sttd)+sttb
                        T("idDisplay:")+TF1(baP.idDisplay)+T(" [1,")+TF1(IDdISPLAYmAX)+T("]")+T("    ")+TT(timeN1,timeN2)+T("    cThreads: ")+TF1(st_pTinCopy)+T("    ")+(baP.idDisplay==1?T("what each thread is doing"):T("what each thread is waiting for"))+tc+sttb+tc+

                    tinP.zEtScratch->strFuseF( tinP , psttr , T("\f")+
                    static strokeS sStarT( '-' ) ;
    
                    }
                        }
                            st_pTinCopy << c_pTinCopy ;
                            sws_pTinCopy >> c_pTinCopy ;
                            ZE( countT , c_pTinCopy ) ;
                        {
                        while( !*tinP.zEtScratch && sws_pTinCopy )
                        leverOsPidCopy = sws_pTinCopy.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !baP.idDisplayRequest ; idf ++ )
                    cFlavors = sws_pTinCopy.cFlavorsF( tinP ) ;
                    stackC st_pTinCopy( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;
    
                    baP.bLeverOsPid.ungrabF( tinP ) ;
            
                    }
                        }
                            while( !*tinP.zEtScratch && !baP.sws_pTin.third && ~hDown && !baP.idDisplayRequest ) ;
                            }
                                }
                                    }
                                        }
                                            }
                                                else                                 { DEL( pTinCopy ) ; }
                                                if( pTinCopy && pTinCopy->idThread ) sws_pTinCopy << (countT)pTinCopy ;
                                            {
                                            else
                                            if( *tinP.zEtScratch ) *tinP.zEtScratch = 0 ;
                                            __Z( pTinCopy ) ;
                                            pTinCopyF( tinP , *tinP.zEtScratch , pTinCopy , pvTin , baP.leverOsPid , 1 ) ; ___( pTinCopy ) ;
                                            ZE( tinS* , pTinCopy ) ;
                                            bOk = 0 ;
                                        {
                                        if( bOk )
                                        ((thirdC&)etScratch).dosWriteProcessMemoryIF( tinP , bOk , pvMon , baP.leverOsPid , (byteT*)&ms.monitor , sizeof ms.monitor ) ;
                                    {
                                    else
                                    if( *tinP.zEtScratch ) *tinP.zEtScratch = 0 ;
                                    stampF( tinP , *tinP.zEtScratch , ms.monitor , ms.idStep , baP ) ;
                                    bOk = 0 ;
                                {
                                if( bOk )
                                ((thirdC&)etScratch).dosReadProcessMemoryIF( tinP , (byteT*)&ms , sizeof ms , bOk , pvMon , leverOsPidCopy ) ;
                                monPlusS ms( tinP ) ;
                                voidT* pvMon = (voidT*)( (byteT*)pvTin + offm ) ;
                                voidT* pvTin = (voidT*)baP.sws_pTin.downF( tinP , hDown ) ;
                            {
                            do
                            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        {
                        if( baP.sws_pTin )
                        leverOsPidCopy = baP.leverOsPid = baP.sws_pTin.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; !*tinP.zEtScratch && idf <= cFlavors && !baP.idDisplayRequest ; idf ++ )
                    countT cFlavors = baP.sws_pTin.cFlavorsF( tinP ) ;
                    ZE( boolT , bOk ) ;
                    const countT offm = (byteT*)&tinP.monitor - (byteT*)&tinP ;
            
                    }
                        ungrabF( tinP , grab_off_aIdaTin ) ;
                        }
                            }
                                }
                                    }
                                        sws_pTinCopy << (countT)pTinCopy ;
                                        pTinCopy->pPool = &>>>>(p oolC&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<Scratch ;
                                        leverOsPidCopy = pTinCopy->osPid ;
                                    {
                                    if( pTinCopy )
                                    tinS* pTinCopy = new( 0 , tinP , LF ) tinS( *pTin , flTINs_DISABLEcOMMENTS | flTINs_CONSTRUCTqUIETLY ) ; ___( pTinCopy ) ;
                                    p oolC& poolOld = >>>>(p oolC&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<Scratch ;
                                {
                                else
                                if( *tinP.zEtScratch ) *tinP.zEtScratch = 0 ;
                                stampF( tinP , *tinP.zEtScratch , pTin->monitor , pTin->idStep , baP ) ;
                            {
                            if( pTin && pTin->idThread )
                            tinS* pTin = (tinS*)(byteT*)ap_artmentOldC( tinP , baP.aIdaTin[ idt ] ) ;
                        {
                        for( countT idt = 1 ; idt <= baP.aIdaTin[ 0 ] && baP.aIdaTin[ idt ] && !baP.idDisplayRequest ; idt ++ )
                        grabF( tinP , grab_off_aIdaTin ) ;
                    {
                    if( baP.bMonitored )
            
                    switchStackC sws_pTinCopy( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO , leverOsPidCopy , flSTACKc_FIFO ) ;
                    ZE( countT , leverOsPidCopy ) ;
            
                    baP.bLeverOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ; //ASSUME: WHILE GRABBED, tinS OBJECTS IN THE MONITORED PROCESS WILL NOT BE DELETED (THIS WILL BE TRUE IF THE hanSayF HANDLER FOR tinS DESTRUCTION GRABS TOO)
                    TELL( "displaying the status of each monitored thread" )
                {
                case 0xb : //U: CASE a NEEDS SOME MINOR DEBUGGING; CONJ: IT CAUSES IMPOTENCE
                case 1 :
            {
            switch( baP.idDisplay )
            ZE( strokeS* , psttr ) ;
            strokeS sttd( '-' ) ;
            strokeS sttb( ' ' ) ;
            TN( tc , "\r\n" ) ;

            }
                baP.idDisplayRequest = 0 ;
                baP.idDisplay = baP.idDisplayRequest ;
            {
            if( baP.idDisplayRequest )
            
            tinP.zEtScratch->osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
            ZE( boolT , bKt ) ;
        {
        if( F(thirdC::third_flagsProcessState_IF(tinP)) & flPROCESSsTATE_OUTPUTwINDOWiSvISIBLE )
        TELL( "looking to see whether my output window is visible" )

        TELL( "waking" )
        }
            while( cNaps -- && !*tinP.zEtScratch && !baP.idDisplayRequest ) tinP.zEtScratch->osSleepF( tinP , TUCK * 0x10 ) ;
            countT cNaps = 0x10 ;
            TELL( "sleeping for 1 tock before the next cycle" )

            //if( baP.bMonitored && idPass == 8 ) tinP.zEtScratch->etherFireImpersonateMonitorIF( tinP ) ; //FOR GORILLA TESTING
        {
        else
        }
            }
                //U:SEEMS TO BLOCK THE LAUNCH OF 254 DEADMAN ET AL: tinP.zEtScratch->osMessageBoxF( tinP , tHello , tTitle ) ;
            
                ) ;
            
                    "Thank you for your interest in the IdeaFarm " "(tm) City."
                    "Please view http://www.ideafarm.com for current system status before clicking \"OK\".  "
                    "This version has been released for technology evaluation purposes only.  "
            
                TN( tHello ,
                TN( tTitle , "IdeaFarm " "(tm) City - www.ideafarm.com" ) ;
            {
            if( !baP.bMonitored )

            ether.osSleepF( tinP , TOCK * 8 ) ;
            TELL( "sleeping for 8 tocks while logo displays and child processes start" )
        {
        if( ++ idPass == 1 )
        *tinP.zEtScratch = 0 ;
    {
    while( !etThread && ( !ether || baP.cMonitors || cAllKidThreads > /*U::3*/2 + bGraphicDisplay ) ) // ME tmWatchF tmObservePoolsF tmWindowsF
    //U::I MUST BE ABLE TO HANDLE FAILURES IN READING OR WRITING PROCESS MEMORY
    //I REMAIN ACTIVE UNTIL ALL MONITORED PROCESSES AND ALL OTHER THREADS ARE GONE, SO THAT I CAN CONTINUE TO REPORT STATUS

    //while( !etThread && !ether )
    //THIS CAN HAPPEN DURING QUIT SINCE DURING QUIT hanSayF DOES NOT MAINTAIN THREAD AND OTHER INFO
    //ASSUME: ether IMPOTENCE IS DETECTED BY ME BEFORE WO OF MY READ PROCESS MEMORY CALLS FAILS
    //U::DELETE THIS DOCUMENTATION AFTER HAVE RESOLVED THIS ISSUE

    ZE( countT , idDisplayLast ) ;
    countT& cAllKidThreads = thirdC::os_cAllKidThreadsI_IF( tinP ) ;
    const boolT bGraphicDisplay = !!( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_tmWindows ) ;
    ZE( boolT , bKidsFired ) ;
    ZE( countT , idPass ) ;

    //U::etThread.osThreadF( tinP , countTC() , tmObservePoolsF , 0 , flTHREADlAUNCH_null , 0 , (countT)&baP ) ;

    countT&     off_aIdaTin = baP.bMonitored ?      poolOld Side.off_aIdaTin_314m :      poolOld Side.off_aIdaTin_314 ;
    grabOldS& grab_off_aIdaTin = baP.bMonitored ? poolOld Side.grab_off_aIdaTin_314m : poolOld Side.grab_off_aIdaTin_314 ;
    poolOld SideS& poolOld Side = (poolOld SideS&)poolOldDflt ;
    const countT* const pcPool = (countT*)(byteT*)poolOldDflt ; //THIS IS USED TO ACCESS PRIVATE VALUES IN THE POOLoLD HEADER
    p oolC& poolOldDflt = poolC::poolOldRootIF( tinP ) ;

    //U::if( !baP.bMonitored ) etThread.osThreadF( tinP , countTC() , tmDeadman_tmDisplay_F , 0 , flTHREADlAUNCH_null , 0 , (countT)&tinP ) ;
    bookAllS& baP = *(bookAllS*)pTaskP->c1 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 )
TASK( tmDisplayF )

}
    return bRing ;

    stGrabImageP.ungrabF( tinP ) ;

    }
        while( !stGrabImageP.third && ~hDown && !baP.idDisplayRequest ) ;
        }
            }
                else bRing = idWantF( tinP , st_idWantP , stGrabImageP , idPlate , baP ) ;
                }
                    break ;
                    bRing = 1 ;
                {
                if( st_idWantP( idHaveP ) )
                st_idWantP << idPlate ;
            {
            if( gHave.osTidHave == gWant.osTidWant && idPlate != idHaveP )
            grabOldS& gWant = *(grabOldS*)&stGrabImageP.downF( tinP , hDown ) ;
            idPlate ++ ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        ZE( countT , idPlate ) ;

        grabOldS& gHave = *(grabOldS*)&stGrabImageP[ idHaveP ] ;
    {
    if( idHaveP && idHaveP <= stGrabImageP )

    stGrabImageP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    ZE( boolT , bRing ) ;
{
boolT idWantF( tinS& tinP , stackC& st_idWantP , stackC& stGrabImageP , const countT idHaveP , bookAllS& baP )
*/
 baP
  he wants an image indirectly if it is wanted by the osTid that has an image that he wants
  he wants an image directly if he appears as osTidWant and the image is not idHaveP
  my job is to find out which images he wants, directly or indirectly
  the osTid that "has" this image is the subject of my work
  the id of the image to start with
 idHaveP
  images to inspect
 stGrabImageP
  i will fill this with the id's of the images that the owner of image idHaveP wants, directly or indirectly
 st_idWantP
 tinP
arguments
/*

}
    return F(grab.flags) & flGRABs_ANNOTATED ? sizeof( grabAnnotatedS ) : sizeof( grabOldS ) ;
    if( tinP.fingerprint && etherP ) ; //U: DO SOMETHING LESS EXPENSIVE TO AVOID THE COMPILER WARNING
    grabOldS& grab = *(grabOldS*)pbP ;
{
countT cbGrabImageF( tinS& tinP , etherC& etherP , const byteT* const pbP )

//U: DONE( tmDeadman_tmDisplay_F )
//U: }
//U:     TELL( "cleaning up" )
//U:     }
//U:         idStepLast = tinDead.idStep ;
//U:         }
//U:             thirdC::dosWriteStdOutIF( tinP , tNote ) ;
//U:             tNote = T("\f")+TF1(tinP.monitor.idStep)+T(" thread \"")+T(tinDead.postThreadName)+T("\" deadlocked while \"")+T(tinDead.postTell)+T("\"\r\n") ;
//U:             TELL( "reporting a locked up thread" )
//U:         {
//U:         if( idStepLast == tinDead.idStep )
//U:         TELL( "" )
//U:         ether.osSleepF( tinP , TOCK ) ;
//U:         TELL( "napping for 1 tock" )
//U:     {
//U:     while( !etThread && !ether )
//U:     TN( tNote , "" ) ;
//U:     countT idStepLast = tinDead.idStep ;
//U: 
//U:     tinS& tinDead = *(tinS*)pTaskP->c1 ;
//U:     TELL( "setting up" )
//U: {
//U: if( pTaskP && pTaskP->c1 )
//U: TASK( tmDeadman_tmDisplay_F )
//U: 
}
    return - scSgn ;
    if( tinP.fingerprint ) ;
    }
        scSgn = grab1.cCollisions - grab2.cCollisions ; //U: USE THE 4 FIELDS
        grabOldS& grab2 = *(grabOldS*)c2P ;
        grabOldS& grab1 = *(grabOldS*)c1P ;
    {
    if( pEther && c3P == sizeof( grabOldS ) )
    ZE( sCountT , scSgn ) ;
{
countT subtractGrabImageBlobsF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

DONE( tmObservePoolsF )
}
    TELL( "cleaning up" )

    }
        baP.swPoolHistory.ungrabF( tinP ) ;
        }
            }
                }
                    etThread.delF( tinP , pbb ) ;
                    stSnap >> pbb ; ___( pbb ) ;
                    ZE( byteT* , pbb ) ;
                {
                while( stSnap > 0x100 )
                stSnap << (byteT*)&snap ;

                snap.cDropDeletedAtLathCursorReset  =           pcPool[ - 0x13 ] ;
                snap.cDropDeleted                   =           pcPool[ - 0x12 ] ;
                snap.cDropNewed                     =           pcPool[ - 0x11 ] ;
                snap.cAccesses                      =           pcPool[ - 0x10 ] ;
                snap.cCollisions                    =           pcPool[ -  0xf ] ;
                snap.cNotUsed                       =           pcPool[ -  0xe ] ;
                snap.cdUsed                         =           pcPool[ -  0xd ] ;
                snap.cbUsed                         =           pcPool[ -  0xc ] ;
                snap.offHighWater                   =           pcPool[ -  0xb ] ;
                snap.offCursor                      =           pcPool[ -  0xa ] ;
                snap.offNewLast                     =           pcPool[ -    9 ] ;
                snap.offNewMin                      =           pcPool[ -    8 ] ;
                snap.off                            =           pcPool[ -    7 ] ;
                snap.cbPool                         =           pcPool[ -    6 ] ;
                snap.flagsBack                      =           pcPool[ -    5 ] ;
                snap.idClientLast                   =           pcPool[ -    4 ] ;
                snap.idClientGrabbing               =           pcPool[ -    3 ] ;
                snap.idFormat                       =           pcPool[ -    2 ] ;
                snap.fingerprint                    =           pcPool[ -    1 ] ;
                // CODE SYNCH: 6a40104 003001b

                const countT* const pcPool = (countT*)(byteT*)poolOldl ; //USED TO ACCESS PRIVATE MEMBERS OF THE POOLoLD HEADER
                p oolC poolOldl( tinP , TAG( TAGiDnULL ) , T(baP.psttPoolName) , 0 , 1 , flPOOLoLDc_NOcLIENTrIGHTS ) ;

                poolOldSnapS snap( tinP , etThread ) ;
                stackC& stSnap = *history.pStkSnap ;
            {
            if( history.pStkSnap )
            __( !history.cRef ) ;
            __( !history.pStkSnap ) ;
            poolOldHistoryS& history = *(poolOldHistoryS*)&(countT&)baP.swPoolHistory ;
            baP.psttPoolName = (strokeS*)baP.swPoolHistory.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = baP.swPoolHistory.cFlavorsF( tinP ) ;
        TELL( "observing each registered poolOld" )
        baP.swPoolHistory.grabF( tinP , TAG( TAGiDnULL ) ) ;
        TELL( "grabbing baP.swPoolHistory" )

        if( ether ) break ;
        //else                    ether.osSleepF( tinP , TICK , TOCK ) ;
        //if( ++ idCycle < 0x20 ) ether.osSleepF( tinP , TOCK * 0x10 ) ;
        //TELL( "sleeping for 1 ticks before the next cycle" )

        ether.osSleepF( tinP , TOCK * 0x10 ) ;
        TELL( "sleeping for 01 tocks before the next cycle" )
        //U::
    {
    while( !etThread && ( !ether || baP.cMonitors || cAllKidThreads > 3 + bGraphicDisplay ) ) // tmWatchF me tmWindowsF tmObservePoolsF
    countT& cAllKidThreads = thirdC::os_cAllKidThreadsI_IF( tinP ) ;
    const boolT bGraphicDisplay = !!( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_tmWindows ) ;
    ZE( countT , idCycle ) ;

    bookAllS& baP = *(bookAllS*)pTaskP->c1 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 )
TASK( tmObservePoolsF )

}
    }
        mP.mStepsPerTuck = timeDelta2 ? 0.0 : (measureT)mP.cNewSteps * TUCK / timeDelta1 ;
        etThread.osTimeSubtractF( tinP , timeDelta1 , timeDelta2 , timeOld1 , timeOld2 ) ;
        sCountT timeDelta2 = mP.time2 ;
        countT  timeDelta1 = mP.time1 ;
    {
    if( timeOld1 || timeOld2 )

    mP.cNewSteps = mP.idStepLast - idStepLastOld ;

    countT idStepLastOld = mP.idStepLast ; mP.idStepLast = idStepP ;

    etThread.osTimeNowF( tinP , mP.time1 , mP.time2 ) ;
    sCountT timeOld2 = mP.time2 ; mP.time2 = 0 ;
    countT  timeOld1 = mP.time1 ; mP.time1 = 0 ;

    mP.idMonitorTock ++ ;
    STATEgRAB mP.idMonitor = state.idMe ; STATEuNGRAB
{
voidT stampF( tinS& tinP , etherC& etThread , monitorOldS& mP , countT idStepP , bookAllS& baP )

DONEdRIVENsERVER( tmcF )
TELL( "cleaning up" )
}
    }
        }
            }
                }
                    break ;
                    bBye = 1 ;
                {
                default :
                case ifcIDcMDsESSION_BYE :
                }
                    break ;
                    TELL( "ifcIDcMDsESSION_HIRE2: cleaning up" )

                    pso->writeF( tinP , sOut ) ;
                    sOut << ptm2.idResultHire ;
                    soulC sOut( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_HIRE2rEPLY ) ;
                    TELL( "ifcIDcMDsESSION_HIRE2: writing final reply" )

                    }
                        sgnDone_tmMonitor.waitF( tinP ) ;
                        TELL( "ifcIDcMDsESSION_HIRE2: waiting for the hired cell to die, as requested" )
                    {
                    if( bWait )

                    //etThread.ifcSayF( tinP , tPrefix+T("-") , flSAY_APPEND | flSAY_LOG ) ;
                    sgnHired.waitF( tinP ) ;
                    TELL( "ifcIDcMDsESSION_HIRE2: waiting for sgnHired" )

                    tinP.zEtScratch->osThreadF( tinP , countTC() , tmMonitorF , bWait ? &sgnDone_tmMonitor : 0 , flTHREADlAUNCH_ORPHAN , 0 , (countT)&baP , (countT)&ptm2 ) ;
                    boolT bWait = F(flags) & flHIRE_WAIT ;
                    baP.cMonitors ++ ;
                    params_tmMonitorF_2S ptm2( sgnHired , 0 , psttArgs , flags , time1limit , time2limit ) ;

                    //etThread.ifcSayF( tinP , tPrefix+T("+") , flSAY_APPEND | flSAY_LOG ) ;
                    //TN( tPrefix , "" ) ; tPrefix = T("ifcIDcMDsESSION_HIRE2: flags=")+TF1(flags)+T(" \"")+T(psttArgs)+T("\": ") ;

                    sIn >> (countT&)time2limit ;
                    sIn >> time1limit ;
                    sIn >> flags ;
                    sIn >> psttArgs ; ___( psttArgs ) ;

                    ZE( sCountT , time2limit ) ;
                    ZE( countT , time1limit ) ;
                    ZE( flagsT , flags ) ;
                    ZE( strokeS* , psttArgs ) ;
                    signC sgnDone_tmMonitor( tinP , TAG( TAGiDnULL ) ) ;
                    signC sgnHired( tinP , TAG( TAGiDnULL ) ) ;
                    TELL( "ifcIDcMDsESSION_HIRE2: setting up" )

                    }
                        tinP.zEtScratch->osSleepF( tinP , TOCK * 4 ) ; // THERE IS A SMALL CHANCE THAT MULTIPLE THREADS WILL SNEAK BY; THIS COULD BE FIXED BY SERIALIZING ACCESS TO baP.cMonitors
                        etherC::etTextIF( tinP ).ifcSayF( tinP , T("ifcIDcMDsESSION_HIRE2: sleeping until cMonitors is low enough") , flSAY_APPEND | flSAY_LOG ) ; //U::
                    {
                    while( baP.cMonitors >= CmONITORmAX )
                    TELL( "ifcIDcMDsESSION_HIRE2: waiting until baP.cMonitors is below its limit" )

                    sIn >> idCmd ;
                    ZE( countT , idCmd ) ;
                {
                case ifcIDcMDsESSION_HIRE2 :
            {
            switch( sIn.cFieldF( tinP ) )
        {
        if( !*tinP.zEtScratch )
        pso->readF( tinP , sIn ) ;
        TELL( "waiting for peer to write a soulC containing a command" )
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    {
    while( !ether && !etThread && !*tinP.zEtScratch && !bBye )
    ZE( boolT , bBye ) ;

    bookAllS& baP = *(bookAllS*)cArg ;
{
if( cArg )
TELL( "setting up" )
TASKdRIVENsERVER( tmcF )

DONE( tmRegisterPortF )
}
    }
        bFirst = 0 ;
        if( !idPort ) break ;

        }
            }
                ether.osSleepF( tinP , ru ) ;
                *tinP.zEtScratch = 0 ;
            {
            else
            if( !*tinP.zEtScratch && !etThread ) bFail = 0 ;

            }
                TELL( "registering my idPort with the local chat server: closing connection" )
                sChat2.writeF( tinP , soulo3 ) ;
                soulC soulo3( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_BYE ) ;
                TELL( "registering my idPort with the local chat server: writing bye" )

                __( idReply - ifcIDcMDsESSION_REGISTERiDpORTlOCALcHATsYSTEMrEPLY ) ;
                souli2 >> idReply ;
                ZE( countT , idReply ) ;
                sChat2.readF( tinP , souli2 ) ;
                soulC souli2( tinP , TAG( TAGiDnULL ) ) ;
                TELL( "registering my idPort with the local chat server: reading registration reply" )

                sChat2.writeF( tinP , soulo2 ) ;
                soulo2 << idPort ;
                soulo2 << (countT)DDNUMB ;
                soulC soulo2( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_REGISTERiDpORTlOCALcHATsYSTEM ) ;
                TELL( "registering my idPort with the local chat server: writing my idPort to register it" )

                sChat2.connectF( tinP , idPortChat2 ) ;
                socketC sChat2( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) ) ;
                TELL( "registering my idPort with the local chat server: connecting to the specified idPort" )

                }
                    souli >> idPortChat2 ;
                    __( idReply - ifcIDcMDsESSION_NEWsOCKETrEPLY ) ;
                    souli >> idReply ;
                    ZE( countT , idReply ) ;
                    sChat.readF( tinP , souli ) ;
                    soulC souli( tinP , TAG( TAGiDnULL ) ) ;
                    TELL( "registering my idPort with the local chat server: reading the idPort that i should connect to" )

                    sChat.writeF( tinP , soulo ) ;
                    soulC soulo( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_NEWsOCKET ) ;
                    TELL( "registering my idPort with the local chat server: writing to request a socket" )

                    sChat.connectF( tinP , ifcPORToLD2_CHAT ) ;
                    socketC sChat( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) ) ;
                    TELL( "registering my idPort with the local chat server: connecting" )

                    }
                        }
                            ether.osSleepF( tinP , TOCK * 0x4 ) ; // TIME FOR 1140104 TO START LISTENING
                            TELL( "registering my idPort with the local chat server: sleeping so the newly hired chat server can wake up" )
                            sgnHired.waitF( tinP ) ;
                            etThread.osThreadF( tinP , countTC() , tmMonitorF , 0 , flTHREADlAUNCH_ORPHAN , 0 , (countT)&baP , (countT)&ptm2 ) ;
                            baP.cMonitors ++ ;
                            params_tmMonitorF_2S ptm2( sgnHired , 1 , tArgs , flHIRE_DISPLAYaUTO ) ;
                            TN( tArgs , "1140104 !minimized" ) ; //USES NONDEFAULT POOLoLD TO AVOID USING DEFAULT POOLoLD BEFORE APPS HAVE A CHANCE TO LOAD DICTIONARIES LAKE FISH ETC INTO LOW POOLoLD
                            signC sgnHired( tinP , TAG( TAGiDnULL ) ) ;
                            TELL( "registering my idPort with the local chat server: hiring the local chat server" )
                        {
                        if( bFirst || !batonC::bExistsF( tinP , T("1140104") ) )
                    {
                {
                ZE( countT , idPortChat2 ) ;
            {
        {
        while( !ether && !etThread && bFail )
        ranUniC ru( TOCK * 8 ) ;
        boolT bFail = 1 ;
        TELL( "registering my idPort with the local chat server: setting up" )

        sgnIdPortReplaced.waitF( tinP ) ;
        TELL( "waiting for sgnIdPortReplaced" )
    {
    while( !ether && !etThread )
    boolT bFirst = 1 ;

    countT& idPort            = *(countT*)pTaskP->c2 ;
    signC&  sgnIdPortReplaced =  *(signC*)pTaskP->c1 ;

    bookAllS& baP = *(bookAllS*)cArg ;
    countT& cArg = pTaskP->c3 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmRegisterPortF )

DONE( tmMonitorF )
baP.cMonitors -- ;
}
    if( bw.bLethal ) etThread.etherFireImpersonateMonitorIF( tinP ) ;

    //logPoolStatsF( tinP , etThread , T("tmMonitorF --: ") , bw.osTidMain , bw.osPid , bw.idProcessOld , bw.idMonitor , baP ) ;

    }
        else if( !baP.bMonitored ) etThread.ifcSayF( tinP , T("314u: tmMonitorF is exiting and its etThread is impotent") , flSAY_APPEND | flSAY_LOG ) ;
        }
            etThread.delF( tinP , psttLog ) ;
            //etThread.ifcSayF( tinP , psttLog , flSAY_APPEND | flSAY_LOG ) ;
            etThread.strConcatenateF( tinP , psttLog , bw.stPhrases ) ; ___( psttLog ) ;
            ZE( strokeS* , psttLog ) ;
            logAllPublicTinF( tinP , etThread , bw.stPhrases , baP , bw.osTidMain , bw.osPid , bw.idProcessOld , bw.idMonitor ) ;
        {
        if( !etThread )
    {
    if( !( bw.flagsComment & fliCOMMENT_PROCESSeNDED ) )

    __( bw.cKidThreads ) ; //8352b; CONJ: main IS TERMINATING EARLY, PREVENTING MONITOR FROM RECEIVING NOTIFICATION OF TERM OF SOME OTHER THREADS
    bw.lever_osTid = bw.osTidMain ;
    //U:bw.sgnDone_tmWhereDriverQuit.waitF( tinP ) ;
    //U:6: bw.sgnDone_tmWhere.waitF( tinP ) ;
    bw.bQuit = 1 ;
    if( bw.bReportWhereProcessWhenDie ) writeWhereInfoF( tinP , etThread , ether , bw.processWhereInfo , bw.osPid ) ;
    TELL( "the process that i was monitoring has ended; i am cleaning up" ) ;

    }
        ptm2P.sgnHired.giveF( tinP ) ; // NO FURTHER REFERENCES TO ptm2P ARE ALLOWED
        if( !ptm2P.idResultHire ) ptm2P.idResultHire = ifcIDrESULThIRE_OTHERfAILURE ;
    {
    if( !bw.bStarted )

    }
        DEL( pInfo ) ;
        }
            Wo ((thirdC&)etThread).dosContinueMonitoringF( tinP , info.osTid , info.osPid , idCmd ) ; Wi
            TELL( "resuming execution of the monitored process" ) ;
            etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'c") ) ; //U::

            }
                bw.st_pTinEventOriginal.purgeF( tinP ) ;
                }
                    DEL( pTin ) ;
                    bw.st_pTinEventCopy >> *(countT*)&pTin ;
                    ZE( tinS* , pTin ) ;
                {
                while( bw.st_pTinEventCopy )
                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'b") ) ; //U::

                TELL( "stPhrases logged" ) ;
                }
                    etThread.osEditF( tinP , tFile , 1 ) ;
                    etThread.delF( tinP , postr ) ;
                    etThread.boxPutF( tinP , tFile , postr , costr ) ;
                    TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF1(DDNUMB)+T("/")+T(".logEntry.")+T(info.osPid)+TT(timeN1,timeN2) ;
                    etThread.delF( tinP , psttLog ) ;
                    countT costr = etThread.strMakeF( tinP , postr , psttLog ) ; ___( postr ) ;
                    ZE( osTextT* , postr ) ;

                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;

                    TELL( "popping up (asynch) a log entry in an editor window" )

                    //etThread.ifcSayF( tinP , psttLog , flSAY_APPEND | flSAY_LOG ) ;
                    etThread.strConcatenateF( tinP , psttLog , bw.stPhrases ) ; ___( psttLog ) ;
                    ZE( strokeS* , psttLog ) ;
                    TELL( "logging stPhrases" ) ;
                {
                if( bw.stPhrases )

                }
                    TELL( "thread handle closed" ) ;
                    bw.sw_hThread_osTid.freeF( tinP ) ;
                    TELL( "closing thread handle" ) ;
                {
                if( bw.flagsComment & fliCOMMENT_CLOSEtHREADhANDLE )
                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'a") ) ; //U::

                else           bw.pTinEvent = 0 ;
                if( bw.bCopy ) { bw.bCopy = 0 ; DEL( bw.pTinEvent ) ; }
                TELL( "deleting pTinEvent" ) ;
                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'9") ) ; //U::
                }
                    //}
                    //    }
                    //        bw.stPhrases << psttOldC( tinP , etThread , T("there are currently no other threads in the offending process\r\n") ) ;
                    //        etThread.delF( tinP , postd ) ;
                    //        bw.stPhrases.extractF( tinP ) ;
                    //        osTextT* postd = (osTextT*)bw.stPhrases[ - 1 ] ;
                    //        __( !bw.stPhrases ) ;
                    //    {
                    //    if( !bFound )
                    //    while( !etThread && !bw.st_pTinEventCopy.third && ~hDown ) ;
                    //    }
                    //        }
                    //            logTinF( tinP , etThread , bw.stPhrases , *pTinEvent , bw.bCopy , flTINrPT1_null , flTINrPT2_null , flTINrPT1_pIdLineStepAll | flTINrPT1_pIdLineStepLast01 ) ;
                    //            bFound = 1 ;
                    //        {
                    //        if( pTinEvent && pTinEvent->osTid != info.osTid )
                    //        tinS* pTinEvent = (tinS*)st_pTinEventCopy.downF( tinP , hDown ) ;
                    //    {
                    //    do
                    //    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    //    ZE( boolT , bFound ) ;
                    //    bw.stPhrases << psttOldC( tinP , etThread , T("thread information for other threads in the offending process:\r\n") ) ;
                    //{
                    //if( bw.st_pTinEventCopy ) //U:ALSO USE st_pTinEventOriginal

                    TELL( "a sin has occured. pTinEvent was logged if it is not ze""ro?" ) ;
                    }
                        TELL( "logTinF for a sin returned" ) ;
                        logTinF( tinP , etThread , bw.stPhrases , *bw.pTinEvent , bw.bCopy ) ;
                        bw.stPhrases << psttOldC( tinP , etThread , T("thread information for the offending thread:\r\n") ) ;
                        //logStackFramesF( tinP , etThread , bw.stPhrases , bw.sw_hThread_osTid , bw.osPid ) ; // pTinEvent CAUSE THIS TO BE SUPRESSED IF VERY EARLY OR VERY LATE.  IN PARTICULAR, FOR THE CREATEpROCESS AND FOR THE WO'TH LOADdLL EVENTS, ccf WOULD BE VERY LARGE AND WOULD CAUSE ME TO FAIL IN THE newF EXPRESSION
                        TELL( "calling logTinF for a sin" ) ;
                    {
                    if( bw.pTinEvent )
                    bw.bLogSin = 0 ;
                    TELL( "a sin has occured. is pTinEvent nonze""ro?" ) ;
                {
                if( bw.flagsComment & fliCOMMENT_SIN && bw.bLogSin )
                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'8") ) ; //U::

                }
                    ptm2P.sgnHired.giveF( tinP ) ; // NO FURTHER REFERENCES TO ptm2P ARE ALLOWED
                    ptm2P.idResultHire = ifcIDrESULThIRE_AOK ;
                    bw.bStarted = 1 ;
                {
                if( bw.flagsComment & fliCOMMENT_PROCESSsTARTED && !bw.bStarted )
                TELL( "i have handled this event and am now cleaning up" ) ;
                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'7") ) ; //U::

                }
                    etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'6") ) ; //U::
                    }
                        default                                : { idCmd = ifcIDcMDmoNITOR_CONTINUE ; break ; }
                        case ifcIDeVENTmONITORED_RIP           :
                        case ifcIDeVENTmONITORED_UNLOADdLL     :
                        case ifcIDeVENTmONITORED_LOADdLL       : { idCmd = hanNewDllF(     tinP , bw , info ) ; break ; }
                        case ifcIDeVENTmONITORED_SAY           : { idCmd = hanSayF(        tinP , bw , info ) ; break ; }
                        case ifcIDeVENTmONITORED_EXITpROCESS   : { idCmd = hanDelProcessF( tinP , bw , info ) ; break ; }
                        case ifcIDeVENTmONITORED_EXITtHREAD    : { idCmd = hanDelThreadF(  tinP , bw , info ) ; break ; }
                        case ifcIDeVENTmONITORED_CREATEtHREAD  : { idCmd = hanNewThreadF(  tinP , bw , info ) ; break ; }
                        case ifcIDeVENTmONITORED_CREATEpROCESS : { idCmd = hanNewProcessF( tinP , bw , info ) ; break ; }
                        case ifcIDeVENTmONITORED_EXCEPTION     : { idCmd = hanExceptionF(  tinP , bw , info ) ; break ; }
                    {
                    switch( info.idEvent )
                    //etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'5:")+TF1(info.idEvent) ) ; //U::
                    TELL( "calling handler" ) ;
                {
                //U::f:else
                //U::f:}
                //U::f:    }
                //U::f:        default                                : { idCmd = ifcIDcMDmoNITOR_CONTINUE ; break ; }
                //U::f:        case ifcIDeVENTmONITORED_EXITpROCESS   : { idCmd = hanDelProcessF( tinP , bw , info ) ; break ; }
                //U::f:        case ifcIDeVENTmONITORED_EXITtHREAD    : { idCmd = hanDelThreadF(  tinP , bw , info ) ; break ; }
                //U::f:        case ifcIDeVENTmONITORED_CREATEtHREAD  : { idCmd = hanNewThreadF(  tinP , bw , info ) ; break ; }
                //U::f:        case ifcIDeVENTmONITORED_CREATEpROCESS : { idCmd = hanNewProcessF( tinP , bw , info ) ; break ; }
                //U::f:        case ifcIDeVENTmONITORED_EXCEPTION     : { idCmd = hanExceptionF(  tinP , bw , info ) ; break ; }
                //U::f:    {
                //U::f:    switch( info.idEvent )
                //U::f:    TELL( "calling handler (ether is impotent)" ) ;
                //U::f:{
                //U::f:if( ether )
                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'4") ) ; //U::

                baP.swTallyEvent.ungrabF( tinP ) ;
                ( (countT&)baP.swTallyEvent ) ++ ;
                baP.idEvent = info.idEvent ;
                TELL( "grabbed baP.swTallyEvent" ) ;
                baP.swTallyEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;
                TELL( "grabbing baP.swTallyEvent" ) ;
                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'3") ) ; //U::

                //U::pTinEventF( tinP , etThread , bw.st_pTinEventOriginal , bw.st_pTinEventCopy , info.osPid , baP , 1 ) ;
                if( bw.bCopy ) { ___( bw.pTinEvent ) ; }
                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'2.1") ) ; //U::
                //U::pTinEventF( tinP , etThread , bw.pTinEvent , bw.bCopy , info , baP , 1 ) ;
                TELL( "getting the tinS records for the event" ) ;
                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'2") ) ; //U::
            {

            __( !info.osPid ) ; // hanSayF INTERPRETS A 0 IN ITS info.osPid PARAMETER TO INDICATE THAT IT HAS BEEN CALLED BY ITS OWN SELF-MONITOR RATHER THAN BY ME
            countT idCmd = ifcIDcMDmoNITOR_CONTINUE ;
            bw.lever_osTid = info.osTid ;
            bw.bAdoptedKid = info.osPid != bw.osPid ;
            ifcMonitorEventS& info = *pInfo ;
        {
        if( !etThread )

        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'1") ) ; //U::
        }
            __Z( pInfo ) ;
            TELL( "received an event notice" ) ;
            WHATsm ((thirdC&)etThread).dosWaitForMonitorEventF( tinP , pInfo , - 1 ) ; ___( pInfo ) ; Wi
            TELL( "waiting forever for an event notice" ) ;
        {
        else
        }
            TELL( "abandoning my limited time wait for an event notice" ) ;
            }
                }
                    }
                        __Z( pInfo ) ;
                        bw.stPhrases << psttOldC( tinP , etThread , T("the time limit of ")+TT(ptm2P.time1limit,ptm2P.time2limit)+T(" has been exceeded.\r\n") ) ;
                    {
                    if( time2now >= 0 )
                    etThread.osTimeSubtractF( tinP , time1now , time2now , bw.time1deadline , bw.time2deadline ) ;
                    etThread.osTimeNowF( tinP , time1now , time2now ) ;
                    ZE( sCountT , time2now ) ;
                    ZE( countT  , time1now ) ;
                {
                else
                if( pInfo ) break ;
                WHATsm ((thirdC&)etThread).dosWaitForMonitorEventF( tinP , pInfo , 1 ) ; ___( pInfo ) ; Wi
            {
            while( !etThread )
            TELL( "waiting for a limited time for an event notice" ) ;
        {
        if( bw.bDeadline )
        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("waitin'") ) ; //U::

        ZE( ifcMonitorEventS* , pInfo ) ;
        bw.flagsComment = 0 ;
    {
    while( !( bw.flagsComment & fliCOMMENT_PROCESSeNDED ) && !etThread ) // THIS INTENTIONALLY IGNORES ASYNCH IMPOTENCE

    //U: ether.osThreadF( tinP , countTC() , tmWhereDriverQuitF , &sgnDone_tmWhereDriverQuit , flTHREADlAUNCH_null , 0 , cArg , (countT)&st_pTinWhere , (countT)&processWhereInfo , (countT)&bQuit , (countT)&bWhereNewThreads , osPid ) ;
    //U: EDIT THIS TO USE bw

    //U:ether.osThreadF( tinP , countTC() , tmWhereF           , &bw.sgnDone_tmWhere           , flTHREADlAUNCH_null , 0 , (countT)&bw ) ;

    bookWoS bw( tinP , etThread , TAG( TAGiDnULL ) , baP , ptm2P , stateBlank ) ;
{
params_tmMonitorF_2S& ptm2P = *(params_tmMonitorF_2S*)pTaskP->c2 ; // IT IS ILLEGAL FOR ME TO REFER TO THIS AFTER GIVING ptm2P.sgnHired
bookAllS& baP = *(bookAllS*)pTaskP->c1 ;
TELL( "initializing" ) ;
TASK( tmMonitorF )

DONE( tmWhereF )
TELL( "cleaning up" )
}
    }
        bwP.ba.bLeverOsPid.ungrabF( tinP ) ;
        bwP.st_pTinWhere.ungrabF( tinP ) ;

        }
            while( !bwP.st_pTinWhere.third && ~hDown ) ;
            }
                }
                    bwP.processWhereInfo.swThreadWhereInfo.ungrabF( tinP ) ;
                    }
                        pwt->swIdWhere.ungrabF( tinP ) ;
                        pwt->swTell.ungrabF( tinP ) ;
                        pwt->swWorking.ungrabF( tinP ) ;
                        pwt->swSupervising.ungrabF( tinP ) ;
                        pwt->swChainOfCommand.ungrabF( tinP ) ;
                        pwt->swNest.ungrabF( tinP ) ;
                        TELL( "inspecting a tinS object: ungrabbing" )

                        }
                            ++ pwt->swNest ;
                            pwt->cLever = cNest ;

                            }
                                ++ pwt->swChainOfCommand ;
                                pwt->pczLever = pczChainOfCommand ;
                                }
                                    ++ pwt->swSupervising ;
                                    pwt->cLever = pczChainOfCommand[ idSup ] ;
                                {
                                for( countT idSup = 1 ; idSup <= idSupMax ; idSup ++ )
                                countT idSupMax = idNestMax > idNestMin ? idNestMax - idNestMin : 0 ;
        
                                ++ pwt->swWorking ;
                                pwt->cLever = pczChainOfCommand[ 0 ] ;
                            {
                            if( idNestMax )
    
                            ++ pwt->swTell ;
                            pwt->psttLever = tTell ;
                            TN( tTell , ostoTell ) ;
    
                            ++ pwt->swIdWhere ;
                            pwt->cLever = idWhere ;
                            TELL( "inspecting a tinS object: accumulating tallies from a clean snapshot" )
                        {
                        if( cTries )

                        }
                            while( !ether && !etThread && cTries && cTries -- ) ;
                            }
                                }
                                    ++ s ; thirdC::dosSleepRawIF( tinP , msSleep ) ;
                                {
                                }
                                    if( idDirty2 == idDirty1 ) break ;
                                    idDirty2 = pTin->idDirty ;
        
                                    pczChainOfCommand[ offo ++ ] = 0 ;
                                    for( countT idNest = idNestMax ; idNest >= idNestMin ; idNest -- ) pczChainOfCommand[ offo ++ ] = pTin->pIdFileNest[ idNest & OFFsLOTtINnESTmAX ] ; //O: DO 2 MEMCOPIES
                                    ZE( countT , offo ) ;
        
                                    idNestMin = idNestMax > OFFsLOTtINnESTmAX + 1 ? idNestMax - OFFsLOTtINnESTmAX : 1 ;
                                    idNestMax = cNest ;
                                    cNest   = pTin->cNest ;
                                    OStEXTA( ostoTell  , pTin->postTell ) ;
                                    idWhere = pTin->idWhere ;
                                {
                                if( !( idDirty1 % 2 ) )
                                idDirty1 = pTin->idDirty ;
                            {
                            do
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        countT cTries = 0x10 ;
                        countT pczChainOfCommand[ OFFsLOTtINnESTmAX + 2 ] ;
                        ZE( countT , idNestMin ) ;
                        ZE( countT , idNestMax ) ;
                        ZE( countT , cNest ) ;
                        OStEXT( ostoTell , COSTmAXtELL + 1 )
                        ZE( countT , idWhere ) ;
                        ZE( countT , idDirty2 ) ;
                        ZE( countT , idDirty1 ) ;

                        }
                            OStEXTA( pwt->postThreadName  , pTin->postThreadName ) ;
                            pwt->idAdam = pTin->idAdam ;
                            pwt->idAdamRoot = pTin->idAdamRoot ;
                            pwt->idProcessOld = pTin->idProcessOld ;
                            pwt->idThread = pTin->idThread ;
                        {
                        if( !*pwt->postThreadName )
                        TELL( "inspecting a tinS object: getting a clean snapshot" )

                        pwt->swNest.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        pwt->swChainOfCommand.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        pwt->swSupervising.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        pwt->swWorking.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        pwt->swTell.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        pwt->swIdWhere.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        TELL( "inspecting a tinS object: grabbing" )
                    {
                    if( pwt )
                    threadWhereInfoS* pwt = (threadWhereInfoS*)(countT)bwP.processWhereInfo.swThreadWhereInfo ;
                        bwP.processWhereInfo.swThreadWhereInfo = (countT)new( 0 , tinP , LF ) threadWhereInfoS( tinP , bwP.processWhereInfo.ether ) ;
                    if( !bwP.processWhereInfo.swThreadWhereInfo )
                    bwP.processWhereInfo.lever_pTin = (countT)pTin ;
                    bwP.processWhereInfo.swThreadWhereInfo.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    TELL( "inspecting a tinS object: setting up" )
                {
                if( pTin )
                tinS* pTin = (tinS*)bwP.st_pTinWhere.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( bwP.st_pTinWhere )

        bwP.st_pTinWhere.grabF( tinP , TAG( TAGiDnULL ) ) ;
        bwP.ba.bLeverOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ; //ASSUME: WHILE GRABBED, tinS OBJECTS IN THE MONITORED PROCESS WILL NOT BE DELETED (THIS WILL BE TRUE IF THE hanSayF HANDLER FOR tinS DESTRUCTION GRABS TOO)
        TELL( "grabbing" )

        }
            ++ s ; thirdC::dosSleepRawIF( tinP , msSleep ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        TELL( "sleeping before looking" )
    {
    while( !etThread && !bwP.bQuit )
    const countT msSleep = 0x100 ;

    bookWoS& bwP = *(bookWoS*)pTaskP->c1 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 )
TASK( tmWhereF )

DONE( tmWhereDriverQuitF )
}
    TELL( "cleaning up" )
    }
        }
            writeWhereInfoF( tinP , etThread , ether , 0 , processWhereInfo , baP.bLeverOsPid , osPidInfo ) ;
            //etThread.beeClickF( tinP , 0x3800 ) ;
            TELL( "reporting where the monitored threads are now" )
        {
        if( !bQuit )
        while( !bQuit && cTries -- ) etThread.osSleepF( tinP , TOCK ) ;
        TELL( "sleeping for 01 tocks before reporting where the monitored threads are" )
        countT cTries = 0x10 ;
    {
    while( !etThread && !bQuit )

    }
        }
            DEL( pTin ) ;
            st_pTinEventCopy >> *(countT*)&pTin ;
            ZE( tinS* , pTin ) ;
        {
        while( st_pTinEventCopy )

        whereAllOnF( tinP , st_pTinWhere , st_pTinEventOriginal , bWhereNewThreads ) ;
        pTinEventF( tinP , etThread , st_pTinEventOriginal , st_pTinEventCopy , osPidInfo , baP , 1 ) ;
        stackC st_pTinEventCopy( tinP , etThread , TAG( TAGiDnULL ) ) ;
        stackC st_pTinEventOriginal( tinP , etThread , TAG( TAGiDnULL ) ) ;
    {
    TELL( "turning on where monitoring" )

    while( !ether ) ether.osSleepF( tinP , TOCK ) ;
    TELL( "sleeping until my process is fired" )

    bookAllS& baP = *(bookAllS*)cArg ;
    countT             osPidInfo            =                      pTaskP->c6 ;
    boolT&             bWhereNewThreads     =             *(boolT*)pTaskP->c5 ;
    boolT&             bQuit                =             *(boolT*)pTaskP->c4 ;
    processWhereInfoS& processWhereInfo     = *(processWhereInfoS*)pTaskP->c3 ;
    stackC&            st_pTinWhere         =            *(stackC*)pTaskP->c2 ;
    countT             cArg                 =                      pTaskP->c1 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmWhereDriverQuitF )

}
    if( osTidP && osPidP && idProcessOldP && idMonitorP && baP.bMonitored ) ;

    //etThread.ifcSayF( tinP , tStat , flSAY_APPEND | flSAY_LOG ) ;
    TN( tStat , "" ) ; tStat = T(psttP)+T("cbPool: ")+TF1(poolOld.cbPoolF( tinP ))+T("    ptUsed: ")+TF1(ptUsed)+T("  cdUsed: ")+TF1(poolOld.cdUsedF( tinP ))+T("    ptHigh: ")+TF1(ptHigh) ;

    measureT ptHigh = (measureT)poolOld.offHighWaterF( tinP ) / (measureT)poolOld.cbPoolF( tinP ) ;
    measureT ptUsed = (measureT)poolOld.cbUsedF( tinP )       / (measureT)poolOld.cbPoolF( tinP ) ;
    p oolC& poolOld = etThread ;
{
voidT logPoolStatsF( tinS& tinP , etherC& etThread , const strokeS* const psttP , const countT osTidP , const countT osPidP , const countT idProcessOldP , const countT idMonitorP , bookAllS& baP )

}
    if( osTidP && idProcessOldP && idMonitorP ) ;

    baP.bLeverOsPid.ungrabF( tinP ) ;

    etThread.delF( tinP , psttLog ) ;
    //etThread.ifcSayF( tinP , psttLog , flSAY_APPEND | flSAY_LOG ) ;
    etThread.strConcatenateF( tinP , psttLog , stPhrasesP ) ; ___( psttLog ) ;
    ZE( strokeS* , psttLog ) ;

    baP.swsIdaTin.ungrabF( tinP ) ;
    }
        while( !etThread && !baP.swsIdaTin.third && ~hDown ) ;
        }
            }
                etThread.delF( tinP , psttr ) ;
                stPhrasesP << psttOldC( tinP , etThread , psttr ) ;
                pTin->strFuseF( tinP , etThread , psttr , 0 , flTINrPT1_null , flTINrPT2_null ) ; ___( psttr ) ;
                ZE( strokeS* , psttr ) ;
            {
            if( osPidP && pTin && pTin->osPid == osPidP )
            tinS* pTin = (tinS*)(byteT*)ap_artmentOldC( tinP , idaTin ) ;
            countT idaTin = baP.swsIdaTin.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( baP.swsIdaTin )
    baP.swsIdaTin.grabF( tinP , TAG( TAGiDnULL ) ) ;

    stPhrasesP << psttOldC( tinP , etThread , T("monitor is ending prematurely for an active process with the following threads\r\n") ) ;

    baP.leverOsPid = osPidP ;
    baP.bLeverOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT logAllPublicTinF( tinS& tinP , etherC& etThread , stackC& stPhrasesP , bookAllS& baP , const countT osTidP , const countT osPidP , const countT idProcessOldP , const countT idMonitorP )

}
    baP.bLeverOsPid.ungrabF( tinP ) ;

    }
        while( !etThread && !baP.sws_pTin.third && ~hDown ) ;
        }
            else                                                                      { DEL( pTinEvent ) ; }
            if( pTinEvent && pTinEvent->osPid == osPidInfoP && pTinEvent->idThread ) st_pTinEventCopyP.sinkF( tinP , countTC() , (countT)pTinEvent , flSTACKsINK_null , subtract_pTin_F ) ;
            pTinCopyF( tinP , etThread , pTinEvent , pvTin , osPidInfoP , bAcceptIfDirtyP ) ; ___( pTinEvent ) ;
            ZE( tinS* , pTinEvent ) ;
            voidT* pvTin = (voidT*)baP.sws_pTin.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( baP.sws_pTin )

    baP.swsIdaTin.ungrabF( tinP ) ;
    }
        while( !etThread && !baP.swsIdaTin.third && ~hDown ) ;
        }
            if( pTin && pTin->osPid == osPidInfoP ) st_pTinEventOriginalP.sinkF( tinP , countTC() , (countT)pTin , flSTACKsINK_null , subtract_pTin_F ) ;
            tinS* pTin = (tinS*)(byteT*)ap_artmentOldC( tinP , idaTin ) ;
            countT idaTin = baP.swsIdaTin.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( baP.swsIdaTin )
    baP.swsIdaTin.grabF( tinP , TAG( TAGiDnULL ) ) ;

    baP.leverOsPid = osPidInfoP ;
    baP.bLeverOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        if( etThread ) return ;
        __Z( osPidInfoP ) ;
        __( st_pTinEventCopyP.idTypeF( tinP ) - ifcSTACKtYPE_countT ) ;
        __( st_pTinEventCopyP ) ;
        __( st_pTinEventOriginalP.idTypeF( tinP ) - ifcSTACKtYPE_countT ) ;
        __( st_pTinEventOriginalP ) ;
        if( etThread ) return ;
    {
    IFbEcAREFUL
{
voidT pTinEventF( tinS& tinP , etherC& etThread , stackC& st_pTinEventOriginalP , stackC& st_pTinEventCopyP , const countT osPidInfoP , bookAllS& baP , const boolT bAcceptIfDirtyP = 0 )

}
    return sgn ;
    if( tinP.fingerprint && c3P ) ;

    }
        sgn = tin1.idThread - tin2.idThread ;
        tinS& tin2 = *(tinS*)c2P ;
        tinS& tin1 = *(tinS*)c1P ;
        etherC& ether = *(etherC*)pEtherP ;
    {
    if( pEtherP && c1P && c2P )
    ZE( countT , sgn ) ;

    }
    {
    IFbEcAREFUL
{
countT subtract_pTin_F( tinS& tinP , countT& pEtherP , countT& c1P , countT& c2P , countT& c3P )

}
    return ifcIDcMDmoNITOR_CONTINUE ;
    if( tinP.fingerprint && bwP.ether && infoP.osPid ) ;
    //logExeDllImageF( tinP , etThread , bwP.stPhrases , infoP ) ;
    //etherC& etThread = bwP.ether ;
{
countT hanNewDllF( tinS& tinP , bookWoS& bwP , ifcMonitorEventS& infoP )

}
    return ifcIDcMDmoNITOR_CONTINUE ;
    etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/j") ) ; //U::

    if( bCopy_pbData ) etThread.delF( tinP , pbData ) ;
    bwP.ba.bLeverOsPid.ungrabF( tinP ) ;
    }
        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/i") ) ; //U::
        //}
        //    if( bCopy ) { DEL( pTinEvent ) ; }
        //    else            __1
        //    if( pTinEvent ) bwP.stPhrases << psttOldC( tinP , etThread , T("thread starting: ")+TF1(pTinEvent->idThread)+T(" + ")+T(pTinEvent->postThreadName)+T("\r\n") ) ;
        //    ZE( tinS* , pTinEvent ) ; pTinEventF( tinP , etThread , pTinEvent , bCopy , infoP , bwP.ba , 1 ) ; ___( pTinEvent ) ;
        //    ZE( boolT , bCopy ) ;
        //{
        //if( pbData == thThread.c_strstrIF( tinP , pbData , post_pTinCti ) || pbData == thThread.c_strstrIF( tinP , pbData , post_pTinCtp ) )
    
        }
            }
                bwP.stPhrases << psttOldC( tinP , etThread , T("sin: ")+T(pbData)+T("\r\n") ) ;
                bwP.flagsComment |= fliCOMMENT_SIN ;
            {
            )
                pbData != thThread.c_strstrIF( tinP , pbData , "LDR: "                                 )
                pbData != thThread.c_strstrIF( tinP , pbData , "aok/"                                  )   &&
                pbData                                                                                   &&
            (
            else if
            }
                bwP.stPhrases << psttOldC( tinP , etThread , T("\r\n") ) ;
                bwP.stPhrases << psttOldC( tinP , etThread , T(pbData) ) ;
            {
            else if( thThread.c_strstrIF( tinP , pbData , " became impotent with code " ) || pbData == thThread.c_strstrIF( tinP , pbData , "aok/hanSayF/" ) )
            if( !thThread.c_strcmpIF( tinP , pbData , "aok/DosPushConsoleHandlerF" ) ) ;
        {
        else if( pbData && pbData != thThread.c_strstrIF( tinP , pbData , "LDR: Automatic DLL Relocation " ) )
        // RESIDUAL TEST (MUST BE LATH)
    
        }
            bLayer3endingNoteReceived = 1 ;
        {
        else if( pbData && !thThread.c_strcmpIF( tinP , pbData , "layer3interruptHandlerF/layer3ending/restart.no/" ) )
        }
            }
                bwP.pTinEvent->monitor.idStepLastSawImpotence = bwP.pTinEvent->idStep ;
                else bwP.pTinEvent->monitor.cImpotenceSeenDuringFallthrough = 0 ;
                }
                    }
                        #endif
                            Wo ((thirdC&)etThread).dosKillProcessF( tinP , infoP.osPid ) ; WHATga // THIS IS UNDESIRABLE BECAUSE DLL'S ARE NOT NOTIFIED THAT THE DOOMED PROCESS IS TERMINATED.  IT IS NEEDED BECAUSE etherC::paperZits_OffF IS NOT COMPLETELY EFFECTIVE ON WINDOWS: FOR A DEBUGGED PROCESS WINDOWS INSISTS ON DISPLAYING A POPUP MESSAGE WINDOW
                        #if defined( __NT__ )
    
                        bwP.stPhrases << psttOldC( tinP , etThread , T("sin: about to see impotence, and idStep has not advanced since lath time saw impotence (001 fallthroughs allowed)\r\n") ) ;
                        bwP.flagsComment |= fliCOMMENT_SIN ;
                    {
                    else
                    if( bwP.pTinEvent->monitor.cImpotenceSeenDuringFallthrough < 0x100 ) bwP.pTinEvent->monitor.cImpotenceSeenDuringFallthrough ++ ;
                {
                if( bwP.pTinEvent->idStep <= bwP.pTinEvent->monitor.idStepLastSawImpotence + 2 ) //ASSUME: DosTellMonitorF APPLIES idStep += 2
            {
            if( bwP.pTinEvent && !bwP.bCopy )
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postImpotence2bSeen ) )
        }
            bwP.bReportWhereProcessWhenDie = 0 ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereRWPD_off ) )
        }
            bwP.bReportWhereProcessWhenDie = 1 ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereRWPD_on ) )
        }
            bwP.bFlushT2PwhenDie = 0 ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereMoveT2PWD_off ) )
        }
            bwP.bFlushT2PwhenDie = 1 ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereMoveT2PWD_on ) )
        }
            bwP.processWhereInfo.flushThreadTalliesF( tinP ) ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereMoveT2P ) )
        }
            //U:etThread.boxZapF( tinP , tFile ) ;
            etThread.osEditF( tinP , tFile , 1 ) ;
            etThread.delF( tinP , postr ) ;
            etThread.boxPutF( tinP , tFile , postr , costr ) ;
            TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF1(DDNUMB)+T("/")+T(bwP.osPid)+T("/reused.postWhereAllNow") ;
            etThread.delF( tinP , psttr ) ;
            countT costr = etThread.strMakeF( tinP , postr , psttr ) ; ___( postr ) ;
            ZE( osTextT* , postr ) ;
        
            reportWhereNowF( tinP , etThread , psttr , bwP.osPid , bwP.ba , infoP ) ; ___( psttr ) ;
            ZE( strokeS* , psttr ) ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereAllNow ) )
        }
            bwP.st_pTinWhere.ungrabF( tinP ) ;
            while( bwP.st_pTinWhere ) bwP.st_pTinWhere >> countTC() ;
            bwP.bWhereNewThreads = 0 ;
            bwP.st_pTinWhere.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereAllOff ) )
        }
            purgeWhereInfoF( tinP , bwP.st_pTinWhere , bwP.processWhereInfo , bwP.ba.bLeverOsPid ) ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereAllPurge ) )
        }
            writeWhereInfoF( tinP , etThread , ether , bwP.processWhereInfo , infoP.osPid ) ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereProcessReport ) )
        }
            writeWhereInfoF( tinP , etThread , ether , 0 , bwP.processWhereInfo , bwP.ba.bLeverOsPid , infoP.osPid ) ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereAllReport ) )
        }
            whereAllOnF( tinP , bwP.st_pTinWhere , bwP.st_pTinEventOriginal , bwP.bWhereNewThreads ) ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereAllOn ) )
        }
            purgeWhereInfoF( tinP , bwP.pTinEvent , bwP.processWhereInfo , bwP.ba.bLeverOsPid ) ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWherePurge ) )
        }
            writeWhereInfoF( tinP , etThread , ether , bwP.pTinEvent , bwP.processWhereInfo , bwP.ba.bLeverOsPid , infoP.osPid ) ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereReport ) )
        }
            bwP.st_pTinWhere.ungrabF( tinP ) ;
            if( bwP.st_pTinWhere( (countT)bwP.pTinEvent ) ) bwP.st_pTinWhere.extractF( tinP ) ;
            bwP.st_pTinWhere.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereOff ) )
        }
            bwP.st_pTinWhere.ungrabF( tinP ) ;
            }
                __Z( ids ) ;
                bwP.st_pTinWhere.sinkF( tinP , ids , (countT)bwP.pTinEvent , flSTACKsINK_UNIQUE ) ;
                ZE( countT , ids ) ;
            {
            if( !bwP.st_pTinWhere( (countT)bwP.pTinEvent ) )
            bwP.st_pTinWhere.grabF( tinP , TAG( TAGiDnULL ) ) ; //THIS CODE BLOCK IS DUPLICATED WITHIN THIS MODULE
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postWhereOn ) )
        }
            //U: CRAFT CODE HERE THAT WRITES TO LOG A REPORT OF VM CHANGES
    
            ((thirdC&)etThread).osRegionInfoF( tinP , vmInfoAfter.cBitsGrain , vmInfoAfter.pbIdRegion , vmInfoAfter.pbIdAlloc , vmInfoAfter.pVmRegion , vmInfoAfter.pVmRegionAlloc , bwP.hProcess ) ; ___( vmInfoAfter.pbIdRegion ) ; ___( vmInfoAfter.pbIdAlloc ) ; ___( vmInfoAfter.pVmRegion ) ; ___( vmInfoAfter.pVmRegionAlloc ) ;
            vmInfoS vmInfoAfter( tinP , etThread ) ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postUncocked ) )
        }
            //logRegionArraysF( tinP , etThread , bwP.stPhrases , bwP.vmInfo.cBitsGrain , bwP.vmInfo.pbIdRegion , bwP.vmInfo.pbIdAlloc , bwP.vmInfo.pVmRegion , bwP.vmInfo.pVmRegionAlloc ) ;
            annotateRegionInfoF( tinP , etThread , bwP.vmInfo , bwP.st_psttVmUsageType ) ;
            ((thirdC&)etThread).osRegionInfoF( tinP , bwP.vmInfo.cBitsGrain , bwP.vmInfo.pbIdRegion , bwP.vmInfo.pbIdAlloc , bwP.vmInfo.pVmRegion , bwP.vmInfo.pVmRegionAlloc , bwP.hProcess ) ; ___( bwP.vmInfo.pbIdRegion ) ; ___( bwP.vmInfo.pbIdAlloc ) ; ___( bwP.vmInfo.pVmRegion ) ; ___( bwP.vmInfo.pVmRegionAlloc ) ;
            //logStackFramesF( tinP , etThread , bwP.stPhrases , sw_hThread_osTidP , infoP.osPid ) ;
        {
        else if( !thThread.c_strcmpIF( tinP , pbData , postOldCocked ) ) //"COCKED" REFERS TO THE MONITORED PROCESS BEING INITIALIZED AND READY TO CALL AN ADAM INSTANCE INTO EXISTENCE
        //EXACT MATCHES (PUT LONGER VALUES BEFORE SHORTER VALUES THAT MATCH THE BEGINNING OF THE LONGER VALUES, JUST FOR GOOD FORM
    
        }
            bwP.ba.swPoolHistory.ungrabF( tinP ) ;
            }
                bwP.ba.swPoolHistory.freeF( tinP ) ;
                DEL( poolOldHistory.pStkSnap ) ;
            {
            if( !( -- poolOldHistory.cRef ) )
            __( !poolOldHistory.pStkSnap ) ;
            poolOldHistoryS& poolOldHistory = *(poolOldHistoryS*)&(countT&)bwP.ba.swPoolHistory ;
            bwP.ba.psttPoolName = tn ;
            bwP.ba.swPoolHistory.grabF( tinP , TAG( TAGiDnULL ) ) ;
            TN( tn , postName ) ;
            
            osTextT* postName = pbData + costPoolDetach ;
        {
        else if( pbData == thThread.c_strstrIF( tinP , pbData , postPoolDetach ) )
        }
            bwP.ba.swPoolHistory.ungrabF( tinP ) ;
            }
                poolOldHistory.cRef = 1 ;
                __( !poolOldHistory.pStkSnap ) ;
                poolOldHistory.pStkSnap = new( 0 , tinP , LF ) stackC( tinP , bwP.ba.swPoolHistory.third , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_BLOB , sizeof( poolOldSnapS ) ) ;
                //U: THIS WILL LEAK IF THE MONITORED PROCESS TERMINATES WITHOUT EMITTING DETACH NOTIFICATIONS (E.G. IF IT VIOLATES MEMORY PROTECTION)
            {
            else
            if( poolOldHistory.pStkSnap ) poolOldHistory.cRef ++ ;
            poolOldHistoryS& poolOldHistory = *(poolOldHistoryS*)&(countT&)bwP.ba.swPoolHistory ;
            bwP.ba.psttPoolName = tn ;
            bwP.ba.swPoolHistory.grabF( tinP , TAG( TAGiDnULL ) ) ;
            TN( tn , postName ) ;
            
            osTextT* postName = pbData + costPoolAttach ;
        {
        else if( pbData == thThread.c_strstrIF( tinP , pbData , postPoolAttach ) )
        }
            bwP.ba.swWatch.ungrabF( tinP ) ;
            if( idw == 4 ) bwP.ba.swWatch.freeF( tinP ) ;
            etThread.delF( tinP , pstt1m ) ;
            }
                }
                    }
                        }
                            case 0xb : { watch.flagsFormat  = etThread.strDigitsToSCountF( tinP , psttc1            ) ; break ; }
                            case 0xa : { watch.radix        = etThread.strDigitsToSCountF( tinP , psttc1            ) ; break ; }
                            }
                                break ;
                                if( !etThread.strCompareF( tinP , psttc1 , T("countT") ) ) watch.idType = 1 ;
                            {
                            case   9 :
                            case   8 : { watch.cbElt        = etThread.strDigitsToSCountF( tinP , psttc1            ) ; break ; }
                            case   7 : { watch.cbAll        = etThread.strDigitsToSCountF( tinP , psttc1            ) ; break ; }
                            case   6 : { watch.idaOrRawAddr = etThread.strDigitsToSCountF( tinP , psttc1            ) ; break ; }
                            case   5 : { watch.osPid = infoP.osPid ; watch.bRawAddr     = !etThread.strCompareF(       tinP , psttc1 , T("raw") ) ; break ; }
                        {
                        switch( idw )
                        watchS& watch = *(watchS*)&(countT&)bwP.ba.swWatch ;
                    {
                    default :
                    case 4 : { bwP.ba.psttWatch = psttc1 ; break ; }
                    case 3 : { break ; }
                    case 2 :
                    case 1 :
                {
                switch( ++ idw )
            {
            FORsTRINGSiN1( pstt1m )
            ZE( countT , idw ) ;
            bwP.ba.swWatch.grabF( tinP , TAG( TAGiDnULL ) ) ;
            etThread.strWordsOldF( tinP , pstt1m , T(pbData) , sttq , T("/") ) ; ___( pstt1m ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1m ) ;
        {
        else if( pbData == thThread.c_strstrIF( tinP , pbData , postWatch ) )
        }
            }
                __( pbCatch + cbAll - pbc ) ;
                }
                    }
                        pbc += cbr ;
                        etThread.delF( tinP , psttr ) ;
                        etThread.memCopyF( tinP , pbc , (byteT*)psttr , cbr ) ;
                        pbc += sizeof ( monitorReplyOldS ) ;
                        pHeader->cbReply = cbr ;
                        pHeader->code  = 0 ;
                        pHeader->flags = flMONITORqUERYoLD_null ;
                        countT cbr = sizeof( strokeS ) * ( CSpREFIX + psttr->idAdam ) ;
                    {
                    if( psttr )
                    stNakedReplies >> psttr ;
                    ZE( strokeS* , psttr ) ;
                {
                while( stNakedReplies )
    
                }
                    pbc += sizeof ( monitorReplyOldS ) ;
                    pHeader->cbReply = cbAll - sizeof( monitorReplyOldS ) ;
                    pHeader->code  = 0 ;
                    pHeader->flags = flMONITORqUERYoLD_REPLYcONTAINSmULTIPLErEPLIES ;
                {
                if( stNakedReplies > 1 )
            {
            if( cbCatch >= cbAll )
            monitorReplyOldS*& pHeader = *(monitorReplyOldS**)&pbc ; //AS pbc CHANGES, SOMETIMES *pHeader WILL REALLY BE A HEADER AND SOMETIMES IT WILL REFER TO THE BEGINNING OF A DATA BLOB
            byteT* pbc = pbCatch ;
            byteT* const pbCatch = ap_artmentOldC( tinP , ap_artmentOldCatch ) ;
    
            etThread.delF( tinP , pstt1q ) ;
            if( stNakedReplies > 1 ) cbAll += sizeof( monitorReplyOldS ) ;
            }
                }
                    cbAll += sizeof( monitorReplyOldS ) + sizeof( strokeS ) * ( CSpREFIX + psttr->idAdam ) ;
                    stNakedReplies << psttr ;
                {
                if( psttr )
                etThread.strMakeF( tinP , psttr , psttc1 ) ; ___( psttr ) ;
                ZE( strokeS* , psttr ) ;
            {
            FORsTRINGSiN1( pstt1q ) //U:THIS LOOP JUST ECHOES THE QUERY VALUES BACK AS REPLIES.  REPLACE THIS PLACEHOLDER CODE
            ZE( countT , cbAll ) ;
            countT cQueries = etThread.strWordsOldF( tinP , pstt1q , T(pbData+off) , sttq , T("/") ) ; ___( pstt1q ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1q ) ;
            stackC stNakedReplies( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    
            if( pbData[ off ] == '/' ) off ++ ;
            while( pbData[ off ] && pbData[ off ] != '/' ) off ++ ;
            const countT cbCatch = thThread.c_atoiIF( tinP , pbData + off ) ;
    
            if( pbData[ off ] == '/' ) off ++ ;
            while( pbData[ off ] && pbData[ off ] != '/' ) off ++ ;
            const countT ap_artmentOldCatch = thThread.c_atoiIF( tinP , pbData + off ) ;
            countT off = costMonitorQuery ;
            __( !bwP.ba.bMonitored ) ;
    
            //FORMAT: TN( tQuery , "aok/cmd/monitorQuery/" ) ; tQuery += TF1(ap_artmentOldCatch)+T("/")+TF1(CBcATCH)+T("/")+T(psttP) ;
        {
        else if( pbData == thThread.c_strstrIF( tinP , pbData , postMonitorQuery ) )
        }
            //U:bwP.st_psttVmUsageType << psttOldC( tinP , etThread , T(pbData) ) ;
            //U:EDIT THE CODE SO THAT bwP.st_psttVmUsageType DOES NOT GROW WITHOUT BOUND WHEN GORILLA IS CAUSING CONTINUOUS CREATION OF THREADS
        {
        if( pbData == thThread.c_strstrIF( tinP , pbData , postVm ) ) // "VM" = "VIRTUAL MEMORY.  THE STRING IS NOTIFYING ME OF AN ADDRESS AND A USAGE TYPE SO THAT I CAN KNOW HOW EACH VM REGION IS BEING USED
        //PREFIX TESTS (LONGEST PREFIX MUST BE TESTED BEFORE TESTING FOR SHORTER PREFIXES THAT WOULD ALSO MATCH)
    
        //    bwP.stPhrases << psttOldC( tinP , etThread , T("thread ending:   ")+TF1(bwP.pTinEvent->idThread)+T(" - ")+T(bwP.pTinEvent->postThreadName)+T("\r\n") ) ;
        //if( bwP.pTinEvent && ( pbData == thThread.c_strstrIF( tinP , pbData , post_pTinDti ) || pbData == thThread.c_strstrIF( tinP , pbData , post_pTinDtp ) ) )
    
    
        static osTextT* postImpotence2bSeen    = "aok/fyi/impotence2bSeen"         ; static countT costImpotence2bSeen    = thirdC::c_strlenIF( tinP , postImpotence2bSeen    ) ;
        static osTextT* postWhereRWPD_off      = "aok/cmd/watchWhereRWPD_off"      ; static countT costWhereRWPD_off      = thirdC::c_strlenIF( tinP , postWhereRWPD_off      ) ;
        static osTextT* postWhereRWPD_on       = "aok/cmd/watchWhereRWPD_on"       ; static countT costWhereRWPD_on       = thirdC::c_strlenIF( tinP , postWhereRWPD_on       ) ;
        static osTextT* postWhereMoveT2PWD_off = "aok/cmd/watchWhereMoveT2PWD_off" ; static countT costWhereMoveT2PWD_off = thirdC::c_strlenIF( tinP , postWhereMoveT2PWD_off ) ;
        static osTextT* postWhereMoveT2PWD_on  = "aok/cmd/watchWhereMoveT2PWD_on"  ; static countT costWhereMoveT2PWD_on  = thirdC::c_strlenIF( tinP , postWhereMoveT2PWD_on  ) ;
        static osTextT* postWhereMoveT2P       = "aok/cmd/watchWhereMoveT2P"       ; static countT costWhereMoveT2P       = thirdC::c_strlenIF( tinP , postWhereMoveT2P       ) ;
        static osTextT* postWhereAllNow        = "aok/cmd/reportWhereAllNow"       ; static countT costWhereAllNow        = thirdC::c_strlenIF( tinP , postWhereAllNow        ) ;
        static osTextT* postWhereAllPurge      = "aok/cmd/watchWhereAllPurge"      ; static countT costWhereAllPurge      = thirdC::c_strlenIF( tinP , postWhereAllPurge      ) ;
        static osTextT* postWhereProcessReport = "aok/cmd/watchWhereProcessReport" ; static countT costWhereProcessReport = thirdC::c_strlenIF( tinP , postWhereProcessReport ) ;
        static osTextT* postWhereAllReport     = "aok/cmd/watchWhereAllReport"     ; static countT costWhereAllReport     = thirdC::c_strlenIF( tinP , postWhereAllReport     ) ;
        static osTextT* postWhereAllOff        = "aok/cmd/watchWhereAllOff"        ; static countT costWhereAllOff        = thirdC::c_strlenIF( tinP , postWhereAllOff        ) ;
        static osTextT* postWhereAllOn         = "aok/cmd/watchWhereAllOn"         ; static countT costWhereAllOn         = thirdC::c_strlenIF( tinP , postWhereAllOn         ) ;
        static osTextT* postWherePurge         = "aok/cmd/watchWherePurge"         ; static countT costWherePurge         = thirdC::c_strlenIF( tinP , postWherePurge         ) ;
        static osTextT* postWhereReport        = "aok/cmd/watchWhereReport"        ; static countT costWhereReport        = thirdC::c_strlenIF( tinP , postWhereReport        ) ;
        static osTextT* postWhereOff           = "aok/cmd/watchWhereOff"           ; static countT costWhereOff           = thirdC::c_strlenIF( tinP , postWhereOff           ) ;
        static osTextT* postWhereOn            = "aok/cmd/watchWhereOn"            ; static countT costWhereOn            = thirdC::c_strlenIF( tinP , postWhereOn            ) ;
        static osTextT* postUncocked           = "aok/fyi/justCalledAdamMain"      ; static countT costUncocked           = thirdC::c_strlenIF( tinP , postUncocked           ) ;
        static osTextT* postOldCocked             = "aok/fyi/aboutToCallAdamMain"     ; static countT costCocked             = thirdC::c_strlenIF( tinP , postOldCocked             ) ;
        //EXACT MATCHES (THE FULL STRING MATCHES THESE EXACTLY)
    
        static osTextT* postLog                = "aok/cmd/log/"                    ; static countT costLog                = thirdC::c_strlenIF( tinP , postLog                ) ;
        static osTextT* postYell               = "aok/cmd/yell/"                   ; static countT costYell               = thirdC::c_strlenIF( tinP , postYell               ) ;
        static osTextT* postPoolDetach         = "aok/fyi/postPoolName/detach/"    ; static countT costPoolDetach         = thirdC::c_strlenIF( tinP , postPoolDetach         ) ;
        static osTextT* postPoolAttach         = "aok/fyi/postPoolName/attach/"    ; static countT costPoolAttach         = thirdC::c_strlenIF( tinP , postPoolAttach         ) ;
        static osTextT* postWatch              = "aok/cmd/watch/"                  ; static countT costWatch              = thirdC::c_strlenIF( tinP , postWatch              ) ;
        static osTextT* postMonitorQuery       = "aok/cmd/monitorQuery/"           ; static countT costMonitorQuery       = thirdC::c_strlenIF( tinP , postMonitorQuery       ) ;
        static osTextT* postVm                 = "aok/vm/"                         ; static countT costVm                 = thirdC::c_strlenIF( tinP , postVm                 ) ;
        static osTextT* postFiredDtp           = "thirdC/dt/p_bFired/"             ; static countT costFiredDtp           = thirdC::c_strlenIF( tinP , postFiredDtp           ) ;
        static osTextT* postFiredCtp           = "thirdC/ct/p_bFired/"             ; static countT costFiredCtp           = thirdC::c_strlenIF( tinP , postFiredCtp           ) ;
        static osTextT* post_pTinDtp           = "tinS/pTin/dt/"                   ; static countT cost_pTinDtp           = thirdC::c_strlenIF( tinP , post_pTinDtp           ) ;
        static osTextT* post_pTinCtp           = "tinS/pTin/ct/"                   ; static countT cost_pTinCtp           = thirdC::c_strlenIF( tinP , post_pTinCtp           ) ;
        static osTextT* post_pTinDti           = "tinS/ida/dt/"                    ; static countT cost_pTinDti           = thirdC::c_strlenIF( tinP , post_pTinDti           ) ;
        static osTextT* post_pTinCti           = "tinS/ida/ct/"                    ; static countT cost_pTinCti           = thirdC::c_strlenIF( tinP , post_pTinCti           ) ;
        static osTextT* postGrabDep            = "grabOldS/pGrab/de/"                 ; static countT costGrabDep            = thirdC::c_strlenIF( tinP , postGrabDep            ) ;
        static osTextT* postGrabAtp            = "grabOldS/pGrab/at/"                 ; static countT costGrabAtp            = thirdC::c_strlenIF( tinP , postGrabAtp            ) ;
        static osTextT* postGrabDei            = "grabOldS/ida/de/"                   ; static countT costGrabDei            = thirdC::c_strlenIF( tinP , postGrabDei            ) ;
        static osTextT* postGrabAti            = "grabOldS/ida/at/"                   ; static countT costGrabAti            = thirdC::c_strlenIF( tinP , postGrabAti            ) ;
        static osTextT* postGrabDtp            = "grabOldS/pGrab/dt/"                 ; static countT costGrabDtp            = thirdC::c_strlenIF( tinP , postGrabDtp            ) ;
        static osTextT* postGrabCtp            = "grabOldS/pGrab/ct/"                 ; static countT costGrabCtp            = thirdC::c_strlenIF( tinP , postGrabCtp            ) ;
        static osTextT* postGrabDti            = "grabOldS/ida/dt/"                   ; static countT costGrabDti            = thirdC::c_strlenIF( tinP , postGrabDti            ) ;
        static osTextT* postGrabCti            = "grabOldS/ida/ct/"                   ; static countT costGrabCti            = thirdC::c_strlenIF( tinP , postGrabCti            ) ;
        //PREFIXES (THE FULL STRING CONTINUES BEYOND THESE VALUES)
    
        //U:EDIT TO USE etherC STRING HANDLING RATHER THAN thirdC STRING HANDLING, AND USE: etherC::strTrimF( tinS& tinP , strokeS*& psttP , const strokeS* const psttOldP , const strokeS* const psttItemDelimiterP , const strokeS* const psttDoomedListP , const strokeS sttNewP )
        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/h") ) ; //U::
    {
    else
    }
        }
            }
                break ;
                }
                    }
                        break ;
                        __1
                        __( idType ) ;
                    {
                    default:
                    }
                        break ;
                        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/g") ) ; //U::
                    
                        }
                            }
                                bwP.ba.swThread.ungrabF( tinP ) ;
                                }
                                    OStEXTA( thread.postThreadName  , bwP.pTinEvent->postThreadName ) ;
                                    thread.idProcessOld          = bwP.pTinEvent->idProcessOld ;
                                    thread.idThread           = bwP.pTinEvent->idThread ;
                                    thread.idAdam = bwP.pTinEvent->idAdam ;
                                    thread.idAdamRoot = bwP.pTinEvent->idAdamRoot ;
                                {
                                if( bwP.pTinEvent )
                                etThread.osTimeNowF( tinP , thread.timeReg.time1 , thread.timeReg.time2 ) ;
                                threadS& thread = (threadS&)(countT&)bwP.ba.swThread ;
                                bwP.ba.leverOsTid = infoP.osTid ;
                                bwP.ba.swThread.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            {
                            else
                            }
                                bwP.ba.swThread.ungrabF( tinP ) ;
                                etThread.osTimeNowF( tinP , thread.timeUnreg.time1 , thread.timeUnreg.time2 ) ;
                                threadS& thread = (threadS&)(countT&)bwP.ba.swThread ;
                                bwP.ba.leverOsTid = infoP.osTid ;
                                bwP.ba.swThread.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            {
                            if( bTinDt )
                        {
                        if( !bwP.pTinEvent || thThread.c_strcmpIF( tinP , bwP.pTinEvent->postThreadName , "mainTinInPool" ) )
                    
                        }
                            }
                                break ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/8") ) ; //U::
                                DEL( pTinCopy ) ;
                                pTinCopyF( tinP , etThread , pTinCopy , pvTin , infoP.osPid , 1 ) ; ___( pTinCopy ) ;
                                ZE( tinS* , pTinCopy ) ;
                        
                                else      __1
                                if( ids ) bwP.ba.sws_pTin.extractF( tinP ) ;
                                countT ids = bwP.ba.sws_pTin( (countT)pvTin ) ;
                        
                                voidT* pvTin = *(voidT**)pbData ;
                                __( cbData - sizeof( countT ) ) ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/7") ) ; //U::
                            {
                            case ifcIDtYPEtELLsYS_TINdTP :
                            }
                                break ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/6") ) ; //U::
                                bwP.bCopy = 1 ;
                                pTinCopyF( tinP , etThread , bwP.pTinEvent , pvTin , infoP.osPid , 1 ) ; ___( bwP.pTinEvent ) ;
                                __( !!bwP.pTinEvent ) ;
                        
                                __Z( ids ) ;
                                bwP.ba.sws_pTin.sinkF( tinP , ids , (countT)pvTin , flSTACKsINK_UNIQUE ) ;
                                ZE( countT , ids ) ;
                        
                                voidT* pvTin = *(voidT**)pbData ;
                                __( cbData - sizeof( countT ) ) ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/5") ) ; //U::
                            {
                            case ifcIDtYPEtELLsYS_TINcTP :
                            }
                                break ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/4") ) ; //U::
                    
                                refreshTinIdaArrayF( tinP , etThread , bwP.ba ) ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/3/7") ) ; //U::
                        
                                bwP.st_pTinWhere.ungrabF( tinP ) ;
                                bwP.processWhereInfo.swThreadWhereInfo.ungrabF( tinP ) ;
                                }
                                    bwP.processWhereInfo.swThreadWhereInfo.freeF( tinP ) ;
                                    DEL( *(threadWhereInfoS**)&(countT&)bwP.processWhereInfo.swThreadWhereInfo ) ;
                                    bwP.processWhereInfo.lever_pTin = (countT)bwP.pTinEvent ;
                                {
                        
                                writeWhereInfoF( tinP , etThread , ether , bwP.pTinEvent , bwP.processWhereInfo , bwP.ba.bLeverOsPid , infoP.osPid ) ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/3/6") ) ; //U::
                        
                                if( bwP.bFlushT2PwhenDie ) bwP.processWhereInfo.flushThreadTalliesF( tinP , bwP.pTinEvent ) ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/3/5") ) ; //U::
                        
                                bwP.processWhereInfo.swThreadWhereInfo.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/3/4") ) ; //U::
                        
                                if( bwP.st_pTinWhere( (countT)bwP.pTinEvent ) ) bwP.st_pTinWhere.extractF( tinP ) ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/3/3") ) ; //U::
                                bwP.st_pTinWhere.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/3/2") ) ; //U::
                        
                                }
                                    //if( bwP.pTinEvent ) bwP.stPhrases << psttOldC( tinP , etThread , T(bwP.pTinEvent->postThreadName)+T("/-") ) ;
                                    bwP.ba.swsIdaTin.ungrabF( tinP ) ;
                                    if( idaTin && bwP.ba.swsIdaTin( idaTin ) ) bwP.ba.swsIdaTin.extractF( tinP ) ;
                                    bwP.ba.swsIdaTin.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                    __( bwP.pTinEvent != (tinS*)(byteT*)ap_artmentOldC( tinP , idaTin ) ) ;
                                    countT idaTin = *(countT*)pbData ;
                                    __( cbData - sizeof( countT ) ) ;
                                {
                        
                                __( !bwP.ba.bMonitored ) ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/3/1") ) ; //U::
                            {
                            case ifcIDtYPEtELLsYS_TINdTI :
                            }
                                break ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/2") ) ; //U::
                    
                                }
                                    bwP.st_pTinWhere.ungrabF( tinP ) ;
                                    }
                                        __Z( ids ) ;
                                        bwP.st_pTinWhere.sinkF( tinP , ids , (countT)bwP.pTinEvent , flSTACKsINK_UNIQUE ) ;
                                        ZE( countT , ids ) ;
                                    {
                                    if( !bwP.st_pTinWhere( (countT)bwP.pTinEvent ) )
                                    bwP.st_pTinWhere.grabF( tinP , TAG( TAGiDnULL ) ) ; //THIS CODE BLOCK IS DUPLICATED WITHIN THIS MODULE
                                {
                                if( bwP.bWhereNewThreads )
                        
                                bwP.ba.swsIdaTin.ungrabF( tinP ) ;
                                refreshTinIdaArrayF( tinP , etThread , bwP.ba ) ;
                                }
                                    //if( bwP.pTinEvent ) bwP.stPhrases << psttOldC( tinP , etThread , T(bwP.pTinEvent->postThreadName)+T("/+") ) ;
                                    bwP.st_pTinEventOriginal << (countT)bwP.pTinEvent ;
                                    bwP.pTinEvent = (tinS*)(byteT*)ap_artmentOldC( tinP , idaTin ) ;
                                    __( !!bwP.pTinEvent ) ;
                        
                                    __Z( ids ) ;
                                    bwP.ba.swsIdaTin.sinkF( tinP , ids , idaTin , flSTACKsINK_UNIQUE ) ;
                                    ZE( countT , ids ) ;
                                    countT idaTin = *(countT*)pbData ;
                                    __( cbData - sizeof( countT ) ) ;
                                {
                                bwP.ba.swsIdaTin.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        
                                __( !bwP.ba.bMonitored ) ;
                                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f/1") ) ; //U::
                            {
                            case ifcIDtYPEtELLsYS_TINcTI :
                        {
                        switch( idType )
                        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/f") ) ; //U::
                    
                        const boolT bTinDt = idType == ifcIDtYPEtELLsYS_TINdTI || idType == ifcIDtYPEtELLsYS_TINdTP ;
                        const boolT bTinCt = idType == ifcIDtYPEtELLsYS_TINcTI || idType == ifcIDtYPEtELLsYS_TINcTP ;
                    {
                    case ifcIDtYPEtELLsYS_TINdTP :
                    case ifcIDtYPEtELLsYS_TINdTI :
                    case ifcIDtYPEtELLsYS_TINcTP :
                    case ifcIDtYPEtELLsYS_TINcTI :
                    }
                        break ;
                        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/e") ) ; //U::
                        bwP.ba.swThread.ungrabF( tinP ) ;
                        thThread.c_memcpyIF( tinP , ((threadS&)(countT&)bwP.ba.swThread).postYell , pbData , cbData ) ;
                        bwP.ba.leverOsTid = infoP.osTid ;
                        bwP.ba.swThread.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/d") ) ; //U::
                    {
                    case ifcIDtYPEtELLsYS_YELL :
                    }
                        break ;
                        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/c") ) ; //U::
                    
                        bwP.stPhrases << psttOldC( tinP , etThread , T("sin: rc" ":")+TF1(info.rc)+T(" idLine:")+TF1(info.idLine)+T(" idFile:")+TF1(info.idFile)+T(" file:\"")+T(info.postFile)+T("\"\r\n") ) ;
                        bwP.flagsComment |= fliCOMMENT_SIN ;
                    
                        infoS& info = *(infoS*)pbData ;
                        __( cbData - sizeof( infoS ) ) ;
                        } ;
                            countT rc ;
                            countT idLine ;
                            countT idFile ;
                            osTextT postFile[ 0x101 ] ;
                        {
                        struct infoS
                        //CODEsYNC: 0c00011 6a40104
                        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/b") ) ; //U::
                    {
                    case ifcIDtYPEtELLsYS_ERRORiMPOTENCE :
                    }
                        break ;
                        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/a") ) ; //U::
                        bwP.ba.swThread.ungrabF( tinP ) ;
                        bwP.ba.logF( tinP , T(pbData) , worker.idAdam , ((threadS&)(countT&)bwP.ba.swThread).postThreadName ) ;
                        bwP.ba.leverOsTid = infoP.osTid ;
                        bwP.ba.swThread.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        workerS& worker = *(workerS*)&(countT&)bwP.ba.swWorker ;
                        //CODEsYNC: 10301b1 6a40104
                        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/9") ) ; //U::
                    {
                    case ifcIDtYPEtELLsYS_LOG :
                    }
                        break ;
                        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/8") ) ; //U::

                        }
                            bwP.ba.swWorker.freeF( tinP ) ;
                            etThread.delF( tinP , worker.psttDisplay ) ;
                            etThread.delF( tinP , worker.psttTitle ) ;
                            __( worker.p_bFired != p_bFired ) ;
                        {
                        else
                        }
                            etThread.strMakeF( tinP , worker.psttDisplay , bwP.worker.psttDisplay ) ; ___( worker.psttDisplay ) ;
                            etThread.strMakeF( tinP , worker.psttTitle , bwP.worker.psttTitle ) ; ___( worker.psttTitle ) ;
                            worker.idAdam = bwP.worker.idAdam ;
                            worker.p_bFired = p_bFired ;
                            __( !!worker.p_bFired ) ;
                        {
                        if( idType == ifcIDtYPEtELLsYS_FIREDcTP )

                        workerS& worker = *(workerS*)&(countT&)bwP.ba.swWorker ;

                        byteT* p_bFired = (byteT*)((countT*)pbData)[ 0 ] ; // p_bFired VALUE VALID IN PROCESS BEING SUPERVISED
                        __( cbData - sizeof( countT ) ) ;
                        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/7") ) ; //U::
                    {
                    case ifcIDtYPEtELLsYS_FIREDdTP :
                    case ifcIDtYPEtELLsYS_FIREDcTP :
                    }
                        break ;
                    {
                    case ifcIDtYPEtELLsYS_ERRORgLOBALnEWoPERATORuSED                     :
                    case ifcIDtYPEtELLsYS_ERRORbADcODEsTYLEsTROKEfUSEbUFFEReXHAUSTED     :
                    case ifcIDtYPEtELLsYS_AOKfYIcANcREATEwINDOWnOW                       :
                    case ifcIDtYPEtELLsYS_AOKfYIcANNOTcREATEwINDOWnOW                    :
                    case ifcIDtYPEtELLsYS_AOKfYIeXCEPTIONhANDLERpUSH                     :
                    case ifcIDtYPEtELLsYS_ERRORlABELtOOlONG                              :
                    case ifcIDtYPEtELLsYS_ERRORpsWeTtHREADiS0                            :
                    case ifcIDtYPEtELLsYS_ERRORpsTsOCKfACEtALKiS0                        :
                    case ifcIDtYPEtELLsYS_ERRORpsTkIDfACESiS0                            :
                    case ifcIDtYPEtELLsYS_ERRORpsTcATCHERSiS0                            :
                    case ifcIDtYPEtELLsYS_ERRORpsTqUITTERSiS0                            :
                    case ifcIDtYPEtELLsYS_ERRORpsTfACEtALKvARSiS0                        :
                    case ifcIDtYPEtELLsYS_ERRORpsTfACEhEARvARSiS0                        :
                    case ifcIDtYPEtELLsYS_ERRORpsTfACEtALKcOLORiS0                       :
                    case ifcIDtYPEtELLsYS_ERRORpsTfACEhEARcOLORiS0                       :
                    case ifcIDtYPEtELLsYS_ERRORpsTaCCEPTORSiS0                           :
                    case ifcIDtYPEtELLsYS_ERRORpsTfACEhEARiS0                            :
                    case ifcIDtYPEtELLsYS_ERRORpsTfACEtALKiS0                            :
                    case ifcIDtYPEtELLsYS_ERRORpeTtEXTiS0                                :
                    case ifcIDtYPEtELLsYS_ERRORpeTpAINTiS0                               :
                    case ifcIDtYPEtELLsYS_POOLoLDdETACH                                     :
                    case ifcIDtYPEtELLsYS_POOLoLDaTTACH                                     :
                    case ifcIDtYPEtELLsYS_POOLoLDfORMAT                                     :
                    case ifcIDtYPEtELLsYS_POOLoLDcORRUPT                                    :
                    case ifcIDtYPEtELLsYS_POOLoLDcORRUPToFFtOP                              :
                    case ifcIDtYPEtELLsYS_QUIETtIN                                       :
                    case ifcIDtYPEtELLsYS_LOUDtIN                                        :
                    case ifcIDtYPEtELLsYS_dnsResourceMiddleS                             :
                    case ifcIDtYPEtELLsYS_dnsMsgHeaderS                                  :
                    case ifcIDtYPEtELLsYS_ERRORlABELiStOOlONG                            :
                    case ifcIDtYPEtELLsYS_ERRORsOMEtHIRDoBJECTSeXIST                     :
                    case ifcIDtYPEtELLsYS_AOKfYIjUSTcALLEDaDAMmAIN                       :
                    case ifcIDtYPEtELLsYS_AOKfYIaBOUTtOcALLaDAMmAIN                      :
                    case ifcIDtYPEtELLsYS_AOKfYIiMPOTENCE2bsEEN                          :
                    case ifcIDtYPEtELLsYS_WHERErwpdoFF                                   :
                    case ifcIDtYPEtELLsYS_WHERErwpdoN                                    :
                    case ifcIDtYPEtELLsYS_WHEREmOVEt2pwdoFF                              :
                    case ifcIDtYPEtELLsYS_WHEREmOVEt2pwdoN                               :
                    case ifcIDtYPEtELLsYS_WHEREmOVEt2p                                   :
                    case ifcIDtYPEtELLsYS_WHEREaLLnOW                                    :
                    case ifcIDtYPEtELLsYS_WHEREaLLpURGE                                  :
                    case ifcIDtYPEtELLsYS_WHEREpROCESSrEPORT                             :
                    case ifcIDtYPEtELLsYS_WHEREaLLrEPORT                                 :
                    case ifcIDtYPEtELLsYS_WHEREaLLoFF                                    :
                    case ifcIDtYPEtELLsYS_WHEREaLLoN                                     :
                    case ifcIDtYPEtELLsYS_WHEREpURGE                                     :
                    case ifcIDtYPEtELLsYS_WHERErEPORT                                    :
                    case ifcIDtYPEtELLsYS_WHEREoFF                                       :
                    case ifcIDtYPEtELLsYS_WHEREoN                                        :
                    case ifcIDtYPEtELLsYS_UNCOCKED                                       :
                    case ifcIDtYPEtELLsYS_COCKED                                         :
                    case ifcIDtYPEtELLsYS_WATCH                                          :
                    case ifcIDtYPEtELLsYS_QUERY                                          :
                    case ifcIDtYPEtELLsYS_VM                                             :
                {
                switch( idType )

                //U:bwP.ba.swTallySay.ungrabF( tinP ) ;
                //U:( (countT&)bwP.ba.swTallySay ) ++ ;
                //U:bwP.ba.idTypeSay = idType ;
                //U:bwP.ba.swTallySay.grabF( tinP , TAG( TAGiDnULL ) ) ;
                //U:COMMENTED OUT FOR MAX SPEED
                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/6") ) ; //U::
            {
            default :
            }
                break ;
            
                }
                    }
                        break ;
                        }
                            }
                                break ;
                                bwP.ba.swsIdaGrab.ungrabF( tinP ) ;
                                if( ip && bwP.ba.swsIdaGrab( ip ) ) bwP.ba.swsIdaGrab.extractF( tinP ) ;
                                bwP.ba.swsIdaGrab.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                __( !bwP.ba.bMonitored ) ;
                            {
                            default :
                            }
                                break ;
                                bwP.ba.sws_pGrab.ungrabF( tinP ) ;
                                else      __1
                                if( ids ) bwP.ba.sws_pGrab.extractF( tinP ) ;
                                countT ids = bwP.ba.sws_pGrab( ip ) ;
                                bwP.ba.sws_pGrab.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            {
                            case ifcIDtYPEtELLsYS_GRABdEP :
                            case ifcIDtYPEtELLsYS_GRABdTP :
                        {
                        switch( idType )
                    {
                    default :
                    }
                        break ;
            
                        }
                            }
                                break ;
                                __Z( ids ) ; // df42b 1052b 1052b 1052b 1052b (CONJ: THIS WAS FIXED BY EDITING main CODE TO ENSURE THAT IT DOES NOT EXIT UNTIL ALL MONITOR THREADS HAVE EXITED
                                bwP.ba.swsIdaGrab.sinkF( tinP , ids , ip , flSTACKsINK_UNIQUE ) ;
                                ZE( countT , ids ) ;
                                __( !bwP.ba.bMonitored ) ;
                            {
                            default :
                            }
                                break ;
                                __Z( ids ) ;
                                bwP.ba.sws_pGrab.sinkF( tinP , ids , ip , flSTACKsINK_UNIQUE ) ;
                                ZE( countT , ids ) ;
                                // bwP.stPhrases << psttOldC( tinP , etThread , T("pGrab +:   ")+TP(bwP.pTinEvent?bwP.pTinEvent->postThreadName:"",0x20)+T(" ")+T(bwP.pTinEvent?bwP.pTinEvent->postTell:"")+T("\r\n") ) ;
                            {
                            case ifcIDtYPEtELLsYS_GRABaTP :
                            case ifcIDtYPEtELLsYS_GRABcTP :
                        {
                        switch( idType )
            
                        //U:bwP.ba.swTallySayGrabCt.ungrabF( tinP ) ;
                        //U:) ) ++ ;
                        //U:    : bwP.ba.swTallySayGrabCtRaw
                        //U:    ? bwP.ba.swTallySayGrabCtIda
                        //U:( (countT&)( idType == ifcIDtYPEtELLsYS_GRABcTI || idType == ifcIDtYPEtELLsYS_GRABaTI
                        //U:( (countT&)bwP.ba.swTallySayGrabCt ) ++ ; //U:OPTIMIZE: THESE ACCUMULATORS ARE CPU COSTLY. CONJ: EDIT switchC CODE FOR SPEED
                        //U:bwP.ba.pczLineFileCt = pc3lf ;
                        //U:bwP.ba.swTallySayGrabCt.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        //U:COMMENTED OUT FOR MAX SPEED
                    {
                    case ifcIDtYPEtELLsYS_GRABaTP :
                    case ifcIDtYPEtELLsYS_GRABaTI :
                    case ifcIDtYPEtELLsYS_GRABcTP :
                    case ifcIDtYPEtELLsYS_GRABcTI :
                {
                switch( idType )
                etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/5") ) ; //U::
            
                count3S pc3lf( idLineCt , idiFileCt ) ;
                countT& idiFileCt = ((countT*)pbData)[ 2 ] ;
                countT& idLineCt  = ((countT*)pbData)[ 1 ] ;
                countT& ip        = ((countT*)pbData)[ 0 ] ; //U:O: DON'T USE REFERENCES
                __( cbData - 3 * sizeof( countT ) ) ;
                //CODEsYNC: 1530005 6a40104
                // CODE ABOVE ME TREATS GRAB ATTACH/DETACH EXACTLY THE SAME AS CT/DT
            {
            case ifcIDtYPEtELLsYS_GRABdEP :
            case ifcIDtYPEtELLsYS_GRABaTP :
            case ifcIDtYPEtELLsYS_GRABdEI :
            case ifcIDtYPEtELLsYS_GRABaTI :
            case ifcIDtYPEtELLsYS_GRABdTP :
            case ifcIDtYPEtELLsYS_GRABcTP :
            case ifcIDtYPEtELLsYS_GRABdTI :
            case ifcIDtYPEtELLsYS_GRABcTI :
        {
        switch( idType )
        //CODEsYNC: 001020f 6a40104
        //THIS CODE IS WRITTEN TO MAKE grabOldS WORK AS SPEEDY AS POSSIBLE
        //ALMOST ALL OF MY WORK INVOLVES grabOldS CONSTRUCTION, DESTRUCTION, ATTACHMENT, DETACHMENT

        //U: MIGRATE ALL dosTellMonitorIF EMISSIONS FROM TEXT TO BINARY DATA (FOR SPEED)
    {
    if( !bText )
    etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/4") ) ; //U::
    bwP.ba.leverOsPid = infoP.osPid ;
    bwP.ba.bLeverOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ; //U:OPTIMIZE: GRAB THIS ONLY WHEN I REALLY NEED TO
    etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/3") ) ; //U::

    //U:OPTIMIZE: (1) DURING QUIT, SUPPRESS SOME idType VALUES.  (2) DO NOT READ THE DATA MEMORY FOR THE idType VALUES THAT ARE SUPPRESSED

    }
        }
            __Z( bOk ) ;
            Wo thThread.dosReadProcessMemoryIF( tinP , pbData , cbData , bOk , infoP.osSay_post + ( bText ? 0 : sizeof( tellS ) ) , infoP.osPid ) ; Wi
            ZE( boolT , bOk ) ;
        {
        if( pbData )
        etThread.newF( tinP , LF , pbData , cbData ) ; ___( pbData ) ;
        bCopy_pbData = 1 ;
    {
    else if( cbData )
    if( infoP.osPid == bwP.ba.osPid ) pbData = infoP.osSay_post + ( bText ? 0 : sizeof( tellS ) ) ;
    ZE( boolT  , bCopy_pbData ) ;
    ZE( byteT* , pbData ) ;
    etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/2") ) ; //U::

    }
        }
            cbData = head.cbData ;
            idType = head.idType ;
        {
        if( !etThread )

        __( getNegAM( head.finger1 ) - ( FINGERnEG_TELEMETRY1 & 0xffffff00 ) ) ; //ASSUME HARDWARE: countT IS 4 BYTES
        __Z( bOk ) ;
        Wo thThread.dosReadProcessMemoryIF( tinP , (byteT*)&head , sizeof head , bOk , infoP.osSay_post , infoP.osPid ) ; Wi
        ZE( boolT , bOk ) ;

        struct tellS head ;
    {
    else
    }
        cbData = infoP.osSay_cost ;
        bText = 1 ;
    {
    if( infoP.osSay_cost > 1 ) //ASSUME: OS WILL NEVER EMIT A NULL LENGTH STRING; NOTE: osSay_cost INCLUDES NULL TERMINATOR
    ZE( countT , cbData ) ;
    ZE( countT , idType ) ;
    ZE( boolT  , bText  ) ;
    etherC::etTextIF( tinP ).winSetTitleF( tinP , T("hanSayF/1") ) ; //U::

    thirdC& thThread = etThread ;
    etherC& ether    = bwP.ba.etPrime ;
    etherC& etThread = bwP.ether ;
{
countT hanSayF( tinS& tinP , bookWoS& bwP , ifcMonitorEventS& infoP )

;
}
   countT cbData ;
   countT idType ;
   countT fingerprint ;
{
struct tellS
//CODEsYNCH: 6a40104 16f0003 16f0005 16f0006

// I TELL THE DIFFERENCE BY INSPECTING WHETHER infoP.osPid IS EQUAL TO MY OWN osPid
// BUT I AM ALSO CALLED BY MY OWN SELF-MONITOR
// I AM "NORMALLY" CALLED BY tmMonitorF

}
    st_pTinEventOriginalP.ungrabF( tinP ) ;
    st_pTinWhereP.ungrabF( tinP ) ;
    }
        while( !st_pTinEventOriginalP.third && ~hDown ) ;
        }
            if( c_pTin ) st_pTinWhereP.sinkF( tinP , countTC() , c_pTin , flSTACKsINK_UNIQUE ) ;
            countT c_pTin = st_pTinEventOriginalP.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( st_pTinEventOriginalP )
    bWhereNewThreadsP = 1 ;
    st_pTinWhereP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    st_pTinEventOriginalP.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT whereAllOnF( tinS& tinP , stackC& st_pTinWhereP , stackC& st_pTinEventOriginalP , boolT& bWhereNewThreadsP )

}
    bLeverOsPidP.ungrabF( tinP ) ;
    processWhereInfoP.swThreadWhereInfo.ungrabF( tinP ) ;
    }
        }
            }
                }
                    etThread.delF( tinP , psttr ) ;
                    }
                        etThread.delF( tinP , postr ) ;
                        }
                            //U:etThread.boxZapF( tinP , tFile ) ;
                            if( !ether ) etThread.osEditF( tinP , tFile , 1 ) ;
                            etThread.boxPutF( tinP , tFile , postr , costr ) ;
                        {
                        if( !ether )
                        TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF1(DDNUMB)+T("/")+TF1(pwt->idProcessOld)+T("/reused.writeWhereInfoF2.eachThread") ;
                        countT costr = etThread.strMakeF( tinP , postr , psttr ) ; ___( postr ) ;
                        ZE( osTextT* , postr ) ;
                    {
                    else
                    if( bToLogP || ether ) etThread.ifcSayF( tinP , T(USCORE79"\r\n")+T(psttr)+T("\r\n"USCORE79) , flSAY_APPEND | flSAY_LOG ) ;
                    pwt->reportWhereF( tinP , psttr ) ; ___( psttr ) ;
                    ZE( strokeS* , psttr ) ;
                {
                if( pwt->bHaveTalliesF( tinP ) )
            {
            else
            if( !pwt ) processWhereInfoP.swThreadWhereInfo.freeF( tinP ) ;
            threadWhereInfoS* pwt = (threadWhereInfoS*)(countT)processWhereInfoP.swThreadWhereInfo ;
            processWhereInfoP.lever_pTin = processWhereInfoP.swThreadWhereInfo.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = processWhereInfoP.swThreadWhereInfo.cFlavorsF( tinP ) ;
        if( etThread.diskFileExistsF( tinP , tLog2 ) ) etThread.boxZapF( tinP , tLog2 ) ;
        if( etThread.diskFileExistsF( tinP , tLog  ) ) etThread.boxZapF( tinP , tLog  ) ;
    {
    else
    }
        }
            }
                etThread.delF( tinP , psttr ) ;
                }
                    //U:etThread.boxZapF( tinP , tFile ) ;
                    etThread.osEditF( tinP , tFile , 1 ) ;
                    etThread.delF( tinP , postr ) ;
                    etThread.boxPutF( tinP , tFile , postr , costr ) ;
                    TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF1(DDNUMB)+T("/")+T(pTinEventP->osPid)+T("/reused.writeWhereInfoF2.woThread") ;
                    countT costr = etThread.strMakeF( tinP , postr , psttr ) ; ___( postr ) ;
                    ZE( osTextT* , postr ) ;
                {
                else
                }
                    //etThread.ifcSayF( tinP , psttr , flSAY_APPEND | flSAY_LOG ) ;
                    if( etThread.diskFileExistsF( tinP , tLog2 ) ) etThread.boxZapF( tinP , tLog2 ) ;
                    if( etThread.diskFileExistsF( tinP , tLog  ) ) etThread.boxZapF( tinP , tLog  ) ;
                {
                if( bToLogP || ether )
                pwt->reportWhereF( tinP , psttr ) ; ___( psttr ) ;
                ZE( strokeS* , psttr ) ;
            {
            if( pwt->bHaveTalliesF( tinP ) )
        {
        else
        if( !pwt ) processWhereInfoP.swThreadWhereInfo.freeF( tinP ) ;
        threadWhereInfoS* pwt = (threadWhereInfoS*)(countT)processWhereInfoP.swThreadWhereInfo ;
        processWhereInfoP.lever_pTin = (countT)pTinEventP ;
    {
    if( pTinEventP )
    TN( tLog2 , "" ) ; tLog2 = tLog+T(".sublog") ;
    TN( tLog  , "///d/ideafarm.log.where." ) ; tLog += (pTinEventP?T("woThread."):T("eachThread."))+TF1(osPidP) ;
    processWhereInfoP.swThreadWhereInfo.grabF( tinP , TAG( TAGiDnULL ) ) ;
    bLeverOsPidP.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT writeWhereInfoF( tinS& tinP , etherC& etThread , etherC& ether , tinS* pTinEventP , processWhereInfoS& processWhereInfoP , batonC& bLeverOsPidP , const countT osPidP , const boolT bToLogP = 0 )

}
    }
        etThread.delF( tinP , psttr ) ;
        }
            //U:etThread.boxZapF( tinP , tFile ) ;
            etThread.osEditF( tinP , tFile , 1 ) ;
            etThread.delF( tinP , postr ) ;
            etThread.boxPutF( tinP , tFile , postr , costr ) ;
            TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF1(DDNUMB)+T("/")+T(osPidP)+T("/reused.writeWhereInfoF1") ;
            countT costr = etThread.strMakeF( tinP , postr , psttr ) ; ___( postr ) ;
            ZE( osTextT* , postr ) ;
        {
        else
        }
            //etThread.ifcSayF( tinP , psttr , flSAY_APPEND | flSAY_LOG ) ;
            if( etThread.diskFileExistsF( tinP , tLog2 ) ) etThread.boxZapF( tinP , tLog2 ) ;
            if( etThread.diskFileExistsF( tinP , tLog  ) ) etThread.boxZapF( tinP , tLog  ) ;
        {
        if( bToLogP || ether )
        processWhereInfoP.reportWhereF( tinP , psttr ) ; ___( psttr ) ;
        ZE( strokeS* , psttr ) ;
    {
    if( processWhereInfoP.bHaveTalliesF( tinP ) )

    TN( tLog2 , "" ) ; tLog2 = tLog+T(".sublog") ;
    TN( tLog  , "///d/ideafarm.log.where.process." ) ; tLog += TF1(osPidP) ;
{
voidT writeWhereInfoF( tinS& tinP , etherC& etThread , etherC& ether , processWhereInfoS& processWhereInfoP , const countT osPidP , const boolT bToLogP = 0 )

}
    bLeverOsPidP.ungrabF( tinP ) ;
    st_pTinWhereP.ungrabF( tinP ) ;

    }
        while( !st_pTinWhereP.third && ~hDown ) ;
        }
            if( pTin ) purgeWhereInfoF( tinP , pTin , processWhereInfoP , bLeverOsPidP ) ;
            tinS* pTin = (tinS*)st_pTinWhereP.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( st_pTinWhereP )

    st_pTinWhereP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    bLeverOsPidP.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT purgeWhereInfoF( tinS& tinP , stackC& st_pTinWhereP , processWhereInfoS& processWhereInfoP , batonC& bLeverOsPidP )

}
    }
        bLeverOsPidP.ungrabF( tinP ) ;
        processWhereInfoP.swThreadWhereInfo.ungrabF( tinP ) ;
        if( pwt ) pwt->purgeF( tinP ) ;
        threadWhereInfoS* pwt = (threadWhereInfoS*)(countT)processWhereInfoP.swThreadWhereInfo ;
        processWhereInfoP.lever_pTin = (countT)pTinEventP ;
        processWhereInfoP.swThreadWhereInfo.grabF( tinP , TAG( TAGiDnULL ) ) ;
        bLeverOsPidP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( pTinEventP )
{
voidT purgeWhereInfoF( tinS& tinP , tinS* pTinEventP , processWhereInfoS& processWhereInfoP , batonC& bLeverOsPidP )

}
    return ifcIDcMDmoNITOR_CONTINUE ;
    if( !bwP.bAdoptedKid ) bwP.flagsComment |= fliCOMMENT_PROCESSeNDED ;
    //U: etThread.DosCloseThreadResourcesF( tinP , osTid ) ;

    //bwP.stPhrases << psttOldC( tinP , etThread , T(bwP.bAdoptedKid?"--adopted kid process--\r\n":"--process--\r\n") ) ;

    }
        //U: etThread.boxZapF( tinP , tFile ) ;
        //etThread.osEditF( tinP , tFile , 1 ) ;
        etThread.delF( tinP , postr ) ;
        etThread.boxPutF( tinP , tFile , postr , costr ) ;
        TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF1(DDNUMB)+T("/")+T(infoP.osPid)+T("/reused.hanDelProcess.bAdoptedKid") ;
        etThread.delF( tinP , psttr ) ;
        countT costr = etThread.strMakeF( tinP , postr , psttr ) ; ___( postr ) ;
        ZE( osTextT* , postr ) ;
    
        reportWhereNowF( tinP , etThread , psttr , bwP.osPid , bwP.ba , infoP ) ; ___( psttr ) ;
        ZE( strokeS* , psttr ) ;
        //U:LOG THE IDENTITY OF THIS KID PROCESS
    {
    if( bwP.bAdoptedKid )

    }
        pTinEventUnregisterF( tinP , etThread , bwP.ba , infoP , 1 ) ;
        //bwP.stPhrases << psttOldC( tinP , etThread , T("A process terminated early.  This was a naughty thing to do.\r\n") ) ;
        bwP.flagsComment |= fliCOMMENT_SIN ;
    {
    if( !bwP.bAdoptedKid && infoP.osExitCodeProcess != ifcEXITcODEpROCESSaOK && infoP.osExitCodeProcess != ifcEXITcODEpROCESSiMPOTENT )
    etherC& etThread = bwP.ether ;
{
countT hanDelProcessF( tinS& tinP , bookWoS& bwP , ifcMonitorEventS& infoP )

}
    return ifcIDcMDmoNITOR_CONTINUE ;
    bwP.cKidThreads -- ;

    }
        bwP.ba.swThread.ungrabF( tinP ) ;
        bwP.ba.swThread.freeF( tinP ) ;
        bwP.ba.stThread << (byteT*)&thread ;
        etThread.osTimeNowF( tinP , thread.timeDel.time1 , thread.timeDel.time2 ) ;
        threadS& thread = (threadS&)(countT&)bwP.ba.swThread ;
        bwP.ba.leverOsTid = infoP.osTid ;
        bwP.ba.swThread.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {

    }
        pTinEventUnregisterF( tinP , etThread , bwP.ba , infoP ) ;
        //bwP.stPhrases << psttOldC( tinP , etThread , T("A thread terminated early.  This was a naughty thing to do.\r\n") ) ;
        bwP.flagsComment |= fliCOMMENT_SIN ;
    {
    if( infoP.osExitCodeThread != ifcEXITcODEtHREADaOK && infoP.osExitCodeThread != ifcEXITcODEtHREADiMPOTENT && bwP.pTinEvent ) // IF !bwP.pTinEvent THEN WE ARE ASSUMING THAT THIS IS A THREAD LAUNCHED BY THE OS (EXAMPLE: Ctrl-C WILL CAUSE WINDOWS-32 TO LAUNCH A THREAD AND THEN CALL THE PROCESS'S HANDLERS)

    bwP.flagsComment |= fliCOMMENT_CLOSEtHREADhANDLE ;

    //bwP.stPhrases << psttOldC( tinP , etThread , T("--thread--\r\n") ) ;
    etherC& etThread = bwP.ether ;
{
countT hanDelThreadF( tinS& tinP , bookWoS& bwP , ifcMonitorEventS& infoP )

}
    return ifcIDcMDmoNITOR_CONTINUE ;
    }
        bwP.ba.swThread.ungrabF( tinP ) ;
        (threadS&)(countT&)bwP.ba.swThread = thread ;
        bwP.ba.leverOsTid = thread.osTid ;
        bwP.ba.swThread.grabF( tinP , TAG( TAGiDnULL ) ) ;
        thread.osPid = infoP.osPid ;
        thread.osTid = infoP.osTid ;
        etThread.osTimeNowF( tinP , thread.timeNew.time1 , thread.timeNew.time2 ) ;
        threadS thread( tinP , etThread ) ;
    {

    //U::CONVERT THIS LINE TO USE handleC::operator =: ((thirdC&)etThread).Dos DupHandleF( tinP , *(handleC*)&(countT&)bwP.sw_hThread_osTid , infoP.osCreateThread_hThread , bwP.ba.hProcess , bwP.ba.hProcess ) ;
    //bwP.stPhrases << psttOldC( tinP , etThread , T("++thread++\r\n") ) ;
    bwP.cKidThreads ++ ;
    etherC& etThread = bwP.ether ;
{
countT hanNewThreadF( tinS& tinP , bookWoS& bwP , ifcMonitorEventS& infoP )

}
    return ifcIDcMDmoNITOR_CONTINUE ;

    if( tinP.fingerprint && etThread && bwP.stPhrases && infoP.osPid ) ;
    //logExeDllImageF( tinP , etThread , bwP.stPhrases , infoP ) ;

    //bwP.stPhrases << psttOldC( tinP , etThread , T(bwP.bAdoptedKid?"++adopted kid process++\r\n":"++process++\r\n") ) ;
    if( !bwP.bAdoptedKid ) bwP.flagsComment |= fliCOMMENT_PROCESSsTARTED ;

    }
        //U:etThread.boxZapF( tinP , tFile ) ;
        //etThread.osEditF( tinP , tFile , 1 ) ;
        etThread.delF( tinP , postr ) ;
        etThread.boxPutF( tinP , tFile , postr , costr ) ;
        TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF1(DDNUMB)+T("/")+T(infoP.osPid)+T("/reused.hanNewProcess.bAdoptedKid") ;
        etThread.delF( tinP , psttr ) ;
        countT costr = etThread.strMakeF( tinP , postr , psttr ) ; ___( postr ) ;
        ZE( osTextT* , postr ) ;
    
        reportWhereNowF( tinP , etThread , psttr , bwP.osPid , bwP.ba , infoP ) ; ___( psttr ) ;
        ZE( strokeS* , psttr ) ;
        //U:LOG THE IDENTITY OF THIS KID PROCESS

        }
            DEL( pInfoFile ) ;
            ((thirdC&)etThread).dosQueryFileInfoIF( tinP , pInfoFile , infoP.osCreateProcess_hFile ) ;
            ZE( infoFileS* , pInfoFile ) ;

            etThread.osTimeFromOldTimeF( tinP , timeC1 , timeC2 , 1998 , 10 , 22 , 11 , 4 ) ;
            ZE( sCountT , timeC2 ) ;
            ZE( countT , timeC1 ) ;
        {
        else if( infoP.osCreateProcess_hFile )
        }
            }
                pb002[ off ] = 0 ;
                while( pb002[ off ] && ++ off < sizeof pb002 - 1 && bOk ) ;
                }
                    ((thirdC&)etThread).dosReadProcessMemoryIF( tinP , pb002 + off , 1 , bOk , (voidT*)( pbImageName + off ) , infoP.osPid ) ;
                    bOk = 0 ;
                {
                do
                ZE( countT , off ) ;
                *pb002 = 0 ;
                byteT pb002[ 0x200 ] ;
            {
            if( pbImageName )
            ((thirdC&)etThread).dosReadProcessMemoryIF( tinP , (byteT*)&pbImageName , sizeof pbImageName , bOk , (voidT*)infoP.osCreateProcess_pbImageName , infoP.osPid ) ;
            ZE( byteT* , pbImageName ) ;
            ZE( boolT , bOk ) ;
        {
        if( infoP.osCreateProcess_pbImageName )
    {
    if( bwP.bAdoptedKid )

    //etThread.delF( tinP , pbContext ) ;
    //etThread.dosSetThreadContextF( tinP , pbContext , cbContext , osTid ) ;
    //U:etThread.dosSetThreadContextField_singleStep_F( tinP , pbContext , cbContext , 1 ) ;
    //etThread.dosGetThreadContextF( tinP , pbContext , cbContext , osTid ) ; ___( pbContext ) ;
    //ZE( countT , cbContext ) ;
    //ZE( byteT* , pbContext ) ;
    //U: THIS DOES NOT WORK
    etherC& etThread = bwP.ether ;
{
countT hanNewProcessF( tinS& tinP , bookWoS& bwP , ifcMonitorEventS& infoP )

}
    return bHandled ? ifcIDcMDmoNITOR_CONTINUE : ifcIDcMDmoNITOR_CONTINUEuNLESSeXCEPTION ;

    }
        }
            break ;
            //U: BECOMES IMPOTENT BECAUSE osTid IS NOT FOUND IN *pswHanFromTid:    ((thirdC&)etThread).DosCloseThreadResourcesF( tinP , osTid ) ;

            #endif
                bHandled = 1 ;
                Wo ((thirdC&)etThread).dosKillProcessF( tinP , infoP.osPid ) ; WHATga // THIS IS UNDESIRABLE BECAUSE DLL'S ARE NOT NOTIFIED THAT THE DOOMED PROCESS IS TERMINATED.  IT IS NEEDED BECAUSE etherC::paperZits_OffF IS NOT COMPLETELY EFFECTIVE ON WINDOWS: FOR A DEBUGGED PROCESS WINDOWS INSISTS ON DISPLAYING A POPUP MESSAGE WINDOW
            #if defined( __NT__ )

            bwP.flagsComment |= fliCOMMENT_SIN ;

            bwP.stPhrases << psttOldC( tinP , etThread , T("This was a naughty thing to do.  The offender will be terminated.\r\n") ) ;
            if( infoP.idException == ifcIDeVENTeXCEPTIONmONITORED_ACCESSvIOLATION ) bwP.stPhrases << psttOldC( tinP , etThread , T("A ")+T(infoP.osException_bWrite ?"write":"read")+T(" was attempted at address ")+TF1((countT)infoP.osException_pbData)+T(".\r\n") ) ;
            bwP.stPhrases << psttOldC( tinP , etThread , T("The code at address ")+TF1((countT)infoP.osException_pbAt)+T(" ")+tSin+T(".\r\n") ) ;

            }
                }
                    __1
                    __( infoP.idException ) ;
                {
                default                                                   :
                case ifcIDeVENTeXCEPTIONmONITORED_NOTlISTED               : PREACH( T("did something unexpected and probably illegal (code ")+TF1(infoP.idExceptionRaw)+T(")"       ) )
                case ifcIDeVENTeXCEPTIONmONITORED_ARRAYbOUNDSeXCEEDED     : PREACH( T("specified an out of bounds array index"                                                      ) )
                case ifcIDeVENTeXCEPTIONmONITORED_DATATYPEmISALIGNMENT    : PREACH( T("attempted to read or write data using a misaligned address"                                  ) )
                case ifcIDeVENTeXCEPTIONmONITORED_FLOATdENORMALoPERAND    : PREACH( T("attempted a floating point calculation with a teeny tiny operand value"                      ) )
                case ifcIDeVENTeXCEPTIONmONITORED_FLOATdIVIDEbYzE       : PREACH( T("attempted to divide a measureT value by ze""ro"                                                ) )
                case ifcIDeVENTeXCEPTIONmONITORED_FLOATiNEXACTrESULT      : PREACH( T("calculated a floating point value that cannot be represented exactly as a decimal fraction"  ) )
                case ifcIDeVENTeXCEPTIONmONITORED_FLOATiNVALIDoPERATION   : PREACH( T("attempted something weird with floating point"                                               ) )
                case ifcIDeVENTeXCEPTIONmONITORED_FLOAToVERFLOW           : PREACH( T("calculated a floating point exponent that is too large to be represented"                    ) )
                case ifcIDeVENTeXCEPTIONmONITORED_FLOATsTACKcHECK         : PREACH( T("used up the floating point stack"                                                            ) )
                case ifcIDeVENTeXCEPTIONmONITORED_FLOATuNDERFLOW          : PREACH( T("calculated a floating point exponent that is too small to be represented"                    ) )
                case ifcIDeVENTeXCEPTIONmONITORED_ILLEGALiNSTRUCTION      : PREACH( T("attempted to execute an invalid instruction"                                                 ) )
                case ifcIDeVENTeXCEPTIONmONITORED_INpAGEeRROR             : PREACH( T("requested a memory page that could not be loaded"                                            ) )
                case ifcIDeVENTeXCEPTIONmONITORED_INTEGERdIVIDEbYzE     : PREACH( T("attempted to divide a countT or sCountT value by ze""ro"                                       ) )
                case ifcIDeVENTeXCEPTIONmONITORED_INTEGERoVERFLOW         : PREACH( T("overflowed a countT or sCountT value"                                                        ) )
                case ifcIDeVENTeXCEPTIONmONITORED_INVALIDdISPOSITION      : PREACH( T("(an exception handler) returned an invalid disposition"                                      ) )
                case ifcIDeVENTeXCEPTIONmONITORED_NONCONTINUABLEeXCEPTION : PREACH( T("attempted to continue a noncontinuable exception"                                            ) )
                case ifcIDeVENTeXCEPTIONmONITORED_PRIVILEGEDiNSTRUCTION   : PREACH( T("attempted to execute a privileged instruction"                                               ) )
                case ifcIDeVENTeXCEPTIONmONITORED_STACKoVERFLOW           : PREACH( T("used up its stack"                                                                           ) )
                case ifcIDeVENTeXCEPTIONmONITORED_ACCESSvIOLATION         : PREACH( T("attempted to access protected memory"                                                        ) )
            {
            switch( infoP.idException )
            TN( tSin , "" ) ;
        {
        default :
        }
            break ;
            bHandled = 1 ;
        {
        case ifcIDeVENTeXCEPTIONmONITORED_CONTROL_C_NOTIFICATION : //NOT TESTED.  TO TEST, NEED TO LAUNCH A MONITORED CONSOLE PROCESS WITH A CONSOLE AND THEN USE THAT CONSOLE TO CTRL-C
        case ifcIDeVENTeXCEPTIONmONITORED_SINGLEsTEP :
        case ifcIDeVENTeXCEPTIONmONITORED_BREAKPOINT :
    {
    switch( infoP.idException )
    ZE( boolT , bHandled ) ;

    etherC& etThread = bwP.ether ;
{
countT hanExceptionF( tinS& tinP , bookWoS& bwP , ifcMonitorEventS& infoP )

}
    baP.bLeverOsPid.ungrabF( tinP ) ;

    baP.swsIdaTin.ungrabF( tinP ) ;
    }
        while( !baP.swsIdaTin.third && ~hDown ) ;
        }
            }
                etThread.strFuseF( tinP , psttP , T(pTin->postThreadName)+T(": ")+T(pTin->postTell)+T("\r\n") ) ;
            {
            if( pTin )
            tinS* pTin = (tinS*)(byteT*)ap_artmentOldC( tinP , baP.swsIdaTin.downF( tinP , hDown ) ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( baP.swsIdaTin )
    baP.swsIdaTin.grabF( tinP , TAG( TAGiDnULL ) ) ;
    etThread.strMakeF( tinP , psttP , T("osPidMonitored: ")+TF4(osPidMonitoredP,flFORMAT_FOREIGN,0,0xa)+T("\r\nosPidEvent: ")+TF4(infoP.osPid,flFORMAT_FOREIGN,0,0xa)+T("\r\nthe current activity of each thread in this process is:\r\n \r\n") , 0x10000 ) ; ___( psttP ) ;

    baP.leverOsPid = osPidMonitoredP ;
    baP.bLeverOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT reportWhereNowF( tinS& tinP , etherC& etThread , strokeS*& psttP , const countT osPidMonitoredP , bookAllS& baP , ifcMonitorEventS& infoP )

}
    baP.bLeverOsPid.ungrabF( tinP ) ;

    }
        while( !etThread && !baP.sws_pTin.third && ~hDown ) ;
        }
            DEL( pTinCopy ) ;
            if( pTinCopy && ( pTinCopy->osTid == infoP.osTid || ( bProcessP && pTinCopy->osPid == infoP.osPid ) ) ) baP.sws_pTin.extractF( tinP ) ;
            pTinCopyF( tinP , etThread , pTinCopy , pvTin , infoP.osPid , 1 ) ; ___( pTinCopy ) ;
            ZE( tinS* , pTinCopy ) ;
            voidT* pvTin = (voidT*)baP.sws_pTin.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( baP.sws_pTin )

    refreshTinIdaArrayF( tinP , etThread , baP ) ;
    }
        while( !etThread && !baP.swsIdaTin.third && ~hDown ) ;
        }
            if( pTin && ( pTin->osTid == infoP.osTid || ( bProcessP && pTin->osPid == infoP.osPid ) ) ) baP.swsIdaTin.extractF( tinP ) ;
            tinS* pTin = (tinS*)(byteT*)ap_artmentOldC( tinP , idaTin ) ;
            countT idaTin = baP.swsIdaTin.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( baP.swsIdaTin )

    baP.leverOsPid = infoP.osPid ;
    baP.bLeverOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        if( etThread ) return ;
        __( !infoP.osPid ) ;
        __( !infoP.osTid ) ;
        if( etThread ) return ;
    {
    IFbEcAREFUL
{
voidT pTinEventUnregisterF( tinS& tinP , etherC& etThread , bookAllS& baP , ifcMonitorEventS& infoP , const boolT bProcessP = 0 )

}
    ungrabF( tinP , grab_off_aIdaTin ) ;
    off_aIdaTin = (byteT*)&baP.aIdaTin[ 0 ] - (byteT*)>>>>(p oolC&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<Thread ;
    }
        baP.aIdaTin[ ide ++ ] = idaTin ;
        stIdaTin >> idaTin ;
        ZE( countT , idaTin ) ;
    {
    while( stIdaTin )
    ZE( countT , ide ) ;
    baP.aIdaTin.trimF( tinP , stIdaTin ) ;
    baP.aIdaTin.trimF( tinP , 0 ) ;
    grabF( tinP , grab_off_aIdaTin ) ;

    countT&     off_aIdaTin = baP.bMonitored ?      poolOld Side.off_aIdaTin_314m :      poolOld Side.off_aIdaTin_314 ;
    grabOldS& grab_off_aIdaTin = baP.bMonitored ? poolOld Side.grab_off_aIdaTin_314m : poolOld Side.grab_off_aIdaTin_314 ;
    poolOld SideS& poolOld Side = (poolOld SideS&)poolC::poolOldRootIF( tinP ) ;

    }
        baP.bLeverOsPid.ungrabF( tinP ) ;
        baP.leverOsPid = leverSave ;
        baP.swsIdaTin.stackF( tinP , stIdaTin ) ;
        countT leverSave = baP.leverOsPid ;
        baP.bLeverOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    stackC stIdaTin( tinP , etThread , TAG( TAGiDnULL ) , baP.swsIdaTin.flagsF( tinP ) , baP.swsIdaTin.idTypeF( tinP ) ) ;
{
voidT refreshTinIdaArrayF( tinS& tinP , etherC& etThread , bookAllS& baP )

}
    baP.bLeverOsPid.ungrabF( tinP ) ;

    }
//        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'2.0.7") ) ; //U::
        }
            while( !etThread && !baP.sws_pTin.third && ~hDown && !pTinEventP ) ;
            }
                else { DEL( pTinCopy ) ; }
                }
                    bCopyP = 1 ;
                    pTinEventP = pTinCopy ;
                {
                if( pTinCopy && pTinCopy->osTid == infoP.osTid && pTinCopy->idThread )
                pTinCopyF( tinP , etThread , pTinCopy , pvTin , infoP.osPid , bAcceptIfDirtyP ) ; ___( pTinCopy ) ;
                ZE( tinS* , pTinCopy ) ;
                voidT* pvTin = (voidT*)baP.sws_pTin.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( baP.sws_pTin )
//        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'2.0.6") ) ; //U::
    {
    if( !pTinEventP )

    baP.swsIdaTin.ungrabF( tinP ) ;
    }
//        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'2.0.5") ) ; //U::
        while( !etThread && !baP.swsIdaTin.third && ~hDown && !pTinEventP ) ;
        }
            if( pTin && pTin->osTid == infoP.osTid ) pTinEventP = pTin ;
            tinS* pTin = (tinS*)(byteT*)ap_artmentOldC( tinP , idaTin ) ;
            countT idaTin = baP.swsIdaTin.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
//        etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'2.0.4") ) ; //U::
    {
    if( baP.swsIdaTin )
    etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'2.0.3") ) ; //U::
    baP.swsIdaTin.grabF( tinP , TAG( TAGiDnULL ) ) ;
    etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'2.0.2") ) ; //U::

    baP.leverOsPid = infoP.osPid ;
    baP.bLeverOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ;
    etherC::etTextIF( tinP ).winSetTitleF( tinP , T("handlin'2.0.1") ) ; //U::

    }
        if( etThread ) return ;
        __( !infoP.osTid ) ;
        __NZ( pTinEventP ) ;
        if( etThread ) return ;
    {
    IFbEcAREFUL
{
voidT pTinEventF( tinS& tinP , etherC& etThread , tinS*& pTinEventP , boolT& bCopyP , ifcMonitorEventS& infoP , bookAllS& baP , const boolT bAcceptIfDirtyP = 0 )

}
    baP.bLeverOsPid.ungrabF( tinP ) ;

    }
        baP.sws_pTin.ungrabF( tinP ) ;
        }
            }
                while( !etThread && !baP.sws_pTin.third && ~hDown && !pTinP ) ;
                }
                    else { DEL( pTinCopy ) ; }
                    }
                        bCopyP = 1 ;
                        pTinP = pTinCopy ;
                    {
                    if( pTinCopy && pTinCopy->osTid == osTidP && pTinCopy->idThread )
                    pTinCopyF( tinP , etThread , pTinCopy , pvTin , osPidP , bAcceptIfDirtyP ) ; ___( pTinCopy ) ;
                    ZE( tinS* , pTinCopy ) ;
                    voidT* pvTin = (voidT*)baP.sws_pTin.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( baP.sws_pTin )
            baP.leverOsPid = baP.sws_pTin.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = baP.sws_pTin.cFlavorsF( tinP ) ;
        baP.sws_pTin.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !pTinP )

    baP.swsIdaTin.ungrabF( tinP ) ;
    }
        }
            while( !etThread && !baP.swsIdaTin.third && ~hDown && !pTinP ) ;
            }
                if( pTin && pTin->osTid == osTidP ) pTinP = pTin ;
                tinS* pTin = (tinS*)(byteT*)ap_artmentOldC( tinP , idaTin ) ;
                countT idaTin = baP.swsIdaTin.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( baP.swsIdaTin )
        baP.leverOsPid = baP.swsIdaTin.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = baP.swsIdaTin.cFlavorsF( tinP ) ;
    baP.swsIdaTin.grabF( tinP , TAG( TAGiDnULL ) ) ;
    baP.bLeverOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        if( etThread ) return ;
        __Z( osTidP ) ;
        __NZ( pTinP ) ;
        if( etThread ) return ;
    {
    IFbEcAREFUL
{
voidT pTinF( tinS& tinP , etherC& etThread , tinS*& pTinP , boolT& bCopyP , const countT osTidP , const countT osPidP , bookAllS& baP , const boolT bAcceptIfDirtyP = 0 )

}
    }
        pTinCopyP->idDirty = idDirty2 != idDirty1 || idDirty2 % 2 ;
        pTinCopyP->pPool = &>>>>(p oolC&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<Thread ;
    {
    if( pTinCopyP )

    pTinCopyP = new( 0 , tinP , LF ) tinS( *(tinS*)pbScratch , flTINs_DISABLEcOMMENTS | flTINs_CONSTRUCTqUIETLY ) ; ___( pTinCopyP ) ; //ASSUME: KNOWS HOW TO COPY FROM ANOTHER PROCESS

    }
        }
            }
                ++ s ; thirdC::dosSleepWinkIF( tinP ) ;
            {
            else
            if( ( idDirty2 == idDirty1 && !( idDirty2 % 2 ) ) || bAcceptIfDirtyP ) break ;
    
            bOk = 0 ;
            __Z( bOk ) ;
            Wo ((thirdC&)etThread).dosReadProcessMemoryIF( tinP , (byteT*)&idDirty2 , sizeof idDirty2 , bOk , pvFromIdDirty , osPidP ) ; Wi
    
            bOk = 0 ;
            __Z( bOk ) ;
            Wo ((thirdC&)etThread).dosReadProcessMemoryIF( tinP , pbScratch , sizeof pbScratch , bOk , pvFromP , osPidP ) ; Wi
        
            bOk = 0 ;
            __Z( bOk ) ;
            Wo ((thirdC&)etThread).dosReadProcessMemoryIF( tinP , (byteT*)&idDirty1 , sizeof idDirty1 , bOk , pvFromIdDirty , osPidP ) ; Wi
        {
        while( !etThread )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    ZE( countT , idDirty2 ) ;
    ZE( countT , idDirty1 ) ; //ASSUME: tinS::idDirty IS INCREMENTED BEFORE tinS OBJECT BECOMES DIRTY AND AGAIN AFTER IT IS CLEAN (NONATOMIC UPDATE IS COMPLETE)

    ZE( boolT , bOk ) ;

    //O:AM USING dosReadProcessMemoryIF TO READ MYSELF: OPTIMIZE BY AVOIDING THIS) (baP.osPid == osPidP)

    const voidT* const pvFromIdDirty = (const voidT*)( (byteT*)pvFromP + ( (byteT*)&tinP.monitor.idDirty - (byteT*)&tinP ) ) ;
    byteT pbScratch[ sizeof( tinS ) ] ;

    }
        if( etThread ) return ;
        __Z( bAcceptIfDirtyP ) ; //ENFORCES STYLE (SEE WARNING)
        __Z( osPidP ) ;
        __Z( pvFromP ) ;
        __NZ( pTinCopyP ) ;
        if( etThread ) return ;
    {
    IFbEcAREFUL
{
voidT pTinCopyF( tinS& tinP , etherC& etThread , tinS*& pTinCopyP , const voidT* const pvFromP , const countT osPidP , const boolT bAcceptIfDirtyP )
// POLICY: RETAIN THE BOOLEAN BUT ALWAYS SET IT
// WARNING: bAcceptIfDirtyP WILL DEADLOCK IF I HAVE GRABBED AND THE tmMonitorF THREAD IS TRYING TO GRAB IT AND THE tinS IS DIRTY

}
    etThread.delF( tinP , psttr ) ;
    stPhrasesP << psttOldC( tinP , etThread , psttr ) ;
    }
        DEL( pTinCopy ) ;
        }
            pTinCopy->strFuseF( tinP , etThread , psttr , 0 , flagsInclude1P , flagsInclude2P , flagsExclude1P , flagsExclude2P , idFormatP ) ; ___( psttr ) ;
            pTinCopy->pPool = &>>>>(p oolC&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<Thread ;
        {
        if( pTinCopy )
        tinS* pTinCopy = new( 0 , tinP , LF ) tinS( tinToLogP , flTINs_DISABLEcOMMENTS | flTINs_CONSTRUCTqUIETLY ) ; ___( pTinCopy ) ; //ASSUME: KNOWS HOW TO COPY FROM ANOTHER PROCESS
    {
    else
    if( bCopyP ) { tinToLogP.strFuseF( tinP , etThread , psttr , 0 , flagsInclude1P , flagsInclude2P , flagsExclude1P , flagsExclude2P , idFormatP ) ; ___( psttr ) ; }
    ZE( strokeS* , psttr ) ;
{
voidT logTinF( tinS& tinP , etherC& etThread , stackC& stPhrasesP , tinS& tinToLogP , boolT& bCopyP , const countT flagsInclude1P = flTINrPT1_null , const countT flagsInclude2P = flTINrPT2_null , const countT flagsExclude1P = flTINrPT1_null , const countT flagsExclude2P = flTINrPT2_null , countT idFormatP = 0 )
// bCopyP IS A REFERENCE TO FORCE THE CODE TO SPECIFY "bCopy" RATHER THAN A HARDCODED VALUE SUCH AS 1 OR 0

}
    }
        }
            }
                if( !pcWoth || !bOk ) break ;
                etThread.delF( tinP , pcf ) ;
                }
                    pcWoth = (countT*)pcf[ ccf - 1 ] ;
                    pcLath = pcWoth + 1 ;

                    dumpF( tinP , etThread , stPhrasesP , (byteT*)pcf , ccf * sizeof( countT ) , (countT)pcLath ) ;

                    stPhrasesP << psttOldC( tinP , etThread , T("[")+TF1((countT)pcLath)+T(",")+TF1((countT)pcWoth)+T("] (")+TF1(ccf)+T(" elements) stack frame ")+TF1(++idFrame)+T(":\r\n") ) ;
                {
                if( bOk )                        
                ((thirdC&)etThread).dosReadProcessMemoryIF( tinP , (byteT*)pcf , ccf * sizeof( countT ) , bOk , (voidT*)pcLath , osPidP ) ;
                ZE( boolT , bOk ) ;
                etThread.newF( tinP , LF , pcf , ccf ) ; ___( pcf ) ;
                ZE( countT* , pcf ) ;
            {
            countT ccf = pcWoth - pcLath + 1 ;
        {
        while( !etThread && !ether )
        ZE( countT , idFrame ) ;
    {
    if( pcWoth >= pcLath )

    ((thirdC&)etThread).dosReadThreadContextF( tinP , pcLath , pcWoth , sw_hThread_osTidP ) ;
    ZE( countT* , pcWoth ) ;
    ZE( countT* , pcLath ) ;

    etherC& ether = etherC::etPrimeIF( tinP ) ;
{
voidT logStackFramesF( tinS& tinP , etherC& etThread , stackC& stPhrasesP , switchC& sw_hThread_osTidP , const countT osPidP )

}
    }
        stPhrasesP << psttOldC( tinP , etThread , TF3(ida,flFORMAT_UNSIGNED,3)+tDesc+T("\r\n") ) ;

        if(   pVmRegionAllocP[ ida ].psttUserName                             ) tDesc += tNameA+T(pVmRegionAllocP[ida].psttUserName)+tNameB ;
        if(   pVmRegionAllocP[ ida ].idUser                                   ) tDesc += tIdUser+TF1(pVmRegionAllocP[ida].idUser)+tb1 ;

        if( F(pVmRegionAllocP[ ida ].flUsageType) & flVMuSAGEtYPE_CODEbASE    ) tDesc += t_flVMuSAGEtYPE_CODEbASE    ;
        if( F(pVmRegionAllocP[ ida ].flUsageType) & flVMuSAGEtYPE_CODEaDAM    ) tDesc += t_flVMuSAGEtYPE_CODEaDAM    ;
        if( F(pVmRegionAllocP[ ida ].flUsageType) & flVMuSAGEtYPE_CPUsTACK    ) tDesc += t_flVMuSAGEtYPE_CPUsTACK    ;
        if( F(pVmRegionAllocP[ ida ].flUsageType) & flVMuSAGEtYPE_POOLoLDsHARED  ) tDesc += t_flVMuSAGEtYPE_POOLoLDsHARED  ;
        if( F(pVmRegionAllocP[ ida ].flUsageType) & flVMuSAGEtYPE_DEFAULThEAP ) tDesc += t_flVMuSAGEtYPE_DEFAULThEAP ;

        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_MODEnOcACHE          ) tDesc += t_flVM_MODEnOcACHE          ;
        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_MODEgUARD            ) tDesc += t_flVM_MODEgUARD            ;
        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_ACCESScOPYoNwRITE    ) tDesc += t_flVM_ACCESScOPYoNwRITE    ;
        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_ACCESSwRITE          ) tDesc += t_flVM_ACCESSwRITE          ;
        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_ACCESSrEAD           ) tDesc += t_flVM_ACCESSrEAD           ;
        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_ACCESSdO             ) tDesc += t_flVM_ACCESSdO             ;
        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_COMMITmAPPED         ) tDesc += t_flVM_COMMITmAPPED         ;
        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_COMMITpRIVATE        ) tDesc += t_flVM_COMMITpRIVATE        ;
        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_COMMITlOADiMAGE      ) tDesc += t_flVM_COMMITlOADiMAGE      ;
        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_ALLOCcOMMITTED       ) tDesc += t_flVM_ALLOCcOMMITTED       ;
        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_ALLOCrESERVED        ) tDesc += t_flVM_ALLOCrESERVED        ;
        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_ALLOCfREE            ) tDesc += t_flVM_ALLOCfREE            ;
        if( F(pVmRegionAllocP[ ida ].flags      ) & flVM_NOiNFOaVAILABLE      ) tDesc += t_flVM_NOiNFOaVAILABLE      ;

        TN( tDesc , "" ) ;
    {
    for( countT ida = 1 ; ida <= cAllocs ; ida ++ )
    countT cAllocs = pbIdAllocP[ cRegions ] ;

    }
        stPhrasesP << psttOldC( tinP , etThread , TF3(idr,flFORMAT_UNSIGNED,3)+tDesc+T("\r\n") ) ;

        if(   pVmRegionP[      idr ].psttUserName                             ) tDesc += tNameA+T(pVmRegionP[idr].psttUserName)+tNameB ;
        if(   pVmRegionP[      idr ].idUser                                   ) tDesc += tIdUser+TF1(pVmRegionP[idr].idUser)+tb1 ;

        if( F(pVmRegionP[      idr ].flUsageType) & flVMuSAGEtYPE_CODEbASE    ) tDesc += t_flVMuSAGEtYPE_CODEbASE    ;
        if( F(pVmRegionP[      idr ].flUsageType) & flVMuSAGEtYPE_CODEaDAM    ) tDesc += t_flVMuSAGEtYPE_CODEaDAM    ;
        if( F(pVmRegionP[      idr ].flUsageType) & flVMuSAGEtYPE_CPUsTACK    ) tDesc += t_flVMuSAGEtYPE_CPUsTACK    ;
        if( F(pVmRegionP[      idr ].flUsageType) & flVMuSAGEtYPE_POOLoLDsHARED  ) tDesc += t_flVMuSAGEtYPE_POOLoLDsHARED  ;
        if( F(pVmRegionP[      idr ].flUsageType) & flVMuSAGEtYPE_DEFAULThEAP ) tDesc += t_flVMuSAGEtYPE_DEFAULThEAP ;

        if( F(pVmRegionP[      idr ].flags      ) & flVM_MODEnOcACHE          ) tDesc += t_flVM_MODEnOcACHE          ;
        if( F(pVmRegionP[      idr ].flags      ) & flVM_MODEgUARD            ) tDesc += t_flVM_MODEgUARD            ;
        if( F(pVmRegionP[      idr ].flags      ) & flVM_ACCESScOPYoNwRITE    ) tDesc += t_flVM_ACCESScOPYoNwRITE    ;
        if( F(pVmRegionP[      idr ].flags      ) & flVM_ACCESSwRITE          ) tDesc += t_flVM_ACCESSwRITE          ;
        if( F(pVmRegionP[      idr ].flags      ) & flVM_ACCESSrEAD           ) tDesc += t_flVM_ACCESSrEAD           ;
        if( F(pVmRegionP[      idr ].flags      ) & flVM_ACCESSdO             ) tDesc += t_flVM_ACCESSdO             ;
        if( F(pVmRegionP[      idr ].flags      ) & flVM_COMMITmAPPED         ) tDesc += t_flVM_COMMITmAPPED         ;
        if( F(pVmRegionP[      idr ].flags      ) & flVM_COMMITpRIVATE        ) tDesc += t_flVM_COMMITpRIVATE        ;
        if( F(pVmRegionP[      idr ].flags      ) & flVM_COMMITlOADiMAGE      ) tDesc += t_flVM_COMMITlOADiMAGE      ;
        if( F(pVmRegionP[      idr ].flags      ) & flVM_ALLOCcOMMITTED       ) tDesc += t_flVM_ALLOCcOMMITTED       ;
        if( F(pVmRegionP[      idr ].flags      ) & flVM_ALLOCrESERVED        ) tDesc += t_flVM_ALLOCrESERVED        ;
        if( F(pVmRegionP[      idr ].flags      ) & flVM_ALLOCfREE            ) tDesc += t_flVM_ALLOCfREE            ;
        if( F(pVmRegionP[      idr ].flags      ) & flVM_NOiNFOaVAILABLE      ) tDesc += t_flVM_NOiNFOaVAILABLE      ;

        TN( tDesc , "" ) ;
    {
    for( countT idr = 1 ; idr <= cRegions ; idr ++ )

    TN( tNameB  , "\" " ) ;
    TN( tNameA  , "name=\"" ) ;
    TN( tb1     , " " ) ;
    TN( tIdUser , "idUser=" ) ;

    TN( t_flVMuSAGEtYPE_CODEbASE    , "usageCodeBase " ) ;
    TN( t_flVMuSAGEtYPE_CODEaDAM    , "usageCodeAdam " ) ;
    TN( t_flVMuSAGEtYPE_CPUsTACK    , "usageStack " ) ;
    TN( t_flVMuSAGEtYPE_POOLoLDsHARED  , "usagePool " ) ;
    TN( t_flVMuSAGEtYPE_DEFAULThEAP , "usageHeap " ) ;

    TN( t_flVM_MODEnOcACHE       , "modeNoCache " ) ;
    TN( t_flVM_MODEgUARD         , "modeGuard " ) ;
    TN( t_flVM_ACCESScOPYoNwRITE , "accessCopyOnWrite " ) ;
    TN( t_flVM_ACCESSwRITE       , "accessWrite " ) ;
    TN( t_flVM_ACCESSrEAD        , "accessRead " ) ;
    TN( t_flVM_ACCESSdO          , "accessDo " ) ;
    TN( t_flVM_COMMITmAPPED      , "commitMapped " ) ;
    TN( t_flVM_COMMITpRIVATE     , "commitPrivate " ) ;
    TN( t_flVM_COMMITlOADiMAGE   , "commitLoadImage " ) ;
    TN( t_flVM_ALLOCcOMMITTED    , "allocCommitted " ) ;
    TN( t_flVM_ALLOCrESERVED     , "allocReserved " ) ;
    TN( t_flVM_ALLOCfREE         , "allocFree " ) ;
    TN( t_flVM_NOiNFOaVAILABLE   , "noInfoAvail " ) ;

    }
        if( etPrime ) stPhrasesP << psttOldC( tinP , etThread , T("report aborted\r\n") ) ;
        etThread.delF( tinP , psttl ) ;
        if( !etPrime && psttl ) stPhrasesP << psttOldC( tinP , etThread , TF3(offlMin,flFORMAT_UNSIGNED,8)+T(" ")+(offlMax-offlMin?TF3((offlMax-offlMin)/CBlINE2+1,flFORMAT_UNSIGNED,8):TP("",8))+TP("",4)+T(psttl)+T("\r\n") ) ;
        }
            }
                    etThread.strFuseF( tinP , psttl , (offl+off?TF3(pbIdAllocP[offl+off],flFORMAT_UNSIGNED,3):T("   ")) ) ;
                for( countT off = 0 ; off < CBlINE2 && offl + off <= cRegions ; off ++ )
                etThread.strMakeF( tinP , psttl , T("") , 0x100 ) ; //U: EXACT ALLOC

                offlMax = offlMin = offl ;

                }
                    etThread.delF( tinP , psttl ) ;
                    stPhrasesP << psttOldC( tinP , etThread , TF3(offlMin,flFORMAT_UNSIGNED,8)+T(" ")+(offlMax-offlMin?TF3((offlMax-offlMin)/CBlINE2+1,flFORMAT_UNSIGNED,8):TP("",8))+TP("",4)+T(psttl)+T("\r\n") ) ;
                {
                if( offl )
            {
            else
            if( bDup ) offlMax = offl ;
            boolT bDup = offl && offl + CBlINE2 <= cRegions && !((thirdC&)etThread).c_memcmpIF( tinP , pbIdAllocP + offl , pbIdAllocP + offl - CBlINE2 , CBlINE2 ) ;
            //if( !( offl % ( 0x10 * CBlINE2 ) ) ) etThread.strokeF( tinP , T("\r                  \r")+TF1(offl)+T(" ")+TF1(cRegions) ) ;
        {
        for( countT offl = 0 ; offl <= cRegions && !etPrime ; offl += CBlINE2 )
        ZE( countT , offlMax ) ;
        ZE( countT , offlMin ) ;
        ZE( strokeS* , psttl ) ;

        stPhrasesP << psttOldC( tinP , etThread , T("idAlloc by idRegion (")+TF1(cRegions)+T(" regions):\r\n") ) ;
        cRegions = pbIdRegionP[ cPages - 1 ] ;
    {   // idAlloc VALUE FOR EACH REGION
    ZE( countT , cRegions ) ;

    }
        if( etPrime ) stPhrasesP << psttOldC( tinP , etThread , T("report aborted\r\n") ) ;
        etThread.delF( tinP , psttl ) ;
        if( !etPrime && psttl ) stPhrasesP << psttOldC( tinP , etThread , TF3(offlMin,flFORMAT_UNSIGNED,8)+T(" ")+(offlMax-offlMin?TF3((offlMax-offlMin)/CBlINE2+1,flFORMAT_UNSIGNED,8):TP("",8))+TP("",4)+T(psttl)+T("\r\n") ) ;
        }
            }
                    etThread.strFuseF( tinP , psttl , TF3(pbIdRegionP[offl+off],flFORMAT_UNSIGNED,3) ) ;
                for( countT off = 0 ; off < CBlINE2 && offl + off < cPages ; off ++ )
                etThread.strMakeF( tinP , psttl , T("") , 0x100 ) ; //U: EXACT ALLOC

                offlMax = offlMin = offl ;

                }
                    etThread.delF( tinP , psttl ) ;
                    stPhrasesP << psttOldC( tinP , etThread , TF3(offlMin,flFORMAT_UNSIGNED,8)+T(" ")+(offlMax-offlMin?TF3((offlMax-offlMin)/CBlINE2+1,flFORMAT_UNSIGNED,8):TP("",8))+TP("",4)+T(psttl)+T("\r\n") ) ;
                {
                if( offl )
            {
            else
            if( bDup ) offlMax = offl ;
            boolT bDup = offl && offl + CBlINE2 <= cPages && !((thirdC&)etThread).c_memcmpIF( tinP , pbIdRegionP + offl , pbIdRegionP + offl - CBlINE2 , CBlINE2 ) ;
            //if( !( offl % ( 0x100 * CBlINE2 ) ) ) etThread.strokeF( tinP , T("\r                  \r")+TF1(offl)+T(" ")+TF1(cPages) ) ;
        {
        for( countT offl = 0 ; offl < cPages && !etPrime ; offl += CBlINE2 )
        ZE( countT , offlMax ) ;
        ZE( countT , offlMin ) ;
        ZE( strokeS* , psttl ) ;

        stPhrasesP << psttOldC( tinP , etThread , T("idRegion by offPage (")+TF1(cPages)+T(" pages):\r\n") ) ;
        cPages = cBitsGrainP ? 1 << sizeof( countT ) * SB - cBitsGrainP : 0 ;
    {   // idRegion VALUE FOR EACH PAGE
    ZE( countT , cPages ) ;

    etherC& etPrime = etherC::etPrimeIF( tinP ) ;
{
voidT logRegionArraysF( tinS& tinP , etherC& etThread , stackC& stPhrasesP , const countT cBitsGrainP , const byteT* const pbIdRegionP , const byteT* const pbIdAllocP , const vmRegionS* const pVmRegionP , const vmRegionS* const pVmRegionAllocP )

}
    etThread.delF( tinP , (byteT*&)pInfoSection ) ;
    }
        }
            stPhrasesP << psttOldC( tinP , etThread , TF3(c_pbiSection+cbSection,flFORMAT_UNSIGNED,8)+T(" ")+TF3(cbSection,flFORMAT_UNSIGNED,8)+T("<end>\r\n") ) ;

            }
                etThread.delF( tinP , pbi ) ;
                }
                    //dumpF( tinP , etThread , stPhrasesP , pbi , cbSection , c_pbiSection ) ;
                    bOk = 0 ; ((thirdC&)etThread).dosReadProcessMemoryIF( tinP , pbi , cbSection , bOk , (voidT*)( c_pbiSection ) , infoP.osPid ) ; __Z( bOk ) ;
                    pbi[ cbSection ] = 0 ;
                {
                if( !etThread )
                etThread.newF( tinP , LF , pbi , cbSection + 1 ) ; ___( pInfoSection ) ;
                ZE( byteT* , pbi ) ;
            {
            if( bDump )

            else if( !((thirdC&)etThread).c_strcmpIF( tinP , pbSectionName , ".bss"   ) ) bDump = 1 ;
            else if( !((thirdC&)etThread).c_strcmpIF( tinP , pbSectionName , "DGROUP" ) ) bDump = 1 ;
                 if( !((thirdC&)etThread).c_strcmpIF( tinP , pbSectionName , ".desc"  ) ) bDump = 1 ;
            ZE( boolT , bDump ) ;

            const countT    cbSection =              pInfoSection[ off ].SizeOfRawData ;
            const countT c_pbiSection = c_pblImage + pInfoSection[ off ].VirtualAddress ;

            stPhrasesP << psttOldC( tinP , etThread , TF3(c_pblImage+(countT)pInfoSection[ off ].VirtualAddress,flFORMAT_UNSIGNED,8)+T(" ")+TF3((countT)pInfoSection[ off ].VirtualAddress,flFORMAT_UNSIGNED,8)+T(" section \"")+T(pbSectionName)+T("\"\r\n") ) ;
            const byteT* const pbSectionName = (const byteT*)pInfoSection[ off ].Name ;
        {
        for( countT off = 0 ; off < infoPe.NumberOfSections ; off ++ )
        bOk = 0 ; ((thirdC&)etThread).dosReadProcessMemoryIF( tinP , (byteT*)pInfoSection , cbInfoSections , bOk , (voidT*)( c_pblImage + infoDos.e_lfanew + sizeof( countT ) + sizeof infoPe + sizeof infoPeOptional ) , infoP.osPid ) ; __Z( bOk ) ;
    {
    if( !etThread )
    etThread.newF( tinP , LF , (byteT*&)pInfoSection , cbInfoSections ) ; ___( pInfoSection ) ;
    countT cbInfoSections = sizeof( IMAGE_SECTION_HEADER ) * infoPe.NumberOfSections ;
    ZE( IMAGE_SECTION_HEADER* , pInfoSection ) ;

    IMAGE_OPTIONAL_HEADER infoPeOptional ; bOk = 0             ; ((thirdC&)etThread).dosReadProcessMemoryIF( tinP , (byteT*)&infoPeOptional , sizeof infoPeOptional , bOk , (voidT*)( c_pblImage + infoDos.e_lfanew + sizeof( countT ) + sizeof infoPe                         ) , infoP.osPid ) ;    __Z( bOk ) ;
    IMAGE_FILE_HEADER infoPe             ; bOk = 0             ; ((thirdC&)etThread).dosReadProcessMemoryIF( tinP , (byteT*)&infoPe         , sizeof infoPe         , bOk , (voidT*)( c_pblImage + infoDos.e_lfanew + sizeof( countT )                                         ) , infoP.osPid ) ;    __Z( bOk ) ;
    ZE( countT , fingerprintPe )       ; bOk = 0             ; ((thirdC&)etThread).dosReadProcessMemoryIF( tinP , (byteT*)&fingerprintPe  , sizeof fingerprintPe  , bOk , (voidT*)( c_pblImage + infoDos.e_lfanew                                                            ) , infoP.osPid ) ;    __Z( bOk ) ;    __( fingerprintPe - 0x4550 ) ;
    IMAGE_DOS_HEADER infoDos             ;                       ((thirdC&)etThread).dosReadProcessMemoryIF( tinP , (byteT*)&infoDos        , sizeof infoDos        , bOk , (voidT*)( c_pblImage                                                                               ) , infoP.osPid ) ;    __Z( bOk ) ;    __( *(USHORT*)&infoDos - 0x5a4d ) ;
    ZE( boolT , bOk ) ;
    stPhrasesP << psttOldC( tinP , etThread , TF3(c_pblImage,flFORMAT_UNSIGNED,8)+T(" image\r\n") ) ;

    }
        }
            break ;
            __1
            __( infoP.idEvent ) ;
        {
        default :
        case ifcIDeVENTmONITORED_LOADdLL       : { c_pblImage = (countT)infoP.osLoadDll_pbImage       ; break ; }
        case ifcIDeVENTmONITORED_CREATEpROCESS : { c_pblImage = (countT)infoP.osCreateProcess_pbImage ; break ; }
    {
    switch( infoP.idEvent )
    ZE( countT , c_pblImage ) ;
{
voidT logExeDllImageF( tinS& tinP , etherC& etThread , stackC& stPhrasesP , ifcMonitorEventS& infoP )

}
    if( etPrime ) stPhrasesP << psttOldC( tinP , etThread , T("dump aborted\r\n") ) ;
    etThread.delF( tinP , psttl ) ;
    if( !etPrime && psttl ) stPhrasesP << psttOldC( tinP , etThread , TF3(c_pblP+offlMin,flFORMAT_UNSIGNED,8)+T(" ")+TF3(offlMin,flFORMAT_UNSIGNED,8)+T(" ")+(offlMax-offlMin?TF3((offlMax-offlMin)/CBlINE+1,flFORMAT_UNSIGNED,8):TP("",8))+TP("",4)+T(psttl) ) ;
    }
        }
            etThread.strFuseF( tinP , psttl , TP("",ccMissing*9-cbTrailing*2)+T("    |")+T(ostox)+T("|\r\n") ) ;

            }
                }
                    off ++ ;
                    etThread.strFuseF( tinP , psttl , (*(pbP+offl+off)?TF3(*(pbP+offl+off),flFORMAT_UNSIGNED,2):TP(".",2)) ) ;
                    cbTrailing ++ ;
                {
                while( offl + off < cbP )
                ccMissing  = CClINE - off / sizeof( countT ) ;
            {
            if( off < CBlINE )
            ZE( countT , cbTrailing ) ;
            ZE( countT , ccMissing ) ;

                etThread.strFuseF( tinP , psttl , (*(countT*)(pbP+offl+off)?TF3(*(countT*)(pbP+offl+off),flFORMAT_UNSIGNED,8):TP(".",8))+T(" ") ) ;
            for( countT off = 0 ; off < CBlINE && offl + off + sizeof( countT ) <= cbP ; off += sizeof( countT ) )
            etThread.strMakeF( tinP , psttl , T("") , 0x100 ) ; //U: EXACT ALLOC

            }
                OStEXTAS( ostox , osti > 0x19 && osti < 0x80 ? osti : ' ' )
                osTextT osti = pbP[ offl + off ] ;
            {
            for( countT off = 0 ; off < CBlINE && offl + off < cbP ; off ++ )
            OStEXT( ostox , CBlINE + 1 )

            offlMax = offlMin = offl ;

            }
                etThread.delF( tinP , psttl ) ;
                stPhrasesP << psttOldC( tinP , etThread , TF3(c_pblP+offlMin,flFORMAT_UNSIGNED,8)+T(" ")+TF3(offlMin,flFORMAT_UNSIGNED,8)+T(" ")+(offlMax-offlMin?TF3((offlMax-offlMin)/CBlINE+1,flFORMAT_UNSIGNED,8):TP("",8))+TP("",4)+T(psttl) ) ;
            {
            if( offl )
        {
        else
        if( bDup ) offlMax = offl ;
        boolT bDup = offl && offl + CBlINE <= cbP && !((thirdC&)etThread).c_memcmpIF( tinP , pbP + offl , pbP + offl - CBlINE , CBlINE ) ;
        //if( !( offl % ( CBlINE * 0x10 ) ) ) etThread.strokeF( tinP , T("\r                  \r")+TF1(offl)+T(" ")+TF1(cbP) ) ;
    {
    for( countT offl = 0 ; offl < cbP && !etPrime ; offl += CBlINE )
    ZE( countT , offlMax ) ;
    ZE( countT , offlMin ) ;
    ZE( strokeS* , psttl ) ;

    etherC& etPrime = etherC::etPrimeIF( tinP ) ;
{
voidT dumpF( tinS& tinP , etherC& etThread , stackC& stPhrasesP , const byteT* const pbP , countT cbP , const countT c_pblP )

}
    }
        while( !etThread && !st_psttVmUsageTypeP.third && ~hDown ) ;
        }
            }
                etThread.delF( tinP , psttw4 ) ;
                etThread.delF( tinP , psttw3 ) ;
                }
                    }
                        }
                            break ;
                            __1
                            __( flVmUsageType ) ;
                        {
                        default :
                        }
                            break ;

                            etThread.delF( tinP , psttw6 ) ;
                            vmInfoP.pVmRegionAlloc[ idAlloc  ].psttUserName = psttOldC( tinP , etThread ,psttw6 ) ;
                            vmInfoP.pVmRegion[      idRegion ].psttUserName = psttOldC( tinP , etThread ,psttw6 ) ;
                            /*sttq = ze ;*/ etThread.strWordF( tinP , psttw6 , psttl , sttq , sttd , 6 ) ; ___( psttw6 ) ;
                            ZE( strokeS* , psttw6 ) ;

                            etThread.delF( tinP , psttw5 ) ;
                            vmInfoP.pVmRegionAlloc[ idAlloc ].idUser = vmInfoP.pVmRegion[ idRegion ].idUser = etThread.strDigitsToSCountF( tinP , psttw5 ) ;
                            /*sttq = ze ;*/ etThread.strWordF( tinP , psttw5 , psttl , sttq , sttd , 5 ) ; ___( psttw5 ) ;
                            ZE( strokeS* , psttw5 ) ;
                        {
                        case flVMuSAGEtYPE_CPUsTACK    :
                        }
                            break ;

                            etThread.delF( tinP , psttw5 ) ;
                            vmInfoP.pVmRegionAlloc[ idAlloc  ].psttUserName = psttOldC( tinP , etThread ,psttw5 ) ;
                            vmInfoP.pVmRegion[      idRegion ].psttUserName = psttOldC( tinP , etThread ,psttw5 ) ;
                            /*sttq = ze ;*/ etThread.strWordF( tinP , psttw5 , psttl , sttq , sttd , 5 ) ; ___( psttw5 ) ;
                            ZE( strokeS* , psttw5 ) ;

                            vmInfoP.pVmRegionAlloc[ idAlloc ].idUser = vmInfoP.pVmRegion[ idRegion ].idUser = ++ idPoolLast ;
                        {
                        case flVMuSAGEtYPE_POOLoLDsHARED  :
                        case flVMuSAGEtYPE_CODEbASE    : { break ; }
                        case flVMuSAGEtYPE_CODEaDAM    :
                        case flVMuSAGEtYPE_DEFAULThEAP :
                    {
                    switch( flVmUsageType )

                    vmInfoP.pVmRegionAlloc[ idAlloc  ].flUsageType |= flVmUsageType ;
                    vmInfoP.pVmRegion[      idRegion ].flUsageType |= flVmUsageType ;
                    flagsT flVmUsageType = (flagsT)etThread.strDigitsToSCountF( tinP , psttw4 ) ;

                    countT idAlloc  = vmInfoP.pbIdAlloc[ idRegion ] ;
                    countT idRegion = vmInfoP.pbIdRegion[ offPage ] ;
                    countT offPage  = c_pbl >> vmInfoP.cBitsGrain ;
                    countT c_pbl    = etThread.strDigitsToSCountF( tinP , psttw3 ) ;
                {
                else
                else if( !psttw4 ) __1
                     if( !psttw3 ) __1
                /*sttq = ze ;*/ etThread.strWordF( tinP , psttw4 , psttl , sttq , sttd , 4 ) ; ___( psttw4 ) ;
                           etThread.strWordF( tinP , psttw3 , psttl , sttq , sttd , 3 ) ; ___( psttw3 ) ;
                ZE( strokeS* , psttw4 ) ;
                ZE( strokeS* , psttw3 ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            {
            if( psttl )
            strokeS* psttl = (strokeS*)st_psttVmUsageTypeP.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        strokeS sttd('/') ;
        ZE( countT , idPoolLast ) ;
    {
    if( st_psttVmUsageTypeP )

    countT cAllocs     = vmInfoP.pbIdAlloc[ cRegions ] ;
    countT cRegions    = vmInfoP.pbIdRegion[ offLastPage ] ;
    countT offLastPage = - 1 >> vmInfoP.cBitsGrain ;

    }
        if( etThread ) return ;
    {
    IFbEcAREFUL
{
voidT annotateRegionInfoF( tinS& tinP , etherC& etThread , vmInfoS& vmInfoP , stackC& st_psttVmUsageTypeP )

}
    swIdWhereP.ungrabF( tinP ) ;
    swTellP.ungrabF( tinP ) ;
    swWorkingP.ungrabF( tinP ) ;
    swSupervisingP.ungrabF( tinP ) ;
    swChainOfCommandP.ungrabF( tinP ) ;
    swNestP.ungrabF( tinP ) ;

    }
        etThread.delF( tinP, pc2o ) ;
        }
            etThread.strFuseF( tinP , psttP , TF3(pc2o->c2,flFORMAT_UNSIGNED,9)+TF1(pc2o->c1)+T("\r\n") ) ;
        {
        if( pc2o )
        stSortedNest >> pc2o ;
        ZE( count2S* , pc2o ) ;
    {
    while( stSortedNest )
    etThread.strFuseF( tinP , psttP , T(" \r\n \r\nthese nesting levels were observed:\r\n \r\ntally___ cNest\r\n \r\n") ) ;
    
    }
        etThread.delF( tinP, pc2o ) ;
        }
            etThread.strFuseF( tinP , psttP , TF3(pc2o->c2,flFORMAT_UNSIGNED,9)+T((countT*)pc2o->c1)+T("\r\n") ) ;
        {
        if( pc2o )
        stSortedChainOfCommand >> pc2o ;
        ZE( count2S* , pc2o ) ;
    {
    while( stSortedChainOfCommand )
    etThread.strFuseF( tinP , psttP , T(" \r\n \r\nthese chains of command were observed:\r\n \r\ntally___ worker/supervisor/.../supervisor\r\n \r\n") ) ;
    
    }
        etThread.delF( tinP, pc2o ) ;
        }
            etThread.strFuseF( tinP , psttP , TF3(pc2o->c2,flFORMAT_UNSIGNED,9)+TF3(pc2o->c1,flFORMAT_UNSIGNED,9)+T( "\"")+T(postFile)+T("\"\r\n") ) ;
            osTextT* postFile = processGlobal7I.source.postFileTitleF( tinP , processGlobal7I.source.idFileRankF( tinP , pc2o->c1 ) ) ;
        {
        if( pc2o )
        stSortedSupervising >> pc2o ;
        ZE( count2S* , pc2o ) ;
    {
    while( stSortedSupervising )
    etThread.strFuseF( tinP , psttP , T(" \r\n \r\nthese definitions were observed supervising:\r\n \r\ntally___ idiFile fileTitle\r\n \r\n") ) ;
    
    }
        etThread.delF( tinP, pc2o ) ;
        }
            etThread.strFuseF( tinP , psttP , TF3(pc2o->c2,flFORMAT_UNSIGNED,9)+TF3(pc2o->c1,flFORMAT_UNSIGNED,8)+T( "\"")+T(postFile)+T("\"\r\n") ) ;
            osTextT* postFile = processGlobal7I.source.postFileTitleF( tinP , processGlobal7I.source.idFileRankF( tinP , pc2o->c1 ) ) ;
        {
        if( pc2o )
        stSortedWorking >> pc2o ;
        ZE( count2S* , pc2o ) ;
    {
    while( stSortedWorking )
    etThread.strFuseF( tinP , psttP , T(" \r\n \r\nthese definitions were observed working:\r\n \r\ntally___ idiFile fileTitle\r\n \r\n") ) ;
    
    }
        etThread.delF( tinP, pc2o ) ;
        if( pc2o ) etThread.strFuseF( tinP , psttP , TF3(pc2o->c2,flFORMAT_UNSIGNED,9)+T((strokeS*)pc2o->c1)+T("\r\n") ) ;
        stSortedTell >> pc2o ;
        ZE( count2S* , pc2o ) ;
    {
    while( stSortedTell )
    etThread.strFuseF( tinP , psttP , T(" \r\n \r\nthese activity declarations were observed:\r\n \r\ntally___ activity\r\n \r\n") ) ;
    
    }
        }
            etThread.delF( tinP, pc2o ) ;
            }
                etThread.strFuseF( tinP , psttP , TF3(pc2o->c2,flFORMAT_UNSIGNED,9)+TF3(pc2o->c1,flFORMAT_UNSIGNED,9)+TP(ppostWhere[idWhere2],0x18)+T("\r\n") ) ;
                countT idWhere2 = pc2o->c1 - ifcIDwHERE_IFC + 1 < sizeof ppostWhere / sizeof ppostWhere[ 0 ] ? pc2o->c1 - ifcIDwHERE_IFC + 1 : 0 ;
            {
            if( pc2o )
            stSortedIdWhere >> pc2o ;
            ZE( count2S* , pc2o ) ;
        {
        while( stSortedIdWhere )
        etThread.strFuseF( tinP , psttP , T("these code classes were observed working:\r\n \r\ntally___ idWhere_ title\r\n \r\n") ) ;
                    
        } ;
            "OSwAITgRAB" ,
            "OSoTHER" ,
            "OSmONITOR" ,
            "OSwAITiNTERNETaCCEPT" ,
            "OSwAITiNTERNETwRITE" ,
            "OSwAITiNTERNETrEAD" ,
            "OSwAITfILEwRITE" ,
            "OSwAITfILErEAD" ,
            "OSwAITwINDOW" ,
            "OSwAITmONITORING" ,
            "OSwAITsIGN" ,
            "OSwAITbATON" ,
            "OSwAITnAP" ,
            "IFC" ,
            "<invalid value>" ,
        {
        static osTextT* ppostWhere[] = // 0010*.ifcIDwHERE AND func.12f0007.tinS.strFuseF AND adam.c740104 MUST BE KEPT IN SYNC
    {
    
    }
        }
            }
                stSortedNest.sinkF( tinP , countTC() , pc2o ) ;
                *pc2o = c2o ;
                count2S c2o( cLeverP , swNestP ) ;
            {
            if( pc2o )
            etThread.newF( tinP , LF , pc2o ) ; ___( pc2o ) ;
            ZE( count2S* , pc2o ) ;
            cLeverP = swNestP.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        cFlavors = swNestP.cFlavorsF( tinP ) ;

        }
            }
                stSortedChainOfCommand.sinkF( tinP , countTC() , pc2o ) ;
                *pc2o = c2o ;
                count2S c2o( (countT)pczLeverP , swChainOfCommandP ) ;
            {
            if( pc2o )
            etThread.newF( tinP , LF , pc2o ) ; ___( pc2o ) ;
            ZE( count2S* , pc2o ) ;
            pczLeverP = (countT*)swChainOfCommandP.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        cFlavors = swChainOfCommandP.cFlavorsF( tinP ) ;
        
        }
            }
                stSortedSupervising.sinkF( tinP , countTC() , pc2o ) ;
                *pc2o = c2o ;
                count2S c2o( cLeverP , swSupervisingP ) ;
            {
            if( pc2o )
            etThread.newF( tinP , LF , pc2o ) ; ___( pc2o ) ;
            ZE( count2S* , pc2o ) ;
            cLeverP = swSupervisingP.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        cFlavors = swSupervisingP.cFlavorsF( tinP ) ;
        
        }
            }
                stSortedWorking.sinkF( tinP , countTC() , pc2o ) ;
                *pc2o = c2o ;
                count2S c2o( cLeverP , swWorkingP ) ;
            {
            if( pc2o )
            etThread.newF( tinP , LF , pc2o ) ; ___( pc2o ) ;
            ZE( count2S* , pc2o ) ;
            cLeverP = swWorkingP.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        cFlavors = swWorkingP.cFlavorsF( tinP ) ;
        
        }
            }
                stSortedTell.sinkF( tinP , countTC() , pc2o ) ;
                *pc2o = c2o ;
                count2S c2o( (countT)psttLeverP , swTellP ) ;
            {
            if( pc2o )
            etThread.newF( tinP , LF , pc2o ) ; ___( pc2o ) ;
            ZE( count2S* , pc2o ) ;
            psttLeverP = (strokeS*)swTellP.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        cFlavors = swTellP.cFlavorsF( tinP ) ;
        
        }
            }
                stSortedIdWhere.sinkF( tinP , countTC() , pc2o ) ;
                *pc2o = c2o ;
                count2S c2o( cLeverP , swIdWhereP ) ;
            {
            if( pc2o )
            etThread.newF( tinP , LF , pc2o ) ; ___( pc2o ) ;
            ZE( count2S* , pc2o ) ;
            cLeverP = swIdWhereP.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swIdWhereP.cFlavorsF( tinP ) ;
    {
    stackC stSortedNest(           tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count2S ) ;
    stackC stSortedChainOfCommand( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count2S ) ;
    stackC stSortedSupervising(    tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count2S ) ;
    stackC stSortedWorking(        tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count2S ) ;
    stackC stSortedTell(           tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count2S ) ;
    stackC stSortedIdWhere(        tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count2S ) ;

    swNestP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    swChainOfCommandP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    swSupervisingP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    swWorkingP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    swTellP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    swIdWhereP.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT reportWhereF( tinS& tinP , etherC& etThread , strokeS*& psttP , switchC& swIdWhereP , switchC& swTellP , switchC& swWorkingP , switchC& swSupervisingP , switchC& swChainOfCommandP , switchC& swNestP , countT& cLeverP , strokeS*& psttLeverP , countT*& pczLeverP )

}
    }
        ether.delF( tinP , (byteT*&)pVmRegionAlloc ) ;
        ether.delF( tinP , (byteT*&)pVmRegion ) ;
        ether.delF( tinP , pbIdAlloc ) ;
        ether.delF( tinP , pbIdRegion ) ;

        }
                if( pVmRegionAlloc[ ida ].psttUserName ) ether.delF( tinP , pVmRegionAlloc[ ida ].psttUserName ) ;
            for( countT ida = 1 ; ida <= cAllocs ; ida ++ )

                if( pVmRegion[ idr ].psttUserName ) ether.delF( tinP , pVmRegion[ idr ].psttUserName ) ;
            for( countT idr = 1 ; idr <= cRegions ; idr ++ )
        {
        if( pVmRegion && pVmRegionAlloc )

        countT cAllocs     = pbIdAlloc[ cRegions ] ;
        countT cRegions    = pbIdRegion[ offLastPage ] ;
        countT offLastPage = - 1 >> cBitsGrain ;
    {
    if( pbIdRegion && pbIdAlloc )

    TINSL
{
vmInfoS::~vmInfoS( voidT )

}
    if( tinP.fingerprint ) ;
{
pVmRegionAlloc( 0 )
pVmRegion( 0 ) ,
pbIdAlloc( 0 ) ,
pbIdRegion( 0 ) ,
cBitsGrain( 0 ) ,
ether( etherP ) ,
vmInfoS::vmInfoS( tinS& tinP , etherC& etherP ) :

}
    swThreadWhereInfo.ungrabF( tinP ) ;
    }
        if( pTinP ) break ;

        }
            pwt->swIdWhere.ungrabF( tinP ) ;
            pwt->swTell.ungrabF( tinP ) ;
            pwt->swWorking.ungrabF( tinP ) ;
            pwt->swSupervising.ungrabF( tinP ) ;
            pwt->swChainOfCommand.ungrabF( tinP ) ;
            pwt->swNest.ungrabF( tinP ) ;

            pwt->swNest.freeAllF( tinP ) ;
            }
                swNest += pwt->swNest ;
                cLever = pwt->cLever = pwt->swNest.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            cFlavors = pwt->swNest.cFlavorsF( tinP ) ;

            pwt->swChainOfCommand.freeAllF( tinP ) ;
            }
                swChainOfCommand += pwt->swChainOfCommand ;
                pczLever = pwt->pczLever = (countT*)pwt->swChainOfCommand.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            cFlavors = pwt->swChainOfCommand.cFlavorsF( tinP ) ;

            pwt->swSupervising.freeAllF( tinP ) ;
            }
                swSupervising += pwt->swSupervising ;
                cLever = pwt->cLever = pwt->swSupervising.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            cFlavors = pwt->swSupervising.cFlavorsF( tinP ) ;

            pwt->swWorking.freeAllF( tinP ) ;
            }
                swWorking += pwt->swWorking ;
                cLever = pwt->cLever = pwt->swWorking.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            cFlavors = pwt->swWorking.cFlavorsF( tinP ) ;

            pwt->swTell.freeAllF( tinP ) ;
            }
                swTell += pwt->swTell ;
                psttLever = pwt->psttLever = (strokeS*)pwt->swTell.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            cFlavors = pwt->swTell.cFlavorsF( tinP ) ;

            pwt->swIdWhere.freeAllF( tinP ) ;
            }
                swIdWhere += pwt->swIdWhere ;
                cLever = pwt->cLever = pwt->swIdWhere.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = pwt->swIdWhere.cFlavorsF( tinP ) ;

            pwt->swNest.grabF( tinP , TAG( TAGiDnULL ) ) ;
            pwt->swChainOfCommand.grabF( tinP , TAG( TAGiDnULL ) ) ;
            pwt->swSupervising.grabF( tinP , TAG( TAGiDnULL ) ) ;
            pwt->swWorking.grabF( tinP , TAG( TAGiDnULL ) ) ;
            pwt->swTell.grabF( tinP , TAG( TAGiDnULL ) ) ;
            pwt->swIdWhere.grabF( tinP , TAG( TAGiDnULL ) ) ;

            }
                idAdam = pwt->idAdam ;
                idAdamRoot = pwt->idAdamRoot ;
                idProcessOld = pwt->idProcessOld ;
            {
            if( !idProcessOld )
        {
        if( pwt )
        threadWhereInfoS* pwt = (threadWhereInfoS*)(countT)swThreadWhereInfo ;
        lever_pTin = pTinP ? (countT)pTinP : swThreadWhereInfo.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swThreadWhereInfo.cFlavorsF( tinP ) ;
    swThreadWhereInfo.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT processWhereInfoS::flushThreadTalliesF( tinS& tinP , tinS* pTinP )

}
    ::reportWhereF( tinP , ether , psttP , swIdWhere , swTell , swWorking , swSupervising , swChainOfCommand , swNest , cLever , psttLever , pczLever ) ;
    
    ) , 0x10000 ) ; ___( psttP ) ;
        
        "owner     : ")+TF1(idAdam)+T("\r\n \r\n \r\n"
        "root owner: ")+TF1(idAdamRoot)+T("\r\n \r\n \r\n"
        "idProcessOld : ")+TF1(idProcessOld)+T("\r\n"
        "www.ideafarm.com  IdeaFarm " "(tm) City\r\n \r\n"
        "author: ")+TF1(DDNUMB)+T("\r\n"
        "time: ")+TT(timeN1,timeN2)+T("\r\n"
        "report title: process activity report\r\n"
        
    ether.strMakeF( tinP , psttP , T(

    ether.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT  , timeN1 ) ;
{
voidT processWhereInfoS::reportWhereF( tinS& tinP , strokeS*& psttP )

}
    ;

        swNest.cFlavorsF( tinP )
        swChainOfCommand.cFlavorsF( tinP )  ||
        swSupervising.cFlavorsF( tinP )     ||
        swWorking.cFlavorsF( tinP )         ||
        swTell.cFlavorsF( tinP )            ||
        swIdWhere.cFlavorsF( tinP )         ||

    return
{
boolT processWhereInfoS::bHaveTalliesF( tinS& tinP )

}
    swNest.freeAllF( tinP ) ;
    swChainOfCommand.freeAllF( tinP ) ;
    swSupervising.freeAllF( tinP ) ;
    swWorking.freeAllF( tinP ) ;
    swTell.freeAllF( tinP ) ;
    swIdWhere.freeAllF( tinP ) ;
{
voidT processWhereInfoS::purgeF( tinS& tinP )

}
{
idAdam( 0 )
idAdamRoot( 0 ) ,
idProcessOld( 0 ) ,
swNest(           tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , cLever    ) ,
swChainOfCommand( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , pczLever  ) ,
swSupervising(    tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , cLever    ) ,
swWorking(        tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , cLever    ) ,
swTell(           tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , psttLever ) ,
swIdWhere(        tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , cLever    ) ,
psttLever( 0 ) ,
pczLever( 0 ) ,
cLever( 0 ) ,
swThreadWhereInfo( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , lever_pTin ) ,
lever_pTin( 0 ) ,
ether( etherP ) ,
processWhereInfoS::processWhereInfoS( tinS& tinP , etherC& etherP ) :

}
    swThreadWhereInfo.ungrabF( tinP ) ;
    }
        DEL( pwt ) ;
        threadWhereInfoS* pwt = (threadWhereInfoS*)(countT)swThreadWhereInfo ;
        lever_pTin = swThreadWhereInfo.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swThreadWhereInfo.cFlavorsF( tinP ) ;
    swThreadWhereInfo.grabF( tinP , TAG( TAGiDnULL ) ) ;

    TINSL
{
processWhereInfoS::~processWhereInfoS( voidT )

}
    ::reportWhereF( tinP , ether , psttP , swIdWhere , swTell , swWorking , swSupervising , swChainOfCommand , swNest , cLever , psttLever , pczLever ) ;
    
    ) , 0x10000 ) ; ___( psttP ) ;
        
        "owner     : ")+TF1(idAdam)+T("\r\n \r\n \r\n"
        "root owner: ")+TF1(idAdamRoot)+T("\r\n \r\n \r\n"
        "idProcessOld : ")+TF1(idProcessOld)+T("\r\n"
        "idThread  : ")+TF1(idThread)+T("\r\n"
        "thread    : \"")+T(postThreadName)+T("\"\r\n"
        "www.ideafarm.com  IdeaFarm " "(tm) City\r\n \r\n"
        "author: ")+TF1(DDNUMB)+T("\r\n"
        "time: ")+TT(timeN1,timeN2)+T("\r\n"
        "report title: single thread activity report\r\n"
        
    ether.strMakeF( tinP , psttP , T(

    ether.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT  , timeN1 ) ;
{
voidT threadWhereInfoS::reportWhereF( tinS& tinP , strokeS*& psttP )

}
    ;

        swNest.cFlavorsF( tinP )
        swChainOfCommand.cFlavorsF( tinP )  ||
        swSupervising.cFlavorsF( tinP )     ||
        swWorking.cFlavorsF( tinP )         ||
        swTell.cFlavorsF( tinP )            ||
        swIdWhere.cFlavorsF( tinP )         ||

    return
{
boolT threadWhereInfoS::bHaveTalliesF( tinS& tinP )

}
    swNest.freeAllF( tinP ) ;
    swChainOfCommand.freeAllF( tinP ) ;
    swSupervising.freeAllF( tinP ) ;
    swWorking.freeAllF( tinP ) ;
    swTell.freeAllF( tinP ) ;
    swIdWhere.freeAllF( tinP ) ;
{
voidT threadWhereInfoS::purgeF( tinS& tinP )

}
    *postThreadName = 0 ;
{
idAdam( 0 )
idAdamRoot( 0 ) ,
idProcessOld( 0 ) ,
idThread( 0 ) ,
swNest(           tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , cLever    ) ,
swChainOfCommand( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , pczLever  ) ,
swSupervising(    tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , cLever    ) ,
swWorking(        tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , cLever    ) ,
swTell(           tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , psttLever ) ,
swIdWhere(        tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , cLever    ) ,
psttLever( 0 ) ,
pczLever( 0 ) ,
cLever( 0 ) ,
ether( etherP ) ,
threadWhereInfoS::threadWhereInfoS( tinS& tinP , etherC& etherP ) :

NEWdELcLASSb( threadWhereInfoS )

}
{
p_bFired( 0 )
psttDisplay( 0 ) ,
psttTitle( 0 ) ,
idAdam( 0 ) ,
workerS::workerS( voidT ) :

}
{
idStep( 0 )
monitor( tinP ) ,
monPlusS::monPlusS( tinS& tinP ) :

stateS stateBlank ;
boolT bLayer3endingNoteReceived ;

}
    DEL( pStkSnap ) ;
    TINSL
{
poolOldHistoryS::~poolOldHistoryS( voidT )

}
    __Z( pStkSnap ) ;
    pStkSnap = new( 0 , tinP , LF ) stackC( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_BLOB , sizeof( poolOldSnapS ) ) ;
    __1 //I WILL NEVER BE CALLED BECAUSE INSTANCES OF ME ARE MANUALLY CONSTRUCTED AND DESTRUCTED
{
cRef( 0 )
pStkSnap( 0 ) ,
poolOldHistoryS::poolOldHistoryS( tinS& tinP , etherC& etherP ) :

}
    return *this ;
    thirdC::c_memcpyIF( *tinP.pPoop , (byteT*)this + sizeof grab , (byteT*)&psP + sizeof grab , sizeof( poolOldSnapS ) - sizeof grab ) ;
{
poolOldSnapS& poolOldSnapS::operator =( poolOldSnapS& psP )

}
    etherP.osTimeNowF( tinP , time1o , time2o ) ;
    thirdC::c_memsetIF( tinP , (byteT*)this , sizeof( poolOldSnapS ) ) ;
{
grab( tinP , TAG( TAGiDnULL ) )
poolOldSnapS::poolOldSnapS( tinS& tinP , etherC& etherP ) :

}

    ((thirdC&)ether).osOpenProcessF( tinP , hProcess ) ;
    __( tinP.monitor.idThread - 1 ) ;
    logF( tinP , T("log file opened") , 0 , 0 ) ;
{
bLog(                tinP , TAG( TAGiDnULL ) )
stThread(            tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( threadS ) ) ,
swThread(            tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , leverOsTid , sizeof( threadS ) ) ,
swWorker(            tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , leverOsPid , sizeof( workerS ) ) ,
swWatch(             tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , psttWatch , sizeof( watchS ) ) ,
swTallySayGrabCtRaw( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , pczLineFileCt ) ,
swTallySayGrabCtIda( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , pczLineFileCt ) ,
swTallySayGrabCt(    tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , pczLineFileCt ) ,
swTallySay(          tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , idTypeSay ) ,
swTallyEvent(        tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , idEvent ) ,
swPoolHistory(       tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , psttPoolName , sizeof( poolOldHistoryS ) ) ,
sws_pTin(            tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , leverOsPid ) ,
swsIdaTin(           tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , leverOsPid ) ,
sws_pGrab(           tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , leverOsPid ) ,
swsIdaGrab(          tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , leverOsPid ) ,
bLeverOsPid(         tinP , TAG( TAGiDnULL ) ) ,
b_pbdVarying(        tinP , TAG( TAGiDnULL ) ) ,
aIdaTin(             tinP , etherP ) ,
psttWatch( 0 ) ,
idTypeSay( 0 ) ,
psttPoolName( 0 ) ,
pbdVarying( 0 ) ,
pczLineFileCt( 0 ) ,
idEvent( 0 ) ,
leverOsPid( 0 ) ,
leverOsTid( 0 ) ,
idDisplayRequest( 0 ) ,
idDisplay( 1 ) ,
cMonitors( 0 ) ,
bMonitored( 1 ) ,
hProcess( 0 ) ,
osPid( tinP.osPid ) ,
osTidMain( tinP.osTid ) ,
bHandedOff( 0 ) ,
etPrime( etherC::etPrimeIF( tinP ) ) ,
ether( etherP ) ,
bookAllS::bookAllS( tinS& tinP , etherC& etherP ) :

}
    bLog.ungrabF( tinP ) ;
    ether.fileWriteF( tinP , hFileLog , tEntry , tEntry.csF( tinP ) ) ;
    TN( tEntry , "" ) ; tEntry = TT(timeN1,timeN2)+T("|")+TF1(idAdamP)+T(".")+T(postThreadP)+T("| ")+T(psttP)+T("\r\n") ;
    { count2S c2z ; ether.fileSetPtrF( tinP , hFileLog , flSETfILEpTR_END , c2z ) ; }
    ether.fileOpenF( tinP , hFileLog , countTC() , T(bMonitored?"///d/ideafarm.log.cells":"///d/ideafarm.log.os") , ifcOPENaCCESS_W , ifcOPENsHARE_WR , flOPENdETAILS_LOCsEQ | flOPENdETAILS_FAIL , ifcOPENhOW_nCeO ) ;
    ZE( countT , hFileLog ) ;
    bLog.grabF( tinP , TAG( TAGiDnULL ) ) ;

    ether.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT  , timeN1 ) ;
{
voidT bookAllS::logF( tinS& tinP , const strokeS* const psttP , const countT idAdamP , const osTextT* const postThreadP )

}
    logF( tinP , T("log file closed") , 0 , 0 ) ;
    TINSL
{
bookAllS::~bookAllS( voidT )

}
{
idResultHire( 0 )
time2limit( time2limitP ) ,
time1limit( time1limitP ) ,
flags( flagsP ) ,
psttArgs( psttArgsP ) ,
bLethal( bLethalP ) ,
sgnHired( sgnHiredP ) ,
) :
    sCountT  time2limitP
    countT   time1limitP  ,
    flagsT   flagsP       ,
    strokeS* psttArgsP    ,
    boolT    bLethalP     ,
    signC&   sgnHiredP    ,
(
params_tmMonitorF_2S::params_tmMonitorF_2S

}
    //logPoolStatsF( tinP , ether , T("tmMonitorF ++: ") , osTidMain , osPid , idProcessOld , idMonitor , baP ) ;
    { TN( tLog , "" ) ; tLog += T("hire ")+T(worker.psttDisplay)+T(": ")+T(psttArgs) ; ether.ifcSayF( tinP , tLog ) , flSAY_APPEND | flSAY_LOG ; }

    }
        }
            }
                ba.swThread.ungrabF( tinP ) ;
                (threadS&)(countT&)ba.swThread = thread ;
                ba.leverOsTid = thread.osTid ;
                ba.swThread.grabF( tinP , TAG( TAGiDnULL ) ) ;
                thread.osPid = osPid ;
                thread.osTid = osTidMain ;
                ether.osTimeNowF( tinP , thread.timeNew.time1 , thread.timeNew.time2 ) ;
                threadS thread( tinP , ether ) ;
            {

            sw_hThread_osTid = hThread ; //U:WILL SET TO 0; NEED TO USE *pSwThreadHandle NOW
            lever_osTid = osTidMain ;
            TELL( "the process has been hired" ) ;
            }
                case 3 : { ether.osSessionF( tinP , osTidMain , osPid , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/01000030.ipdos-we") , psttArgs , 0 , 0 , 0 , 0 , flSESSION_MONITORED                             ) ; break ; }
                case 2 : { ether.osProcessF( tinP , osTidMain , osPid , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/01000020.ipdos-we") , psttArgs                 , flPROCESShIRE_MONITORED | flPROCESShIRE_VISIBLE ) ; break ; }
                case 1 : { ether.osProcessF( tinP , osTidMain , osPid , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/01000020.ipdos-we") , psttArgs                 , flPROCESShIRE_MONITORED                         ) ; break ; }
            {
            else switch( idDisplayType )
            }
                case 3 : { ether.osSessionF( tinP , osTidMain , osPid , psttExe                                                                     , psttArgs , 0 , 0 , 0 , 0 , flSESSION_MONITORED                             ) ; break ; }
                case 2 : { ether.osProcessF( tinP , osTidMain , osPid , psttExe                                                                     , psttArgs                 , flPROCESShIRE_MONITORED | flPROCESShIRE_VISIBLE ) ; break ; }
                case 1 : { ether.osProcessF( tinP , osTidMain , osPid , psttExe                                                                     , psttArgs                 , flPROCESShIRE_MONITORED                         ) ; break ; }
            {
            if( bLiteral ) switch( idDisplayType )
            ZE( countT , hThread ) ;
            TELL( "hiring the process to be monitored" ) ;
        {
    
        }
            else __1
            }
                else __1
                else if( !ether.strCompareF( tinP , worker.psttDisplay , T("graphics") ) ) idDisplayType = 3 ;
                else if( !ether.strCompareF( tinP , worker.psttDisplay , T("text"    ) ) ) idDisplayType = 2 ;
                     if( !ether.strCompareF( tinP , worker.psttDisplay , T("none"    ) ) ) idDisplayType = 1 ;
            {
            else if( F(ptm2P.flags) & flHIRE_DISPLAYaUTO     )
            else if( F(ptm2P.flags) & flHIRE_DISPLAYgRAPHICS ) { idDisplayType = 3 ; if( !worker.psttDisplay ) ether.strMakeF( tinP , worker.psttDisplay , T("graphics") ) ; }
            else if( F(ptm2P.flags) & flHIRE_DISPLAYtEXT     ) { idDisplayType = 2 ; if( !worker.psttDisplay ) ether.strMakeF( tinP , worker.psttDisplay , T("text"    ) ) ; }
                 if( F(ptm2P.flags) & flHIRE_DISPLAYnONE     ) { idDisplayType = 1 ; if( !worker.psttDisplay ) ether.strMakeF( tinP , worker.psttDisplay , T("none"    ) ) ; }
        {
        ZE( countT , idDisplayType ) ;
    
        ether.delF( tinP , ptm2P.psttArgs ) ;
        }
            }
                }
                    }
                        }
                            ether.strMakeF( tinP , worker.psttDisplay , T(info.psttDirectivesReplied) ) ; ___( worker.psttDisplay ) ;
                            (*pPeekF)( &info ) ;
                            peekS info( tinP , ether , T("!display") ) ;
                        {
                        }
                            ether.strMakeF( tinP , worker.psttTitle , T(info.psttDirectivesReplied) ) ; ___( worker.psttTitle ) ;
                            (*pPeekF)( &info ) ;
                            peekS info( tinP , ether , T("!title") ) ;
                        {
                        declareVmUsageTypeGF( tinP , (byteT*)pPeekF , flVMuSAGEtYPE_CODEaDAM ) ;
                    {
                    else
                    if( !pPeekF ) ptm2P.idResultHire = ifcIDrESULThIRE_COULDnOTfINDpEEK ;
                    __Z( pPeekF ) ;
                    ether.dllEntryF( tinP , pPeekF , hDllAdam , T("peekF") ) ;
                    ZE( peekFT , pPeekF ) ;
                {
                else
                if( ether ) ptm2P.idResultHire = ifcIDrESULThIRE_COULDnOTlOADaDAM ;
                __Z( hDllAdam ) ;
                else                                           ether.dllOpenF( tinP , hDllAdam , psttDll                                                                                                     ) ;
                if( !ether.strIdF( tinP , S1C('/') , psttDll ) ) ether.dllOpenF( tinP , hDllAdam , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/")+T(psttDll)+T(".ipdos-wd") ) ;
            {
            if( !ether )
    
            ether.delF( tinP , pstt1w ) ;
            }
                }
                    worker.idAdam = ether.strDigitsToSCountF( tinP , psttDll ) ;
                    ether.strFuseF( tinP , psttArgs , tInsert ) ;
                    ether.strMakeF( tinP , psttDll , psttc1 ) ; ___( psttDll ) ;
                    bWoth = 0 ;
                {
                if( bWoth )
                ether.strFuseF( tinP , psttArgs , psttc1 ) ;
                if( !bWoth ) ether.strFuseF( tinP , psttArgs , tb ) ;
            {
            FORsTRINGSiN1( pstt1w )
            boolT bWoth = 1 ;
            ether.strWordsOldF( tinP , pstt1w , ptm2P.psttArgs , sttq ) ; ___( pstt1w ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1w ) ;
            TN( tb , " " ) ;
    
            ether.strMakeF( tinP , psttArgs , T("") , ptm2P.psttArgs->idAdam + tInsert.csF( tinP ) ) ;
            TN( tInsert , " !monitored !idProcessOld " ) ; tInsert += TF1(idProcessOld) ;
        {
        else
        }
            ether.strSubstringF( tinP , psttArgs , idf , countTC() , ptm2P.psttArgs     ) ; ___( psttArgs ) ;
            ether.strSubstringF( tinP , psttExe  , idf , sttq , T(" ")    , ptm2P.psttArgs , 1 ) ; ___( psttExe ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        if( bLiteral ) //U:ELIMINATE THIS BOOLEAN BY TESTING !!psttDll

        }
            ether.osTimeAddF( tinP , time1deadline , time2deadline , ptm2P.time1limit , ptm2P.time2limit ) ;
            ether.osTimeNowF( tinP , time1deadline , time2deadline ) ;
            bDeadline = 1 ;
        {
        if( ptm2P.time1limit || ptm2P.time2limit )
    {
    else
    }
        osTidMain = ba.osTidMain ;
        hProcess = ba.hProcess ;
        osPid = ba.osPid ;
    {
    if( ptm2P.flags == flHIRE_null ) //WILL BE TRUE IFF I AM FOR SELF MONITORING

    STATEgRAB idMonitor = ++ state.idMonitorLast ; idProcessOld = ++ state.idProcessOldLast ; STATEuNGRAB
{
bLethal( ptm2P.bLethal )
bAdoptedKid( 0 ) ,
bLogSin( 1 ) ,
sgnDone_tmWhereDriverQuit( tinP , TAG( TAGiDnULL ) ) ,
sgnDone_tmWhere( tinP , TAG( TAGiDnULL ) ) ,
bQuit( 0 ) ,
bStarted( 0 ) ,
cKidThreads( 0 ) ,
sw_hThread_osTid( tinP , etherP , idLineCtP , idiFileCtP , flSTACKc_null , lever_osTid ) ,
lever_osTid( 0 ) ,
osTidMain( 0 ) ,
psttArgs( 0 ) ,
psttExe( 0 ) ,
psttDll( 0 ) ,
bLiteral( !!( F(ptm2P.flags) & flHIRE_LITERAL ) ) ,
idProcessOld( 0 ) ,
idMonitor( 0 ) ,
bDeadline( 0 ) ,
time2deadline( 0 ) ,
time1deadline( 0 ) ,
st_pTinEventCopy( tinP , etherP , idLineCtP , idiFileCtP ) ,
st_pTinEventOriginal( tinP , etherP , idLineCtP , idiFileCtP ) ,
st_psttVmUsageType( tinP , etherP , idLineCtP , idiFileCtP , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ,
st_pTinWhere( tinP , etherP , idLineCtP , idiFileCtP ) ,
hDllAdam( 0 ) ,
bFlushT2PwhenDie( 0 ) ,
bReportWhereProcessWhenDie( 0 ) ,
bWhereNewThreads( 0 ) ,
processWhereInfo( tinP , etherP ) ,
pTinEvent( 0 ) ,
bCopy( 0 ) ,
hProcess( 0 ) ,
osPid( 0 ) ,
flagsComment( 0 ) ,
stPhrases( tinP , etherP , idLineCtP , idiFileCtP , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ,
vmInfo( tinP , etherP ) ,
ba( baP ) ,
idiFileCt( idiFileCtP ) ,
idLineCt( idLineCtP ) ,
ether( etherP ) ,
bookWoS::bookWoS( tinS& tinP , etherC& etherP , const countT idLineCtP , const countT idiFileCtP , bookAllS& baP , params_tmMonitorF_2S& ptm2P , stateS& stateBlank ) :

}
    }
        ba.swThread.ungrabF( tinP ) ;
        ba.swThread.freeF( tinP ) ;
        ba.stThread << (byteT*)&thread ;
        ether.osTimeNowF( tinP , thread.timeDel.time1 , thread.timeDel.time2 ) ;
        threadS& thread = (threadS&)(countT&)ba.swThread ;
        ba.leverOsTid = osTidMain ;
        ba.swThread.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {

    ether.delF( tinP , psttDll ) ;
    TINSL
{
bookWoS::~bookWoS( voidT )

}
    etherP.memSetF( tinP , (byteT*)this , sizeof *this ) ;
{
threadS::threadS( tinS& tinP , etherC& etherP )

;
}
    threadS( tinS& tinP , etherC& etherP ) ;

    osTextT postYell[ COSTmAXtELL + 1 ] ;
    osTextT postThreadName[ COSTmAXtHREADnAME + 1 ] ;
    countT  idProcessOld ;
    countT  idThread ;
    countT  idAdam ;
    countT  idAdamRoot ;
    countT  osPid ;
    countT  osTid ;
    timeS   timeUnreg ;
    timeS   timeReg ;
    timeS   timeDel ;
    timeS   timeNew ;
{
struct threadS

;
}
    bookWoS( tinS& tinP , etherC& etherP , const countT idLineCtP , const countT idiFileCtP , bookAllS& baP , params_tmMonitorF_2S& ptm2P , stateS& stateBlank ) ;
    ~bookWoS( voidT ) ;

    boolT bLethal ;
    boolT bAdoptedKid ;
    boolT bLogSin ;
    signC sgnDone_tmWhereDriverQuit ;
    signC sgnDone_tmWhere ;
    boolT bQuit ;
    boolT bStarted ;
    countT cKidThreads ;
    switchC sw_hThread_osTid ;
    countT lever_osTid ;
    countT osTidMain ;
    strokeS* psttArgs ;
    strokeS* psttExe ;
    strokeS* psttDll ;
    const boolT bLiteral ;
    countT idProcessOld ;
    countT idMonitor ;
    boolT bDeadline ;
    sCountT time2deadline ;
    countT time1deadline ;
    stackC st_pTinEventCopy ;
    stackC st_pTinEventOriginal ;
    stackC st_psttVmUsageType ;
    stackC st_pTinWhere ;
    countT hDllAdam ;
    workerS worker ;
    boolT bFlushT2PwhenDie ;
    boolT bReportWhereProcessWhenDie ;
    boolT bWhereNewThreads ;
    processWhereInfoS processWhereInfo ;
    tinS* pTinEvent ;
    boolT bCopy ;
    countT hProcess ;
    countT osPid ;
    flagsT flagsComment ;
    stackC stPhrases ;
    vmInfoS vmInfo ;
    bookAllS& ba ;
    const countT idiFileCt ;
    const countT idLineCt ;
    etherC& ether ;
{
struct bookWoS

;
}
    boolT bHaveTalliesF( tinS& tinP ) ;
    voidT reportWhereF( tinS& tinP , strokeS*& psttP ) ;
    voidT purgeF( tinS& tinP ) ;
    threadWhereInfoS( tinS& tinP , etherC& etherP ) ;
    NEWdELcLASSpROTOS( threadWhereInfoS , etherC , thirdC )

    osTextT  postThreadName[ COSTmAXtHREADnAME + 1 ] ;
    countT   idAdam ;
    countT   idAdamRoot ;
    countT   idProcessOld ;
    countT   idThread ;
    switchC  swNest ;
    switchC  swChainOfCommand ;
    switchC  swSupervising ;
    switchC  swWorking ;
    switchC  swTell ;
    switchC  swIdWhere ;
    strokeS* psttLever ;
    countT*  pczLever ;
    countT   cLever ;
    etherC&  ether ;
{
struct threadWhereInfoS

;
}
    poolOldHistoryS( tinS& tinP , etherC& etherP ) ;
    ~poolOldHistoryS( voidT ) ;

    countT cRef ;
    stackC* pStkSnap ;
{
struct poolOldHistoryS

;
}
    poolOldSnapS& operator =( poolOldSnapS& psP ) ;
    poolOldSnapS( tinS& tinP , etherC& etherP ) ;

    countT  cDropDeletedAtLathCursorReset  ;
    countT  cDropDeleted                   ;
    countT  cDropNewed                     ;
    countT  cAccesses                      ;
    countT  cCollisions                    ;
    countT  cNotUsed                       ;
    countT  cdUsed                         ;
    countT  cbUsed                         ;
    countT  offHighWater                   ;
    countT  offCursor                      ;
    countT  offNewLast                     ;
    countT  offNewMin                      ;
    countT  off                            ;
    countT  cbPool                         ;
    countT  flagsBack                      ;
    countT  idClientLast                   ;
    countT  idClientGrabbing               ;
    countT  idFormat                       ;
    countT  fingerprint                    ;
    sCountT time2o                         ;
    countT  time1o                         ;
    grabOldS   grab                           ; //MUST BE AT THE BEGINNING SO THAT operator = CAN DO A MEMCOPY TO GET ALL OTHER MEMBERS
{
struct poolOldSnapS

;
}
    monPlusS( tinS& tinP ) ;

    countT   idStep ;
    monitorOldS monitor ;
{
struct monPlusS // ASSUME: tinS::monitor IS IMMEDIATELY BELOW tinS::idStep

;
}
    countT flagsFormat ; //PLEASE DISPLAY NUMERIC VALUE USING THESE FLAGS
    countT radix ; //PLEASE DISPLAY NUMERIC VALUE IN THIS RADIX
    countT idType ; //TYPE OF AN ELEMENT. EXAMPLES: countT measureT strokeS strokeStringPrefix
    countT cbElt ; //ELEMENT.  EXAMPLE: SIZE OF A SINGLE ELEMENT IN AN ARRAY
    countT cbAll ; //ALL. EXAMPLE: SIZE OF THE WHOLE ARRAY (IMPLICITLY SPECIFIES THE RANGE OF INDEX VALUES TO BE WATCHED)
    countT idaOrRawAddr ;
    countT bRawAddr ; //0: I SPECIFY A RAW ADDRESS; 1: I SPECIFY AN ida VALUE INTO THE PRIMARY POOLoLD
    countT osPid ;
{
struct watchS // SPECIFIES 1 WATCH VARIABLE, COMPARABLE TO A WATCH IN A CONVENTIONAL DEBUGGER
// THE VALUE OF THE SWITCH IS A watchS object
// THE LEVER IS THE NAME TO USE IN THE DISPLAY LIST
// IF baP.idDisplay == 3 THEN DISPLAY WATCH LOCATION VALUES SPECIFIED USING A SWITCH OF THESE

;
}
    workerS( voidT ) ; //NO DESTRUCTOR, AND NO etherC&, BECAUSE I AM USED AS A RECORD LAYOUT FOR A switchC VALUE.  THE CONSTRUCTOR IS NEVER CALLED; IT IS DEFINED HERE ONLY TO MAINTAIN GOOD CODING FORM

    byteT*   p_bFired ;
    strokeS* psttDisplay ;
    strokeS* psttTitle ;
    countT   idAdam ;
{
struct workerS

;
}
    boolT bHaveTalliesF( tinS& tinP ) ;
    voidT reportWhereF( tinS& tinP , strokeS*& psttP ) ;
    voidT purgeF( tinS& tinP ) ;
    voidT flushThreadTalliesF( tinS& tinP , tinS* pTinP = 0 ) ;
    processWhereInfoS( tinS& tinP , etherC& etherP ) ;
    ~processWhereInfoS( voidT ) ;

    countT   idAdam ;
    countT   idAdamRoot ;
    countT   idProcessOld ;
    switchC  swNest ;
    switchC  swChainOfCommand ;
    switchC  swSupervising ;
    switchC  swWorking ;
    switchC  swTell ;
    switchC  swIdWhere ;
    strokeS* psttLever ;
    countT*  pczLever ;
    countT   cLever ;

    switchC swThreadWhereInfo ;
    countT  lever_pTin ;
    etherC& ether ;
{
struct processWhereInfoS

;
}
    ~vmInfoS( voidT ) ;
    vmInfoS( tinS& tinP , etherC& etherP ) ;

    vmRegionS* pVmRegionAlloc ;
    vmRegionS* pVmRegion ;
    byteT*     pbIdAlloc ;
    byteT*     pbIdRegion ;
    countT     cBitsGrain ;
    etherC&    ether ;
{
struct vmInfoS

;
}
    ) ;
        sCountT  time2limitP = 0
        countT   time1limitP = 0 ,
        flagsT   flagsP      = flHIRE_null ,
        strokeS* psttArgsP   = 0 ,
        boolT    bLethalP    = 0 ,
        signC&   sgnHiredP       ,
    (
    params_tmMonitorF_2S

    countT   idResultHire ;
    sCountT  time2limit  ;
    countT   time1limit  ;
    flagsT   flags       ;
    strokeS* psttArgs    ;
    boolT    bLethal     ;
    signC&   sgnHired    ;
{
struct params_tmMonitorF_2S

;
}
    voidT logF( tinS& tinP , const strokeS* const psttP , const countT idAdamP , const osTextT* const postThreadP ) ;
    bookAllS( tinS& tinP , etherC& etherP ) ;
    ~bookAllS( voidT ) ;

    batonC       bLog ;
    stackC       stThread ;
    switchC      swThread ;
    switchC      swWorker ;
    switchC      swWatch ;
    switchC      swTallySayGrabCtRaw ;
    switchC      swTallySayGrabCtIda ;
    switchC      swTallySayGrabCt ;
    switchC      swTallySay ;
    switchC      swTallyEvent ;
    switchC      swPoolHistory ;
    switchStackC sws_pTin ;
    switchStackC swsIdaTin ;
    switchStackC sws_pGrab ;
    switchStackC swsIdaGrab ;
    batonC       bLeverOsPid ;
    batonC       b_pbdVarying ;
    arrayC       aIdaTin ; //U::POSSIBLY BROKEN BY CHANGE IN SEMANTICS ( aIdaTin[ 0 ] NOW CONTAINS DATA RATHER THAN #ELTS )
    strokeS*     psttWatch ;
    countT       idTypeSay ;
    strokeS*     psttPoolName ;
    byteT*       pbdVarying ;
    countT*      pczLineFileCt ;
    countT       idEvent ;
    countT       leverOsPid ;
    countT       leverOsTid ;
    countT       idDisplayRequest ;
    countT       idDisplay ;
    countT       cMonitors ;
    const boolT  bMonitored ;
    countT       hProcess ;
    const countT osPid ;
    const countT osTidMain ;
    boolT        bHandedOff ;
    etherC&      etPrime ;
    etherC&      ether ;
{
struct bookAllS // COMPARE WITH bookWoS.  "ALL"="ALL MONITORED PROCESSES.  "WO"="A SINGLE MONITORED PROCESS"

voidT reportWhereF( tinS& tinP , etherC& etThread , strokeS*& psttP , switchC& swIdWhereP , switchC& swTellP , switchC& swWorkingP , switchC& swSupervisingP , switchC& swChainOfCommandP , switchC& swNestP , countT& cLeverP , strokeS*& psttLeverP , countT*& pczLeverP ) ;

//": #define LOGfILEtHREADsTATUS ( baP.bMonitored ? "\\ideafarm.log.layer3.monitor.threadStatus" : "\\ideafarm.log.layer2.monitor.threadStatus" )
//EDIT TO USE etherC::ifc_idHomeI_IF(): #define LOGfILE             ( baP.bMonitored ? "\\ideafarm.log.layer3.monitor"              : "\\ideafarm.log.layer2.monitor"              )
#define fliCOMMENT_CLOSEtHREADhANDLE 0x00000008
#define fliCOMMENT_PROCESSeNDED      0x00000004
#define fliCOMMENT_SIN               0x00000002
#define fliCOMMENT_PROCESSsTARTED    0x00000001
#define CBlINE ( CClINE * sizeof( countT ) )
#define CClINE 8
#define PREACH(tP) { tSin = tP ; break ; }
#define CmONITORmAX     0x20
#define IDdISPLAYmAX 0x4
//U::#define IDdISPLAYmAX 0xa
#define CBlINE2 0x10

TRANSLATEsTATEdRIVENsERVER_END
    state.idMe ++ ;
TRANSLATEsTATEdRIVENsERVER_MIDDLE
    case 1 : { state.idMe          = stateOther.idMe          ; }
    case 2 : { state.idMonitorLast = stateOther.idMonitorLast ; state.idProcessOldLast = stateOther.idProcessOldLast ; }
TRANSLATEsTATEdRIVENsERVER_BEGIN( stateS , 2 )

;
}
    countT idProcessOldLast ;
    countT idMonitorLast ;
    countT idMe ;
    countT idVersion ;
{
struct stateS

//#define STATEpERIODiDmE (0x12321)
//#define STATEuNGRAB
//#define STATEgRAB
//DELETE ABOVE WHEN KNOW THAT I DO NOT NEED TO COMMENT OUT STATE GRABBING
#define STATEuNGRAB } baP.b_pbdVarying.ungrabF( tinP ) ;
#define STATEgRAB     baP.b_pbdVarying.grabF(   tinP ) ; { stateS& state = baP.pbdVarying ? *(stateS*)baP.pbdVarying : stateBlank ;

#define MYtITLE "city.driven.server.monitor"
/*1*/WAKEhIDE(      "city.driven.server.monitor" )/*1*/
/**/
*/
 i use sampling to obtain information about where my monitored processes are spending their time
i am also comparable to a conventional performance monitor
  i do performance monitoring as well
  i do not know anything about source code and do not attempt to display it
   i do not attempt to trap my own exceptions
  i can also monitor myself (my wo'th instance does this)
  a single instance of me can simultaneously monitor many processes
 but i also differ from such a program
  i can read from and write to the memory of the process that i am monitoring
   for example, i can receive access violation notifications
  i can launch a process and receive event notifications regarding it
  i display information to the local operator
 i am similar to such a program
 consider a conventional source code enabled single process debugger
i am comparable to a conventional debugger
 the oo'th instance of me is called the "cell monitor"
 the wo'th instance of me is called the "operating system monitor"
 on request, the oo'th instance launches (and monitors) other processes
 the oo'th instance launches the chat server, which launches the console
 when i am hired by the root driver, i launch an oo'th instance of myself and monitor its execution
i am the platform upon which all IFC processes other than the root driver ("service" in NT terms) live
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

