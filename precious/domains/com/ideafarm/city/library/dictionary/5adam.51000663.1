
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

//BOSpOOP
//BOS( WHATgbo , BOSoK , LockSetForegroundWindow( LSFW_UNLOCK ) )

//bOk = EnumWindows( enumWindowsCBF , osPid ) ;

etThread.loafIF( tinP ) ;

}
    ++ s ; ether.osSleepF( tinP , TOCK >> 3 ) ;

    //}
    //    pvtFlag[ offb ]->setF( tinP , T(mask&flags?"X":" ") ) ;
    //
    //    count02T mask = 1 << offb ;
    //{
    //for( countT offb = 0 ; offb < sizeof pvtFlag / sizeof pvtFlag[ 0 ] ; offb ++ )
{
while( !ether && !etThread )
sleepC s( tinP , TAG( TAGiDnULL ) ) ;

vtLogo.setF( tinP , T("IdeaFarm " "(tm) Audio File Categorizer and Flagger") , flVtEXTsET_CELLStOfIT , 0x20 ) ;

//etThread.osThreadF( TaRG1( tmWalkF ) , (countT)&osPid , (countT)postCat , (countT)&flags ) ;
//
//boolT bOk = tinP.brcRaw ;
//BOSpOOP
//BOS( WHATgbo , BOSoK , LockSetForegroundWindow( LSFW_LOCK ) ) //THIS IS DONE BECAUSE OTHERWISE SONY PROGRAM TAKES FOREGROUND

etThread.delF( tinP , psttSay ) ;
tinP.pc Utility[ 0 ] -- ;
etThread.strokeF( tinP , psttSay ) ;
tinP.pc Utility[ 0 ] ++ ;

}
    etThread.strFuseF( tinP , psttSay ,                 tcr ) ;
    etThread.strFuseF( tinP , psttSay ,                 *pbtFlag[ offb ] ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 *pvtFlag[ offb ] ) ;
{
for( countT offb = 0 ; offb < sizeof pbtFlag / sizeof pbtFlag[ 0 ] ; offb ++ )

    etThread.strFuseF( tinP , psttSay ,                 tcr ) ;
    etThread.strFuseF( tinP , psttSay ,                 S2(0,scOld_POPfRAMEdETACH) ) ;
    etThread.strFuseF( tinP , psttSay , S2(0,scOld_POPoFFfRAME) ) ;
    etThread.strFuseF( tinP , psttSay , S2(0,scOld_POPcOLOR) ) ;
    etThread.strFuseF( tinP , psttSay , S2(0,scOld_ccFLOOD) ) ;
    etThread.strFuseF( tinP , psttSay , S3(1.0,scOld_mmMOVEpEL,1.0) ) ;
    etThread.strFuseF( tinP , psttSay , S3(0.0,scOld_mmLINEtO,rROW2) ) ;
    etThread.strFuseF( tinP , psttSay , S3(0.0,scOld_mmLINEtO,rROW2+rROWtHICK) ) ;
    etThread.strFuseF( tinP , psttSay , S3(1.0,scOld_mmLINEtO,rROW2+rROWtHICK) ) ;
    etThread.strFuseF( tinP , psttSay , S3(1.0,scOld_mmLINEtO,rROW2) ) ;
    etThread.strFuseF( tinP , psttSay , S3(0.0,scOld_mmMOVEtO,rROW2) ) ;
    etThread.strFuseF( tinP , psttSay , S2(ifcRGB_W1,scOld_cPUSHcOLOR) ) ;
    etThread.strFuseF( tinP , psttSay ,                 S2(4,scOld_cPUSHoFFfRAME) ) ;
    etThread.strFuseF( tinP , psttSay ,                 S2(0,scOld_FRAMEdETACH) ) ;
    etThread.strFuseF( tinP , psttSay ,                 S2(0,scOld_WRAPoFF) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tcr ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( 0_reserved  ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( f_reserved  ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( e_reserved  ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( d_reserved  ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( c_reserved  ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( b_reserved  ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( a_reserved  ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( 9_nullevent ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( 8_travel    ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( 7_timecard  ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( 6_police    ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( 5_personal  ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( 4_journal   ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( 3_equipment ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( 2_code      ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 BUTTONcAT( 1_audience  ) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tcr ) ;
    etThread.strFuseF( tinP , psttSay ,                 S2(0,scOld_POPfRAMEdETACH) ) ;
    etThread.strFuseF( tinP , psttSay , S2(0,scOld_POPoFFfRAME) ) ;
    etThread.strFuseF( tinP , psttSay , S2(0,scOld_POPcOLOR) ) ;
    etThread.strFuseF( tinP , psttSay , S2(0,scOld_ccFLOOD) ) ;
    etThread.strFuseF( tinP , psttSay , S3(1.0,scOld_mmMOVEpEL,1.0) ) ;
    etThread.strFuseF( tinP , psttSay , S3(0.0,scOld_mmLINEtO,rROW1) ) ;
    etThread.strFuseF( tinP , psttSay , S3(0.0,scOld_mmLINEtO,rROW1+rROWtHICK) ) ;
    etThread.strFuseF( tinP , psttSay , S3(1.0,scOld_mmLINEtO,rROW1+rROWtHICK) ) ;
    etThread.strFuseF( tinP , psttSay , S3(1.0,scOld_mmLINEtO,rROW1) ) ;
    etThread.strFuseF( tinP , psttSay , S3(0.0,scOld_mmMOVEtO,rROW1) ) ;
    etThread.strFuseF( tinP , psttSay , S2(ifcRGB_W1,scOld_cPUSHcOLOR) ) ;
    etThread.strFuseF( tinP , psttSay ,                 S2(4,scOld_cPUSHoFFfRAME) ) ;
    etThread.strFuseF( tinP , psttSay ,                 S2(0,scOld_FRAMEdETACH) ) ;
    etThread.strFuseF( tinP , psttSay ,                 S2(0,scOld_WRAPoN) ) ;
    etThread.strFuseF( tinP , psttSay ,                 tcr ) ;
    etThread.strFuseF( tinP , psttSay ,                 vtLogo ) ;
    etThread.strFuseF( tinP , psttSay ,                 tb ) ;
    etThread.strFuseF( tinP , psttSay ,                 tcQuit ) ;
    etThread.strFuseF( tinP , psttSay ,                 S2(0,scOld_WRAPoFF) ) ;
    etThread.strFuseF( tinP , psttSay ,             S3(64.0,scOld_mmFRAMEcELLS,36.0) ) ;
    etThread.strFuseF( tinP , psttSay ,             S2(0,scOld_POPfRAMEdETACH) ) ;
    etThread.strFuseF( tinP , psttSay ,         S2(0,scOld_POPoFFfRAME) ) ;
    etThread.strFuseF( tinP , psttSay ,     S3(1.0,scOld_mmFRAMEtO,1.0) ) ;
    etThread.strFuseF( tinP , psttSay ,     S3(0.0,scOld_mmMOVEtO,0.0) ) ;
    etThread.strFuseF( tinP , psttSay ,         S2(1,scOld_cPUSHoFFfRAME) ) ;
    etThread.strFuseF( tinP , psttSay ,         S2(0,scOld_FRAMEdETACH) ) ;
    //etThread.strFuseF( tinP , psttSay ,         S2(0,scOld_TRACEoN) ) ;
    //EFFECTIVE FRAME:                  1   2   3   4   5   6
    //                                  |   |   |   |   |
    //                                  |   |   |   |   +TEXT.64.36
    //                                  |   |   |   +COPYoFdEFAULTgRAPH
    //                                  |   |   +DEFAULTtEXT
    //                                  |   +DEFAULTgRAPH
    //                                  +DISPLAY

etThread.strMakeF( tinP , psttSay , 0 , TUCK << 4 ) ; ___( psttSay ) ;
ZE( strokeS* , psttSay ) ;

TN( tcr , "\r\n" ) ;
TN( tn , "" ) ;
TN( tb , " " ) ;
vTextC vtLogo( tinP , "vtLogo" , 0 , 0x3e ) ;

} ;
    &VTfLAG( 1b ) ,
    &VTfLAG( 1a ) ,
    &VTfLAG( 19 ) ,
    &VTfLAG( 18 ) ,
    &VTfLAG( 17 ) ,
    &VTfLAG( 16 ) ,
    &VTfLAG( 15 ) ,
    &VTfLAG( 14 ) ,
    &VTfLAG( 13 ) ,
    &VTfLAG( 12 ) ,
    &VTfLAG( 11 ) ,
    &VTfLAG( 10 ) ,
    &VTfLAG( f ) ,
    &VTfLAG( e ) ,
    &VTfLAG( d ) ,
    &VTfLAG( c ) ,
    &VTfLAG( b ) ,
    &VTfLAG( a ) ,
    &VTfLAG( 9 ) ,
    &VTfLAG( 8 ) ,
    &VTfLAG( 7 ) ,
    &VTfLAG( 6 ) ,
    &VTfLAG( 5 ) ,
    &VTfLAG( 4 ) ,
    &VTfLAG( 3 ) ,
    &VTfLAG( 2 ) ,
    &VTfLAG( 1 ) ,
    &VTfLAG( 0 ) ,
{
vTextC* pvtFlag[] =

VTfLAGcT( 1b ) ;
VTfLAGcT( 1a ) ;
VTfLAGcT( 19 ) ;
VTfLAGcT( 18 ) ;
VTfLAGcT( 17 ) ;
VTfLAGcT( 16 ) ;
VTfLAGcT( 15 ) ;
VTfLAGcT( 14 ) ;
VTfLAGcT( 13 ) ;
VTfLAGcT( 12 ) ;
VTfLAGcT( 11 ) ;
VTfLAGcT( 10 ) ;
VTfLAGcT( f ) ;
VTfLAGcT( e ) ;
VTfLAGcT( d ) ;
VTfLAGcT( c ) ;
VTfLAGcT( b ) ;
VTfLAGcT( a ) ;
VTfLAGcT( 9 ) ;
VTfLAGcT( 8 ) ;
VTfLAGcT( 7 ) ;
VTfLAGcT( 6 ) ;
VTfLAGcT( 5 ) ;
VTfLAGcT( 4 ) ;
VTfLAGcT( 3 ) ;
VTfLAGcT( 2 ) ;
VTfLAGcT( 1 ) ;
VTfLAGcT( 0 ) ;

} ;
    &BUTTONfLAG( 1b ) ,
    &BUTTONfLAG( 1a ) ,
    &BUTTONfLAG( 19 ) ,
    &BUTTONfLAG( 18 ) ,
    &BUTTONfLAG( 17 ) ,
    &BUTTONfLAG( 16 ) ,
    &BUTTONfLAG( 15 ) ,
    &BUTTONfLAG( 14 ) ,
    &BUTTONfLAG( 13 ) ,
    &BUTTONfLAG( 12 ) ,
    &BUTTONfLAG( 11 ) ,
    &BUTTONfLAG( 10 ) ,
    &BUTTONfLAG( f ) ,
    &BUTTONfLAG( e ) ,
    &BUTTONfLAG( d ) ,
    &BUTTONfLAG( c ) ,
    &BUTTONfLAG( b ) ,
    &BUTTONfLAG( a ) ,
    &BUTTONfLAG( 9 ) ,
    &BUTTONfLAG( 8 ) ,
    &BUTTONfLAG( 7 ) ,
    &BUTTONfLAG( 6 ) ,
    &BUTTONfLAG( 5 ) ,
    &BUTTONfLAG( 4 ) ,
    &BUTTONfLAG( 3 ) ,
    &BUTTONfLAG( 2 ) ,
    &BUTTONfLAG( 1 ) ,
    &BUTTONfLAG( 0 ) ,
{
vTextC* pbtFlag[] =

*/
cordial
threat
investigation
unreasonable interpretation of law

FLAGS TO ADD:
/*

BUTTONfLAGcT( 1b , G_flyby ) ;
BUTTONfLAGcT( 1a , F_streetoperation ) ;
BUTTONfLAGcT( 19 , F_photos ) ;
BUTTONfLAGcT( 18 , E_timesync ) ;
BUTTONfLAGcT( 17 , D_tow ) ;
BUTTONfLAGcT( 16 , C_thoughtsteering ) ;
BUTTONfLAGcT( 15 , B_socialscience ) ;
BUTTONfLAGcT( 14 , A_philosophy ) ;
BUTTONfLAGcT( 13 , z_gender ) ;
BUTTONfLAGcT( 12 , y_economics ) ;
BUTTONfLAGcT( 11 , x_administrative ) ;
BUTTONfLAGcT( 10 , w_helppolice ) ;
BUTTONfLAGcT( f , v_violence ) ;
BUTTONfLAGcT( e , u_soliloque ) ;
BUTTONfLAGcT( d , t_sell ) ;
BUTTONfLAGcT( c , s_prolog ) ;
BUTTONfLAGcT( b , r_migration ) ;
BUTTONfLAGcT( a , q_memory ) ;
BUTTONfLAGcT( 9 , p_imprisonment ) ;
BUTTONfLAGcT( 8 , o_hostile ) ;
BUTTONfLAGcT( 7 , n_feedback ) ;
BUTTONfLAGcT( 6 , m_federal ) ;
BUTTONfLAGcT( 5 , l_epilog ) ;
BUTTONfLAGcT( 4 , k_detention ) ;
BUTTONfLAGcT( 3 , j_buy ) ;
BUTTONfLAGcT( 2 , i_arrest ) ;
BUTTONfLAGcT( 1 , h_antipolice ) ;
BUTTONfLAGcT( 0 , g_antiaudience ) ;

//FLAGS THAT ARE ADDED LATER WILL NOT BE ALPHABETICAL BECAUSE THE OFFSETS OF THE EXISTING FLAGS CANNOT BE CHANGED
//TRY TO GET ALL OF THE FLAGS DEFINED AND SORTED ALPHABETICALLY SO THAT NO FLAGS NEED TO BE ADDED LATER

BUTTONcATcT( 0_reserved  ) ;
BUTTONcATcT( f_reserved  ) ;
BUTTONcATcT( e_reserved  ) ;
BUTTONcATcT( d_reserved  ) ;
BUTTONcATcT( c_reserved  ) ;
BUTTONcATcT( b_reserved  ) ;
BUTTONcATcT( a_reserved  ) ;
BUTTONcATcT( 9_nullevent ) ;
BUTTONcATcT( 8_travel    ) ;
BUTTONcATcT( 7_timecard  ) ;
BUTTONcATcT( 6_police    ) ;
BUTTONcATcT( 5_personal  ) ;
BUTTONcATcT( 4_journal   ) ;
BUTTONcATcT( 3_equipment ) ;
BUTTONcATcT( 2_code      ) ;
BUTTONcATcT( 1_audience  ) ;

tcButtonQuitC tcQuit( tinP , "tcQuit" ) ;

countT pcArg[] = { (countT)&osPid , (countT)postCat , (countT)&flags } ;
ZE( count02T , flags ) ;
osTextT postCat[ TUCK ] ;
ZE( countT , osPid ) ;

// flTCfEATURE_KEYaCTION
// flTCfEATURE_TABhEREsUPPRESSEShOTkEYS
// flTCfEATURE_TABpARTICIPANT
// flTCfEATURE_DRAGGABLE
// flTCfEATURE_FLYOVER
// flTCfEATURE_HOTkEYgRABStAB
// flTCfEATURE_HOTkEYbIGIT
//
// FEATURES NOT INCLUDED IN flTCfEATURE_defaultButton

{ tcStateCBFT pcb = CATcBF( 1_audience ) ; }

etThread.strokeF( tinP , tnFoo ) ;
TN( tnFoo , "" ) ;

TODO

DONE( tmWalkF )
}
    thirdC::diskWalkIF( tinP , cDirsP , cFilesP , "\\tmp\\uncategorized\\" , ether , myWalkCBF , pcArg ) ;
    ZE( countT , cFilesP ) ;
    ZE( countT , cDirsP ) ;

    etThread.diskMakeDirIfNeededF( tinP , T("///d/tmp/categorized/") ) ;
    
    countT pcArg[] = { (countT)postExe , (countT)&osPidP , (countT)postCatP , (countT)&flagsP } ;
    osTextT postExe[ TUCK ] ;

    count02T& flagsP   = *(count02T*)pTaskP->c3 ; 
    osTextT*  postCatP =   (osTextT*)pTaskP->c2 ;
    countT&   osPidP   =   *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmWalkF )

}
    return bDoIt ;

    CONoUTrAW( "\r\n" ) ;
    CONoUTrAW( postNameP ) ;

    boolT bDoIt = 1 ;

    }
        }
            flagsP = 0 ;
            *postCatP = 0 ;


            }
                BOSpOOP
                BOS( WHATgbo , BOSoK , MoveFile( postNameP , postLongNew ) ) ;

                BOSdOnOTtEST( WHATgbo , strcat( postLongNew , postShortNew ) )
                strcpy( posto , posti ) ;
                strcpy( posto ++ , "." ) ;
                strcpy( posto , postCatP ) ;     posto += saveRaw ;
                countT saveRaw = tinP.brcRaw ;
                BOSdOnOTtEST( WHATgbo , strlen( postCatP ) )
                strcpy( posto , postTag2 ) ;     posto += sizeof postTag2 - 1 ;
                strcpy( posto ++ , "." ) ;
                strcpy( posto , tFlags   ) ;     posto += tFlags.csF( tinP ) ;
                strcpy( posto , postTag1 ) ;     posto += sizeof postTag1 - 1 ;
                posti += 0x14 ; posto += 0x14 ;
                BOSdOnOTtEST( WHATgbo , memcpy( posto , posti , 0x14 ) )
                osTextT* posto = postShortNew ;
                osTextT* posti = postShortOld ;

                TN( tFlags , "" ) ; tFlags = TF3(flagsP,flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FILLzE,8) ;

                osTextT postTag2[] = "!c." ;
                osTextT postTag1[] = "!f." ;
            {
            if( postShortOld[ 0x13 ] == '.' && *postCatP )

            BOSdOnOTtEST( WHATgbo , strcat( postLongNew , "\\categorized\\" ) )
            *postc = 0 ;
            postc = (osTextT*)tinP.brcRaw ;
            BOSdOnOTtEST( WHATgbo , strrchr( postLongNew , '\\' ) )

            strcpy( postShortOld , postc + 1 ) ;

            *postc = 0 ;
            osTextT* postc = (osTextT*)tinP.brcRaw ;
            BOSdOnOTtEST( WHATgbo , strrchr( postLongNew , '\\' ) )
            strcpy( postLongNew , postNameP ) ;

            osTextT postShortNew[ TUCK ] ;
            osTextT postShortOld[ TUCK ] ;
            osTextT postLongNew[ TUCK ] ;

            tinP.pEther->beeClickF( tinP ) ;
            osPidP = 0 ;
            tinP.pEther->osSessionF( tinP , countTC() , osPidP , value , idTypeDeath , T(ifFileNameC(tinP,*tinP.pEther,postExeP)) , T(postShort) ) ;
            ZE( countT , idTypeDeath ) ;
            ZE( countT , value ) ;

            tinP.pEther->diskHoverF( tinP , T("///d/tmp/uncategorized/") ) ;

            //U::SET flagsP HERE IF !f. IS PRESENT IN postShort

            //U::SET TAB HERE IF !c. IS PRESENT IN postShort

            }
                HINSTANCE oshInstance = (HINSTANCE)tinP.brcRaw ;
                BOSdOnOTtEST( WHATgbo , FindExecutable( postShort , "d:\\tmp\\uncategorized" , postExeP ) )
            {
            if( !*postExeP )

            postShort ++ ;
        {
        if( postShort )
        osTextT* postShort = (osTextT*)tinP.brcRaw ;
        BOSdOnOTtEST( WHATgbo , strrchr( postNameP , '\\' ) )
    {
    if( postExeP )

    count02T& flagsP   = *(count02T*)pcArgP[ 3 ] ; 
    osTextT*  postCatP =   (osTextT*)pcArgP[ 2 ] ;
    countT&   osPidP   =   *(countT*)pcArgP[ 1 ] ;
    osTextT*  postExeP =   (osTextT*)pcArgP[ 0 ] ;
{
boolT myWalkCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

FLAGcBFdEF( 1b )
FLAGcBFdEF( 1a )
FLAGcBFdEF( 19 )
FLAGcBFdEF( 18 )
FLAGcBFdEF( 17 )
FLAGcBFdEF( 16 )
FLAGcBFdEF( 15 )
FLAGcBFdEF( 14 )
FLAGcBFdEF( 13 )
FLAGcBFdEF( 12 )
FLAGcBFdEF( 11 )
FLAGcBFdEF( 10 )
FLAGcBFdEF( f )
FLAGcBFdEF( e )
FLAGcBFdEF( d )
FLAGcBFdEF( c )
FLAGcBFdEF( b )
FLAGcBFdEF( a )
FLAGcBFdEF( 9 )
FLAGcBFdEF( 8 )
FLAGcBFdEF( 7 )
FLAGcBFdEF( 6 )
FLAGcBFdEF( 5 )
FLAGcBFdEF( 4 )
FLAGcBFdEF( 3 )
FLAGcBFdEF( 2 )
FLAGcBFdEF( 1 )
FLAGcBFdEF( 0 )

CATcBFdEF( 0_reserved )
CATcBFdEF( f_reserved )
CATcBFdEF( e_reserved )
CATcBFdEF( d_reserved )
CATcBFdEF( c_reserved )
CATcBFdEF( b_reserved )
CATcBFdEF( a_reserved )
CATcBFdEF( 9_nullevent )
CATcBFdEF( 8_travel )
CATcBFdEF( 7_timecard )
CATcBFdEF( 6_police )
CATcBFdEF( 5_personal )
CATcBFdEF( 4_journal )
CATcBFdEF( 3_equipment )
CATcBFdEF( 2_code )
CATcBFdEF( 1_audience )

}
    return bContinue ;

    }
        }
            BOSpOOP
            BOS( WHATgbo , BOSoK , PostMessage( hwndP , WM_CLOSE , 0 , 0 ) )
            bContinue = 0 ;
        {
        if( !tinP.brcRaw )
        BOSdOnOTtEST( WHATgbo , strcmp( postTitle , "Digital Voice Editor" ) )

        int rc = tinP.brcRaw ;
        BOSpOOP
        BOS( WHATgbo , BOSoK , GetWindowText( hwndP , postTitle , sizeof postTitle - 1 ) )
        osTextT postTitle[ TUCK ] ;
    {
    if( p1P == osPid )
    boolT bContinue = 1 ;

    BOSdOnOTtEST( WHATgbo , GetWindowThreadProcessId( hwndP , &osPid ) )
    ZE( DWORD , osPid ) ;
{
BOOL CALLBACK enumWindowsCBF( HWND hwndP , LPARAM p1P )

#define VTfLAGcT(offFlagP) vTextC VTfLAG( offFlagP )( tinP , "vtFlag##offFlagP##_" , 0 , 1 )

#define VTfLAG(offFlagP) vtFlag_##offFlagP##_

#define BUTTONfLAGcT(offFlagP,displayP) tcButtonC BUTTONfLAG( offFlagP )( tinP , "tcFlag##offFlagP##_" , FLAGcBF( offFlagP ) , (countT)pcArg , flTCfEATURE_defaultButton | flTCfEATURE_TABpARTICIPANT | flTCfEATURE_DRAGGABLE , 0 , T(#displayP) )

#define BUTTONfLAG(offFlagP) tcFlag_##offFlagP##_

#define BUTTONcATcT(catP) tcButtonC BUTTONcAT( catP )( tinP , "tcCat##catP##_" , CATcBF( catP ) , (countT)pcArg , ( flTCfEATURE_defaultButton | flTCfEATURE_TABpARTICIPANT | flTCfEATURE_DRAGGABLE ) /*& ~( F(flTCfEATURE_FRAME) )*/ , 0 , T(#catP) )

#define BUTTONcAT(catP) tcCat_##catP##_

    }
        return bHandled ;                                                                                                                                       \
                                                                                                                                                                \
        }                                                                                                                                                       \
            }                                                                                                                                                   \
                break ;                                                                                                                                         \
                                                                                                                                                                \
                flagsP ^= flagMe ;                                                                                                                              \
                count02T flagMe = 1 << 0x##offFlagP ;                                                                                                           \
                                                                                                                                                                \
                count02T& flagsP   = *(count02T*)pcArgP[ 2 ] ;                                                                                                  \
                osTextT*  postCatP =   (osTextT*)pcArgP[ 1 ] ;                                                                                                  \
                countT&   osPidP   =   *(countT*)pcArgP[ 0 ] ;                                                                                                  \
                countT*   pcArgP   =    (countT*)cArgP ;                                                                                                        \
            {                                                                                                                                                   \
            case ifcIDtYPEsTROKEcALLbACK_HOTkEY :                                                                                                               \
            }                                                                                                                                                   \
                if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;                                                       \
                                                                                                                                                                \
                const countT& idAction = pcNotesP[ 3 ] ;                                                                                                        \
                const countT& idTool   = pcNotesP[ 2 ] ;                                                                                                        \
            {                                                                                                                                                   \
            case ifcIDtYPEsTROKEcALLbACK_MOUSE :                                                                                                                \
        {                                                                                                                                                       \
        switch( idTypeCallP )                                                                                                                                   \
        ZE( boolT , bHandled ) ;                                                                                                                              \
    {                                                                                                                                                           \
    boolT _export FLAGcBF( offFlagP )( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP ) \
                                                                                                                                                                \
#define FLAGcBFdEF(offFlagP)                                                                                                                                    \

#define FLAGcBF(offFlagP) tcButtonFlag_##offFlagP##_CBF

    }
        return bHandled ;                                                                                                                                       \
                                                                                                                                                                \
        }                                                                                                                                                       \
            }                                                                                                                                                   \
                break ;                                                                                                                                         \
                                                                                                                                                                \
                EnumWindows( enumWindowsCBF , osPidP ) ;                                                                                                        \
                strcpy( postCatP , #catP ) ;                                                                                                                    \
                                                                                                                                                                \
                count02T& flagsP   = *(count02T*)pcArgP[ 2 ] ;                                                                                                  \
                osTextT*  postCatP =   (osTextT*)pcArgP[ 1 ] ;                                                                                                  \
                countT&   osPidP   =   *(countT*)pcArgP[ 0 ] ;                                                                                                  \
                countT*   pcArgP   =    (countT*)cArgP ;                                                                                                        \
            {                                                                                                                                                   \
            case ifcIDtYPEsTROKEcALLbACK_HOTkEY :                                                                                                               \
            }                                                                                                                                                   \
                if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;                                                       \
                                                                                                                                                                \
                const countT& idAction = pcNotesP[ 3 ] ;                                                                                                        \
                const countT& idTool   = pcNotesP[ 2 ] ;                                                                                                        \
            {                                                                                                                                                   \
            case ifcIDtYPEsTROKEcALLbACK_MOUSE :                                                                                                                \
        {                                                                                                                                                       \
        switch( idTypeCallP )                                                                                                                                   \
        ZE( boolT , bHandled ) ;                                                                                                                              \
    {                                                                                                                                                           \
    boolT _export CATcBF(catP)( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP ) \
                                                                                                                                                                \
#define CATcBFdEF(catP)                                                                                                                                         \

#define CATcBF(catP) tcButtonCat_##catP##_CBF

#define rROW2 (0.20)
#define rROW1 (0.06)

#define rROWtHICK (0.01)

//extern "C" BOOL __stdcall LockSetForegroundWindow( __in UINT uLockCode ) ;
#define LSFW_LOCK       1
#define LSFW_UNLOCK     2
//U::MOVE TO MONOLITH

/*1*/WAKEsHOW( "tool.categorize.audio.recordings" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

