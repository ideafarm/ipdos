
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


;
}
    //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34002.processGlobal1S._processGlobal1I_IF!||
    static processGlobal1S& _processGlobal1I_IF( voidT ) ;

    //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34001.processGlobal1S.processGlobal1S!||
    processGlobal1S( voidT ) ;
    
    #endif

        virtual ~processGlobal1S( voidT ) = 0 ;

    #else

        //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34001.processGlobal1S.processGlobal1S!||
        ~processGlobal1S( voidT ) ;

        #endif

            zlib_inflateEndFT           zlib_pInflateEndF       ;
            zlib_inflateFT              zlib_pInflateF          ;
            zlib_inflateInit2FT         zlib_pInflateInit2F     ;
            zlib_inflateInitFT          zlib_pInflateInitF      ;
            zlib_deflateEndFT           zlib_pDeflateEndF       ;
            zlib_deflateFT              zlib_pDeflateF          ;
            zlib_deflateInitFT          zlib_pDeflateInitF      ;
            HMODULE                     zlib_hModule            ;

            openSsl_pCurvesFT           openSsl_pCurvesF        ;
            openSsl_pPemFileKeyFT       openSsl_pPemFileKeyF    ;
            openSsl_pPemFileCertFT      openSsl_pPemFileCertF   ;
            openSsl_pWaveByeFT          openSsl_pWaveByeF       ;
            openSsl_pPeekFT             openSsl_pPeekF          ;
            openSsl_pReadFT             openSsl_pReadF          ;
            openSsl_pWriteFT            openSsl_pWriteF         ;
            openSsl_pShakeAsClientFT    openSsl_pShakeAsClientF ;
            openSsl_pShakeAsServerFT    openSsl_pShakeAsServerF ;
            openSsl_pWrapFT             openSsl_pWrapF          ;
            openSsl_pWrapperFreeFT      openSsl_pWrapperFreeF   ;
            openSsl_pWrapperFT          openSsl_pWrapperF       ;
            openSsl_pContextFreeFT      openSsl_pContextFreeF   ;
            openSsl_pContextFT          openSsl_pContextF       ;
            openSsl_pInitFT             openSsl_pInitF          ;
            openSsl_pMethodFT           openSsl_pMethodF        ;
            HMODULE                     openSsl_hModule         ;
    
            EXCEPTION_POINTERS          ecInfo ;
            CONTEXT                     cInfo ;
            EXCEPTION_RECORD            eInfo ;
    
        #if defined( __NT__ )
    
    #if defined( ifcENABLEtHIRDpARTIES )
    //PUT PLATFORM DEPENDENT MEMBERS HERE SO THAT OFFSETS TO THE OTHER MEMBERS ARE INVARIANT

    byteT                           pbMemoryBitsPrivate[ ( TOCK >> 1 ) / SB ] ;
    byteT                           pbMemoryBitsShared[  ( TOCK >> 1 ) / SB ] ;
    byteT                           pbMemoryBitsStack[   ( TOCK >> 1 ) / SB ] ;
    byteT                           pbMemoryBitsCode[    ( TOCK >> 1 ) / SB ] ;
    byteT                           pbMemoryBitsAll[     ( TOCK >> 1 ) / SB ] ;
    countT                          idBlammo        ;
    countT                          idiFileBlammoCt ;
    countT                          idLineBlammoCt  ;
    countT                          idiFileBlammo   ;
    countT                          idLineBlammo    ;
    countT                          pcTrace8[ TOCK << 6 ] ;
    countT                          pcTrace7[ TOCK << 6 ] ;
    countT                          pcTrace6[ TOCK << 6 ] ;
    countT                          pcTrace5[ TOCK << 6 ] ;
    countT                          pcTrace4[ TOCK << 6 ] ;
    countT                          pcTrace3[ TOCK << 6 ] ;
    countT                          pcTrace2[ TOCK << 6 ] ;
    countT                          pcTrace1[ TOCK << 6 ] ;
    countT                          cTrace ;
    count04T                        pcInfoGrain[        TOCK >> 1        ] ; // A:ASSUME: ADDRESSES AT OR ABOVE BM_HIGH ARE NOT ACCESSIBLE (WIN32) ; A:ASSUME: cbAllocationGrain is TOCK
    byteT                           pbEarlyGrain[ 1 + ( TOCK >> 1 ) / SB ] ; // A:ASSUME: ADDRESSES AT OR ABOVE BM_HIGH ARE NOT ACCESSIBLE (WIN32) ; A:ASSUME: cbAllocationGrain is TOCK
    const countT                    cbAllocationGrain ;
    //thisLifiS                     pThisLifi[ TOCK ] ; //COMMENT THIS OUT IN PRODUCTION
    countT                          valueExpectedByInOut ;
    countT*                         pcWatchedByInOut ;
    const flagsT                    flagsCpuFeatures ;
    fireGroupS                      pFireGroup[ CfIREgROUPS ] ;
    byteT                           pbBkTelemetryScratchRoot[ SIZEOF_bookC ] ;
    osTextT                         postPathHomeTmp[ TUCK ] ;
    osTextT                         postDllsLoaded[ TOCK ] ;
    countT                          pcDebug[ TUCK << 1 ] ; //NOT USED IN PRODUCTION ; AVAILABLE FOR DEBUGGING
    byteT                           pbTlsBreak[ CBtLSdEFAULT ] ;
    byteT                           pbTlsHeart[ CBtLSdEFAULT ] ;
    byteT                           pbTlsMain[ CBtLSdEFAULT ] ;
    byteT                           pb_bPoolRpt[          CBzOMBIEbATONc ] ;
    byteT                           pb_bOsCallISharedMem[ CBzOMBIEbATONc ] ;
    byteT                           pb_bOsCallIMonitor[   CBzOMBIEbATONc ] ;
    byteT                           pb_bOsCall[           CBzOMBIEbATONc ] ;
    byteT                           pb_bLog[              CBzOMBIEbATONc ] ;
    byteT                           pb_bMemorySpace[         CBzOMBIEbATONc ] ;
    byteT                           pb_bBeep[             CBzOMBIEbATONc ] ;
    byteT                           pb_bNapkinCt[         CBzOMBIEbATONc ] ;
    tinS*                           pTinDadService ;
    etherC*                         pEtThreadServiceEventHandler ;
    sharedMemInfoS                  _thirdC_pSharedMemInfo[ CsHAREDmEMiNFO ] ;
    osTextT                         ostLathLog ;
    countT                          osTidTerminator ;
    countT                          osTidMain ;
    countT                          idTrial ;
    countT                          idPhaseProcess ;
    countT                          idProcessOld ;
    const countT                    idNumaNode  ;
    const countT                    idHome      ;
    const countT                    idAdamRoot  ;
    flagsT                          flDt        ;
    flagsT                          flCt        ;
    countT                          pcUtility[ 0x10 ] ; //TO FACILITATE DEBUGGING
    countT                          pcPhaseLow[ 1 + ClOWtHREADS ] ; //IT IS ILLEGAL TO WRITE TO ME EXCEPT IN SYSTEM CODE
    countT                          ebp_tmWindowsF_ ;
    countT                          cTls        ;
    countT                          cDllLoaded      ;
    countT                          cDebug      ; //USED ONLY FOR DEBUGGING; NORMALLY NOT REFERENCED
    countT                          ccValidFlags ;
    const countT                    ccPrime ;
    const countT                    cb_nicNameC_ ; //THIS IS USED TO AVOID COMPILER WARNINGS FOR sizeof(  ) CALLED FOR baseSoilXxxxC DERIVED CLASS
    const countT                    cb_portTimeC_ ; //THIS IS USED TO AVOID COMPILER WARNINGS FOR sizeof(  ) CALLED FOR baseSoilXxxxC DERIVED CLASS
    //boolT                         bGo ;       //REMOVE IN PRODUCTION
    countT                          _tinS_idTinLath ;
    flagsT                          _thirdC_flagsProcessState ;
    flagsT                          _thirdC_flagsModeProcess2 ;       // IT IS ILLEGAL TO REFER TO THIS SYMBOL, OR TO ANY PUBLIC STATIC MEMBERS, IN THE DEF OF AN ADAM.   PUBLIC SO CAN EASILY INSPECT FOR DEBUGGING CODE IN BASE
    flagsT                          _thirdC_flagsModeProcess1 ;       // IT IS ILLEGAL TO REFER TO THIS SYMBOL, OR TO ANY PUBLIC STATIC MEMBERS, IN THE DEF OF AN ADAM.   PUBLIC SO CAN EASILY INSPECT FOR DEBUGGING CODE IN BASE
    countT                          _taskS_idThreadLath ;
    boolT                           _poolC_bQuitFlushing ;
    countT                          _poolC_idFlushLath ;
    countT                          _poolC_cBacked ;
    poolC*                          _poolC_pPool ;
    countT                          _handleC_cInstances ; //FOR DEBUGGING, TO VERIFY THAT DESTRUCTOR IS CALLED FOR ALL INSTANCES FOR WHICH CONSTRUCTOR WAS CALLED
    grabWantS*                      _grabC_pgw ;
    const countT                    _grabC_cgw ;
    displayC*                       _displayC_pDisplay ;
    //ALPHABETICAL (TYPE INSTANCES ONLY; NO CLASS INSTANCES)

    static byteT                    pbnuTuck[ TUCK ] ;
    static osTextT                  postIdHome[ 0x9 ] ; //A: ASSUME: sizeof( countT ) == 4
    static osTextT                  postIdAdamRoot[ 0x9 ] ; //A: ASSUME: sizeof( countT ) == 4
    static osTextT                  postIdNumaNode[ 0x9 ] ; //A: ASSUME: sizeof( countT ) == 4
    static flagsT                   pcValidFlags[] ;
    static countT                   pcPrime[] ;
    static const osTextT* const     _handleC_postOldClassName ;
{
/*1*/struct _export processGlobal1S/*1*/

//ALL PROCESS GLOBALS ARE HERE EXCEPT THOSE THAT REQUIRE MEMBERS OF rootAdamGlobal1I

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

