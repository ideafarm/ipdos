
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS1gATHERuNPACK / -") ) ;

while( ~hFind && !POOP ) ;
}
    }
        }
            etThread.diskMoveFileOrDirF( tinP , tToAll+tShort , tIfoName , 0 ) ;
            DEL( pInfo ) ;
            }
                etThread.delF( tinP , pstt1Lines ) ;

                }
                    etThread.traceF( tinP , T("[idJot]:    ")+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    etThread.delF( tinP , pstt1Entry ) ;
                    }
                        idJot = (countT)pbEncoded ;
                        etThread.strEncodeF( tinP , pbEncoded , pstt1Entry , 0 , sizeof( countT ) , (const byteT*)&hash ) ; ___( pbEncoded ) ;
                        ZEJ( byteT* , pbEncoded , jotHashString ) ;
                    {
                    if( !idJot )

                    }
                        }
                            }
                                etThread.delF( tinP , pstt1EntryHe ) ;
                                if( !etThread.strCompareF( tinP , pstt1Entry , pstt1EntryHe ) ) idJot = jotHashString.idLathReadF() ;
                                etThread.strDecodeF( tinP , pstt1EntryHe , pbEncodedHe + sizeof( countT ) ) ; ___( pstt1EntryHe ) ;
                                ZE( strokeS* , pstt1EntryHe ) ;
                            {
                            else if( *(countT*)pbEncodedHe == hash )
                            if( !pbEncodedHe || !cbEncodedHe ) break ;

                            countT       cbEncodedHe = pageHe ;
                            const byteT* pbEncodedHe = pageHe ;
                            
                            pageC pageHe = jotHashString ;
                        {
                        while( !idJot )
                        jotHashString.resetLathReadF() ;
                    {
                    ZE( countT , idJot ) ;

                    //etThread.traceF( tinP , T("[hash]:    ")+TF2(hash,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT hash = hashF( (byteT*)pstt1Entry , sizeof( strokeS ) * ( CSpREFIX + pstt1Entry->idAdam ) , 0 ) ;

                    etThread.strFuseSeparateF( tinP , pstt1Entry , tURIContainerPlus ) ;
                    etThread.strFuseSeparateF( tinP , pstt1Entry , tContainer        ) ;
                    etThread.strFuseSeparateF( tinP , pstt1Entry , tLogBucket        , 0 , 0 , 0 , 0 , CSpREFIX * 2 + tContainer.csF( tinP ) + tURIContainerPlus.csF( tinP ) ) ; ___( pstt1Entry ) ;
                    ZE( strokeS* , pstt1Entry ) ;

                    }
                        etThread.delF( tinP , psttGot ) ;
                        tURIContainerPlus = T(psttGot) ;
                        etThread.strSubstringF( tinP , psttGot , idf , idl , tURIContainerPlus , 0 ) ; ___( psttGot ) ;
                        countT idl = idHit - 1 ;
                        countT idf = 1 ;
                        ZE( strokeS* , psttGot ) ;
                    {
                    if( idHit > 1 )
                    idHit = tURIContainerPlus.csF( tinP ) && etThread.strIdF( tinP , idf , sttq , tBlankHttpSlash , tURIContainerPlus , 0 , 1 ) ;
                    idf = 1 ;

                    }
                        etThread.delF( tinP , psttGot ) ;
                        tURIContainerPlus = T(psttGot) ;
                        etThread.strSubstringF( tinP , psttGot , idf , idl , tURIContainerPlus , 0 ) ; ___( psttGot ) ;
                        countT idl = idHit - 1 ;
                        countT idf = 1 ;
                        ZE( strokeS* , psttGot ) ;
                    {
                    if( idHit > 1 )
                    countT idHit = tURIContainerPlus.csF( tinP ) && etThread.strIdF( tinP , idf , sttq , sttDoubleQuote , tURIContainerPlus , 0 , 1 ) ;
                    idf = 1 ;

                    etThread.traceF( tinP , tURIContainerPlus ) ;
                    }
                        etThread.delF( tinP , psttGot ) ;
                        tURIContainerPlus = T(psttGot) ;
                        etThread.strSubstringF( tinP , psttGot , idf , idl , tURIContainerPlus , 0 ) ; ___( psttGot ) ;
                        ZE( countT , idl ) ;
                        countT idf = tContainer.csF( tinP ) + 1 ;
                        ZE( strokeS* , psttGot ) ;
                    {
                    if( !etThread.strCompareF( tinP , tLogBucket , tLogBucketAccessLogs ) && tContainer.csF( tinP ) && tURIContainerPlus.csF( tinP ) && 1 == etThread.strIdF( tinP , tContainer , tURIContainerPlus , 1 ) && tContainer.csF( tinP ) < tURIContainerPlus.csF( tinP ) )

                    etThread.traceF( tinP , tURIContainerPlus ) ;
                    }
                        etThread.delF( tinP , psttGot ) ;
                        tURIContainerPlus = T(psttGot) ;
                        etThread.delF( tinP , psttnu ) ;
                        etThread.strBisectF( tinP , psttnu , psttGot , tMethodPlus , tSlash , !etThread.strCompareF( tinP , tLogBucket , tLogBucketAccessLogs ) ? 3 : 2 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttGot ) ;
                        ZE( strokeS* , psttGot ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tURIContainerPlus , "" ) ;

                    etThread.traceF( tinP , tMethodPlus ) ;

                    }
                        etThread.delF( tinP , psttGot ) ;
                        tMethodPlus = T(psttGot) ;
                        etThread.strSubstringF( tinP , psttGot , idf , idl , psttc1 , 0 ) ; ___( psttGot ) ;
                        ZE( countT , idl ) ;
                        ZE( strokeS* , psttGot ) ;
                    {
                    if( psttc1->idAdam && etThread.strIdF( tinP , idf , sttq , sttDoubleQuote , psttc1 , 0 , 1 ) )
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    countT idf = 1 ;

                    // 216.244.66.247 - - [21/01/2018:19:08:26 +0000] "GET /838a98a1c3503d5080fc-0120a6193262fb464e305f722f61adc1.r53.cf5.rackcdn.com/2016/3/pages/index.z.white.4069b4cf.10000000.html HTTP/1.1" 200 13548 "-" "Mozilla/5.0 (compatible; DotBot/1.1; http://www.opensiteexplorer.org/dotbot, help@moz.com)"
                    // 204.213.85.999 - - [21/01/2018:23:58:02 +0000] "GET /v1/MossoCloudFS_921871/ipdos.home.registry?format=json HTTP/1.0" 200 7174 "-" "-"
                    TN( tMethodPlus , "" ) ;

                    //etThread.traceF( tinP , psttc1 ) ;
                {
                FORsTRINGSiN1( pstt1Lines )

                etThread.delF( tinP , posti ) ;
                etThread.strWordsF( tinP , pstt1Lines , T(posti) , sttq , tCRLF , flSTRwORDS_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1Lines ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , pstt1Lines ) ;

                etThread.boxGetShadowF( tinP , posti , costi , pInfo->psttIfoName ) ; ___( posti ) ;
                ZE( countT   , costi ) ;
                ZE( osTextT* , posti ) ;
            {

            etThread.traceF( tinP , tLogBucket+tb4+tContainer ) ;
            etThread.traceF( tinP , tContainerPlus ) ;
            etThread.traceF( tinP , tAfterHey ) ;
            etThread.traceF( tinP , tLogBucket ) ;

            }
                etThread.delF( tinP , psttGot ) ;
                tContainer = T(psttGot) ;
                etThread.delF( tinP , psttnu ) ;
                etThread.strBisectF( tinP , psttGot , psttnu , tContainerPlus , tDot , -6 , flSTRbISECT_null ) ; ___( psttGot ) ; ___( psttnu ) ;
                ZE( strokeS* , psttnu ) ;
                ZE( strokeS* , psttGot ) ;
            {
            TN( tContainer , "" ) ;

            }
                etThread.delF( tinP , psttGot ) ;
                tContainerPlus = T(psttGot) ;
                etThread.strSubstringF( tinP , psttGot , idf , idl , tAfterHey , 0 ) ; ___( psttGot ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( countT , idl ) ;
                countT idf = 0x2e ; ;
                ZE( strokeS* , psttGot ) ;
            {
            TN( tContainerPlus , "" ) ;     // web.archiveview.2018.01.21.20.53c96b155170cfa84d4a67396da97101.log

            }
                etThread.delF( tinP , psttGot ) ;
                tAfterHey = T(psttGot) ;
                etThread.strSubstringF( tinP , psttGot , idf , idl , tShort , 0 ) ; ___( psttGot ) ;
                ZE( countT , idl ) ;

                etThread.delF( tinP , psttGot ) ;
                tLogBucket = T(psttGot) ;
                etThread.strSubstringF( tinP , psttGot , idf , sttq , tDotHeyDot , tShort , 0 , 0 ) ; ___( psttGot ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                countT idf = 1 ;
                ZE( strokeS* , psttGot ) ;  // 0              1               2
            {                               // 123456789abcdef0123456789abcdef0123456789abcdef
            TN( tAfterHey , "" ) ;          // 00b0d3bc.21f75cd8.9d7e9628.0a810000.4a810000.web.archiveview.2018.01.21.20.53c96b155170cfa84d4a67396da97101.log
            TN( tLogBucket , "" ) ;         // .CDN_ACCESS_LOGS
        {
        if( !bDir )

        }
            etThread.delF( tinP , psttShort ) ;
            tShort = T(psttShort) ;
            etThread.delF( tinP , psttnu ) ;
            etThread.strBisectF( tinP , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
            ZE( strokeS* , psttShort ) ;
            ZE( strokeS* , psttnu ) ;
        {
        TN( tShort , "" ) ;            // .CDN_ACCESS_LOGS.!.00b0d3bc.21f75cd8.9d7e9628.0a810000.4a810000.web.archiveview.2018.01.21.18.0f687d0ce0e187c640bbe7d56b250a52.log

        const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;

        TN( tIfoName , pInfo->psttIfoName ) ;
    {
    else
    }
        break ;
        DEL( pInfo ) ;
    {
    if( !pInfo || !pInfo->psttIfoName )

    etThread.diskFindFileOrDirOldF( tinP , pInfo , hFind , tToPending+T("*") ) ;
    ZE( infoFileS* , pInfo ) ;
{
do
handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

strokeS sttDoubleQuote( '\"' ) ;
const countT tagHighNibble = jotHashString.tagHighNibbleF() ;
jotC jotHashString( tinP , "hash.string.triplets" , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 ) ;   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)

}
    etThread.traceF( tinP , T("called  gzip to unpack all gz files in ")+tToPending ) ;
    thirdC::c_systemIF( tinP , tCmd ) ;
    //etThread.traceF( tinP , tCmd ) ;
    }
        tCmd += T(osfn)+T("*") ;
        osFileNameC osfn( tinP , etThread , tToPending ) ;
    {
    TN( tCmd , "gzip -d " ) ;
    etThread.traceF( tinP , T("calling gzip to unpack all gz files in ")+tToPending ) ;

    etThread.diskFileOrDirDeleteF( tinP , tFrom , flFILEoRdIRdELETE_RECURSE ) ;
    etThread.traceF( tinP , T("deleting ")+tFrom+T("; WARNING: i assume that no other process is downloading or otherwise modifying the contents of ")+tFrom ) ;

    etThread.traceF( tinP , T("new access logs [cDirs,cFiles]:    ")+TF2(cDirs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.diskWalkGatherF( tinP , cDirs , cFiles , countTC() , tToPending , tFrom , 0 , pcArgs ) ;
    countT pcArgs[] = { 2 } ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs ) ;
    etThread.traceF( tinP , T("gathering the poured files into the single directory ")+tToPending+T(" from ")+tFrom ) ;
{

TN( tBlankHttpSlash ," HTTP/" ) ;
TN( tLogBucketCDNAccessLogs , ".CDN_ACCESS_LOGS" ) ;
TN( tLogBucketAccessLogs , ".ACCESS_LOGS" ) ;
TN( tCRLF , "\r\n" ) ;
TN( tDotHeyDot , ".!." ) ;
TN( tDot   , "." ) ;
TN( tSlash , "/" ) ;
TN( tb4 , "    " ) ;
TN( tToAll     , "///d/tmp/cloud.access.log.entries.all/" ) ;
TN( tToPending , "///d/tmp/cloud.access.log.entries.new/" ) ;
TN( tFrom      , "///d/tmp/cloud.access.log.entries.incoming/" ) ;

etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS1gATHERuNPACK / +") ) ;

TODO

// OBSOLETED BY 51000738

/*1*/WAKEhIDE( "ifcIDaDAM_ACCESSeVENTS1gATHERuNPACK" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

