
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUTsTACKc_

    THREADmODE1rESTORE

    DEL( pXray ) ;
    DEL( pSw_idLathRef ) ;
    DEL( pSw_ppLathRef ) ;
    DEL( pSw_idCursor  ) ;
    DEL( pSw_ppCursor  ) ;

    }
        _OUTsTACKc_
        DEL( pBaton ) ;
        _INsTACKc_
    {
    if( !bDoNotDeleteBaton ) //~batonC HAS COMPLAINED OF "FUNCTIONS STILL PENDING", APPARENTLY HERE; THE CALL NEST INDICATED NESTED ~batonC, WHICH APPEARED TO NOT BE POSSIBLE, REVIEWING THE CODE; RETAIN THIS INOUT BRACKETING UNTIL THAT ISSUE HAS BEEN REPRODUCED AND ANALYSED

    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

    if( pBaton ) pBaton->ungrabF( tinP ) ;

    }
        third.delF( tinP , postOsFile ) ;
        }
            DEL( pSoul ) ;
            THREADmODE1rESTORE
            }
                third.dosWriteF( tinP , hFile , *pSoul ) ;
                { ZE( countT , idr ) ; third.dosOpenIF( tinP , hFile , idr , postOsFile , ifcOPENaCCESS_W , 0 , flOPENdETAILS_FAIL | flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ; }
                handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            {
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            //ASSUME: THE DESTINATION DIRECTORY EXISTS
        {
        if( pSoul )
    {
    if( postOsFile ) //U:: IF postOsFile THEN I WILL BLOW THE STACK

    purgeF( tinP ) ;
    third.delF( tinP , pbnu ) ;

    if( pSoul ) operator >>( *pSoul ) ;

    soulC* pSoul = !postOsFile ? 0 : new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;

    }
        THREADmODE1rESTORE
        DEL( pSgnEvent ) ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

        }
            }
                third.dosSleepIF( tinP , TOCK ) ;
                pSgnEvent->giveF( tinP ) ;
                ++ s ;
            {
            while( cWaitingForEvent )
            ZE( countT , idTry ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( cWaitingForEvent )
    {
    if( pSgnEvent )
    bDying ++ ;

    _INbATONsTACKc_
    SCOOP
    TINSL
{
/*1*/stackC::~stackC( voidT )/*1*/

/**/
*/
 if this is not desired, the app must purge the stackC object before calling its destructor
true: pointers will always be d eleted
not true: if flSTACKc_COPY was not specified, then the stack just stores numbers and, if those numbers are pointers, the application is responsible for deleting them
if flSTACKc_COPY was specified during construction, then idType is used to d elete the copies that were placed onto the stack
  ifcSTACKtYPE_ANY
  ifcSTACKtYPE_tableC
 if the stackC object is one of the following types, it must not contain any plates when it is destroyed
  ifcSTACKtYPE_timeS
  ifcSTACKtYPE_nicNameC
  ifcSTACKtYPE_measureT   
  ifcSTACKtYPE_sCountT    
  ifcSTACKtYPE_countT
 if the stack is one of the following types, there is no object associated with each plate
  ifcSTACKtYPE_PTR_soulC
  ifcSTACKtYPE_PTR_nicNameC
  ifcSTACKtYPE_PTR_plateC
  ifcSTACKtYPE_PTR_count8S
  ifcSTACKtYPE_PTR_count7S
  ifcSTACKtYPE_PTR_count6S
  ifcSTACKtYPE_PTR_count5S
  ifcSTACKtYPE_PTR_count4S
  ifcSTACKtYPE_PTR_count3S
  ifcSTACKtYPE_PTR_count2S
  ifcSTACKtYPE_PTR_strokeS
 if the stack is one of the following types, the object pointed to by each plate will be d eleted
i will d elete the object associated with each plate if i can
  \<A HREF=\"5.cb10104.1.1.0.html\"\>cb10104:  WAKEsHOW( "example.simplest.func.1150002.stackC.dt_stackC" )\</A\>
 simplest
examples
\<A HREF=\"5.1150002.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

