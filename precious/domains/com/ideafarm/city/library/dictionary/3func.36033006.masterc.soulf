
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        b_cLever.ungrabF( tinP ) ;
        }
            __( pbc - pbe ) ;

            }
                }
                    }
                        }
                            while( !ether && ~handle ) ;
                            }
                                *(countT*)pbc = stUses.upF( tinP , handle ) ; pbc += sizeof( countT ) ;
                            {
                            do
                            handleC handle( tinP , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        {
                        if( stUses )

                        *(countT*)pbc = stUses   ; pbc += sizeof( countT ) ;
                        *(countT*)pbc = pc3n->c2 ; pbc += sizeof( countT ) ;
                        *(countT*)pbc = pc3n->c1 ; pbc += sizeof( countT ) ;

                        stackC& stUses = *(stackC*)pc3n->c3 ;
                    {
                    else
                    if( !pc3n->c3 ) __1
                {
                else
                if( !pc3n ) __1
                count3S*& pc3n = (count3S*&)(countT&)swc3 ;

                *(countT*)pbc = cLever = swc3.leverF( tinP , idf ) ; pbc += sizeof( countT ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )

            *(countT*)pbc = cFlavors                   ; pbc += sizeof( countT ) ;
            *(countT*)pbc = idCopyHW                   ; pbc += sizeof( countT ) ;
            *(countT*)pbc = cbn - 3 * sizeof( countT ) ; pbc += sizeof( countT ) ;
            *(countT*)pbc = 1                          ; pbc += sizeof( countT ) ;
            putNegAM( *(countT*)pbc , FINGERnEG_SOULc ) ; pbc += sizeof( countT ) ;
            byteT* pbe = pbSoulP + cbn ;
            byteT* pbc = pbSoulP ;
        {
        if( pbSoulP )
        ether.newF( tinP , LF , pbSoulP , cbn ) ; ___( pbSoulP ) ;

        }
            }
                }
                    cbn += sizeof( countT ) * stUses ;      // FOR EACH PLATE: value
                    stackC& stUses = *(stackC*)pc3n->c3 ;
                {
                else
                if( !pc3n->c3 ) __1
            {
            else
            if( !pc3n ) __1
            count3S*& pc3n = (count3S*&)(countT&)swc3 ;
            cLever = swc3.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cbn = sizeof( countT ) * ( 5 + cFlavors * 4 ) ; // FINGERPRINT , IDFORMAT , LENGTHpREFIX , idCopyHW , cFlavors ; FOR EA FLAVOR: cLever , flags , idCopy , cPlates

        const countT cFlavors = swc3.cFlavorsF( tinP ) ;
        b_cLever.grabF( tinP , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) ) ;
    {
    else
    if( tinP.pAdamGlobal1->_masterOldC_.pMePrime != this ) tinP.pAdamGlobal1->_masterOldC_.pMePrime->soulF( tinP , pbSoulP ) ;

    }
        if( POOP ) return ;
        __NZ( pbSoulP ) ;
        __( !tinP.pAdamGlobal1->_masterOldC_.pMePrime ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    upDnC upDn( tinP , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) , IDFILE , ether ) ;
    scoopC scoop( tinP , LF , ether ) ;
{
/*1*/voidT masterOldC::soulF( tinS& tinP , byteT*& pbSoulP )/*1*/

/**/
*/
\<A HREF=\"5.1490006.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$soulF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

