
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_
    }
        //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/cleaning up") , flSAY_APPEND | flSAY_LOG ) ;
        }
            //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/disconnecting from local chat server") , flSAY_APPEND | flSAY_LOG ) ;
            }
                //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/destroying sgnReadTested") , flSAY_APPEND | flSAY_LOG ) ;
                }
                    //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/destroying sgnDone_tmStackCourses") , flSAY_APPEND | flSAY_LOG ) ;
                    sgnDone_tmStackCourses.waitF( tinP ) ;
                    //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/waiting for tmStackCourses to end") , flSAY_APPEND | flSAY_LOG ) ;
                    }
                        stOrdersP.ungrabF( tinP ) ;
                        }
                            DEL( psOrder ) ;
                            }
                                else            soUp.writeF( tinP , *psOrder ) ;
                                if( !*psOrder ) bEmpty = 1 ;
                            {
                            if( psOrder )
                            stOrdersP >> psOrder ;
                            ZE( soulC* , psOrder ) ;
                        {
                        while( !POOP && stOrdersP && !bEmpty )
                        //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/emptying stOrdersP") , flSAY_APPEND | flSAY_LOG ) ;
                        stOrdersP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/grabbing stOrdersP") , flSAY_APPEND | flSAY_LOG ) ;
                        stOrdersP.waitF( tinP ) ;
                        //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/waiting for an order to be pushed into stOrdersP") , flSAY_APPEND | flSAY_LOG ) ;
                    {
                    while( !POOP && !bEmpty )
                    ZE( boolT , bEmpty ) ;
                
                    //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/returned from waiting on sgnReadTested") , flSAY_APPEND | flSAY_LOG ) ;
                    if( !POOP ) sgnReadTested.waitF( tinP ) ;
                    //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/waiting for sgnReadTested") , flSAY_APPEND | flSAY_LOG ) ;
                    osThreadF( tinP , countTC() , tmStackCoursesF , &sgnDone_tmStackCourses , flTHREADlAUNCH_null , 0 , (countT)this , (countT)&stCoursesP , (countT)&soUp , (countT)&sgnReadTested , (countT)&stOrdersP , (countT)(strokeS*)psttOldC( tinP , *this , psttOldCommentP ) ) ;
                    signC sgnDone_tmStackCourses( tinP , TAG( TAGiDnULL ) ) ;
                {
                signC sgnReadTested( tinP , TAG( TAGiDnULL ) ) ;
            {

            soUp.writeF( tinP , sRelay ) ;
            //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/writing relay package soulC") , flSAY_APPEND | flSAY_LOG ) ;
            soUp.connectF( tinP , 0 , nicNameC() , 1 ) ;
            socketC soUp( tinP , *this , TAG( TAGiDnULL ) ) ;
        {
        //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/connecting to local chat server") , flSAY_APPEND | flSAY_LOG ) ;
    
        }
            ifcChatRelayPackageF( tinP , sRelay , sJob , idAdamP , T(psttOldCommentP)+T(" (ifcJobF/inner)") , 1 , 0 , nicNameP ) ;
    
            sJob << sOrderPrimaryP ;
            sJob << (boolT)0 ; // bAccepted
            nicNameP >> sJob ;
            sJob << idAdamP ;
            soulC sJob( tinP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcIDcMDsESSION_JOB ) ;
        {
        soulC sRelay( tinP , TAG( TAGiDnULL ) ) ;
        //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/setting up") , flSAY_APPEND | flSAY_LOG ) ;
        TN( tBar , "| " ) ;
    {
    _INoLD_

    }
        if( POOP ) return ;
        __Z( idAdamP ) ;
        __(  stOrdersP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_soulC ) ;
        __(  !( F(stOrdersP.flagsF(tinP)) & flSTACKc_GIVEsIGNnEWpLATE ) ) ;
        __(  !( F(stOrdersP.flagsF(tinP)) & flSTACKc_FIFO ) ) ;
        __(  stCoursesP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_soulC ) ;
        __(  !( F(stCoursesP.flagsF(tinP)) & flSTACKc_GIVEsIGNnEWpLATE ) ) ;
        __(  !( F(stCoursesP.flagsF(tinP)) & flSTACKc_FIFO ) ) ;
        __(  stCoursesP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::ifcJobF( stackC& stCoursesP , tinS& tinP , const countT idAdamP , soulC& sOrderPrimaryP , stackC& stOrdersP , const strokeS* const psttOldCommentP , const nicNameC nicNameP )/*1*/

/**/
*/
   nonze values are supported to facilitate debugging
  it is bad style to specify a nonze value
  specify a nonze value if the cell at the specified host is to handle the job
  normally should be 0
  can be 0
 nicNameP
  for such dialogs, the caller puts outgoing orders onto stOrdersP and monitors stCoursesP for incoming results
  the caller and the job doer cell can, but need not, dialog in full duplex while the job is in progress
  contains all orders other than the primary order
  can be empty
  must be flSTACKc_FIFO
  must be flSTACKc_GIVEsIGNnEWpLATE
 stOrdersP
  normally this will contain all information needed for the job, and stOrdersP will be empty
  this is the order that defines the job
 sOrderPrimaryP
 idAdamP
 tinP
  must be empty
  must be flSTACKc_FIFO
  must be flSTACKc_GIVEsIGNnEWpLATE
 stCoursesP
arguments
 wait for the course receiving thread to end
 until an empty order has been sent
  remove all items in stOrdersP, writing each
  wait for a new item to be placed onto stOrdersP
 forever
    if the course is not empty, stack it
    extract the course from the tray
    if the tray is empty then break
    read a tray
   forever
  protocol for this thread
 launch a thread to receive courses into stCoursesP
 remove the wo'th order, wrap it into the relay package, and write it
 connect to idAdamP via relay chat
protocol
  the caller can then remove all courses that have not already been removed by its attendant thread
  when all courses have been put onto stCoursesP, i will return
   this thread can end at any time during job processing as long as it has put an empty order onto stOrdersP
    the contents of such an order would be defined by the particular idAdam
   this thread can put an interrupt style cancel order onto stOrdersP to tell the server to cancel the job
    it -must- serialize properly
   this thread can either traverse stCoursesP or empty it as courses are placed onto it
   this thread -must- eventually place an empty order onto stOrdersP
  caller launches a thread to monitor the contents of stCoursesP
  caller places at least the wo'th order for the job onto stOrdersP
 attended operation
  then the caller can obtain all of the courses produced by emptying stCoursesP
  i return when the job is complete
  the la'th order placed onto stOrdersP must be empty
  caller places all orders for the job onto stOrdersP before calling me
 unattended operation
usage models
 U: edit the protocol to implement a state commit dialog
   a notice of pending commit
   client must not send a null order until it has received a notice of pending commit
   job is not done until client's null order has been received
  state changes must not be committed until job is done
 acceptor cell and worker cell
requirements for the adam class
if a failure occurs after the connection spline is established, i will retry with a new connection spline
if a failure occurs while establishing the connection spline, i will retry
while the job is being done, other threads of the caller can communicate with the adam cell that is doing the work
i initiate an IdeaFarm " "(tm) City job and block until the job has been done
U: these comments might be obsolete; review them vis the actual code
\<A HREF=\"5.103017f.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$ifcJobF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

