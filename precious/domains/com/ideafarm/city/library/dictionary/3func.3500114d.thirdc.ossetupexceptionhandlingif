
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    processGlobal1I.flCt |= flCTdTg_exceptionHandlerRegistered ;

    #endif

        //THE COMMENT ON THE PRECEDING LINE MIGHT BE OBSOLETE ; IT IS LEFT OVER FROM WHEN SetErrorMode WAS CALLED ON A SINGLE LINE
        countT rc = tinP.brcRaw ; //DOC SAYS THAT THIS DOES NOTHING, BUT IT APPEARS TO WORK, AND ASSEMBLY CODE LOOKS LIKE IT IS DOING SOMETHING; BUT IT DOES ONLY RETURN A USELESS CONSTANT
        BOSdOnOTtEST( WHATgbo , SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX | SEM_NOGPFAULTERRORBOX ) )

    #if defined( __NT__ )

    BOSdOnOTtEST( WHATgbo , SetUnhandledExceptionFilter( pHandler ) ) //THIS IS DONE IN CT'OR IN ORDER TO AVOID NEEDING TO CT ANOTHER OBJECT EARLY IN THE GLOBAL STATIC LIST
    rootExceptionFilterFT pHandler = (rootExceptionFilterFT)rootExceptionFilterF ;

    //WINDOWS 7 BUG: THE HANDLER WILL BE CALLED RECURSIVELY IFF MAIN THREAD

    _INoLD_

    }
        if( POOP )  return ;
    {
    IFbEcAREFUL
{
/*1*/voidT thirdC::osSetupExceptionHandlingIF( tinS& tinP )/*1*/

#undef CsLOTS

}
    return rc ;
    //CONoUTrAW( "rootExceptionFilterF/-\r\n" ) ;

    }
        thirdC::dosExitProcessIF( ifcEXITcODEpROCESSiMPOTENT ) ;
        flagsResult |= flEXCEPTIONrESULT_EXITpROCESScALLED ;
        //CONoUTrAW( "rootExceptionFilterF: calling ExitProcess\r\n" ) ;
    {
    if( rc == EXCEPTION_EXECUTE_HANDLER )

    }
        //CONoUTrAW( "rootExceptionFilterF/2/-\r\n" ) ;
        }
            //CONoUTrAW( "rootExceptionFilterF/2/2/-\r\n" ) ;
            DELnOtIN( prFloat ) ;_M
            //CONoUTrAW( "rootExceptionFilterF/2/2/2\r\n" ) ;

            }
                }
                    break ;

                    //CONoUTrAW( "rootExceptionFilterF/2/2/1/3/- normal\r\n" ) ;
                    //etherC::ifcSayIF( processGlobal5I.tinBreak , "rootExceptionFilterF: normal report written\r\n" , flSAY_LOG | flSAY_APPEND ) ;

                    }
                        //CONoUTrAW( "rootExceptionFilterF/2/2/1/3/2/-\r\n" ) ;
                        pTinOffender->pTieLath = 0 ;
                        //CONoUTrAW( "rootExceptionFilterF/2/2/1/3/2/2\r\n" ) ;
                        //CONoUTrAW3( "rootExceptionFilterF 2 [rc]: " , rc , "\r\n" ) ;
                        rc = threadLocalStorageLocationF( 0 , 0 , 0 , (countT)&c8p ) ? EXCEPTION_CONTINUE_EXECUTION : EXCEPTION_EXECUTE_HANDLER ;_M
                        //CONoUTrAW( "rootExceptionFilterF/2/2/1/3/2/1\r\n" ) ;
                        thirdC::c_memcpyIF( poopC() , pTinOffender->pTieLath->pbTin , (byteT*)pTinOffender , sizeof pTinOffender->pTieLath->pbTin ) ;_M
                        thirdC::c_memsetIF( (byteT*)pTinOffender->pTieLath , sizeof *pTinOffender->pTieLath ) ;_M
    
                        pTinOffender->pTieLath = &tellInfo ;_M
                        tellInfoExceptionS tellInfo ;_M
                        //CONoUTrAW( "rootExceptionFilterF/2/2/1/3/2/+\r\n" ) ;
                    {_M
                    else
                    }
                        //CONoUTrAW( "rootExceptionFilterF/2/2/1/3/1/-\r\n" ) ;
                        rc = threadLocalStorageLocationF( 0 , 0 , 0 , (countT)&c8p ) ? EXCEPTION_CONTINUE_EXECUTION : EXCEPTION_EXECUTE_HANDLER ;_M
                        //CONoUTrAW( "rootExceptionFilterF/2/2/1/3/1/1\r\n" ) ;
    
                        thirdC::c_memcpyIF( poopC() , pTinOffender->pTieLath->pbTin , (byteT*)pTinOffender , sizeof pTinOffender->pTieLath->pbTin ) ;_M
                        thirdC::c_memsetIF( (byteT*)pTinOffender->pTieLath , sizeof *pTinOffender->pTieLath ) ;_M
                        //CONoUTrAW( "rootExceptionFilterF/2/2/1/3/1/+\r\n" ) ;
                    {_M
                    if( pTinOffender->pTieLath )
                    count8S c8p( (countT)&osInfo , (countT)&idMile , ebpOffender , (countT)&prFloat ) ;

                    //etherC::ifcSayIF( processGlobal5I.tinBreak , "rootExceptionFilterF: beginning to write my normal report\r\n" , flSAY_LOG | flSAY_APPEND ) ;
                    //CONoUTrAW( "rootExceptionFilterF/2/2/1/3/+ normal\r\n" ) ;
                {_M
                case normalE :
                }
                    break ;

                    //CONoUTrAW( "rootExceptionFilterF/2/2/1/2/- short\r\n" ) ;
                    //logGF( ostoBuf , "d:\\tm p\\ideafarm.log.exception" ) ;
                    // 20150105@1803: DEPRECATED CAUSE NONCONFORMANT (USES C:\TMP)
                    OStEXTAK( ostoBuf , "\r\n" ) ;_M
                    }
                        }
                            break ;
                            }
                                OStEXTC( ostoBuf , osInfo.ExceptionRecord->ExceptionInformation[ off ] , 0 ) ; _M
                                OStEXTAK( ostoBuf , "\r\nnote: " ) ;_M
                            {_M
                            for( countT off = 0 ; off < osInfo.ExceptionRecord->NumberParameters ; off ++ )
                        {_M
                        case ifcIDeVENTeXCEPTIONmONITORED_GRUNT & 0xefffffff : //WINDOWS CLEARS BIT 28 IN RaiseException(...)
                        }
                            break ;
                            OStEXTC( ostoBuf , osInfo.ExceptionRecord->ExceptionInformation[ 1 ] , 0 ) ; _M
                            OStEXTAK( ostoBuf , "\r\npvTarget: " ) ;_M
                            OStEXTC( ostoBuf , !!osInfo.ExceptionRecord->ExceptionInformation[ 0 ] , 0 ) ; _M
                            OStEXTAK( ostoBuf , "\r\nbWrite: " ) ;_M
                        {_M
                        case EXCEPTION_ACCESS_VIOLATION                          :
                    {
                    switch( osInfo.ExceptionRecord->ExceptionCode )
                    OStEXTC( ostoBuf , osInfo.ExceptionRecord->ExceptionCode , 0 ) ; _M
                    OStEXTAK( ostoBuf , "\r\nbase os exception code: " ) ;_M
                    OStEXTC( ostoBuf , osInfo.ContextRecord->Eip , 0 ) ; _M
                    OStEXTAK( ostoBuf , "\r\noffending code address: " ) ;_M
                    OStEXTA( ostoBuf , processGlobal1I.postDllsLoaded ) ;_M
                    OStEXTAK( ostoBuf , "\r\ndll load history: " ) ;_M
                    OStEXTC( ostoBuf , processGlobal1I.cDllLoaded , 0 ) ;_M
                    OStEXTAK( ostoBuf , "\r\ncDllLoaded: " ) ;_M
                    OStEXTC( ostoBuf , rootAdamGlobal1I._thirdC_.cAllOrphanThreads , 0 ) ;_M
                    OStEXTAK( ostoBuf , "\r\ncAllOrphanThreadsI (root adam): " ) ;_M
                    OStEXTC( ostoBuf , rootAdamGlobal1I._thirdC_.cAllKidThreads , 0 ) ;_M
                    OStEXTAK( ostoBuf , "\r\ncAllKidThreadsI (root adam): " ) ;_M
                    }
                        OStEXTC( ostoBuf , rootAdamGlobal1I._etherC_.pcUtility[ off ] , 0 ) ;_M
                        OStEXTAK( ostoBuf , "]: " ) ;_M
                        OStEXTC( ostoBuf , off , 0 ) ;_M
                        OStEXTAK( ostoBuf , "\r\nroot adam: etherC::pcUtilityI[" ) ;_M
                    {
                    for( off = 0 ; off < CCuTILITY ; off ++ )
                    }
                        OStEXTC( ostoBuf , processGlobal1I.pcPhaseLow[ off ] , 0 ) ;_M
                        OStEXTAK( ostoBuf , "]: " ) ;_M
                        OStEXTC( ostoBuf , off , 0 ) ;_M
                        OStEXTAK( ostoBuf , "\r\netherC::pcPhaseLowI[" ) ;_M
                    {
                    for( off = 1 ; off <= ClOWtHREADS ; off ++ )
                    OStEXTC( ostoBuf , processGlobal1I.idHome , 0 ) ; _M
                    OStEXTAK( ostoBuf , "\r\nprocessGlobal1I.idHome: " ) ;_M
                    OStEXTCmIN( ostoBuf , processGlobal1I.idAdamRoot , 7 ) ; _M
                    OStEXTAK( ostoBuf , "\r\nidAdamI: " ) ;_M
                    }
                        OStEXTC( ostoBuf , rootAdamGlobal1I.idPhaseAdam , 0 ) ;_M
                    {_M
                    else
                    }
                        OStEXTA( ostoBuf , postIdPhaseAdam ) ;_M
                    {_M
                    if( postIdPhaseAdam )
                    const osTextT* postIdPhaseAdam = processGlobal3I.mapProcessPhase( rootAdamGlobal1I.idPhaseAdam ) ;
                    OStEXTAK( ostoBuf , "\r\nidPhaseAdamI: " ) ;_M
                    if( off > ClOWtHREADS ) { OStEXTAK( ostoBuf , "\r\n(not a low thread of the root adam)" ) ;_M }
                    }
                        break ;
                        OStEXTAK( ostoBuf , "\"" ) ;_M
                        OStEXTA( ostoBuf , processGlobal2I.pLowThread[ off ].postThreadName ) ;_M
                        OStEXTAK( ostoBuf , "\r\npostThreadName: \"" ) ;_M
                        OStEXTC( ostoBuf , off , 0 ) ;_M
                        OStEXTAK( ostoBuf , "\r\nidThread: " ) ;_M

                        if( osTid != processGlobal2I.pLowThread[ off ].osTid ) continue ;
                    {_M
                    for( off = 1 ; off <= ClOWtHREADS ; off ++ )
                    ZE( countT , off ) ;
                    #endif
                        countT osTid = _brcRaw ;
                        BOSnOtIN( GetCurrentThreadId() )
                        ZE( countT , _brcRaw ) ;
                    #if defined( __NT__ )

                    OStEXTC( ostoBuf , idMileLag , 0 ) ;_M
                    OStEXTAK( ostoBuf , "idMile: " ) ;_M
                    OStEXTAK( ostoBuf , "\r\n" ) ;_M
                    OStEXTAK( ostoBuf , "routine encountered a problem.\r\n" ) ;_M
                    OStEXTAK( ostoBuf , "This is an abridged report because the nifty swifty exception reporting\r\n" ) ;_M
                    OStEXTAK( ostoBuf , "\r\n" ) ;_M
                    OStEXTAK( ostoBuf , "Wo'O Ideafarm\r\n" ) ;_M
                    OStEXTAK( ostoBuf , "http://ideafarm.com\r\n" ) ;_M
                    OStEXTAK( ostoBuf , "IdeaFarm " "(tm) Piggyback Distributed Operating System\r\n" ) ;_M
                    OStEXTAK( ostoBuf , "\r\n" ) ;_M
                    OStEXTAK( ostoBuf , "Subject: IPDOS (tm) Exception Event\r\n" ) ;_M
                    OStEXT( ostoBuf , TUCK * 0x20 ) _M
                    //CONoUTrAW( "rootExceptionFilterF/2/2/1/2/+ short\r\n" ) ;
                {_M
                case shortE :
                }
                    break ;

                    //CONoUTrAW( "rootExceptionFilterF/2/2/1/1/- tiny\r\n" ) ;
                    //logGF( ostoBuf , "d:\\tm p\\ideafarm.log.exception" ) ;
                    //OStEXTAK( ostoBuf , "routine and the simple reporting routine encountered problems.\r\n" ) ;_M
                    //OStEXTAK( ostoBuf , "This is a stub report because both the nifty swifty exception reporting\r\n" ) ;_M
                    //OStEXTAK( ostoBuf , "\r\n" ) ;_M
                    //OStEXTAK( ostoBuf , "Wo'O Ideafarm\r\n" ) ;_M
                    //OStEXTAK( ostoBuf , "http://ideafarm.com\r\n" ) ;_M
                    //OStEXTAK( ostoBuf , "IdeaFarm " "(tm) Piggyback Distributed Operating System\r\n" ) ;_M
                    //OStEXTAK( ostoBuf , "\r\n" ) ;_M
                    //OStEXTAK( ostoBuf , "Subject: IPDOS (tm) Exception Event\r\n" ) ;_M
                    //OStEXT( ostoBuf , TUCK << 2 ) _M
                    // 20150105@1803: DEPRECATED CAUSE NONCONFORMANT (USES C:\TMP)

                    //CONoUTrAW( "rootExceptionFilterF/2/2/1/1/+ tiny\r\n" ) ;
                {_M
                case tinyE :
            {
            switch( eTypeReport )
            //CONoUTrAW( "rootExceptionFilterF/2/2/1\r\n" ) ;

            else                                                                                                                             eTypeReport = normalE ; // FULL INFORMATION
            else if( idIn == 1 || ( prFloat && *prFloat == 1 ) || !pTinOffender || getNegAM( pTinOffender->fingerprint ) != FINGERnEG_TINs ) eTypeReport = shortE  ; // NO tinS INFORMATION
            else if( idIn == 2 || ( prFloat && *prFloat == 2 )                                                                             ) eTypeReport = tinyE   ; // NO INFO ; JUST A SINGLE LINE OF TEXT TO INDICATE THAT THE SHORT REPORT COULD NOT BE WRITTEN
                 if( idIn >  2 || ( prFloat && *prFloat >  2 )                                                                             ) eTypeReport = nullE   ; // PREVENTS SPIN 

            enum { normalE , shortE , tinyE , nullE } eTypeReport ;
            //CONoUTrAW( "rootExceptionFilterF/2/2/0/4\r\n" ) ;

            ;
                : pTin2AM( ebpOffender )                        //MUST NOT MODIFY *pTinOffender UNTIL IT HAS BEEN COPIED
                ? 0
            tinS* pTinOffender = !prFloat || *prFloat || !ebpOffender
            const countT ebpOffender = osInfo.ContextRecord ? osInfo.ContextRecord->Ebp : 0 ;_M
            //CONoUTrAW( "rootExceptionFilterF/2/2/0/3\r\n" ) ;

            const countT idMileLag = idMile ;
            if( prFloat ) getRegsAM( prFloat->pcRegisters ) ; /*Z*/ //MY RESTART POINT IS HERE, IMMEDIATELY AFTER THE RETURN OF getRegsAM
            ZE( countT , idMile ) ;
            //CONoUTrAW( "rootExceptionFilterF/2/2/0/2\r\n" ) ;

            }
                if( !prFloat ) idIn = 1 + incv02AM( idInLath ) ;
                static countT idInLath ;
            {
            ZE( countT , idIn ) ;
            //CONoUTrAW( "rootExceptionFilterF/2/2/0/1\r\n" ) ;

            // prFloat WILL NORMALLY BE NONZE BUT WILL BE ZE IF NO SLOT AVAILABLE
            }
                }
                    break ;
                    prFloat = new( 0 , (byteT*)( (restartC*)pbzTop + offm ) , sizeof( restartC ) ) restartC( prFloat ) ;
                    //U::ASSUME: processGlobal5I.tinBreak IS NOT MODIFIED BY THIS CALL
                    //CONoUTrAW5( "rootExceptionFilterF set [osTidMe,offm]: " , osTidMe , " " , offm , "\r\n" ) ;
                {
                if( !setIfZeAM( ((restartC*)pbzTop)[ offm ].osTid , osTidMe ) )
            {
            for( countT offm = 0 ; offm < CsLOTS ; offm ++ )
            //CONoUTrAW( "rootExceptionFilterF/2/2/+\r\n" ) ;
        {
        else
        }
            //CONoUTrAW( "rootExceptionFilterF/2/1/-\r\n" ) ;
            rc = EXCEPTION_CONTINUE_EXECUTION ;

            #endif
                osInfo.ContextRecord->SegCs  = prFloat->pcRegisters[ 0xf ] ;
                osInfo.ContextRecord->SegSs  = prFloat->pcRegisters[ 0xe ] ;
                osInfo.ContextRecord->SegGs  = prFloat->pcRegisters[ 0xd ] ;
                osInfo.ContextRecord->SegFs  = prFloat->pcRegisters[ 0xc ] ;
                osInfo.ContextRecord->SegEs  = prFloat->pcRegisters[ 0xb ] ;
                osInfo.ContextRecord->SegDs  = prFloat->pcRegisters[ 0xa ] ;
                osInfo.ContextRecord->EFlags = prFloat->pcRegisters[ 0x9 ] ;
                osInfo.ContextRecord->Eip    = prFloat->pcRegisters[ 0x8 ] ;
                osInfo.ContextRecord->Esp    = prFloat->pcRegisters[ 0x7 ] ;
                osInfo.ContextRecord->Ebp    = prFloat->pcRegisters[ 0x6 ] ;
                osInfo.ContextRecord->Edi    = prFloat->pcRegisters[ 0x5 ] ;
                osInfo.ContextRecord->Esi    = prFloat->pcRegisters[ 0x4 ] ;
                osInfo.ContextRecord->Edx    = prFloat->pcRegisters[ 0x3 ] ;
                osInfo.ContextRecord->Ecx    = prFloat->pcRegisters[ 0x2 ] ;
                osInfo.ContextRecord->Ebx    = prFloat->pcRegisters[ 0x1 ] ;
                osInfo.ContextRecord->Eax    = prFloat->pcRegisters[ 0x0 ] ;
            #if defined( __NT__ )
    
            if( !( F(prFloat->flags) & flRESTARTc_DOnOTtALLY ) ) prFloat->cRestarted ++ ;
            //CONoUTrAW( "rootExceptionFilterF/2/1/+\r\n" ) ;
        {
        if( prFloat ) //IF I HAVE ALREADY CREATED A restartC OBJECT FOR THIS THREAD THEN EXCEPTION MUST HAVE OCCURED WHILE I WAS EXECUTING

        #endif

            //fileWriteGF( "d:\\tm p\\cinfo" , (byteT*)&processGlobal1I.cInfo , sizeof processGlobal1I.cInfo ) ;
            //fileWriteGF( "d:\\tm p\\einfo" , (byteT*)&processGlobal1I.eInfo , sizeof processGlobal1I.eInfo ) ;

            thirdC::c_memcpyIF( poopC() , (byteT*)&processGlobal1I.cInfo , (byteT*)osInfo.ContextRecord   , sizeof processGlobal1I.cInfo ) ;
            thirdC::c_memcpyIF( poopC() , (byteT*)&processGlobal1I.eInfo , (byteT*)osInfo.ExceptionRecord , sizeof processGlobal1I.eInfo ) ;

        #if defined( __NT__ )
        //MAKE A COPY ; THE EXCEPTION HANDLING SUBYSTEM (me and thirdC::osExceptionHandlerWorkIF) DO NOT USE THE COPY ; IT IS JUST MADE FOR GLASS WALLS ; FOR EXAMPLE, AN ADAM USED TO DEBUG ME USES THE COPY TO CALL ME

        _EXCEPTION_POINTERS& osInfo = *(_EXCEPTION_POINTERS*)pvOsInfoP ;

        }
            }
                break ;
                prFloat = (restartC*)pbzTop + offm ;
            {
            if( osTidMe == ((restartC*)pbzTop)[ offm ].osTid )
            //CONoUTrAW5( "rootExceptionFilterF search [osTidMe,osTidRegistered]: " , osTidMe , " " , ((restartC*)pbzTop)[ offm ].osTid , "\r\n" ) ;
        {
        for( countT offm = 0 ; offm < CsLOTS ; offm ++ )
        ZE( restartC* , prFloat ) ; // "FLOAT": "THIS restartC INSTANCE FLOATS ABOVE THE TOP restartC INSTANCE IN THE RESTART STACK FOR THIS THREAD" ; IT IS USED TO DETECT AND RECOVER FROM EXCEPTIONS THAT OCCUR IN ME

        const countT osTidMe = _brcRaw ;
        BOSnOtIN( GetCurrentThreadId() )
        ZE( countT , _brcRaw ) ;
        static byteT pbzTop[ CsLOTS * sizeof( restartC ) ] ;
        //CONoUTrAW( "rootExceptionFilterF/2/+\r\n" ) ;
    {
    else
    }
        //CONoUTrAW( "rootExceptionFilterF/1/-\r\n" ) ;
        BOSnOtIN( Beep( 0x0200 , 0x100 ) )
        BOSnOtIN( Beep( 0x0400 , 0x100 ) )
        BOSnOtIN( Beep( 0x0800 , 0x100 ) )
        BOSnOtIN( Beep( 0x1000 , 0x100 ) )
        ZE( countT , _brcRaw ) ;

        //CONoUTrAW( "rootExceptionFilterF/1/+\r\n" ) ;
    {
    if( !pvOsInfoP )

    if( F(flagsResult) & flEXCEPTIONrESULT_EXITpROCESScALLED ) thirdC::dosExitProcessIF( ifcEXITcODEpROCESSiMPOTENT ) ; //EXCEPTION OCCURED DURING DLL TERMINATION ELICITED BY PRIOR CALL TO ExitProcess ; THIS CALL WILL KILL THE BEAST
    static flagsT flagsResult = flEXCEPTIONrESULT_null ;

    countT rc = EXCEPTION_EXECUTE_HANDLER ;

    //CONoUTrAW( "rootExceptionFilterF/+\r\n" ) ;
{
countT _stdcall rootExceptionFilterF( voidT* pvOsInfoP )

typedef long _stdcall (*rootExceptionFilterFT)( _EXCEPTION_POINTERS* pOsInfoP ) ;

#define CsLOTS 0x10

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

