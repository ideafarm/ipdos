
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

HEAReNTER( ether )
etThread.strokeF( tinP , T("\r\npress the enter key") ) ;

}
    etThread.strokeF( tinP , TF3(vv,0,2)+T("\t") ) ;

    stack >> vv ;
    ZE( countT , vv ) ;
{
while( stack )

while( cDone < cThreads ) etThread.osSleepF( tinP , TUCK * 32 ) ;
}
    etThread.osThreadF( tinP , tnu , tmF , 0 , flTHREADlAUNCH_null , 0 , (countT)&stack , idt , (countT)&cDone ) ;
    ZE( countT , tnu ) ;
{
for( countT idt = 1 ; idt <= cThreads ; idt ++ )
const countT cThreads = 8 ;

ZE( countT , cDone ) ;

stackC stack( tinP , ether , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmF )
}
    cDone ++ ;

    stack.ungrabF( tinP ) ;
    }
        etThread.osSleepF( tinP , TUCK ) ;
        stack << idThread * 0x10 + digit ;
    {
    for( countT digit = 1 ; digit <= 0xa ; digit ++ )
    stack.grabF( tinP , TAG( TAGiDnULL ) ) ;

    countT& cDone    = *(countT*)pTaskP->c3 ;
    countT  idThread =           pTaskP->c2 ;
    stackC& stack    = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmF )

/*1*/WAKEhIDE( "example.simplest.func.1150025.stackC.operator_decrement" )/*1*/
/**/
*/
\<A HREF=\"5.fd10104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

