
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

//etThread.traceF( tinP , T("ok") ) ;

}
    etThread.traceF( tinP , T("ACCESSeVENTS2bOOKtOGETHER napped") ) ;
    ++ s ; ether.osSleepF( tinP , TICK ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    etThread.traceF( tinP , T("ACCESSeVENTS2bOOKtOGETHER napping [cOut,cIn]:    ")+TF2(cIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    while( !ether && ~hFind && !POOP ) ;
    }
        DEL( pInfo ) ;
        }
            }
                if( idBookWoth && idBookLath ) etThread.diskMoveFileOrDirF( tinP , tToAll+tBookDot+TF3(idBookWoth,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot+TF3(idBookLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot+tShort , tIfoName , 0 ) ;

                }
                    etThread.delF( tinP , pstt1Lines ) ;
    
                    }
                        ++ cOut ;
                        if(  idBookLath < idBook ) idBookLath = idBook ;
                        if( !idBookWoth          ) idBookWoth = idBook ;
                        countT idBook = bksAccessEvents.writeF( tinP , (byteT*)&cbo , sizeof cbo , WS( soulRecord ) , flBOOKScwRITE_ALLOWoDDlENGTH | flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ELSEfILLtOeND , 0 ) ;

                        //etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS2bOOKtOGETHER: writing an event") ) ;

                        countT cbo = soulRecord.cbF( tinP ) ;
    
                        soulRecord << (strokeS*)tBrowser ;
                        soulRecord << cbRequest ;
                        soulRecord << code ;
                        soulRecord << (strokeS*)tProtocol ;
                        soulRecord << (strokeS*)tQuery ;
                        soulRecord << (strokeS*)tUri ;
                        soulRecord << (strokeS*)tContainer ;
                        soulRecord << (strokeS*)tLogBucket ;
                        soulRecord << (strokeS*)tMethod ;
                        soulRecord << nnHe ;
                        soulRecord << (countT)timeW2 ;
                        soulRecord << timeW1 ;
                        soulRecord << (countT)1 ;                                               // IDfORMAT
                        soulRecord << finger ;                                  finger = 0 ;    // finger IS 0'D OUT ASAP; IT IS BAD CODE STYLE TO LEAVE FINGERPRINT VALUES IN MEMORY BECAUSE IT IS IMPORTANT THAT FINGERPRINT VALUES NEVER EXIST EXCEPT WHERE THEY ARE SUPPOSED TO
                        soulC soulRecord( tinP , TAG( TAGiDnULL ) ) ;
    
                        putNegAM( finger, FINGERnEG_ACCESSeVENTrAW ) ;
                        ZE( countT , finger ) ;
    
                        //etThread.traceF( tinP , T("[nnHe,time,method,bucket,container,uri,query,protocol,code,cb,browser]:    \"")+tSay+tdq ) ;
    
                        //;
                        //
                        //    +tb4+tBrowser
                        //    +tb4+TF4(cbRequest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                        //    +tb4+TF4(code,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                        //    +tb4+tProtocol
                        //    +tb4+tQuery
                        //    +tb4+tUri
                        //    +tb4+tContainer
                        //    +tb4+tLogBucket
                        //    +tb4+tMethod
                        //    +tb4+TT(timeW1,timeW2)
                        //    +tb4+T(nnHe)
                        //    TF3(++cIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)
                        //
                        //TN( tSay , "" ) ; tSay =
    
                        }
                            if( tRawCbRequest.csF( tinP ) ) cbRequest = etThread.strDigitsToSCountF( tinP , tRawCbRequest , 0xa , 1 ) ;
    
                            if( tRawCode.csF( tinP ) ) code = etThread.strDigitsToSCountF( tinP , tRawCode , 0xa , 1 ) ;
    
                            }
                                //etThread.traceF( tinP , T("[uri" ":    \"")+tUri+tdq ) ;
                                //etThread.traceF( tinP , T("[urilong:    \"")+tUriLong+tdq ) ;
                                }
                                    etThread.delF( tinP , psttQuery ) ;
                                    etThread.delF( tinP , psttUri ) ;
                                    }
                                        tQuery = T(psttQuery) ;
                                        tUri   = T(psttUri) ;
                                    {
                                    else
                                    if( !idHit ) tUri = tUriLong ;
                                    countT idHit = etThread.strBisectF( tinP , psttUri , psttQuery , tUriLong , tQuestion , 1 , flSTRbISECT_null ) ; ___( psttUri ) ; ___( psttQuery ) ;
                                    ZE( strokeS* , psttQuery ) ;
                                    ZE( strokeS* , psttUri ) ;
                                {
                                if( tUriLong.csF( tinP ) )
    
                                etThread.delF( tinP , pstt5Words ) ;
                                }
                                    }
                                        }
                                            case 3 : { tProtocol = T(psttc5) ; break ; }
                                            case 2 : { tUriLong  = T(psttc5) ; break ; }
                                            case 1 : { tMethod   = T(psttc5) ; break ; }
                                        {
                                        switch( ++ idw )
                                    {
                                    FORsTRINGSiN5( pstt5Words )
                                    ZE( countT , idw ) ;
                                {
                                etThread.strWordsF( tinP , pstt5Words , tRawUri , sttq , tb , flSTRwORDS_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt5Words ) ;
                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                ZE( strokeS* , pstt5Words ) ;
                                TN( tUriLong , "" ) ;
    
                                // tRawUri      : GET /4e39b6468aeaa79a23d5-1252569462859d1220e63a54b0dcaa83.r91.cf5.rackcdn.com/robots.txt HTTP/1.1
                            {
                            if( tRawUri.csF( tinP ) )

                            }
                                }
                                    //if( v_dow ) ;
                                    //etThread.osTimeToOldTimeF( tinP , v_ms , v_ss , v_mm , v_hh , v_d , v_m , v_y , v_dow , timeW1 , timeW2 , flOStIMEfROMoLDtIME_OLDtIMEiSutc ) ;
                                    //ZE( countT , v_dow ) ;
                                    //ZE( countT , v_ms ) ;
                                    //ZE( countT , v_ss ) ;
                                    //ZE( countT , v_mm ) ;
                                    //ZE( countT , v_hh ) ;
                                    //ZE( sCountT , v_y ) ;
                                    //ZE( countT , v_m ) ;
                                    //ZE( countT , v_d ) ;
                                    // COMMENT OUT IN PRODUCTION; CAN BE USED TO VERIFY THAT THE CORRECT DOW IS IMPLIED BY timeW1 , timeW2
    
                                    etThread.osTimeFromOldTimeF( tinP , timeW1 , timeW2 , y , m , d , hh , mm , ss , 0 , flOStIMEfROMoLDtIME_OLDtIMEiSutc ) ;
    
                                    etThread.delF( tinP , pstt4Words ) ;
                                    }
                                        }
                                            }
                                                default: { etThread.traceF( tinP , T("unexpected time word [idw]:    ")+TF2(idw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttc4) ) ; break ; }
                                                case 6 : { ss = vv     ; break ; }
                                                case 5 : { mm = vv     ; break ; }
                                                case 4 : { hh = vv     ; break ; }
                                                case 3 : { y  = vv - 1 ; break ; }
                                                case 2 : { m  = vv - 1 ; break ; }
                                                case 1 : { d  = vv - 1 ; break ; }
                                            {
                                            switch( idw )
    
                                            ;
    
                                                                                                    : 0
                                                                                                    ? 0xc
                                                                                                : !etThread.strCompareF( tinP , psttc4 , tDec )
                                                                                                ? 0xb
                                                                                            : !etThread.strCompareF( tinP , psttc4 , tNov )
                                                                                            ? 0xa
                                                                                        : !etThread.strCompareF( tinP , psttc4 , tOct )
                                                                                        ? 0x9
                                                                                    : !etThread.strCompareF( tinP , psttc4 , tSep )
                                                                                    ? 0x8
                                                                                : !etThread.strCompareF( tinP , psttc4 , tAug )
                                                                                ? 0x7
                                                                            : !etThread.strCompareF( tinP , psttc4 , tJul )
                                                                            ? 0x6
                                                                        : !etThread.strCompareF( tinP , psttc4 , tJun )
                                                                        ? 0x5
                                                                    : !etThread.strCompareF( tinP , psttc4 , tMay )
                                                                    ? 0x4
                                                                : !etThread.strCompareF( tinP , psttc4 , tApr )
                                                                ? 0x3
                                                        : !etThread.strCompareF( tinP , psttc4 , tMar )
                                                        ? 0x2
                                                    : !etThread.strCompareF( tinP , psttc4 , tFeb )
                                                    ? 0x1
                                                : !etThread.strCompareF( tinP , psttc4 , tJan )
                                                ? etThread.strDigitsToSCountF( tinP , psttc4 , 0xa , 1 )
    
                                            countT vv = ++ idw != 2 || !bWindows
                                        {
                                        FORsTRINGSiN4( pstt4Words )
                                        ZE( countT , idw ) ;
                                    {
                                    ZE( countT , ss ) ;
                                    ZE( countT , mm ) ;
                                    ZE( countT , hh ) ;
                                    ZE( countT , y ) ;
                                    ZE( countT , m ) ;
                                    ZE( countT , d ) ;
    
                                    // | time word [idw]:    6    16                        29
                                    // | time word [idw]:    5    04                        00
                                    // | time word [idw]:    4    20                        10
                                    // | time word [idw]:    3    2018                      2018
                                    // | time word [idw]:    2    01                        Jun
                                    // | time word [idw]:    1    21                        18
                                    // |
                                    // | tRawTime       :    [21/01/2018:20:04:16           [18/Jun/2018:10:00:29
                                    //                       RACKSPACE                      WINDOWS
    
                                    etThread.strWordsF( tinP , pstt4Words , tRawTime , sttq , tTimeDelims , flSTRwORDS_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt4Words ) ;
                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                    ZE( strokeS* , pstt4Words ) ;
    
                                    // tRawTime (Windows Server): [18/Jun/2018:10:00:29
                                    // tRawTime (Rackspace)     : [21/01/2018:20:04:16
                                    //                            123456789abcdef012345
                                    //                            0              1
                                {
                                else
                                }
                                    tRawTime = tn ;
                                    etThread.traceF( tinP , T("unexpected Time format (probably IPv6) [bWindows,rawTime:    \"")+T(bWindows?"windows":"rackspace")+tb4+tRawTime+tdq ) ;
                                {
                                if( tRawTime.csF( tinP ) != 0x14 + bWindows )              // WINDOWS USES 3 CHAR FOR MONTH; RAX USES 2
                            {
                            if( tRawTime.csF( tinP ) )
    
                            }
                                //etThread.traceF( tinP , T("[ipv4]:    ")+TF2(ipv4,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                nnHe = ipv4 ;
                                etThread.delF( tinP , pstt3Words ) ;
                                }
                                    ipv4 = ( ipv4 << 8 ) | vv ;
                                    countT vv = etThread.strDigitsToSCountF( tinP , psttc3 , 0xa , 1 ) ;
                                {
                                FORsTRINGSiN3( pstt3Words )
                                ZE( countT , ipv4 ) ;
                                etThread.strWordsF( tinP , pstt3Words , tRawIP , sttq , tDot , flSTRwORDS_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt3Words ) ;
                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                ZE( strokeS* , pstt3Words ) ;
    
                                // CONJ: I HAVE CODE TO DO THIS FOR IPv4 ADDRESSES, BUT I CANNOT FIND IT
                            {
                            if( tRawIP.csF( tinP ) )
    
                            }
                                tRawIP = tn ;
                                etThread.traceF( tinP , T("unexpected IP format (probably IPv6):    \"")+tRawIP+tdq ) ;       //U:: ADD CODE TO HANDLE IPv6 VALUES
                            {
                            if( tRawIP.csF( tinP ) && etThread.strIdF( tinP , sttColon , tRawIP ) )
    
                            //etThread.traceF( tinP , T("tBrowser      : ")+tBrowser      ) ;
                            //etThread.traceF( tinP , T("tRawCbRequest : ")+tRawCbRequest ) ;
                            //etThread.traceF( tinP , T("tRawCode      : ")+tRawCode      ) ;
                            //etThread.traceF( tinP , T("tRawUri       : ")+tRawUri       ) ;
                            //etThread.traceF( tinP , T("tRawTime      : ")+tRawTime      ) ;
                            //etThread.traceF( tinP , T("tRawIP        : ")+tRawIP        ) ;
    
                            }
                                if( !etThread.strCompareF( tinP , *pptTo[ offt ] , tDash ) ) *pptTo[ offt ] = tn ;
                            {
                            for( countT offt = 0 ; offt < sizeof pptTo / sizeof pptTo[ 0 ] ; offt ++ )
                            textC* pptTo[] = { &tRawIP , &tRawTime , &tRawUri , &tRawCode , &tRawCbRequest , &tBrowser } ;
    
                            // tBrowser  : Mozilla/5.0 (compatible; DotBot/1.1; http://www.opensiteexplorer.org/dotbot, help@moz.com)
                            // tRawCbRequest : 344
                            // tRawCode      : 404
                            // tRawUri       : GET /4e39b6468aeaa79a23d5-1252569462859d1220e63a54b0dcaa83.r91.cf5.rackcdn.com/robots.txt HTTP/1.1
                            // tRawTime      : [21/01/2018:20:04:16
                            // tRawIP        : 216.244.66.247
    
                            //                123456789abcdef012345
                            //                0              1
    
                            }
                                etThread.delF( tinP , pstt2Words ) ;
                                }
                                    if( ptTo ) *ptTo = T(psttc2) ;
    
                                    }
                                        case 0xa : { ptTo = &tBrowser      ; break ; }
                                        case 0x8 : { ptTo = &tRawCbRequest ; break ; }
                                        case 0x7 : { ptTo = &tRawCode      ; break ; }
                                        case 0x6 : { ptTo = &tRawUri       ; break ; }
                                        case 0x4 : { ptTo = &tRawTime      ; break ; }
                                        case 0x1 : { ptTo = &tRawIP        ; break ; }
                                    {
                                    switch( ++ idw )
                                    ZE( textC* , ptTo ) ;
    
                                    //etThread.traceF( tinP , T("word:    ")+T(psttc2) ) ;
                                {
                                FORsTRINGSiN2( pstt2Words )
                                ZE( countT , idw ) ;
                                etThread.strWordsF( tinP , pstt2Words , psttc1 , sttq , tb , flSTRwORDS_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt2Words ) ;
                                strokeS sttq ;
                                //strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                ZE( strokeS* , pstt2Words ) ;
    
                                // a    browser                      Mozilla/5.0 (compatible; DotBot/1.1; http://www.opensiteexplorer.org/dotbot, help@moz.com)
                                // 9                                 -
                                // 8    cb                           344
                                // 7    responsecode                 404
                                // 6    method.uri.ver               GET /4e39b6468aeaa79a23d5-1252569462859d1220e63a54b0dcaa83.r91.cf5.rackcdn.com/robots.txt HTTP/1.1
                                // 5                                 +0000]
                                // 4    datetimeutc                  [21/01/2018:20:04:16
                                // 3                                 -
                                // 2                                 -
                                // 1    ipv4                         216.244.66.247
                            {
                            TN( tRawCbRequest , "" ) ;
                            TN( tRawCode      , "" ) ;
                            TN( tRawUri       , "" ) ;
                            TN( tRawTime      , "" ) ;
                            TN( tRawIP        , "" ) ;
                        {
                        TN( tBrowser , "" ) ;
                        ZE( countT , cbRequest ) ;
                        ZE( countT , code ) ;
                        TN( tProtocol , "" ) ;
                        TN( tQuery , "" ) ;
                        TN( tUri , "" ) ;
                        TN( tMethod , "" ) ;
                        ZE( sCountT , timeW2 ) ;
                        ZE( countT , timeW1 ) ;
                        nicNameC nnHe ;
    
                        // 216.244.66.247 - - [21/01/2018:19:08:26 +0000] "GET /838a98a1c3503d5080fc-0120a6193262fb464e305f722f61adc1.r53.cf5.rackcdn.com/2016/3/pages/index.z.white.4069b4cf.10000000.html HTTP/1.1" 200 13548 "-" "Mozilla/5.0 (compatible; DotBot/1.1; http://www.opensiteexplorer.org/dotbot, help@moz.com)"
                        // 204.213.85.999 - - [21/01/2018:23:58:02 +0000] "GET /v1/MossoCloudFS_921871/ipdos.home.registry?format=json HTTP/1.0" 200 7174 "-" "-"
                        TN( tMethodPlus , "" ) ;
    
                        //etThread.traceF( tinP , T("line:    \"")+T(psttc1)+tdq ) ;
                        ++ cIn ;
                    {
                    FORsTRINGSiN1( pstt1Lines )
    
                    etThread.delF( tinP , posti ) ;
                    etThread.strWordsF( tinP , pstt1Lines , T(posti) , sttq , tCRLF , flSTRwORDS_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1Lines ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , pstt1Lines ) ;
    
                    etThread.boxGetShadowF( tinP , posti , costi , pInfo->psttIfoName ) ; ___( posti ) ;
                    ZE( countT   , costi ) ;
                    ZE( osTextT* , posti ) ;
                {
                if( !ether && !POOP )
                ZE( countT , idBookLath ) ;
                ZE( countT , idBookWoth ) ;
    
                //etThread.traceF( tinP , tLogBucket+tb4+tContainer ) ;
    
                }
                    etThread.diskMoveFileOrDirF( tinP , tToRejected+tShort , tIfoName , 0 ) ;
                    etThread.traceF( tinP , T("file ignored because I could not obtain tLogBucket or tContainer [tShort]:    ")+tShort ) ;
                {
                if( !tLogBucket.csF( tinP ) || !tContainer.csF( tinP ) )
    
                }
                    etThread.delF( tinP , psttGot ) ;
                    tContainer = T(psttGot) ;
                    etThread.delF( tinP , psttnu ) ;
                    etThread.strBisectF( tinP , psttGot , psttnu , tContainerPlus , tDot , -6 , flSTRbISECT_null ) ; ___( psttGot ) ; ___( psttnu ) ;
                    ZE( strokeS* , psttnu ) ;
                    ZE( strokeS* , psttGot ) ;
    
                    //etThread.traceF( tinP , tContainerPlus ) ;
                    }
                        etThread.delF( tinP , psttGot ) ;
                        tContainerPlus = T(psttGot) ;
                        etThread.strSubstringF( tinP , psttGot , idf , idl , tAfterHey , 0 ) ; ___( psttGot ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        ZE( countT , idl ) ;
                        countT idf = 0x2e ; ;
                        ZE( strokeS* , psttGot ) ;
                    {
                    TN( tContainerPlus , "" ) ;     // web.archiveview.2018.01.21.20.53c96b155170cfa84d4a67396da97101.log
    
                    //etThread.traceF( tinP , tAfterHey ) ;
    
                    }
                        }
                            etThread.delF( tinP , psttGot ) ;
                            tAfterHey = T(psttGot) ;
                            etThread.strSubstringF( tinP , psttGot , idf , idl , tShort , 0 ) ; ___( psttGot ) ;
                            ZE( countT , idl ) ;
                        {
                        if( idf )
    
                        etThread.delF( tinP , psttGot ) ;
                        tLogBucket = T(psttGot) ;
                        etThread.strSubstringF( tinP , psttGot , idf , sttq , tDotHeyDot , tShort , 0 , 0 ) ; ___( psttGot ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        countT idf = 0x23 ;
                        ZE( strokeS* , psttGot ) ;  // 0              1               2
                    {                               // 123456789abcdef0123456789abcdef0123456789abcdef
                    TN( tAfterHey , "" ) ;          // 00b0d3bc.21f75cd8.9d7e9628.0a810000.4a810000.web.archiveview.2018.01.21.20.53c96b155170cfa84d4a67396da97101.log
                {
                else
                }
                    tContainer = tContainerFactory2 ;
                    tLogBucket = tLogBucketWindowsServer ;
                    bWindows = 1 ;
                {
                if( tShort.csF( tinP ) == tExampleWindowsServerFileName.csF( tinP ) && 1 == etThread.strIdF( tinP , tExampleWindowsServerFileNameProlog , tShort ) )
                TN( tContainer , "" ) ;         // ipdos.home.registry
                TN( tLogBucket , "" ) ;         // .CDN_ACCESS_LOGS
                ZE( boolT , bWindows ) ;
    
                // THE CODE THAT FOLLOWS IGNORES GROUPING AND PROCESSES EACH INCOMING LINE INDEPENDENTLY
                // THE ELEMENTARY INCOMING TRANSACTION IS A CRLF DELIMITED LINE ; THESE LINES ARE GROUPED INTO FILES, BUT THE GROUPING HAS NO SIGNIFICANCE (THE GROUPING IS DETERMINED BY THE RACKSPACE REPORTING PERIOD AS WELL AS FILE SIZE)
    
                // ACC: 204.13.85.99   - - [21/01/2018:23:39:02 +0000] "GET /v1/MossoCloudFS_921871/ipdos.home.registry?format=json&marker=ideafarmcitygmailcom%2ef9d60a58d6eb82ff11e4dc8c11fd9f1a%2ehome%2etxt HTTP/1.0" 200 2     "-" "-"
                // CDN: 216.244.66.236 - - [21/01/2018:20:25:06 +0000] "GET /838a98a1c3503d5080fc-0120a6193262fb464e305f722f61adc1.r53.cf5.rackcdn.com/2099/3/pages/index.z.black.ade76e37.1d300000.html HTTP/1.1"        200 13473 "-" "Mozilla/5.0 (compatible; DotBot/1.1; http://www.opensiteexplorer.org/dotbot, help@moz.com)"
    
                //                                0              1               2
                //                                123456789abcdef0123456789abcdef0123456789abcdef
                // BEGINNING OF SHORT FILE NAME: "cloud.access.log.entries.incoming..ACCESS_LOGS.!."

                }
                    etThread.delF( tinP , psttShort ) ;
                    tShort = T(psttShort) ;
                    etThread.delF( tinP , psttnu ) ;
                    etThread.strBisectF( tinP , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                    ZE( strokeS* , psttShort ) ;
                    ZE( strokeS* , psttnu ) ;
                {
                TN( tShort , "" ) ;            // .CDN_ACCESS_LOGS.!.00b0d3bc.21f75cd8.9d7e9628.0a810000.4a810000.web.archiveview.2018.01.21.18.0f687d0ce0e187c640bbe7d56b250a52.log
            {
            if( !bDir )
    
            const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
    
            TN( tIfoName , pInfo->psttIfoName ) ;
        {
        else
        }
            break ;
            DEL( pInfo ) ;
        {
        if( !pInfo || !pInfo->psttIfoName )
    
        etThread.diskFindFileOrDirOldF( tinP , pInfo , hFind , tNew+tStarDotLog ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    ZE( countT , cOut ) ;
    ZE( countT , cIn ) ;
{
while( !ether && !POOP )

TN( tDec , "Dec" ) ;
TN( tNov , "Nov" ) ;
TN( tOct , "Oct" ) ;
TN( tSep , "Sep" ) ;
TN( tAug , "Aug" ) ;
TN( tJul , "Jul" ) ;
TN( tJun , "Jun" ) ;
TN( tMay , "May" ) ;
TN( tApr , "Apr" ) ;
TN( tMar , "Mar" ) ;
TN( tFeb , "Feb" ) ;
TN( tJan , "Jan" ) ;            // WINDOWS SUCKS IN EVERY POSSIBLE WAY

TN( tContainerFactory2      , "factory2" ) ;
TN( tLogBucketWindowsServer , "windowsServer" ) ;
TN( tExampleWindowsServerFileNameProlog , "u_nc" ) ;
TN( tExampleWindowsServerFileName       , "u_nc18061615.log" ) ;
TN( tStarDotLog , "*.log" ) ;
TN( tCRLF , "\r\n" ) ;
TN( tTimeDelims , "[/:" ) ;
TN( tDotHeyDot , ".!." ) ;
TN( tDot   , "." ) ;
TN( tQuestion , "?" ) ;
TN( tdq  , "\"" ) ;
TN( tDash  , "-" ) ;
TN( tSlash , "/" ) ;
TN( tb4 , "    " ) ;
TN( tn , "" ) ;
TN( tb , " " ) ;
TN( tBookDot   , "book." ) ;
TN( tToRejected , "///d/tmp/cloud.access.log.entries.rejected/" ) ;
TN( tToAll     , "///d/tmp/cloud.access.log.entries.all/" ) ;
TN( tNew       , "///d/tmp/cloud.access.log.entries.new/" ) ;
strokeS sttColon( ':' ) ;

ether.ifcHireF( tinP , T("ifcIDaDAM_ACCESSeVENTS2bOOKtOGETHER") , ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE1 , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; //PRODUCTION

booksC bksAccessEvents( tinP , TAG( TAGiDnULL ) , "bksAccessEvents.1.raw" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER | flBOOKSc_RESETcREFoNcT , TICK >> 2 ) ;           // TOCK >> 6 IS GOOD FOR TESTING; I WILL RESET CREF IN ALL BOOKS        //A:ASSUME: I AM THE WOTH PROCESS TO OPEN THESE BOOKS DURING SYSTEM GEN
//THIS IS EARLY, BEFORE HIRING, BECAUSE THIS LINE WILL RESET CREF IN THE BOOKS

TODO

/*1*/WAKEhIDE( "ifcIDaDAM_ACCESSeVENTS2bOOKtOGETHER" )/*1*/
/**/
*/
i eat access events (soulC instances) from a booksC instance and add them to a persistent list (database)
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
