
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;



TODO

*/


 note: 1 bits only in lowest byte.  this is convenient
 do table lookup on only MS byte of the crc register
x**32 + x**7 5 3 2 1 0

XOR CRC by -1 before transmitting

don't initialize M to 0 -> can detect spurious leading 0 bits (instead, init to -1)

 CRC of (the data followed by CRC) == 0 always
 CRC of S||C is always 0
to check received data

 precalculate result of a bunch of shifts and XORs
for speed

 repeat 32 times
  (XOR it with the 32 low order bits of G)
 if a 1 got shifted off the left end, zap the register
 left shift 32 bits of S into 32 bit register M (one bit at a time)
pseudocode:

S /= G (the remainder is the crc "C")
S *= 0x100000000
S = bit sequence
G = 100000100110000010001110110110111

32 bit: x**32 + x**26 23 22 16 12 11 10 8 7 5 4 2 1 0 (AUTOINOII)
16 bit: x**16 + x**12 + x**5 + 1

PACKET: s1,s2,s3,...,sn,c1,c2 WHERE c1 IS LEAST SIGNIFICANT 8 BITS, c2 IS MOST SIG 8 BITS

    KERMIT          0           -1
    CRC-CCITT       0           -1
    -----           255         -1
    X.25            255         -1
    XMODEM          0           1

    CONVENTION      JINIT       JREV

/*

// FOR 32 BIT CHECKSUM: CALL WITH jrev = 1 FOR 16 BITS.  CALL AGAIN WITH jrev = - 1 FOR ANOTHER 16 BITS

}
    return (count01T)( jrev >= 0 ? cword : rchr[ MYhIbYTE( cword ) ] | rchr[ MYlObYTE( cword ) ] << 8 ) ;

    }
        cword = (count01T)( icrcFtb[ ( jrev < 0 ? rchr[ bufptr[ j ] ] : bufptr[ j ] ) ^ MYhIbYTE( cword ) ] ^ MYlObYTE( cword ) << 8 ) ;
    {
    for( j = 1 ; j <= len ; j ++ )

    else if( jrev  < 0  ) cword = (count01T)( rchr[ MYhIbYTE( cword ) ] | rchr[ MYlObYTE( cword ) ] << 8 ) ;
         if( jinit >= 0 ) cword = (count01T)( (byteT)jinit | ( (byteT)jinit << 8 ) ) ;

    }
        }
            rchr[ j ] = (byteT)( it[ j & 0xf ] << 4 | it[ j >> 4 ] ) ;
            icrcFtb[ j ] = (count01T)/*U:icrcF1*/ccriF( (count01T)( j << 8 ) , 0 ) ;
        {
        for( j = 0 ; j <= 255 ; j ++ )
        init = 1 ;
    {
    if( !init )

    static byteT it[ 0x10 ] = { 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 } ;
    count01T cword = crc ;
    count01T j ;
    static byteT rchr[ 0x100 ] ;
    static count01T init = 0 ;
    static count01T icrcFtb[ 0x100 ] ;
{
count01T icrcF( count01T crc , byteT* bufptr , countT len , count01T jinit , int jrev )

#define MYhIbYTE(x) (    (byteT)( (x) >> 8   )    )
#define MYlObYTE(x) (    (byteT)( (x) & 0xff )    )

}
    return ans ;

    }
        else               ans <<= 1 ;
        if( ans & 0x8000 ) ans = (count01T)( ( ans <<= 1 ) ^ 4129 ) ;
    {
    for( i = 0 ; i < 8 ; i ++ )
    count01T ans = (count01T)( crc ^ onech << 8 ) ;
    int i ;
{
count01T ccriF( count01T crc , byteT onech )

// CRC CODE

/*1*/WAKEhIDE( "doodle.cyclic.redundancy.checksum" )/*1*/
/**/
*/
\<A HREF=\"5.2530104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

