
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cWords ;

    _OUT_

    }
        }
            }
                }
                    cWords ++ ;
                    delF( tinP , psttd ) ;
                    POSTPONEtEST( pstt1P ) ;
                    else          strFuseSeparateF( tinP , *pSoulP , psttd , csttPrefixNullsP , csttSuffixNullsP , pGrabP  ) ;
                    if( !pSoulP ) strFuseSeparateF( tinP , pstt1P , psttd , csttPrefixNullsP , csttSuffixNullsP , pSoulP , pGrabP  ) ;
                    strSubstringF( tinP , psttd , idfDelim , idlDelim , psttP ) ; ___( psttd ) ;
                    ZE( strokeS* , psttd ) ;
                {
                else
                if( cTries ) csNeeded += CSpREFIX + idlDelim - idfDelim + 1 + csttPrefixNullsP + csttSuffixNullsP ;
            {
            if( bDelimiters && idfDelim )

            }
                }
                    delF( tinP , psttw3 ) ;

                    }
                        }
                            cWords ++ ;
                            else            strFuseSeparateF( tinP , *pSoulP , psttw3 , csttPrefixNullsP , csttSuffixNullsP , pGrabP ) ;
                            if( !pSoulP ) { strFuseSeparateF( tinP , pstt1P , psttw3 , csttPrefixNullsP , csttSuffixNullsP , pSoulP , pGrabP ) ; ___( pstt1P ) ; }
                            if( sttQuoteP.idCaste != sc_IGNOREqUOTES ) strReplaceF( tinP , psttw3 , 0 , pstt_sq , pstt_q , 0 , flSTRrEPLACE_IGNOREqUOTES ) ;
                        {
                        else
                        if( cTries ) csNeeded += CSpREFIX + psttw3->idAdam + csttPrefixNullsP + csttSuffixNullsP ;
                    {
                    if( !bOnlyDelimiters )

                    delF( tinP , psttw2 ) ;
                    }
                        strMakeF( tinP , psttw3 , psttw2 ) ; ___( psttw3 ) ;
                    {
                    else
                    }
                        }
                            strSubstringF( tinP , psttw3 , idf3 , idl3 , psttw2 ) ; ___( psttw3 ) ;
                            countT idl3 = psttw2->idAdam - 1 ;
                            countT idf3 = 2 ;
                        {
                        else
                        }
                            strMakeF( tinP , psttw3 , T("") ) ; ___( psttw3 ) ;
                        {
                        if( psttw2->idAdam == 2 )
                    {
                    if( sttQuoteP.idCaste != sc_IGNOREqUOTES && psttw2->idAdam > 1 && psttw2[ CSpREFIX ] == sttd && psttw2[ CSpREFIX - 1 + psttw2->idAdam ] == sttd )
                    strokeS sttd = S1C(0x22) ; //0x22 is a double quote
                    ZE( strokeS* , psttw3 ) ;
                    strSubstringF( tinP , psttw2 , idfSave , idw , psttP ) ; ___( psttw2 ) ;
                    ZE( strokeS* , psttw2 ) ;
                    if( idw > idfSave ) idw -- ;
                {
                if( !bIsDelimiter )

                }
                    ;

                        : !!strIdF( tinP , psttP[ CSpREFIX - 1 + idfSave ] , psttDelimiters )               // DOES THE DELIMITER STRING CONTAIN THE STROKE AT idfSave?
                        ? 1 == strIdF( tinP , 0 , flSTRmATCH_null , idf2 , sttq , psttDelimiters , psttP )                        // IS THE DELIMITER STRING                      AT idfSave?

                    bIsDelimiter = bDelimiterString

                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    countT idf2 = idfSave ;
                {
                ZE( boolT , bIsDelimiter ) ;
            {
            if( idfSave <= psttP->idAdam )

            //if( tinP.pc Utility[ 0 ] ) LOGrAW5( "[idfDelim,idlDelim]: " , idfDelim , " " , idlDelim , "\r\n" ) ;

            //traceF( tinP , T("[idfDelim,idlDelim]: ")+TF2(idfDelim,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(idlDelim,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG

            ;
                    : psttP->idAdam ;
                    ? idf - 1
                : idf
                ? 0
            countT idlDelim = !idfDelim
            countT idfDelim = idw ;

            ;
                : strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttQuoteP , psttDelimiters , psttP )
                ? strIdF   ( tinP , 0 , flSTRmATCH_null , idf , sttQuoteP , psttDelimiters , psttP )
            countT idw = bDelimiterString
            sttQuoteP = sttqSave ; //NEEDED WHEN INPUT CONTAINS AN UNPAIRED QUOTE
            countT idfSave = idf ;

            //traceF( tinP , T("[cTries,idf]: ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG
        {
        while( !POOP && idf )
        countT idf = 1 ;

        }
            POSTPONEtEST( pstt1P ) ;
            if( !pSoulP ) strMakeF( tinP , pstt1P , T("") , csNeeded + csttExtraP ) ; //CALLER MUST TAG ___( pstt1P )
        {
        if( !pstt1P && !cTries )
    {
    while( cTries -- )
    ZE( countT , cWords ) ;
    ZE( countT , csNeeded ) ;
    countT cTries = 1 + !pstt1P ;

    PSTT2( pstt_sq , '\\' , '\"' ) ;
    PSTT1( pstt_q  , '\"' ) ;

    //}
    //    PUSE( tinP , *(byteT**)&psttd ) ;
    //    LOGrAW( T(USCORE79 "\r\n\r\n")+T(tinP.monitor.idThread)+T("|psttP| ")+T(psttd)+T("\r\n") ) ;
    //    etherC::strDumpStrokesIF( tinP , psttd , psttP ) ; ___( psttd ) ;
    //    ZE( strokeS* , psttd ) ;
    //{
    //if( tinP.pc Utility[ 0 ] )

    const strokeS* psttDelimiters = psttDelimitersP ? psttDelimitersP : (strokeS*)tBlack ;
    TN( tBlack , TbLACK ) ;
    const strokeS sttqSave = sttQuoteP ;
    boolT bOnlyDelimiters  = !!( F(flagsP) & flSTRwORDS_ONLYdELIMITERS  ) ;
    boolT bDelimiters      = !!( F(flagsP) & flSTRwORDS_DELIMITERS      ) ;
    boolT bDelimiterString = !!( F(flagsP) & flSTRwORDS_DELIMITERsTRING ) ;

    _INoLD_

    }
        if( POOP ) return 0 ;
        __Z( psttP ) ;
        FV( flSTRwORDS , flagsP )
        //__NZ( pstt1P ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/countT etherC::strWordsF( tinS& tinP , strokeS*& pstt1P , const strokeS* const psttP , strokeS& sttQuoteP , const strokeS* psttDelimitersP , const flagsT flagsP , const countT csttExtraP , const countT csttPrefixNullsP , const countT csttSuffixNullsP , soulC* pSoulP , grabC* pGrabP )/*1*/

    aNameP[ CSpREFIX + 1 ] = ost2P ;
    aNameP[ CSpREFIX ] = ost1P ;                                                        \
    SETpREFIX( aNameP , 2 , 0 ) ;                                                       \
    strokeS aNameP[ CSpREFIX + 2 ] ;                                                    \
                                                                                        \
#define PSTT2(aNameP,ost1P,ost2P)                                                       \

    aNameP[ CSpREFIX ] = ost1P ;                                                        \
    SETpREFIX( aNameP , 1 , 0 ) ;                                                       \
    strokeS aNameP[ CSpREFIX + 1 ] ;                                                    \
                                                                                        \
#define PSTT1(aNameP,ost1P)                                                             \

/**/
*/
  each word in pstt1P will be suffixed with this many nulls
 csttSuffixNullsP
  each word in pstt1P will be prefixed with this many nulls
 csttPrefixNullsP
 csttExtraP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00103cf.flSTRwORDS!||
 flagsP
  if 0 then T(TbLACK) is used
  can be 0
 psttDelimitersP
 sttQuoteP
  must not be 0
 psttP
  if not 0 then must point to a string that has a sufficient unused capacity
   after evaluation, will be allocated with exactly the number of strokes needed to store the result, plus csttExtraP
  can be 0
 pstt1P
 tinP
arguments
backslash quote pairs are replaced with a quote stroke
a single leading and trailing pair of double quotes, if present, is trimmed from each string
delimiters within quotes are not used as delimiters
evaluates to the number of separate strings
parses psttP into separate strings
\<A HREF=\"5.103011a.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strWordsF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

